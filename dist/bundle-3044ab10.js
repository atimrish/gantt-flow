/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 247:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

var Scheduler = __webpack_require__(982),
  React = __webpack_require__(540),
  ReactDOM = __webpack_require__(961);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return (
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
function isValidContainer(node) {
  return !(
    !node ||
    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
  );
}
var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy");
Symbol.for("react.scope");
Symbol.for("react.debug_trace_mode");
var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
Symbol.for("react.legacy_hidden");
Symbol.for("react.tracing_marker");
var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable =
    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
    maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function getComponentNameFromType(type) {
  if (null == type) return null;
  if ("function" === typeof type)
    return type.$$typeof === REACT_CLIENT_REFERENCE
      ? null
      : type.displayName || type.name || null;
  if ("string" === typeof type) return type;
  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return "Fragment";
    case REACT_PORTAL_TYPE:
      return "Portal";
    case REACT_PROFILER_TYPE:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
  }
  if ("object" === typeof type)
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return (type.displayName || "Context") + ".Provider";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type ||
          ((type = innerType.displayName || innerType.name || ""),
          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
        return type;
      case REACT_MEMO_TYPE:
        return (
          (innerType = type.displayName || null),
          null !== innerType
            ? innerType
            : getComponentNameFromType(type.type) || "Memo"
        );
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}
    }
  return null;
}
var ReactSharedInternals =
    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  assign = Object.assign,
  prefix,
  suffix;
function describeBuiltInComponentFrame(name) {
  if (void 0 === prefix)
    try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = (match && match[1]) || "";
      suffix =
        -1 < x.stack.indexOf("\n    at")
          ? " (<anonymous>)"
          : -1 < x.stack.indexOf("@")
            ? "@unknown:0:0"
            : "";
    }
  return "\n" + prefix + name + suffix;
}
var reentry = !1;
function describeNativeComponentFrame(fn, construct) {
  if (!fn || reentry) return "";
  reentry = !0;
  var previousPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    var RunInRootFrame = {
      DetermineComponentFrameRoot: function () {
        try {
          if (construct) {
            var Fake = function () {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function () {
                throw Error();
              }
            });
            if ("object" === typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                var control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x$0) {
                control = x$0;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x$1) {
              control = x$1;
            }
            (Fake = fn()) &&
              "function" === typeof Fake.catch &&
              Fake.catch(function () {});
          }
        } catch (sample) {
          if (sample && control && "string" === typeof sample.stack)
            return [sample.stack, control.stack];
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName =
      "DetermineComponentFrameRoot";
    var namePropDescriptor = Object.getOwnPropertyDescriptor(
      RunInRootFrame.DetermineComponentFrameRoot,
      "name"
    );
    namePropDescriptor &&
      namePropDescriptor.configurable &&
      Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
      sampleStack = _RunInRootFrame$Deter[0],
      controlStack = _RunInRootFrame$Deter[1];
    if (sampleStack && controlStack) {
      var sampleLines = sampleStack.split("\n"),
        controlLines = controlStack.split("\n");
      for (
        namePropDescriptor = RunInRootFrame = 0;
        RunInRootFrame < sampleLines.length &&
        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");

      )
        RunInRootFrame++;
      for (
        ;
        namePropDescriptor < controlLines.length &&
        !controlLines[namePropDescriptor].includes(
          "DetermineComponentFrameRoot"
        );

      )
        namePropDescriptor++;
      if (
        RunInRootFrame === sampleLines.length ||
        namePropDescriptor === controlLines.length
      )
        for (
          RunInRootFrame = sampleLines.length - 1,
            namePropDescriptor = controlLines.length - 1;
          1 <= RunInRootFrame &&
          0 <= namePropDescriptor &&
          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];

        )
          namePropDescriptor--;
      for (
        ;
        1 <= RunInRootFrame && 0 <= namePropDescriptor;
        RunInRootFrame--, namePropDescriptor--
      )
        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
            do
              if (
                (RunInRootFrame--,
                namePropDescriptor--,
                0 > namePropDescriptor ||
                  sampleLines[RunInRootFrame] !==
                    controlLines[namePropDescriptor])
              ) {
                var frame =
                  "\n" +
                  sampleLines[RunInRootFrame].replace(" at new ", " at ");
                fn.displayName &&
                  frame.includes("<anonymous>") &&
                  (frame = frame.replace("<anonymous>", fn.displayName));
                return frame;
              }
            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
          }
          break;
        }
    }
  } finally {
    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);
  }
  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
    ? describeBuiltInComponentFrame(previousPrepareStackTrace)
    : "";
}
function describeFiber(fiber) {
  switch (fiber.tag) {
    case 26:
    case 27:
    case 5:
      return describeBuiltInComponentFrame(fiber.type);
    case 16:
      return describeBuiltInComponentFrame("Lazy");
    case 13:
      return describeBuiltInComponentFrame("Suspense");
    case 19:
      return describeBuiltInComponentFrame("SuspenseList");
    case 0:
    case 15:
      return (fiber = describeNativeComponentFrame(fiber.type, !1)), fiber;
    case 11:
      return (
        (fiber = describeNativeComponentFrame(fiber.type.render, !1)), fiber
      );
    case 1:
      return (fiber = describeNativeComponentFrame(fiber.type, !0)), fiber;
    default:
      return "";
  }
}
function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = "";
    do
      (info += describeFiber(workInProgress)),
        (workInProgress = workInProgress.return);
    while (workInProgress);
    return info;
  } catch (x) {
    return "\nError generating stack: " + x.message + "\n" + x.stack;
  }
}
function getNearestMountedFiber(fiber) {
  var node = fiber,
    nearestMounted = fiber;
  if (fiber.alternate) for (; node.return; ) node = node.return;
  else {
    fiber = node;
    do
      (node = fiber),
        0 !== (node.flags & 4098) && (nearestMounted = node.return),
        (fiber = node.return);
    while (fiber);
  }
  return 3 === node.tag ? nearestMounted : null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (13 === fiber.tag) {
    var suspenseState = fiber.memoizedState;
    null === suspenseState &&
      ((fiber = fiber.alternate),
      null !== fiber && (suspenseState = fiber.memoizedState));
    if (null !== suspenseState) return suspenseState.dehydrated;
  }
  return null;
}
function assertIsMounted(fiber) {
  if (getNearestMountedFiber(fiber) !== fiber)
    throw Error(formatProdErrorMessage(188));
}
function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    alternate = getNearestMountedFiber(fiber);
    if (null === alternate) throw Error(formatProdErrorMessage(188));
    return alternate !== fiber ? null : fiber;
  }
  for (var a = fiber, b = alternate; ; ) {
    var parentA = a.return;
    if (null === parentA) break;
    var parentB = parentA.alternate;
    if (null === parentB) {
      b = parentA.return;
      if (null !== b) {
        a = b;
        continue;
      }
      break;
    }
    if (parentA.child === parentB.child) {
      for (parentB = parentA.child; parentB; ) {
        if (parentB === a) return assertIsMounted(parentA), fiber;
        if (parentB === b) return assertIsMounted(parentA), alternate;
        parentB = parentB.sibling;
      }
      throw Error(formatProdErrorMessage(188));
    }
    if (a.return !== b.return) (a = parentA), (b = parentB);
    else {
      for (var didFindChild = !1, child$2 = parentA.child; child$2; ) {
        if (child$2 === a) {
          didFindChild = !0;
          a = parentA;
          b = parentB;
          break;
        }
        if (child$2 === b) {
          didFindChild = !0;
          b = parentA;
          a = parentB;
          break;
        }
        child$2 = child$2.sibling;
      }
      if (!didFindChild) {
        for (child$2 = parentB.child; child$2; ) {
          if (child$2 === a) {
            didFindChild = !0;
            a = parentB;
            b = parentA;
            break;
          }
          if (child$2 === b) {
            didFindChild = !0;
            b = parentB;
            a = parentA;
            break;
          }
          child$2 = child$2.sibling;
        }
        if (!didFindChild) throw Error(formatProdErrorMessage(189));
      }
    }
    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
  }
  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
  return a.stateNode.current === a ? fiber : alternate;
}
function findCurrentHostFiberImpl(node) {
  var tag = node.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
  for (node = node.child; null !== node; ) {
    tag = findCurrentHostFiberImpl(node);
    if (null !== tag) return tag;
    node = node.sibling;
  }
  return null;
}
var isArrayImpl = Array.isArray,
  ReactDOMSharedInternals =
    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  sharedNotPendingObject = {
    pending: !1,
    data: null,
    method: null,
    action: null
  },
  valueStack = [],
  index = -1;
function createCursor(defaultValue) {
  return { current: defaultValue };
}
function pop(cursor) {
  0 > index ||
    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
}
function push(cursor, value) {
  index++;
  valueStack[index] = cursor.current;
  cursor.current = value;
}
var contextStackCursor = createCursor(null),
  contextFiberStackCursor = createCursor(null),
  rootInstanceStackCursor = createCursor(null),
  hostTransitionProviderCursor = createCursor(null);
function pushHostContainer(fiber, nextRootInstance) {
  push(rootInstanceStackCursor, nextRootInstance);
  push(contextFiberStackCursor, fiber);
  push(contextStackCursor, null);
  fiber = nextRootInstance.nodeType;
  switch (fiber) {
    case 9:
    case 11:
      nextRootInstance = (nextRootInstance = nextRootInstance.documentElement)
        ? (nextRootInstance = nextRootInstance.namespaceURI)
          ? getOwnHostContext(nextRootInstance)
          : 0
        : 0;
      break;
    default:
      if (
        ((fiber = 8 === fiber ? nextRootInstance.parentNode : nextRootInstance),
        (nextRootInstance = fiber.tagName),
        (fiber = fiber.namespaceURI))
      )
        (fiber = getOwnHostContext(fiber)),
          (nextRootInstance = getChildHostContextProd(fiber, nextRootInstance));
      else
        switch (nextRootInstance) {
          case "svg":
            nextRootInstance = 1;
            break;
          case "math":
            nextRootInstance = 2;
            break;
          default:
            nextRootInstance = 0;
        }
  }
  pop(contextStackCursor);
  push(contextStackCursor, nextRootInstance);
}
function popHostContainer() {
  pop(contextStackCursor);
  pop(contextFiberStackCursor);
  pop(rootInstanceStackCursor);
}
function pushHostContext(fiber) {
  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
  var context = contextStackCursor.current;
  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
  context !== JSCompiler_inline_result &&
    (push(contextFiberStackCursor, fiber),
    push(contextStackCursor, JSCompiler_inline_result));
}
function popHostContext(fiber) {
  contextFiberStackCursor.current === fiber &&
    (pop(contextStackCursor), pop(contextFiberStackCursor));
  hostTransitionProviderCursor.current === fiber &&
    (pop(hostTransitionProviderCursor),
    (HostTransitionContext._currentValue = sharedNotPendingObject));
}
var hasOwnProperty = Object.prototype.hasOwnProperty,
  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
  cancelCallback$1 = Scheduler.unstable_cancelCallback,
  shouldYield = Scheduler.unstable_shouldYield,
  requestPaint = Scheduler.unstable_requestPaint,
  now = Scheduler.unstable_now,
  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
  ImmediatePriority = Scheduler.unstable_ImmediatePriority,
  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
  NormalPriority$1 = Scheduler.unstable_NormalPriority,
  LowPriority = Scheduler.unstable_LowPriority,
  IdlePriority = Scheduler.unstable_IdlePriority,
  log$1 = Scheduler.log,
  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
  rendererID = null,
  injectedHook = null;
function onCommitRoot(root) {
  if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
    try {
      injectedHook.onCommitFiberRoot(
        rendererID,
        root,
        void 0,
        128 === (root.current.flags & 128)
      );
    } catch (err) {}
}
function setIsStrictModeForDevtools(newIsStrictMode) {
  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
    try {
      injectedHook.setStrictMode(rendererID, newIsStrictMode);
    } catch (err) {}
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
  log = Math.log,
  LN2 = Math.LN2;
function clz32Fallback(x) {
  x >>>= 0;
  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
}
var nextTransitionLane = 128,
  nextRetryLane = 4194304;
function getHighestPriorityLanes(lanes) {
  var pendingSyncLanes = lanes & 42;
  if (0 !== pendingSyncLanes) return pendingSyncLanes;
  switch (lanes & -lanes) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
      return 64;
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return lanes & 4194176;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return lanes & 62914560;
    case 67108864:
      return 67108864;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 0;
    default:
      return lanes;
  }
}
function getNextLanes(root, wipLanes) {
  var pendingLanes = root.pendingLanes;
  if (0 === pendingLanes) return 0;
  var nextLanes = 0,
    suspendedLanes = root.suspendedLanes,
    pingedLanes = root.pingedLanes,
    warmLanes = root.warmLanes;
  root = 0 !== root.finishedLanes;
  var nonIdlePendingLanes = pendingLanes & 134217727;
  0 !== nonIdlePendingLanes
    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
      0 !== pendingLanes
        ? (nextLanes = getHighestPriorityLanes(pendingLanes))
        : ((pingedLanes &= nonIdlePendingLanes),
          0 !== pingedLanes
            ? (nextLanes = getHighestPriorityLanes(pingedLanes))
            : root ||
              ((warmLanes = nonIdlePendingLanes & ~warmLanes),
              0 !== warmLanes &&
                (nextLanes = getHighestPriorityLanes(warmLanes)))))
    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
      0 !== nonIdlePendingLanes
        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
        : 0 !== pingedLanes
          ? (nextLanes = getHighestPriorityLanes(pingedLanes))
          : root ||
            ((warmLanes = pendingLanes & ~warmLanes),
            0 !== warmLanes &&
              (nextLanes = getHighestPriorityLanes(warmLanes))));
  return 0 === nextLanes
    ? 0
    : 0 !== wipLanes &&
        wipLanes !== nextLanes &&
        0 === (wipLanes & suspendedLanes) &&
        ((suspendedLanes = nextLanes & -nextLanes),
        (warmLanes = wipLanes & -wipLanes),
        suspendedLanes >= warmLanes ||
          (32 === suspendedLanes && 0 !== (warmLanes & 4194176)))
      ? wipLanes
      : nextLanes;
}
function checkIfRootIsPrerendering(root, renderLanes) {
  return (
    0 ===
    (root.pendingLanes &
      ~(root.suspendedLanes & ~root.pingedLanes) &
      renderLanes)
  );
}
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case 1:
    case 2:
    case 4:
    case 8:
      return currentTime + 250;
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return currentTime + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function claimNextTransitionLane() {
  var lane = nextTransitionLane;
  nextTransitionLane <<= 1;
  0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
  return lane;
}
function claimNextRetryLane() {
  var lane = nextRetryLane;
  nextRetryLane <<= 1;
  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
  return lane;
}
function createLaneMap(initial) {
  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
  return laneMap;
}
function markRootUpdated$1(root, updateLane) {
  root.pendingLanes |= updateLane;
  268435456 !== updateLane &&
    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
}
function markRootFinished(
  root,
  finishedLanes,
  remainingLanes,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes
) {
  var previouslyPendingLanes = root.pendingLanes;
  root.pendingLanes = remainingLanes;
  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.warmLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  root.errorRecoveryDisabledLanes &= remainingLanes;
  root.shellSuspendCounter = 0;
  var entanglements = root.entanglements,
    expirationTimes = root.expirationTimes,
    hiddenUpdates = root.hiddenUpdates;
  for (
    remainingLanes = previouslyPendingLanes & ~remainingLanes;
    0 < remainingLanes;

  ) {
    var index$7 = 31 - clz32(remainingLanes),
      lane = 1 << index$7;
    entanglements[index$7] = 0;
    expirationTimes[index$7] = -1;
    var hiddenUpdatesForLane = hiddenUpdates[index$7];
    if (null !== hiddenUpdatesForLane)
      for (
        hiddenUpdates[index$7] = null, index$7 = 0;
        index$7 < hiddenUpdatesForLane.length;
        index$7++
      ) {
        var update = hiddenUpdatesForLane[index$7];
        null !== update && (update.lane &= -536870913);
      }
    remainingLanes &= ~lane;
  }
  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
  0 !== suspendedRetryLanes &&
    0 === updatedLanes &&
    0 !== root.tag &&
    (root.suspendedLanes |=
      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
}
function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
  root.pendingLanes |= spawnedLane;
  root.suspendedLanes &= ~spawnedLane;
  var spawnedLaneIndex = 31 - clz32(spawnedLane);
  root.entangledLanes |= spawnedLane;
  root.entanglements[spawnedLaneIndex] =
    root.entanglements[spawnedLaneIndex] |
    1073741824 |
    (entangledLanes & 4194218);
}
function markRootEntangled(root, entangledLanes) {
  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
  for (root = root.entanglements; rootEntangledLanes; ) {
    var index$8 = 31 - clz32(rootEntangledLanes),
      lane = 1 << index$8;
    (lane & entangledLanes) | (root[index$8] & entangledLanes) &&
      (root[index$8] |= entangledLanes);
    rootEntangledLanes &= ~lane;
  }
}
function lanesToEventPriority(lanes) {
  lanes &= -lanes;
  return 2 < lanes
    ? 8 < lanes
      ? 0 !== (lanes & 134217727)
        ? 32
        : 268435456
      : 8
    : 2;
}
function resolveUpdatePriority() {
  var updatePriority = ReactDOMSharedInternals.p;
  if (0 !== updatePriority) return updatePriority;
  updatePriority = window.event;
  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
}
function runWithPriority(priority, fn) {
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    return (ReactDOMSharedInternals.p = priority), fn();
  } finally {
    ReactDOMSharedInternals.p = previousPriority;
  }
}
var randomKey = Math.random().toString(36).slice(2),
  internalInstanceKey = "__reactFiber$" + randomKey,
  internalPropsKey = "__reactProps$" + randomKey,
  internalContainerInstanceKey = "__reactContainer$" + randomKey,
  internalEventHandlersKey = "__reactEvents$" + randomKey,
  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
  internalEventHandlesSetKey = "__reactHandles$" + randomKey,
  internalRootNodeResourcesKey = "__reactResources$" + randomKey,
  internalHoistableMarker = "__reactMarker$" + randomKey;
function detachDeletedInstance(node) {
  delete node[internalInstanceKey];
  delete node[internalPropsKey];
  delete node[internalEventHandlersKey];
  delete node[internalEventHandlerListenersKey];
  delete node[internalEventHandlesSetKey];
}
function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];
  if (targetInst) return targetInst;
  for (var parentNode = targetNode.parentNode; parentNode; ) {
    if (
      (targetInst =
        parentNode[internalContainerInstanceKey] ||
        parentNode[internalInstanceKey])
    ) {
      parentNode = targetInst.alternate;
      if (
        null !== targetInst.child ||
        (null !== parentNode && null !== parentNode.child)
      )
        for (
          targetNode = getParentSuspenseInstance(targetNode);
          null !== targetNode;

        ) {
          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
          targetNode = getParentSuspenseInstance(targetNode);
        }
      return targetInst;
    }
    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }
  return null;
}
function getInstanceFromNode(node) {
  if (
    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
  ) {
    var tag = node.tag;
    if (
      5 === tag ||
      6 === tag ||
      13 === tag ||
      26 === tag ||
      27 === tag ||
      3 === tag
    )
      return node;
  }
  return null;
}
function getNodeFromInstance(inst) {
  var tag = inst.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
  throw Error(formatProdErrorMessage(33));
}
function getResourcesFromRoot(root) {
  var resources = root[internalRootNodeResourcesKey];
  resources ||
    (resources = root[internalRootNodeResourcesKey] =
      { hoistableStyles: new Map(), hoistableScripts: new Map() });
  return resources;
}
function markNodeAsHoistable(node) {
  node[internalHoistableMarker] = !0;
}
var allNativeEvents = new Set(),
  registrationNameDependencies = {};
function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + "Capture", dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  registrationNameDependencies[registrationName] = dependencies;
  for (
    registrationName = 0;
    registrationName < dependencies.length;
    registrationName++
  )
    allNativeEvents.add(dependencies[registrationName]);
}
var canUseDOM = !(
    "undefined" === typeof window ||
    "undefined" === typeof window.document ||
    "undefined" === typeof window.document.createElement
  ),
  VALID_ATTRIBUTE_NAME_REGEX = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ),
  illegalAttributeNameCache = {},
  validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
    return !0;
  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
    return (validatedAttributeNameCache[attributeName] = !0);
  illegalAttributeNameCache[attributeName] = !0;
  return !1;
}
function setValueForAttribute(node, name, value) {
  if (isAttributeNameSafe(name))
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          node.removeAttribute(name);
          return;
        case "boolean":
          var prefix$10 = name.toLowerCase().slice(0, 5);
          if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
            node.removeAttribute(name);
            return;
          }
      }
      node.setAttribute(name, "" + value);
    }
}
function setValueForKnownAttribute(node, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttribute(name, "" + value);
  }
}
function setValueForNamespacedAttribute(node, namespace, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttributeNS(namespace, name, "" + value);
  }
}
function getToStringValue(value) {
  switch (typeof value) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return value;
    case "object":
      return value;
    default:
      return "";
  }
}
function isCheckable(elem) {
  var type = elem.type;
  return (
    (elem = elem.nodeName) &&
    "input" === elem.toLowerCase() &&
    ("checkbox" === type || "radio" === type)
  );
}
function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? "checked" : "value",
    descriptor = Object.getOwnPropertyDescriptor(
      node.constructor.prototype,
      valueField
    ),
    currentValue = "" + node[valueField];
  if (
    !node.hasOwnProperty(valueField) &&
    "undefined" !== typeof descriptor &&
    "function" === typeof descriptor.get &&
    "function" === typeof descriptor.set
  ) {
    var get = descriptor.get,
      set = descriptor.set;
    Object.defineProperty(node, valueField, {
      configurable: !0,
      get: function () {
        return get.call(this);
      },
      set: function (value) {
        currentValue = "" + value;
        set.call(this, value);
      }
    });
    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable
    });
    return {
      getValue: function () {
        return currentValue;
      },
      setValue: function (value) {
        currentValue = "" + value;
      },
      stopTracking: function () {
        node._valueTracker = null;
        delete node[valueField];
      }
    };
  }
}
function track(node) {
  node._valueTracker || (node._valueTracker = trackValueOnNode(node));
}
function updateValueIfChanged(node) {
  if (!node) return !1;
  var tracker = node._valueTracker;
  if (!tracker) return !0;
  var lastValue = tracker.getValue();
  var value = "";
  node &&
    (value = isCheckable(node)
      ? node.checked
        ? "true"
        : "false"
      : node.value);
  node = value;
  return node !== lastValue ? (tracker.setValue(node), !0) : !1;
}
function getActiveElement(doc) {
  doc = doc || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof doc) return null;
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
  return value.replace(
    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
    function (ch) {
      return "\\" + ch.charCodeAt(0).toString(16) + " ";
    }
  );
}
function updateInput(
  element,
  value,
  defaultValue,
  lastDefaultValue,
  checked,
  defaultChecked,
  type,
  name
) {
  element.name = "";
  null != type &&
  "function" !== typeof type &&
  "symbol" !== typeof type &&
  "boolean" !== typeof type
    ? (element.type = type)
    : element.removeAttribute("type");
  if (null != value)
    if ("number" === type) {
      if ((0 === value && "" === element.value) || element.value != value)
        element.value = "" + getToStringValue(value);
    } else
      element.value !== "" + getToStringValue(value) &&
        (element.value = "" + getToStringValue(value));
  else
    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");
  null != value
    ? setDefaultValue(element, type, getToStringValue(value))
    : null != defaultValue
      ? setDefaultValue(element, type, getToStringValue(defaultValue))
      : null != lastDefaultValue && element.removeAttribute("value");
  null == checked &&
    null != defaultChecked &&
    (element.defaultChecked = !!defaultChecked);
  null != checked &&
    (element.checked =
      checked && "function" !== typeof checked && "symbol" !== typeof checked);
  null != name &&
  "function" !== typeof name &&
  "symbol" !== typeof name &&
  "boolean" !== typeof name
    ? (element.name = "" + getToStringValue(name))
    : element.removeAttribute("name");
}
function initInput(
  element,
  value,
  defaultValue,
  checked,
  defaultChecked,
  type,
  name,
  isHydrating
) {
  null != type &&
    "function" !== typeof type &&
    "symbol" !== typeof type &&
    "boolean" !== typeof type &&
    (element.type = type);
  if (null != value || null != defaultValue) {
    if (
      !(
        ("submit" !== type && "reset" !== type) ||
        (void 0 !== value && null !== value)
      )
    )
      return;
    defaultValue =
      null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    value = null != value ? "" + getToStringValue(value) : defaultValue;
    isHydrating || value === element.value || (element.value = value);
    element.defaultValue = value;
  }
  checked = null != checked ? checked : defaultChecked;
  checked =
    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
  element.checked = isHydrating ? element.checked : !!checked;
  element.defaultChecked = !!checked;
  null != name &&
    "function" !== typeof name &&
    "symbol" !== typeof name &&
    "boolean" !== typeof name &&
    (element.name = name);
}
function setDefaultValue(node, type, value) {
  ("number" === type && getActiveElement(node.ownerDocument) === node) ||
    node.defaultValue === "" + value ||
    (node.defaultValue = "" + value);
}
function updateOptions(node, multiple, propValue, setDefaultSelected) {
  node = node.options;
  if (multiple) {
    multiple = {};
    for (var i = 0; i < propValue.length; i++)
      multiple["$" + propValue[i]] = !0;
    for (propValue = 0; propValue < node.length; propValue++)
      (i = multiple.hasOwnProperty("$" + node[propValue].value)),
        node[propValue].selected !== i && (node[propValue].selected = i),
        i && setDefaultSelected && (node[propValue].defaultSelected = !0);
  } else {
    propValue = "" + getToStringValue(propValue);
    multiple = null;
    for (i = 0; i < node.length; i++) {
      if (node[i].value === propValue) {
        node[i].selected = !0;
        setDefaultSelected && (node[i].defaultSelected = !0);
        return;
      }
      null !== multiple || node[i].disabled || (multiple = node[i]);
    }
    null !== multiple && (multiple.selected = !0);
  }
}
function updateTextarea(element, value, defaultValue) {
  if (
    null != value &&
    ((value = "" + getToStringValue(value)),
    value !== element.value && (element.value = value),
    null == defaultValue)
  ) {
    element.defaultValue !== value && (element.defaultValue = value);
    return;
  }
  element.defaultValue =
    null != defaultValue ? "" + getToStringValue(defaultValue) : "";
}
function initTextarea(element, value, defaultValue, children) {
  if (null == value) {
    if (null != children) {
      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
      if (isArrayImpl(children)) {
        if (1 < children.length) throw Error(formatProdErrorMessage(93));
        children = children[0];
      }
      defaultValue = children;
    }
    null == defaultValue && (defaultValue = "");
    value = defaultValue;
  }
  defaultValue = getToStringValue(value);
  element.defaultValue = defaultValue;
  children = element.textContent;
  children === defaultValue &&
    "" !== children &&
    null !== children &&
    (element.value = children);
}
function setTextContent(node, text) {
  if (text) {
    var firstChild = node.firstChild;
    if (
      firstChild &&
      firstChild === node.lastChild &&
      3 === firstChild.nodeType
    ) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
}
var unitlessNumbers = new Set(
  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
    " "
  )
);
function setValueForStyle(style, styleName, value) {
  var isCustomProperty = 0 === styleName.indexOf("--");
  null == value || "boolean" === typeof value || "" === value
    ? isCustomProperty
      ? style.setProperty(styleName, "")
      : "float" === styleName
        ? (style.cssFloat = "")
        : (style[styleName] = "")
    : isCustomProperty
      ? style.setProperty(styleName, value)
      : "number" !== typeof value ||
          0 === value ||
          unitlessNumbers.has(styleName)
        ? "float" === styleName
          ? (style.cssFloat = value)
          : (style[styleName] = ("" + value).trim())
        : (style[styleName] = value + "px");
}
function setValueForStyles(node, styles, prevStyles) {
  if (null != styles && "object" !== typeof styles)
    throw Error(formatProdErrorMessage(62));
  node = node.style;
  if (null != prevStyles) {
    for (var styleName in prevStyles)
      !prevStyles.hasOwnProperty(styleName) ||
        (null != styles && styles.hasOwnProperty(styleName)) ||
        (0 === styleName.indexOf("--")
          ? node.setProperty(styleName, "")
          : "float" === styleName
            ? (node.cssFloat = "")
            : (node[styleName] = ""));
    for (var styleName$16 in styles)
      (styleName = styles[styleName$16]),
        styles.hasOwnProperty(styleName$16) &&
          prevStyles[styleName$16] !== styleName &&
          setValueForStyle(node, styleName$16, styleName);
  } else
    for (var styleName$17 in styles)
      styles.hasOwnProperty(styleName$17) &&
        setValueForStyle(node, styleName$17, styles[styleName$17]);
}
function isCustomElement(tagName) {
  if (-1 === tagName.indexOf("-")) return !1;
  switch (tagName) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var aliases = new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]),
  isJavaScriptProtocol =
    /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
function sanitizeURL(url) {
  return isJavaScriptProtocol.test("" + url)
    ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
    : url;
}
var currentReplayingEvent = null;
function getEventTarget(nativeEvent) {
  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
  nativeEvent.correspondingUseElement &&
    (nativeEvent = nativeEvent.correspondingUseElement);
  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
}
var restoreTarget = null,
  restoreQueue = null;
function restoreStateOfTarget(target) {
  var internalInstance = getInstanceFromNode(target);
  if (internalInstance && (target = internalInstance.stateNode)) {
    var props = target[internalPropsKey] || null;
    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {
      case "input":
        updateInput(
          target,
          props.value,
          props.defaultValue,
          props.defaultValue,
          props.checked,
          props.defaultChecked,
          props.type,
          props.name
        );
        internalInstance = props.name;
        if ("radio" === props.type && null != internalInstance) {
          for (props = target; props.parentNode; ) props = props.parentNode;
          props = props.querySelectorAll(
            'input[name="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(
                "" + internalInstance
              ) +
              '"][type="radio"]'
          );
          for (
            internalInstance = 0;
            internalInstance < props.length;
            internalInstance++
          ) {
            var otherNode = props[internalInstance];
            if (otherNode !== target && otherNode.form === target.form) {
              var otherProps = otherNode[internalPropsKey] || null;
              if (!otherProps) throw Error(formatProdErrorMessage(90));
              updateInput(
                otherNode,
                otherProps.value,
                otherProps.defaultValue,
                otherProps.defaultValue,
                otherProps.checked,
                otherProps.defaultChecked,
                otherProps.type,
                otherProps.name
              );
            }
          }
          for (
            internalInstance = 0;
            internalInstance < props.length;
            internalInstance++
          )
            (otherNode = props[internalInstance]),
              otherNode.form === target.form && updateValueIfChanged(otherNode);
        }
        break a;
      case "textarea":
        updateTextarea(target, props.value, props.defaultValue);
        break a;
      case "select":
        (internalInstance = props.value),
          null != internalInstance &&
            updateOptions(target, !!props.multiple, internalInstance, !1);
    }
  }
}
var isInsideEventHandler = !1;
function batchedUpdates$1(fn, a, b) {
  if (isInsideEventHandler) return fn(a, b);
  isInsideEventHandler = !0;
  try {
    var JSCompiler_inline_result = fn(a);
    return JSCompiler_inline_result;
  } finally {
    if (
      ((isInsideEventHandler = !1),
      null !== restoreTarget || null !== restoreQueue)
    )
      if (
        (flushSyncWork$1(),
        restoreTarget &&
          ((a = restoreTarget),
          (fn = restoreQueue),
          (restoreQueue = restoreTarget = null),
          restoreStateOfTarget(a),
          fn))
      )
        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
  }
}
function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;
  if (null === stateNode) return null;
  var props = stateNode[internalPropsKey] || null;
  if (null === props) return null;
  stateNode = props[registrationName];
  a: switch (registrationName) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (props = !props.disabled) ||
        ((inst = inst.type),
        (props = !(
          "button" === inst ||
          "input" === inst ||
          "select" === inst ||
          "textarea" === inst
        )));
      inst = !props;
      break a;
    default:
      inst = !1;
  }
  if (inst) return null;
  if (stateNode && "function" !== typeof stateNode)
    throw Error(
      formatProdErrorMessage(231, registrationName, typeof stateNode)
    );
  return stateNode;
}
var passiveBrowserEventsSupported = !1;
if (canUseDOM)
  try {
    var options = {};
    Object.defineProperty(options, "passive", {
      get: function () {
        passiveBrowserEventsSupported = !0;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (e) {
    passiveBrowserEventsSupported = !1;
  }
var root = null,
  startText = null,
  fallbackText = null;
function getData() {
  if (fallbackText) return fallbackText;
  var start,
    startValue = startText,
    startLength = startValue.length,
    end,
    endValue = "value" in root ? root.value : root.textContent,
    endLength = endValue.length;
  for (
    start = 0;
    start < startLength && startValue[start] === endValue[start];
    start++
  );
  var minEnd = startLength - start;
  for (
    end = 1;
    end <= minEnd &&
    startValue[startLength - end] === endValue[endLength - end];
    end++
  );
  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
}
function getEventCharCode(nativeEvent) {
  var keyCode = nativeEvent.keyCode;
  "charCode" in nativeEvent
    ? ((nativeEvent = nativeEvent.charCode),
      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
    : (nativeEvent = keyCode);
  10 === nativeEvent && (nativeEvent = 13);
  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
}
function functionThatReturnsTrue() {
  return !0;
}
function functionThatReturnsFalse() {
  return !1;
}
function createSyntheticEvent(Interface) {
  function SyntheticBaseEvent(
    reactName,
    reactEventType,
    targetInst,
    nativeEvent,
    nativeEventTarget
  ) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;
    for (var propName in Interface)
      Interface.hasOwnProperty(propName) &&
        ((reactName = Interface[propName]),
        (this[propName] = reactName
          ? reactName(nativeEvent)
          : nativeEvent[propName]));
    this.isDefaultPrevented = (
      null != nativeEvent.defaultPrevented
        ? nativeEvent.defaultPrevented
        : !1 === nativeEvent.returnValue
    )
      ? functionThatReturnsTrue
      : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event &&
        (event.preventDefault
          ? event.preventDefault()
          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),
        (this.isDefaultPrevented = functionThatReturnsTrue));
    },
    stopPropagation: function () {
      var event = this.nativeEvent;
      event &&
        (event.stopPropagation
          ? event.stopPropagation()
          : "unknown" !== typeof event.cancelBubble &&
            (event.cancelBubble = !0),
        (this.isPropagationStopped = functionThatReturnsTrue));
    },
    persist: function () {},
    isPersistent: functionThatReturnsTrue
  });
  return SyntheticBaseEvent;
}
var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  SyntheticEvent = createSyntheticEvent(EventInterface),
  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
  lastMovementX,
  lastMovementY,
  lastMouseEvent,
  MouseEventInterface = assign({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function (event) {
      return void 0 === event.relatedTarget
        ? event.fromElement === event.srcElement
          ? event.toElement
          : event.fromElement
        : event.relatedTarget;
    },
    movementX: function (event) {
      if ("movementX" in event) return event.movementX;
      event !== lastMouseEvent &&
        (lastMouseEvent && "mousemove" === event.type
          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
            (lastMovementY = event.screenY - lastMouseEvent.screenY))
          : (lastMovementY = lastMovementX = 0),
        (lastMouseEvent = event));
      return lastMovementX;
    },
    movementY: function (event) {
      return "movementY" in event ? event.movementY : lastMovementY;
    }
  }),
  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
  AnimationEventInterface = assign({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
  ClipboardEventInterface = assign({}, EventInterface, {
    clipboardData: function (event) {
      return "clipboardData" in event
        ? event.clipboardData
        : window.clipboardData;
    }
  }),
  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
  normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
function modifierStateGetter(keyArg) {
  var nativeEvent = this.nativeEvent;
  return nativeEvent.getModifierState
    ? nativeEvent.getModifierState(keyArg)
    : (keyArg = modifierKeyToProp[keyArg])
      ? !!nativeEvent[keyArg]
      : !1;
}
function getEventModifierState() {
  return modifierStateGetter;
}
var KeyboardEventInterface = assign({}, UIEventInterface, {
    key: function (nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if ("Unidentified" !== key) return key;
      }
      return "keypress" === nativeEvent.type
        ? ((nativeEvent = getEventCharCode(nativeEvent)),
          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
          ? translateToKey[nativeEvent.keyCode] || "Unidentified"
          : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function (event) {
      return "keypress" === event.type ? getEventCharCode(event) : 0;
    },
    keyCode: function (event) {
      return "keydown" === event.type || "keyup" === event.type
        ? event.keyCode
        : 0;
    },
    which: function (event) {
      return "keypress" === event.type
        ? getEventCharCode(event)
        : "keydown" === event.type || "keyup" === event.type
          ? event.keyCode
          : 0;
    }
  }),
  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
  PointerEventInterface = assign({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
  TouchEventInterface = assign({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
  }),
  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
  TransitionEventInterface = assign({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
  WheelEventInterface = assign({}, MouseEventInterface, {
    deltaX: function (event) {
      return "deltaX" in event
        ? event.deltaX
        : "wheelDeltaX" in event
          ? -event.wheelDeltaX
          : 0;
    },
    deltaY: function (event) {
      return "deltaY" in event
        ? event.deltaY
        : "wheelDeltaY" in event
          ? -event.wheelDeltaY
          : "wheelDelta" in event
            ? -event.wheelDelta
            : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
  ToggleEventInterface = assign({}, EventInterface, {
    newState: 0,
    oldState: 0
  }),
  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
  END_KEYCODES = [9, 13, 27, 32],
  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
  documentMode = null;
canUseDOM &&
  "documentMode" in document &&
  (documentMode = document.documentMode);
var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
  useFallbackCompositionData =
    canUseDOM &&
    (!canUseCompositionEvent ||
      (documentMode && 8 < documentMode && 11 >= documentMode)),
  SPACEBAR_CHAR = String.fromCharCode(32),
  hasSpaceKeypress = !1;
function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case "keyup":
      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
    case "keydown":
      return 229 !== nativeEvent.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function getDataFromCustomEvent(nativeEvent) {
  nativeEvent = nativeEvent.detail;
  return "object" === typeof nativeEvent && "data" in nativeEvent
    ? nativeEvent.data
    : null;
}
var isComposing = !1;
function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case "compositionend":
      return getDataFromCustomEvent(nativeEvent);
    case "keypress":
      if (32 !== nativeEvent.which) return null;
      hasSpaceKeypress = !0;
      return SPACEBAR_CHAR;
    case "textInput":
      return (
        (domEventName = nativeEvent.data),
        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
      );
    default:
      return null;
  }
}
function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  if (isComposing)
    return "compositionend" === domEventName ||
      (!canUseCompositionEvent &&
        isFallbackCompositionEnd(domEventName, nativeEvent))
      ? ((domEventName = getData()),
        (fallbackText = startText = root = null),
        (isComposing = !1),
        domEventName)
      : null;
  switch (domEventName) {
    case "paste":
      return null;
    case "keypress":
      if (
        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
        (nativeEvent.ctrlKey && nativeEvent.altKey)
      ) {
        if (nativeEvent.char && 1 < nativeEvent.char.length)
          return nativeEvent.char;
        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case "compositionend":
      return useFallbackCompositionData && "ko" !== nativeEvent.locale
        ? null
        : nativeEvent.data;
    default:
      return null;
  }
}
var supportedInputTypes = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return "input" === nodeName
    ? !!supportedInputTypes[elem.type]
    : "textarea" === nodeName
      ? !0
      : !1;
}
function createAndAccumulateChangeEvent(
  dispatchQueue,
  inst,
  nativeEvent,
  target
) {
  restoreTarget
    ? restoreQueue
      ? restoreQueue.push(target)
      : (restoreQueue = [target])
    : (restoreTarget = target);
  inst = accumulateTwoPhaseListeners(inst, "onChange");
  0 < inst.length &&
    ((nativeEvent = new SyntheticEvent(
      "onChange",
      "change",
      null,
      nativeEvent,
      target
    )),
    dispatchQueue.push({ event: nativeEvent, listeners: inst }));
}
var activeElement$1 = null,
  activeElementInst$1 = null;
function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}
function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);
  if (updateValueIfChanged(targetNode)) return targetInst;
}
function getTargetInstForChangeEvent(domEventName, targetInst) {
  if ("change" === domEventName) return targetInst;
}
var isInputEventSupported = !1;
if (canUseDOM) {
  var JSCompiler_inline_result$jscomp$283;
  if (canUseDOM) {
    var isSupported$jscomp$inline_418 = "oninput" in document;
    if (!isSupported$jscomp$inline_418) {
      var element$jscomp$inline_419 = document.createElement("div");
      element$jscomp$inline_419.setAttribute("oninput", "return;");
      isSupported$jscomp$inline_418 =
        "function" === typeof element$jscomp$inline_419.oninput;
    }
    JSCompiler_inline_result$jscomp$283 = isSupported$jscomp$inline_418;
  } else JSCompiler_inline_result$jscomp$283 = !1;
  isInputEventSupported =
    JSCompiler_inline_result$jscomp$283 &&
    (!document.documentMode || 9 < document.documentMode);
}
function stopWatchingForValueChange() {
  activeElement$1 &&
    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
    (activeElementInst$1 = activeElement$1 = null));
}
function handlePropertyChange(nativeEvent) {
  if (
    "value" === nativeEvent.propertyName &&
    getInstIfValueChanged(activeElementInst$1)
  ) {
    var dispatchQueue = [];
    createAndAccumulateChangeEvent(
      dispatchQueue,
      activeElementInst$1,
      nativeEvent,
      getEventTarget(nativeEvent)
    );
    batchedUpdates$1(runEventInBatch, dispatchQueue);
  }
}
function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  "focusin" === domEventName
    ? (stopWatchingForValueChange(),
      (activeElement$1 = target),
      (activeElementInst$1 = targetInst),
      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
    : "focusout" === domEventName && stopWatchingForValueChange();
}
function getTargetInstForInputEventPolyfill(domEventName) {
  if (
    "selectionchange" === domEventName ||
    "keyup" === domEventName ||
    "keydown" === domEventName
  )
    return getInstIfValueChanged(activeElementInst$1);
}
function getTargetInstForClickEvent(domEventName, targetInst) {
  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
}
function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if ("input" === domEventName || "change" === domEventName)
    return getInstIfValueChanged(targetInst);
}
function is(x, y) {
  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is;
function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) return !0;
  if (
    "object" !== typeof objA ||
    null === objA ||
    "object" !== typeof objB ||
    null === objB
  )
    return !1;
  var keysA = Object.keys(objA),
    keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return !1;
  for (keysB = 0; keysB < keysA.length; keysB++) {
    var currentKey = keysA[keysB];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !objectIs(objA[currentKey], objB[currentKey])
    )
      return !1;
  }
  return !0;
}
function getLeafNode(node) {
  for (; node && node.firstChild; ) node = node.firstChild;
  return node;
}
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  root = 0;
  for (var nodeEnd; node; ) {
    if (3 === node.nodeType) {
      nodeEnd = root + node.textContent.length;
      if (root <= offset && nodeEnd >= offset)
        return { node: node, offset: offset - root };
      root = nodeEnd;
    }
    a: {
      for (; node; ) {
        if (node.nextSibling) {
          node = node.nextSibling;
          break a;
        }
        node = node.parentNode;
      }
      node = void 0;
    }
    node = getLeafNode(node);
  }
}
function containsNode(outerNode, innerNode) {
  return outerNode && innerNode
    ? outerNode === innerNode
      ? !0
      : outerNode && 3 === outerNode.nodeType
        ? !1
        : innerNode && 3 === innerNode.nodeType
          ? containsNode(outerNode, innerNode.parentNode)
          : "contains" in outerNode
            ? outerNode.contains(innerNode)
            : outerNode.compareDocumentPosition
              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
              : !1
    : !1;
}
function getActiveElementDeep(containerInfo) {
  containerInfo =
    null != containerInfo &&
    null != containerInfo.ownerDocument &&
    null != containerInfo.ownerDocument.defaultView
      ? containerInfo.ownerDocument.defaultView
      : window;
  for (
    var element = getActiveElement(containerInfo.document);
    element instanceof containerInfo.HTMLIFrameElement;

  ) {
    try {
      var JSCompiler_inline_result =
        "string" === typeof element.contentWindow.location.href;
    } catch (err) {
      JSCompiler_inline_result = !1;
    }
    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
    else break;
    element = getActiveElement(containerInfo.document);
  }
  return element;
}
function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return (
    nodeName &&
    (("input" === nodeName &&
      ("text" === elem.type ||
        "search" === elem.type ||
        "tel" === elem.type ||
        "url" === elem.type ||
        "password" === elem.type)) ||
      "textarea" === nodeName ||
      "true" === elem.contentEditable)
  );
}
function restoreSelection(priorSelectionInformation, containerInfo) {
  var curFocusedElem = getActiveElementDeep(containerInfo);
  containerInfo = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (
    curFocusedElem !== containerInfo &&
    containerInfo &&
    containerInfo.ownerDocument &&
    containsNode(containerInfo.ownerDocument.documentElement, containerInfo)
  ) {
    if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo))
      if (
        ((priorSelectionInformation = priorSelectionRange.start),
        (curFocusedElem = priorSelectionRange.end),
        void 0 === curFocusedElem &&
          (curFocusedElem = priorSelectionInformation),
        "selectionStart" in containerInfo)
      )
        (containerInfo.selectionStart = priorSelectionInformation),
          (containerInfo.selectionEnd = Math.min(
            curFocusedElem,
            containerInfo.value.length
          ));
      else if (
        ((curFocusedElem =
          ((priorSelectionInformation =
            containerInfo.ownerDocument || document) &&
            priorSelectionInformation.defaultView) ||
          window),
        curFocusedElem.getSelection)
      ) {
        curFocusedElem = curFocusedElem.getSelection();
        var length = containerInfo.textContent.length,
          start = Math.min(priorSelectionRange.start, length);
        priorSelectionRange =
          void 0 === priorSelectionRange.end
            ? start
            : Math.min(priorSelectionRange.end, length);
        !curFocusedElem.extend &&
          start > priorSelectionRange &&
          ((length = priorSelectionRange),
          (priorSelectionRange = start),
          (start = length));
        length = getNodeForCharacterOffset(containerInfo, start);
        var endMarker = getNodeForCharacterOffset(
          containerInfo,
          priorSelectionRange
        );
        length &&
          endMarker &&
          (1 !== curFocusedElem.rangeCount ||
            curFocusedElem.anchorNode !== length.node ||
            curFocusedElem.anchorOffset !== length.offset ||
            curFocusedElem.focusNode !== endMarker.node ||
            curFocusedElem.focusOffset !== endMarker.offset) &&
          ((priorSelectionInformation =
            priorSelectionInformation.createRange()),
          priorSelectionInformation.setStart(length.node, length.offset),
          curFocusedElem.removeAllRanges(),
          start > priorSelectionRange
            ? (curFocusedElem.addRange(priorSelectionInformation),
              curFocusedElem.extend(endMarker.node, endMarker.offset))
            : (priorSelectionInformation.setEnd(
                endMarker.node,
                endMarker.offset
              ),
              curFocusedElem.addRange(priorSelectionInformation)));
      }
    priorSelectionInformation = [];
    for (
      curFocusedElem = containerInfo;
      (curFocusedElem = curFocusedElem.parentNode);

    )
      1 === curFocusedElem.nodeType &&
        priorSelectionInformation.push({
          element: curFocusedElem,
          left: curFocusedElem.scrollLeft,
          top: curFocusedElem.scrollTop
        });
    "function" === typeof containerInfo.focus && containerInfo.focus();
    for (
      containerInfo = 0;
      containerInfo < priorSelectionInformation.length;
      containerInfo++
    )
      (curFocusedElem = priorSelectionInformation[containerInfo]),
        (curFocusedElem.element.scrollLeft = curFocusedElem.left),
        (curFocusedElem.element.scrollTop = curFocusedElem.top);
  }
}
var skipSelectionChangeEvent =
    canUseDOM && "documentMode" in document && 11 >= document.documentMode,
  activeElement = null,
  activeElementInst = null,
  lastSelection = null,
  mouseDown = !1;
function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  var doc =
    nativeEventTarget.window === nativeEventTarget
      ? nativeEventTarget.document
      : 9 === nativeEventTarget.nodeType
        ? nativeEventTarget
        : nativeEventTarget.ownerDocument;
  mouseDown ||
    null == activeElement ||
    activeElement !== getActiveElement(doc) ||
    ((doc = activeElement),
    "selectionStart" in doc && hasSelectionCapabilities(doc)
      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
      : ((doc = (
          (doc.ownerDocument && doc.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        })),
    (lastSelection && shallowEqual(lastSelection, doc)) ||
      ((lastSelection = doc),
      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
      0 < doc.length &&
        ((nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        )),
        dispatchQueue.push({ event: nativeEvent, listeners: doc }),
        (nativeEvent.target = activeElement))));
}
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit" + styleProp] = "webkit" + eventName;
  prefixes["Moz" + styleProp] = "moz" + eventName;
  return prefixes;
}
var vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  },
  prefixedEventNames = {},
  style = {};
canUseDOM &&
  ((style = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete vendorPrefixes.animationend.animation,
    delete vendorPrefixes.animationiteration.animation,
    delete vendorPrefixes.animationstart.animation),
  "TransitionEvent" in window ||
    delete vendorPrefixes.transitionend.transition);
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
  if (!vendorPrefixes[eventName]) return eventName;
  var prefixMap = vendorPrefixes[eventName],
    styleProp;
  for (styleProp in prefixMap)
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
      return (prefixedEventNames[eventName] = prefixMap[styleProp]);
  return eventName;
}
var ANIMATION_END = getVendorPrefixedEventName("animationend"),
  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
  ANIMATION_START = getVendorPrefixedEventName("animationstart"),
  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
  TRANSITION_END = getVendorPrefixedEventName("transitionend"),
  topLevelEventsToReactNames = new Map(),
  simpleEventPluginEvents =
    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
      " "
    );
function registerSimpleEvent(domEventName, reactName) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}
var concurrentQueues = [],
  concurrentQueuesIndex = 0,
  concurrentlyUpdatedLanes = 0;
function finishQueueingConcurrentUpdates() {
  for (
    var endIndex = concurrentQueuesIndex,
      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
    i < endIndex;

  ) {
    var fiber = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var queue = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var update = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var lane = concurrentQueues[i];
    concurrentQueues[i++] = null;
    if (null !== queue && null !== update) {
      var pending = queue.pending;
      null === pending
        ? (update.next = update)
        : ((update.next = pending.next), (pending.next = update));
      queue.pending = update;
    }
    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
  }
}
function enqueueUpdate$1(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
  concurrentlyUpdatedLanes |= lane;
  fiber.lanes |= lane;
  fiber = fiber.alternate;
  null !== fiber && (fiber.lanes |= lane);
}
function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  enqueueUpdate$1(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function enqueueConcurrentRenderForLane(fiber, lane) {
  enqueueUpdate$1(fiber, null, null, lane);
  return getRootForUpdatedFiber(fiber);
}
function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
  sourceFiber.lanes |= lane;
  var alternate = sourceFiber.alternate;
  null !== alternate && (alternate.lanes |= lane);
  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
    (parent.childLanes |= lane),
      (alternate = parent.alternate),
      null !== alternate && (alternate.childLanes |= lane),
      22 === parent.tag &&
        ((sourceFiber = parent.stateNode),
        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),
      (sourceFiber = parent),
      (parent = parent.return);
  isHidden &&
    null !== update &&
    3 === sourceFiber.tag &&
    ((parent = sourceFiber.stateNode),
    (isHidden = 31 - clz32(lane)),
    (parent = parent.hiddenUpdates),
    (sourceFiber = parent[isHidden]),
    null === sourceFiber
      ? (parent[isHidden] = [update])
      : sourceFiber.push(update),
    (update.lane = lane | 536870912));
}
function getRootForUpdatedFiber(sourceFiber) {
  if (50 < nestedUpdateCount)
    throw (
      ((nestedUpdateCount = 0),
      (rootWithNestedUpdates = null),
      Error(formatProdErrorMessage(185)))
    );
  for (var parent = sourceFiber.return; null !== parent; )
    (sourceFiber = parent), (parent = sourceFiber.return);
  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
}
var emptyContextObject = {},
  CapturedStacks = new WeakMap();
function createCapturedValueAtFiber(value, source) {
  if ("object" === typeof value && null !== value) {
    var existing = CapturedStacks.get(value);
    if (void 0 !== existing) return existing;
    source = {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
    CapturedStacks.set(value, source);
    return source;
  }
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}
var forkStack = [],
  forkStackIndex = 0,
  treeForkProvider = null,
  treeForkCount = 0,
  idStack = [],
  idStackIndex = 0,
  treeContextProvider = null,
  treeContextId = 1,
  treeContextOverflow = "";
function pushTreeFork(workInProgress, totalChildren) {
  forkStack[forkStackIndex++] = treeForkCount;
  forkStack[forkStackIndex++] = treeForkProvider;
  treeForkProvider = workInProgress;
  treeForkCount = totalChildren;
}
function pushTreeId(workInProgress, totalChildren, index) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextProvider = workInProgress;
  var baseIdWithLeadingBit = treeContextId;
  workInProgress = treeContextOverflow;
  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
  baseIdWithLeadingBit &= ~(1 << baseLength);
  index += 1;
  var length = 32 - clz32(totalChildren) + baseLength;
  if (30 < length) {
    var numberOfOverflowBits = baseLength - (baseLength % 5);
    length = (
      baseIdWithLeadingBit &
      ((1 << numberOfOverflowBits) - 1)
    ).toString(32);
    baseIdWithLeadingBit >>= numberOfOverflowBits;
    baseLength -= numberOfOverflowBits;
    treeContextId =
      (1 << (32 - clz32(totalChildren) + baseLength)) |
      (index << baseLength) |
      baseIdWithLeadingBit;
    treeContextOverflow = length + workInProgress;
  } else
    (treeContextId =
      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
      (treeContextOverflow = workInProgress);
}
function pushMaterializedTreeId(workInProgress) {
  null !== workInProgress.return &&
    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
}
function popTreeContext(workInProgress) {
  for (; workInProgress === treeForkProvider; )
    (treeForkProvider = forkStack[--forkStackIndex]),
      (forkStack[forkStackIndex] = null),
      (treeForkCount = forkStack[--forkStackIndex]),
      (forkStack[forkStackIndex] = null);
  for (; workInProgress === treeContextProvider; )
    (treeContextProvider = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null),
      (treeContextOverflow = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null),
      (treeContextId = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null);
}
var hydrationParentFiber = null,
  nextHydratableInstance = null,
  isHydrating = !1,
  hydrationErrors = null,
  rootOrSingletonContext = !1,
  HydrationMismatchException = Error(formatProdErrorMessage(519));
function throwOnHydrationMismatch(fiber) {
  var error = Error(formatProdErrorMessage(418, ""));
  queueHydrationError(createCapturedValueAtFiber(error, fiber));
  throw HydrationMismatchException;
}
function prepareToHydrateHostInstance(fiber) {
  var instance = fiber.stateNode,
    type = fiber.type,
    props = fiber.memoizedProps;
  instance[internalInstanceKey] = fiber;
  instance[internalPropsKey] = props;
  switch (type) {
    case "dialog":
      listenToNonDelegatedEvent("cancel", instance);
      listenToNonDelegatedEvent("close", instance);
      break;
    case "iframe":
    case "object":
    case "embed":
      listenToNonDelegatedEvent("load", instance);
      break;
    case "video":
    case "audio":
      for (type = 0; type < mediaEventTypes.length; type++)
        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
      break;
    case "source":
      listenToNonDelegatedEvent("error", instance);
      break;
    case "img":
    case "image":
    case "link":
      listenToNonDelegatedEvent("error", instance);
      listenToNonDelegatedEvent("load", instance);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", instance);
      break;
    case "input":
      listenToNonDelegatedEvent("invalid", instance);
      initInput(
        instance,
        props.value,
        props.defaultValue,
        props.checked,
        props.defaultChecked,
        props.type,
        props.name,
        !0
      );
      track(instance);
      break;
    case "select":
      listenToNonDelegatedEvent("invalid", instance);
      break;
    case "textarea":
      listenToNonDelegatedEvent("invalid", instance),
        initTextarea(instance, props.value, props.defaultValue, props.children),
        track(instance);
  }
  type = props.children;
  ("string" !== typeof type &&
    "number" !== typeof type &&
    "bigint" !== typeof type) ||
  instance.textContent === "" + type ||
  !0 === props.suppressHydrationWarning ||
  checkForUnmatchedText(instance.textContent, type)
    ? (null != props.popover &&
        (listenToNonDelegatedEvent("beforetoggle", instance),
        listenToNonDelegatedEvent("toggle", instance)),
      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),
      null != props.onScrollEnd &&
        listenToNonDelegatedEvent("scrollend", instance),
      null != props.onClick && (instance.onclick = noop$1),
      (instance = !0))
    : (instance = !1);
  instance || throwOnHydrationMismatch(fiber);
}
function popToNextHostParent(fiber) {
  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
    switch (hydrationParentFiber.tag) {
      case 3:
      case 27:
        rootOrSingletonContext = !0;
        return;
      case 5:
      case 13:
        rootOrSingletonContext = !1;
        return;
      default:
        hydrationParentFiber = hydrationParentFiber.return;
    }
}
function popHydrationState(fiber) {
  if (fiber !== hydrationParentFiber) return !1;
  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;
  var shouldClear = !1,
    JSCompiler_temp;
  if ((JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag)) {
    if ((JSCompiler_temp = 5 === fiber.tag))
      (JSCompiler_temp = fiber.type),
        (JSCompiler_temp =
          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
          shouldSetTextContent(fiber.type, fiber.memoizedProps));
    JSCompiler_temp = !JSCompiler_temp;
  }
  JSCompiler_temp && (shouldClear = !0);
  shouldClear && nextHydratableInstance && throwOnHydrationMismatch(fiber);
  popToNextHostParent(fiber);
  if (13 === fiber.tag) {
    fiber = fiber.memoizedState;
    fiber = null !== fiber ? fiber.dehydrated : null;
    if (!fiber) throw Error(formatProdErrorMessage(317));
    a: {
      fiber = fiber.nextSibling;
      for (shouldClear = 0; fiber; ) {
        if (8 === fiber.nodeType)
          if (((JSCompiler_temp = fiber.data), "/$" === JSCompiler_temp)) {
            if (0 === shouldClear) {
              nextHydratableInstance = getNextHydratable(fiber.nextSibling);
              break a;
            }
            shouldClear--;
          } else
            ("$" !== JSCompiler_temp &&
              "$!" !== JSCompiler_temp &&
              "$?" !== JSCompiler_temp) ||
              shouldClear++;
        fiber = fiber.nextSibling;
      }
      nextHydratableInstance = null;
    }
  } else
    nextHydratableInstance = hydrationParentFiber
      ? getNextHydratable(fiber.stateNode.nextSibling)
      : null;
  return !0;
}
function resetHydrationState() {
  nextHydratableInstance = hydrationParentFiber = null;
  isHydrating = !1;
}
function queueHydrationError(error) {
  null === hydrationErrors
    ? (hydrationErrors = [error])
    : hydrationErrors.push(error);
}
var SuspenseException = Error(formatProdErrorMessage(460)),
  SuspenseyCommitException = Error(formatProdErrorMessage(474)),
  noopSuspenseyCommitThenable = { then: function () {} };
function isThenableResolved(thenable) {
  thenable = thenable.status;
  return "fulfilled" === thenable || "rejected" === thenable;
}
function noop$3() {}
function trackUsedThenable(thenableState, thenable, index) {
  index = thenableState[index];
  void 0 === index
    ? thenableState.push(thenable)
    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      thenableState = thenable.reason;
      if (thenableState === SuspenseException)
        throw Error(formatProdErrorMessage(483));
      throw thenableState;
    default:
      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
      else {
        thenableState = workInProgressRoot;
        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
          throw Error(formatProdErrorMessage(482));
        thenableState = thenable;
        thenableState.status = "pending";
        thenableState.then(
          function (fulfilledValue) {
            if ("pending" === thenable.status) {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          },
          function (error) {
            if ("pending" === thenable.status) {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error;
            }
          }
        );
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          thenableState = thenable.reason;
          if (thenableState === SuspenseException)
            throw Error(formatProdErrorMessage(483));
          throw thenableState;
      }
      suspendedThenable = thenable;
      throw SuspenseException;
  }
}
var suspendedThenable = null;
function getSuspendedThenable() {
  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}
var thenableState$1 = null,
  thenableIndexCounter$1 = 0;
function unwrapThenable(thenable) {
  var index = thenableIndexCounter$1;
  thenableIndexCounter$1 += 1;
  null === thenableState$1 && (thenableState$1 = []);
  return trackUsedThenable(thenableState$1, thenable, index);
}
function coerceRef(workInProgress, element) {
  element = element.props.ref;
  workInProgress.ref = void 0 !== element ? element : null;
}
function throwOnInvalidObjectType(returnFiber, newChild) {
  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
    throw Error(formatProdErrorMessage(525));
  returnFiber = Object.prototype.toString.call(newChild);
  throw Error(
    formatProdErrorMessage(
      31,
      "[object Object]" === returnFiber
        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
        : returnFiber
    )
  );
}
function resolveLazy(lazyType) {
  var init = lazyType._init;
  return init(lazyType._payload);
}
function createChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (shouldTrackSideEffects) {
      var deletions = returnFiber.deletions;
      null === deletions
        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))
        : deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) return null;
    for (; null !== currentFirstChild; )
      deleteChild(returnFiber, currentFirstChild),
        (currentFirstChild = currentFirstChild.sibling);
    return null;
  }
  function mapRemainingChildren(currentFirstChild) {
    for (var existingChildren = new Map(); null !== currentFirstChild; )
      null !== currentFirstChild.key
        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
        : existingChildren.set(currentFirstChild.index, currentFirstChild),
        (currentFirstChild = currentFirstChild.sibling);
    return existingChildren;
  }
  function useFiber(fiber, pendingProps) {
    fiber = createWorkInProgress(fiber, pendingProps);
    fiber.index = 0;
    fiber.sibling = null;
    return fiber;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects)
      return (newFiber.flags |= 1048576), lastPlacedIndex;
    newIndex = newFiber.alternate;
    if (null !== newIndex)
      return (
        (newIndex = newIndex.index),
        newIndex < lastPlacedIndex
          ? ((newFiber.flags |= 33554434), lastPlacedIndex)
          : newIndex
      );
    newFiber.flags |= 33554434;
    return lastPlacedIndex;
  }
  function placeSingleChild(newFiber) {
    shouldTrackSideEffects &&
      null === newFiber.alternate &&
      (newFiber.flags |= 33554434);
    return newFiber;
  }
  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (null === current || 6 !== current.tag)
      return (
        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, textContent);
    current.return = returnFiber;
    return current;
  }
  function updateElement(returnFiber, current, element, lanes) {
    var elementType = element.type;
    if (elementType === REACT_FRAGMENT_TYPE)
      return updateFragment(
        returnFiber,
        current,
        element.props.children,
        lanes,
        element.key
      );
    if (
      null !== current &&
      (current.elementType === elementType ||
        ("object" === typeof elementType &&
          null !== elementType &&
          elementType.$$typeof === REACT_LAZY_TYPE &&
          resolveLazy(elementType) === current.type))
    )
      return (
        (current = useFiber(current, element.props)),
        coerceRef(current, element),
        (current.return = returnFiber),
        current
      );
    current = createFiberFromTypeAndProps(
      element.type,
      element.key,
      element.props,
      null,
      returnFiber.mode,
      lanes
    );
    coerceRef(current, element);
    current.return = returnFiber;
    return current;
  }
  function updatePortal(returnFiber, current, portal, lanes) {
    if (
      null === current ||
      4 !== current.tag ||
      current.stateNode.containerInfo !== portal.containerInfo ||
      current.stateNode.implementation !== portal.implementation
    )
      return (
        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, portal.children || []);
    current.return = returnFiber;
    return current;
  }
  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (null === current || 7 !== current.tag)
      return (
        (current = createFiberFromFragment(
          fragment,
          returnFiber.mode,
          lanes,
          key
        )),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, fragment);
    current.return = returnFiber;
    return current;
  }
  function createChild(returnFiber, newChild, lanes) {
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return (
        (newChild = createFiberFromText(
          "" + newChild,
          returnFiber.mode,
          lanes
        )),
        (newChild.return = returnFiber),
        newChild
      );
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return (
            (lanes = createFiberFromTypeAndProps(
              newChild.type,
              newChild.key,
              newChild.props,
              null,
              returnFiber.mode,
              lanes
            )),
            coerceRef(lanes, newChild),
            (lanes.return = returnFiber),
            lanes
          );
        case REACT_PORTAL_TYPE:
          return (
            (newChild = createFiberFromPortal(
              newChild,
              returnFiber.mode,
              lanes
            )),
            (newChild.return = returnFiber),
            newChild
          );
        case REACT_LAZY_TYPE:
          var init = newChild._init;
          newChild = init(newChild._payload);
          return createChild(returnFiber, newChild, lanes);
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return (
          (newChild = createFiberFromFragment(
            newChild,
            returnFiber.mode,
            lanes,
            null
          )),
          (newChild.return = returnFiber),
          newChild
        );
      if ("function" === typeof newChild.then)
        return createChild(returnFiber, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return createChild(
          returnFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    var key = null !== oldFiber ? oldFiber.key : null;
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return null !== key
        ? null
        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return newChild.key === key
            ? updateElement(returnFiber, oldFiber, newChild, lanes)
            : null;
        case REACT_PORTAL_TYPE:
          return newChild.key === key
            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
            : null;
        case REACT_LAZY_TYPE:
          return (
            (key = newChild._init),
            (newChild = key(newChild._payload)),
            updateSlot(returnFiber, oldFiber, newChild, lanes)
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return null !== key
          ? null
          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      if ("function" === typeof newChild.then)
        return updateSlot(
          returnFiber,
          oldFiber,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateSlot(
          returnFiber,
          oldFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function updateFromMap(
    existingChildren,
    returnFiber,
    newIdx,
    newChild,
    lanes
  ) {
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return (
        (existingChildren = existingChildren.get(newIdx) || null),
        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
      );
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return (
            (existingChildren =
              existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null),
            updateElement(returnFiber, existingChildren, newChild, lanes)
          );
        case REACT_PORTAL_TYPE:
          return (
            (existingChildren =
              existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null),
            updatePortal(returnFiber, existingChildren, newChild, lanes)
          );
        case REACT_LAZY_TYPE:
          var init = newChild._init;
          newChild = init(newChild._payload);
          return updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            newChild,
            lanes
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return (
          (existingChildren = existingChildren.get(newIdx) || null),
          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
        );
      if ("function" === typeof newChild.then)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function reconcileChildrenArray(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes
  ) {
    for (
      var resultingFirstChild = null,
        previousNewFiber = null,
        oldFiber = currentFirstChild,
        newIdx = (currentFirstChild = 0),
        nextOldFiber = null;
      null !== oldFiber && newIdx < newChildren.length;
      newIdx++
    ) {
      oldFiber.index > newIdx
        ? ((nextOldFiber = oldFiber), (oldFiber = null))
        : (nextOldFiber = oldFiber.sibling);
      var newFiber = updateSlot(
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes
      );
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects &&
        oldFiber &&
        null === newFiber.alternate &&
        deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber
        ? (resultingFirstChild = newFiber)
        : (previousNewFiber.sibling = newFiber);
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx === newChildren.length)
      return (
        deleteRemainingChildren(returnFiber, oldFiber),
        isHydrating && pushTreeFork(returnFiber, newIdx),
        resultingFirstChild
      );
    if (null === oldFiber) {
      for (; newIdx < newChildren.length; newIdx++)
        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
          null !== oldFiber &&
            ((currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            )),
            null === previousNewFiber
              ? (resultingFirstChild = oldFiber)
              : (previousNewFiber.sibling = oldFiber),
            (previousNewFiber = oldFiber));
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (
      oldFiber = mapRemainingChildren(oldFiber);
      newIdx < newChildren.length;
      newIdx++
    )
      (nextOldFiber = updateFromMap(
        oldFiber,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        lanes
      )),
        null !== nextOldFiber &&
          (shouldTrackSideEffects &&
            null !== nextOldFiber.alternate &&
            oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ),
          (currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          )),
          null === previousNewFiber
            ? (resultingFirstChild = nextOldFiber)
            : (previousNewFiber.sibling = nextOldFiber),
          (previousNewFiber = nextOldFiber));
    shouldTrackSideEffects &&
      oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildrenIterator(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes
  ) {
    if (null == newChildren) throw Error(formatProdErrorMessage(151));
    for (
      var resultingFirstChild = null,
        previousNewFiber = null,
        oldFiber = currentFirstChild,
        newIdx = (currentFirstChild = 0),
        nextOldFiber = null,
        step = newChildren.next();
      null !== oldFiber && !step.done;
      newIdx++, step = newChildren.next()
    ) {
      oldFiber.index > newIdx
        ? ((nextOldFiber = oldFiber), (oldFiber = null))
        : (nextOldFiber = oldFiber.sibling);
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects &&
        oldFiber &&
        null === newFiber.alternate &&
        deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber
        ? (resultingFirstChild = newFiber)
        : (previousNewFiber.sibling = newFiber);
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (step.done)
      return (
        deleteRemainingChildren(returnFiber, oldFiber),
        isHydrating && pushTreeFork(returnFiber, newIdx),
        resultingFirstChild
      );
    if (null === oldFiber) {
      for (; !step.done; newIdx++, step = newChildren.next())
        (step = createChild(returnFiber, step.value, lanes)),
          null !== step &&
            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
            null === previousNewFiber
              ? (resultingFirstChild = step)
              : (previousNewFiber.sibling = step),
            (previousNewFiber = step));
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (
      oldFiber = mapRemainingChildren(oldFiber);
      !step.done;
      newIdx++, step = newChildren.next()
    )
      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
        null !== step &&
          (shouldTrackSideEffects &&
            null !== step.alternate &&
            oldFiber.delete(null === step.key ? newIdx : step.key),
          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
          null === previousNewFiber
            ? (resultingFirstChild = step)
            : (previousNewFiber.sibling = step),
          (previousNewFiber = step));
    shouldTrackSideEffects &&
      oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildFibersImpl(
    returnFiber,
    currentFirstChild,
    newChild,
    lanes
  ) {
    "object" === typeof newChild &&
      null !== newChild &&
      newChild.type === REACT_FRAGMENT_TYPE &&
      null === newChild.key &&
      (newChild = newChild.props.children);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          a: {
            for (var key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key) {
                key = newChild.type;
                if (key === REACT_FRAGMENT_TYPE) {
                  if (7 === currentFirstChild.tag) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(
                      currentFirstChild,
                      newChild.props.children
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                } else if (
                  currentFirstChild.elementType === key ||
                  ("object" === typeof key &&
                    null !== key &&
                    key.$$typeof === REACT_LAZY_TYPE &&
                    resolveLazy(key) === currentFirstChild.type)
                ) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.props);
                  coerceRef(lanes, newChild);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                }
                deleteRemainingChildren(returnFiber, currentFirstChild);
                break;
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            newChild.type === REACT_FRAGMENT_TYPE
              ? ((lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                )),
                (lanes.return = returnFiber),
                (returnFiber = lanes))
              : ((lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                )),
                coerceRef(lanes, newChild),
                (lanes.return = returnFiber),
                (returnFiber = lanes));
          }
          return placeSingleChild(returnFiber);
        case REACT_PORTAL_TYPE:
          a: {
            for (key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key)
                if (
                  4 === currentFirstChild.tag &&
                  currentFirstChild.stateNode.containerInfo ===
                    newChild.containerInfo &&
                  currentFirstChild.stateNode.implementation ===
                    newChild.implementation
                ) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.children || []);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
            lanes.return = returnFiber;
            returnFiber = lanes;
          }
          return placeSingleChild(returnFiber);
        case REACT_LAZY_TYPE:
          return (
            (key = newChild._init),
            (newChild = key(newChild._payload)),
            reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            )
          );
      }
      if (isArrayImpl(newChild))
        return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      if (getIteratorFn(newChild)) {
        key = getIteratorFn(newChild);
        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
        newChild = key.call(newChild);
        return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      }
      if ("function" === typeof newChild.then)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
      ? ((newChild = "" + newChild),
        null !== currentFirstChild && 6 === currentFirstChild.tag
          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
            (lanes = useFiber(currentFirstChild, newChild)),
            (lanes.return = returnFiber),
            (returnFiber = lanes))
          : (deleteRemainingChildren(returnFiber, currentFirstChild),
            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
            (lanes.return = returnFiber),
            (returnFiber = lanes)),
        placeSingleChild(returnFiber))
      : deleteRemainingChildren(returnFiber, currentFirstChild);
  }
  return function (returnFiber, currentFirstChild, newChild, lanes) {
    try {
      thenableIndexCounter$1 = 0;
      var firstChildFiber = reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      );
      thenableState$1 = null;
      return firstChildFiber;
    } catch (x) {
      if (x === SuspenseException) throw x;
      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
      fiber.lanes = lanes;
      fiber.return = returnFiber;
      return fiber;
    } finally {
    }
  };
}
var reconcileChildFibers = createChildReconciler(!0),
  mountChildFibers = createChildReconciler(!1),
  currentTreeHiddenStackCursor = createCursor(null),
  prevEntangledRenderLanesCursor = createCursor(0);
function pushHiddenContext(fiber, context) {
  fiber = entangledRenderLanes;
  push(prevEntangledRenderLanesCursor, fiber);
  push(currentTreeHiddenStackCursor, context);
  entangledRenderLanes = fiber | context.baseLanes;
}
function reuseHiddenContextOnStack() {
  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
}
function popHiddenContext() {
  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
  pop(currentTreeHiddenStackCursor);
  pop(prevEntangledRenderLanesCursor);
}
var suspenseHandlerStackCursor = createCursor(null),
  shellBoundary = null;
function pushPrimaryTreeSuspenseHandler(handler) {
  var current = handler.alternate;
  push(suspenseStackCursor, suspenseStackCursor.current & 1);
  push(suspenseHandlerStackCursor, handler);
  null === shellBoundary &&
    (null === current || null !== currentTreeHiddenStackCursor.current
      ? (shellBoundary = handler)
      : null !== current.memoizedState && (shellBoundary = handler));
}
function pushOffscreenSuspenseHandler(fiber) {
  if (22 === fiber.tag) {
    if (
      (push(suspenseStackCursor, suspenseStackCursor.current),
      push(suspenseHandlerStackCursor, fiber),
      null === shellBoundary)
    ) {
      var current = fiber.alternate;
      null !== current &&
        null !== current.memoizedState &&
        (shellBoundary = fiber);
    }
  } else reuseSuspenseHandlerOnStack(fiber);
}
function reuseSuspenseHandlerOnStack() {
  push(suspenseStackCursor, suspenseStackCursor.current);
  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
}
function popSuspenseHandler(fiber) {
  pop(suspenseHandlerStackCursor);
  shellBoundary === fiber && (shellBoundary = null);
  pop(suspenseStackCursor);
}
var suspenseStackCursor = createCursor(0);
function findFirstSuspended(row) {
  for (var node = row; null !== node; ) {
    if (13 === node.tag) {
      var state = node.memoizedState;
      if (
        null !== state &&
        ((state = state.dehydrated),
        null === state || "$?" === state.data || "$!" === state.data)
      )
        return node;
    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
      if (0 !== (node.flags & 128)) return node;
    } else if (null !== node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === row) break;
    for (; null === node.sibling; ) {
      if (null === node.return || node.return === row) return null;
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  return null;
}
var AbortControllerLocal =
    "undefined" !== typeof AbortController
      ? AbortController
      : function () {
          var listeners = [],
            signal = (this.signal = {
              aborted: !1,
              addEventListener: function (type, listener) {
                listeners.push(listener);
              }
            });
          this.abort = function () {
            signal.aborted = !0;
            listeners.forEach(function (listener) {
              return listener();
            });
          };
        },
  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
  NormalPriority = Scheduler.unstable_NormalPriority,
  CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
function createCache() {
  return {
    controller: new AbortControllerLocal(),
    data: new Map(),
    refCount: 0
  };
}
function releaseCache(cache) {
  cache.refCount--;
  0 === cache.refCount &&
    scheduleCallback$2(NormalPriority, function () {
      cache.controller.abort();
    });
}
var currentEntangledListeners = null,
  currentEntangledPendingCount = 0,
  currentEntangledLane = 0,
  currentEntangledActionThenable = null;
function entangleAsyncAction(transition, thenable) {
  if (null === currentEntangledListeners) {
    var entangledListeners = (currentEntangledListeners = []);
    currentEntangledPendingCount = 0;
    currentEntangledLane = requestTransitionLane();
    currentEntangledActionThenable = {
      status: "pending",
      value: void 0,
      then: function (resolve) {
        entangledListeners.push(resolve);
      }
    };
  }
  currentEntangledPendingCount++;
  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
  return thenable;
}
function pingEngtangledActionScope() {
  if (
    0 === --currentEntangledPendingCount &&
    null !== currentEntangledListeners
  ) {
    null !== currentEntangledActionThenable &&
      (currentEntangledActionThenable.status = "fulfilled");
    var listeners = currentEntangledListeners;
    currentEntangledListeners = null;
    currentEntangledLane = 0;
    currentEntangledActionThenable = null;
    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
  }
}
function chainThenableValue(thenable, result) {
  var listeners = [],
    thenableWithOverride = {
      status: "pending",
      value: null,
      reason: null,
      then: function (resolve) {
        listeners.push(resolve);
      }
    };
  thenable.then(
    function () {
      thenableWithOverride.status = "fulfilled";
      thenableWithOverride.value = result;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
    },
    function (error) {
      thenableWithOverride.status = "rejected";
      thenableWithOverride.reason = error;
      for (error = 0; error < listeners.length; error++)
        (0, listeners[error])(void 0);
    }
  );
  return thenableWithOverride;
}
var prevOnStartTransitionFinish = ReactSharedInternals.S;
ReactSharedInternals.S = function (transition, returnValue) {
  "object" === typeof returnValue &&
    null !== returnValue &&
    "function" === typeof returnValue.then &&
    entangleAsyncAction(transition, returnValue);
  null !== prevOnStartTransitionFinish &&
    prevOnStartTransitionFinish(transition, returnValue);
};
var resumedCache = createCursor(null);
function peekCacheFromPool() {
  var cacheResumedFromPreviousRender = resumedCache.current;
  return null !== cacheResumedFromPreviousRender
    ? cacheResumedFromPreviousRender
    : workInProgressRoot.pooledCache;
}
function pushTransition(offscreenWorkInProgress, prevCachePool) {
  null === prevCachePool
    ? push(resumedCache, resumedCache.current)
    : push(resumedCache, prevCachePool.pool);
}
function getSuspendedCache() {
  var cacheFromPool = peekCacheFromPool();
  return null === cacheFromPool
    ? null
    : { parent: CacheContext._currentValue, pool: cacheFromPool };
}
var renderLanes = 0,
  currentlyRenderingFiber$1 = null,
  currentHook = null,
  workInProgressHook = null,
  didScheduleRenderPhaseUpdate = !1,
  didScheduleRenderPhaseUpdateDuringThisPass = !1,
  shouldDoubleInvokeUserFnsInHooksDEV = !1,
  localIdCounter = 0,
  thenableIndexCounter = 0,
  thenableState = null,
  globalClientIdCounter = 0;
function throwInvalidHookError() {
  throw Error(formatProdErrorMessage(321));
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (null === prevDeps) return !1;
  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
  return !0;
}
function renderWithHooks(
  current,
  workInProgress,
  Component,
  props,
  secondArg,
  nextRenderLanes
) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber$1 = workInProgress;
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = 0;
  ReactSharedInternals.H =
    null === current || null === current.memoizedState
      ? HooksDispatcherOnMount
      : HooksDispatcherOnUpdate;
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  nextRenderLanes = Component(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  didScheduleRenderPhaseUpdateDuringThisPass &&
    (nextRenderLanes = renderWithHooksAgain(
      workInProgress,
      Component,
      props,
      secondArg
    ));
  finishRenderingHooks(current);
  return nextRenderLanes;
}
function finishRenderingHooks(current) {
  ReactSharedInternals.H = ContextOnlyDispatcher;
  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
  didScheduleRenderPhaseUpdate = !1;
  thenableIndexCounter = 0;
  thenableState = null;
  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
  null === current ||
    didReceiveUpdate ||
    ((current = current.dependencies),
    null !== current &&
      checkIfContextChanged(current) &&
      (didReceiveUpdate = !0));
}
function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
  currentlyRenderingFiber$1 = workInProgress;
  var numberOfReRenders = 0;
  do {
    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
    thenableIndexCounter = 0;
    didScheduleRenderPhaseUpdateDuringThisPass = !1;
    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
    numberOfReRenders += 1;
    workInProgressHook = currentHook = null;
    if (null != workInProgress.updateQueue) {
      var children = workInProgress.updateQueue;
      children.lastEffect = null;
      children.events = null;
      children.stores = null;
      null != children.memoCache && (children.memoCache.index = 0);
    }
    ReactSharedInternals.H = HooksDispatcherOnRerender;
    children = Component(props, secondArg);
  } while (didScheduleRenderPhaseUpdateDuringThisPass);
  return children;
}
function TransitionAwareHostComponent() {
  var dispatcher = ReactSharedInternals.H,
    maybeThenable = dispatcher.useState()[0];
  maybeThenable =
    "function" === typeof maybeThenable.then
      ? useThenable(maybeThenable)
      : maybeThenable;
  dispatcher = dispatcher.useState()[0];
  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
    (currentlyRenderingFiber$1.flags |= 1024);
  return maybeThenable;
}
function checkDidRenderIdHook() {
  var didRenderIdHook = 0 !== localIdCounter;
  localIdCounter = 0;
  return didRenderIdHook;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= -2053;
  current.lanes &= ~lanes;
}
function resetHooksOnUnwind(workInProgress) {
  if (didScheduleRenderPhaseUpdate) {
    for (
      workInProgress = workInProgress.memoizedState;
      null !== workInProgress;

    ) {
      var queue = workInProgress.queue;
      null !== queue && (queue.pending = null);
      workInProgress = workInProgress.next;
    }
    didScheduleRenderPhaseUpdate = !1;
  }
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
  didScheduleRenderPhaseUpdateDuringThisPass = !1;
  thenableIndexCounter = localIdCounter = 0;
  thenableState = null;
}
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === workInProgressHook
    ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook)
    : (workInProgressHook = workInProgressHook.next = hook);
  return workInProgressHook;
}
function updateWorkInProgressHook() {
  if (null === currentHook) {
    var nextCurrentHook = currentlyRenderingFiber$1.alternate;
    nextCurrentHook =
      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
  } else nextCurrentHook = currentHook.next;
  var nextWorkInProgressHook =
    null === workInProgressHook
      ? currentlyRenderingFiber$1.memoizedState
      : workInProgressHook.next;
  if (null !== nextWorkInProgressHook)
    (workInProgressHook = nextWorkInProgressHook),
      (currentHook = nextCurrentHook);
  else {
    if (null === nextCurrentHook) {
      if (null === currentlyRenderingFiber$1.alternate)
        throw Error(formatProdErrorMessage(467));
      throw Error(formatProdErrorMessage(310));
    }
    currentHook = nextCurrentHook;
    nextCurrentHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };
    null === workInProgressHook
      ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook =
          nextCurrentHook)
      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
  }
  return workInProgressHook;
}
var createFunctionComponentUpdateQueue;
createFunctionComponentUpdateQueue = function () {
  return { lastEffect: null, events: null, stores: null, memoCache: null };
};
function useThenable(thenable) {
  var index = thenableIndexCounter;
  thenableIndexCounter += 1;
  null === thenableState && (thenableState = []);
  thenable = trackUsedThenable(thenableState, thenable, index);
  index = currentlyRenderingFiber$1;
  null ===
    (null === workInProgressHook
      ? index.memoizedState
      : workInProgressHook.next) &&
    ((index = index.alternate),
    (ReactSharedInternals.H =
      null === index || null === index.memoizedState
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate));
  return thenable;
}
function use(usable) {
  if (null !== usable && "object" === typeof usable) {
    if ("function" === typeof usable.then) return useThenable(usable);
    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
  }
  throw Error(formatProdErrorMessage(438, String(usable)));
}
function useMemoCache(size) {
  var memoCache = null,
    updateQueue = currentlyRenderingFiber$1.updateQueue;
  null !== updateQueue && (memoCache = updateQueue.memoCache);
  if (null == memoCache) {
    var current = currentlyRenderingFiber$1.alternate;
    null !== current &&
      ((current = current.updateQueue),
      null !== current &&
        ((current = current.memoCache),
        null != current &&
          (memoCache = {
            data: current.data.map(function (array) {
              return array.slice();
            }),
            index: 0
          })));
  }
  null == memoCache && (memoCache = { data: [], index: 0 });
  null === updateQueue &&
    ((updateQueue = createFunctionComponentUpdateQueue()),
    (currentlyRenderingFiber$1.updateQueue = updateQueue));
  updateQueue.memoCache = memoCache;
  updateQueue = memoCache.data[memoCache.index];
  if (void 0 === updateQueue)
    for (
      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;
      current < size;
      current++
    )
      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
  memoCache.index++;
  return updateQueue;
}
function basicStateReducer(state, action) {
  return "function" === typeof action ? action(state) : action;
}
function updateReducer(reducer) {
  var hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, currentHook, reducer);
}
function updateReducerImpl(hook, current, reducer) {
  var queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var baseQueue = hook.baseQueue,
    pendingQueue = queue.pending;
  if (null !== pendingQueue) {
    if (null !== baseQueue) {
      var baseFirst = baseQueue.next;
      baseQueue.next = pendingQueue.next;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  pendingQueue = hook.baseState;
  if (null === baseQueue) hook.memoizedState = pendingQueue;
  else {
    current = baseQueue.next;
    var newBaseQueueFirst = (baseFirst = null),
      newBaseQueueLast = null,
      update = current,
      didReadFromEntangledAsyncAction$54 = !1;
    do {
      var updateLane = update.lane & -536870913;
      if (
        updateLane !== update.lane
          ? (workInProgressRootRenderLanes & updateLane) === updateLane
          : (renderLanes & updateLane) === updateLane
      ) {
        var revertLane = update.revertLane;
        if (0 === revertLane)
          null !== newBaseQueueLast &&
            (newBaseQueueLast = newBaseQueueLast.next =
              {
                lane: 0,
                revertLane: 0,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }),
            updateLane === currentEntangledLane &&
              (didReadFromEntangledAsyncAction$54 = !0);
        else if ((renderLanes & revertLane) === revertLane) {
          update = update.next;
          revertLane === currentEntangledLane &&
            (didReadFromEntangledAsyncAction$54 = !0);
          continue;
        } else
          (updateLane = {
            lane: 0,
            revertLane: update.revertLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }),
            null === newBaseQueueLast
              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                (baseFirst = pendingQueue))
              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
            (currentlyRenderingFiber$1.lanes |= revertLane),
            (workInProgressRootSkippedLanes |= revertLane);
        updateLane = update.action;
        shouldDoubleInvokeUserFnsInHooksDEV &&
          reducer(pendingQueue, updateLane);
        pendingQueue = update.hasEagerState
          ? update.eagerState
          : reducer(pendingQueue, updateLane);
      } else
        (revertLane = {
          lane: updateLane,
          revertLane: update.revertLane,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }),
          null === newBaseQueueLast
            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
              (baseFirst = pendingQueue))
            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
          (currentlyRenderingFiber$1.lanes |= updateLane),
          (workInProgressRootSkippedLanes |= updateLane);
      update = update.next;
    } while (null !== update && update !== current);
    null === newBaseQueueLast
      ? (baseFirst = pendingQueue)
      : (newBaseQueueLast.next = newBaseQueueFirst);
    if (
      !objectIs(pendingQueue, hook.memoizedState) &&
      ((didReceiveUpdate = !0),
      didReadFromEntangledAsyncAction$54 &&
        ((reducer = currentEntangledActionThenable), null !== reducer))
    )
      throw reducer;
    hook.memoizedState = pendingQueue;
    hook.baseState = baseFirst;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = pendingQueue;
  }
  null === baseQueue && (queue.lanes = 0);
  return [hook.memoizedState, queue.dispatch];
}
function rerenderReducer(reducer) {
  var hook = updateWorkInProgressHook(),
    queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var dispatch = queue.dispatch,
    lastRenderPhaseUpdate = queue.pending,
    newState = hook.memoizedState;
  if (null !== lastRenderPhaseUpdate) {
    queue.pending = null;
    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
    do (newState = reducer(newState, update.action)), (update = update.next);
    while (update !== lastRenderPhaseUpdate);
    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
    hook.memoizedState = newState;
    null === hook.baseQueue && (hook.baseState = newState);
    queue.lastRenderedState = newState;
  }
  return [newState, dispatch];
}
function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  var fiber = currentlyRenderingFiber$1,
    hook = updateWorkInProgressHook(),
    isHydrating$jscomp$0 = isHydrating;
  if (isHydrating$jscomp$0) {
    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
    getServerSnapshot = getServerSnapshot();
  } else getServerSnapshot = getSnapshot();
  var snapshotChanged = !objectIs(
    (currentHook || hook).memoizedState,
    getServerSnapshot
  );
  snapshotChanged &&
    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));
  hook = hook.queue;
  updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
    subscribe
  ]);
  if (
    hook.getSnapshot !== getSnapshot ||
    snapshotChanged ||
    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
  ) {
    fiber.flags |= 2048;
    pushEffect(
      9,
      updateStoreInstance.bind(
        null,
        fiber,
        hook,
        getServerSnapshot,
        getSnapshot
      ),
      { destroy: void 0 },
      null
    );
    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
    isHydrating$jscomp$0 ||
      0 !== (renderLanes & 60) ||
      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
  }
  return getServerSnapshot;
}
function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
  fiber.flags |= 16384;
  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
  getSnapshot = currentlyRenderingFiber$1.updateQueue;
  null === getSnapshot
    ? ((getSnapshot = createFunctionComponentUpdateQueue()),
      (currentlyRenderingFiber$1.updateQueue = getSnapshot),
      (getSnapshot.stores = [fiber]))
    : ((renderedSnapshot = getSnapshot.stores),
      null === renderedSnapshot
        ? (getSnapshot.stores = [fiber])
        : renderedSnapshot.push(fiber));
}
function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;
  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
}
function subscribeToStore(fiber, inst, subscribe) {
  return subscribe(function () {
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  });
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return !0;
  }
}
function forceStoreRerender(fiber) {
  var root = enqueueConcurrentRenderForLane(fiber, 2);
  null !== root && scheduleUpdateOnFiber(root, fiber, 2);
}
function mountStateImpl(initialState) {
  var hook = mountWorkInProgressHook();
  if ("function" === typeof initialState) {
    var initialStateInitializer = initialState;
    initialState = initialStateInitializer();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        initialStateInitializer();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
  }
  hook.memoizedState = hook.baseState = initialState;
  hook.queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  return hook;
}
function updateOptimisticImpl(hook, current, passthrough, reducer) {
  hook.baseState = passthrough;
  return updateReducerImpl(
    hook,
    currentHook,
    "function" === typeof reducer ? reducer : basicStateReducer
  );
}
function dispatchActionState(
  fiber,
  actionQueue,
  setPendingState,
  setState,
  payload
) {
  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
  fiber = actionQueue.action;
  if (null !== fiber) {
    var actionNode = {
      payload: payload,
      action: fiber,
      next: null,
      isTransition: !0,
      status: "pending",
      value: null,
      reason: null,
      listeners: [],
      then: function (listener) {
        actionNode.listeners.push(listener);
      }
    };
    null !== ReactSharedInternals.T
      ? setPendingState(!0)
      : (actionNode.isTransition = !1);
    setState(actionNode);
    setPendingState = actionQueue.pending;
    null === setPendingState
      ? ((actionNode.next = actionQueue.pending = actionNode),
        runActionStateAction(actionQueue, actionNode))
      : ((actionNode.next = setPendingState.next),
        (actionQueue.pending = setPendingState.next = actionNode));
  }
}
function runActionStateAction(actionQueue, node) {
  var action = node.action,
    payload = node.payload,
    prevState = actionQueue.state;
  if (node.isTransition) {
    var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = action(prevState, payload),
        onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish &&
        onStartTransitionFinish(currentTransition, returnValue);
      handleActionReturnValue(actionQueue, node, returnValue);
    } catch (error) {
      onActionError(actionQueue, node, error);
    } finally {
      ReactSharedInternals.T = prevTransition;
    }
  } else
    try {
      (prevTransition = action(prevState, payload)),
        handleActionReturnValue(actionQueue, node, prevTransition);
    } catch (error$60) {
      onActionError(actionQueue, node, error$60);
    }
}
function handleActionReturnValue(actionQueue, node, returnValue) {
  null !== returnValue &&
  "object" === typeof returnValue &&
  "function" === typeof returnValue.then
    ? returnValue.then(
        function (nextState) {
          onActionSuccess(actionQueue, node, nextState);
        },
        function (error) {
          return onActionError(actionQueue, node, error);
        }
      )
    : onActionSuccess(actionQueue, node, returnValue);
}
function onActionSuccess(actionQueue, actionNode, nextState) {
  actionNode.status = "fulfilled";
  actionNode.value = nextState;
  notifyActionListeners(actionNode);
  actionQueue.state = nextState;
  actionNode = actionQueue.pending;
  null !== actionNode &&
    ((nextState = actionNode.next),
    nextState === actionNode
      ? (actionQueue.pending = null)
      : ((nextState = nextState.next),
        (actionNode.next = nextState),
        runActionStateAction(actionQueue, nextState)));
}
function onActionError(actionQueue, actionNode, error) {
  var last = actionQueue.pending;
  actionQueue.pending = null;
  if (null !== last) {
    last = last.next;
    do
      (actionNode.status = "rejected"),
        (actionNode.reason = error),
        notifyActionListeners(actionNode),
        (actionNode = actionNode.next);
    while (actionNode !== last);
  }
  actionQueue.action = null;
}
function notifyActionListeners(actionNode) {
  actionNode = actionNode.listeners;
  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
}
function actionStateReducer(oldState, newState) {
  return newState;
}
function mountActionState(action, initialStateProp) {
  if (isHydrating) {
    var ssrFormState = workInProgressRoot.formState;
    if (null !== ssrFormState) {
      a: {
        var JSCompiler_inline_result = currentlyRenderingFiber$1;
        if (isHydrating) {
          if (nextHydratableInstance) {
            b: {
              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
              for (
                var inRootOrSingleton = rootOrSingletonContext;
                8 !== JSCompiler_inline_result$jscomp$0.nodeType;

              ) {
                if (!inRootOrSingleton) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                  JSCompiler_inline_result$jscomp$0.nextSibling
                );
                if (null === JSCompiler_inline_result$jscomp$0) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
              }
              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
              JSCompiler_inline_result$jscomp$0 =
                "F!" === inRootOrSingleton || "F" === inRootOrSingleton
                  ? JSCompiler_inline_result$jscomp$0
                  : null;
            }
            if (JSCompiler_inline_result$jscomp$0) {
              nextHydratableInstance = getNextHydratable(
                JSCompiler_inline_result$jscomp$0.nextSibling
              );
              JSCompiler_inline_result =
                "F!" === JSCompiler_inline_result$jscomp$0.data;
              break a;
            }
          }
          throwOnHydrationMismatch(JSCompiler_inline_result);
        }
        JSCompiler_inline_result = !1;
      }
      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
    }
  }
  ssrFormState = mountWorkInProgressHook();
  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
  JSCompiler_inline_result = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: actionStateReducer,
    lastRenderedState: initialStateProp
  };
  ssrFormState.queue = JSCompiler_inline_result;
  ssrFormState = dispatchSetState.bind(
    null,
    currentlyRenderingFiber$1,
    JSCompiler_inline_result
  );
  JSCompiler_inline_result.dispatch = ssrFormState;
  JSCompiler_inline_result = mountStateImpl(!1);
  inRootOrSingleton = dispatchOptimisticSetState.bind(
    null,
    currentlyRenderingFiber$1,
    !1,
    JSCompiler_inline_result.queue
  );
  JSCompiler_inline_result = mountWorkInProgressHook();
  JSCompiler_inline_result$jscomp$0 = {
    state: initialStateProp,
    dispatch: null,
    action: action,
    pending: null
  };
  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
  ssrFormState = dispatchActionState.bind(
    null,
    currentlyRenderingFiber$1,
    JSCompiler_inline_result$jscomp$0,
    inRootOrSingleton,
    ssrFormState
  );
  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
  JSCompiler_inline_result.memoizedState = action;
  return [initialStateProp, ssrFormState, !1];
}
function updateActionState(action) {
  var stateHook = updateWorkInProgressHook();
  return updateActionStateImpl(stateHook, currentHook, action);
}
function updateActionStateImpl(stateHook, currentStateHook, action) {
  currentStateHook = updateReducerImpl(
    stateHook,
    currentStateHook,
    actionStateReducer
  )[0];
  stateHook = updateReducer(basicStateReducer)[0];
  currentStateHook =
    "object" === typeof currentStateHook &&
    null !== currentStateHook &&
    "function" === typeof currentStateHook.then
      ? useThenable(currentStateHook)
      : currentStateHook;
  var actionQueueHook = updateWorkInProgressHook(),
    actionQueue = actionQueueHook.queue,
    dispatch = actionQueue.dispatch;
  action !== actionQueueHook.memoizedState &&
    ((currentlyRenderingFiber$1.flags |= 2048),
    pushEffect(
      9,
      actionStateActionEffect.bind(null, actionQueue, action),
      { destroy: void 0 },
      null
    ));
  return [currentStateHook, dispatch, stateHook];
}
function actionStateActionEffect(actionQueue, action) {
  actionQueue.action = action;
}
function rerenderActionState(action) {
  var stateHook = updateWorkInProgressHook(),
    currentStateHook = currentHook;
  if (null !== currentStateHook)
    return updateActionStateImpl(stateHook, currentStateHook, action);
  updateWorkInProgressHook();
  stateHook = stateHook.memoizedState;
  currentStateHook = updateWorkInProgressHook();
  var dispatch = currentStateHook.queue.dispatch;
  currentStateHook.memoizedState = action;
  return [stateHook, dispatch, !1];
}
function pushEffect(tag, create, inst, deps) {
  tag = { tag: tag, create: create, inst: inst, deps: deps, next: null };
  create = currentlyRenderingFiber$1.updateQueue;
  null === create &&
    ((create = createFunctionComponentUpdateQueue()),
    (currentlyRenderingFiber$1.updateQueue = create));
  inst = create.lastEffect;
  null === inst
    ? (create.lastEffect = tag.next = tag)
    : ((deps = inst.next),
      (inst.next = tag),
      (tag.next = deps),
      (create.lastEffect = tag));
  return tag;
}
function updateRef() {
  return updateWorkInProgressHook().memoizedState;
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    1 | hookFlags,
    create,
    { destroy: void 0 },
    void 0 === deps ? null : deps
  );
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var inst = hook.memoizedState.inst;
  null !== currentHook &&
  null !== deps &&
  areHookInputsEqual(deps, currentHook.memoizedState.deps)
    ? (hook.memoizedState = pushEffect(hookFlags, create, inst, deps))
    : ((currentlyRenderingFiber$1.flags |= fiberFlags),
      (hook.memoizedState = pushEffect(1 | hookFlags, create, inst, deps)));
}
function mountEffect(create, deps) {
  mountEffectImpl(8390656, 8, create, deps);
}
function updateEffect(create, deps) {
  updateEffectImpl(2048, 8, create, deps);
}
function updateInsertionEffect(create, deps) {
  return updateEffectImpl(4, 2, create, deps);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(4, 4, create, deps);
}
function imperativeHandleEffect(create, ref) {
  if ("function" === typeof ref) {
    create = create();
    var refCleanup = ref(create);
    return function () {
      "function" === typeof refCleanup ? refCleanup() : ref(null);
    };
  }
  if (null !== ref && void 0 !== ref)
    return (
      (create = create()),
      (ref.current = create),
      function () {
        ref.current = null;
      }
    );
}
function updateImperativeHandle(ref, create, deps) {
  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
}
function mountDebugValue() {}
function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  hook.memoizedState = [callback, deps];
  return callback;
}
function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  prevState = nextCreate();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(!0);
    try {
      nextCreate();
    } finally {
      setIsStrictModeForDevtools(!1);
    }
  }
  hook.memoizedState = [prevState, deps];
  return prevState;
}
function mountDeferredValueImpl(hook, value, initialValue) {
  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
    return (hook.memoizedState = value);
  hook.memoizedState = initialValue;
  hook = requestDeferredLane();
  currentlyRenderingFiber$1.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return initialValue;
}
function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
  if (objectIs(value, prevValue)) return value;
  if (null !== currentTreeHiddenStackCursor.current)
    return (
      (hook = mountDeferredValueImpl(hook, value, initialValue)),
      objectIs(hook, prevValue) || (didReceiveUpdate = !0),
      hook
    );
  if (0 === (renderLanes & 42))
    return (didReceiveUpdate = !0), (hook.memoizedState = value);
  hook = requestDeferredLane();
  currentlyRenderingFiber$1.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return prevValue;
}
function startTransition(fiber, queue, pendingState, finishedState, callback) {
  var previousPriority = ReactDOMSharedInternals.p;
  ReactDOMSharedInternals.p =
    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  dispatchOptimisticSetState(fiber, !1, queue, pendingState);
  try {
    var returnValue = callback(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish &&
      onStartTransitionFinish(currentTransition, returnValue);
    if (
      null !== returnValue &&
      "object" === typeof returnValue &&
      "function" === typeof returnValue.then
    ) {
      var thenableForFinishedState = chainThenableValue(
        returnValue,
        finishedState
      );
      dispatchSetStateInternal(
        fiber,
        queue,
        thenableForFinishedState,
        requestUpdateLane(fiber)
      );
    } else
      dispatchSetStateInternal(
        fiber,
        queue,
        finishedState,
        requestUpdateLane(fiber)
      );
  } catch (error) {
    dispatchSetStateInternal(
      fiber,
      queue,
      { then: function () {}, status: "rejected", reason: error },
      requestUpdateLane()
    );
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function noop$2() {}
function startHostTransition(formFiber, pendingState, action, formData) {
  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
  var queue = ensureFormComponentIsStateful(formFiber).queue;
  startTransition(
    formFiber,
    queue,
    pendingState,
    sharedNotPendingObject,
    null === action
      ? noop$2
      : function () {
          requestFormReset$1(formFiber);
          return action(formData);
        }
  );
}
function ensureFormComponentIsStateful(formFiber) {
  var existingStateHook = formFiber.memoizedState;
  if (null !== existingStateHook) return existingStateHook;
  existingStateHook = {
    memoizedState: sharedNotPendingObject,
    baseState: sharedNotPendingObject,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: sharedNotPendingObject
    },
    next: null
  };
  var initialResetState = {};
  existingStateHook.next = {
    memoizedState: initialResetState,
    baseState: initialResetState,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialResetState
    },
    next: null
  };
  formFiber.memoizedState = existingStateHook;
  formFiber = formFiber.alternate;
  null !== formFiber && (formFiber.memoizedState = existingStateHook);
  return existingStateHook;
}
function requestFormReset$1(formFiber) {
  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
}
function useHostTransitionStatus() {
  return readContext(HostTransitionContext);
}
function updateId() {
  return updateWorkInProgressHook().memoizedState;
}
function updateRefresh() {
  return updateWorkInProgressHook().memoizedState;
}
function refreshCache(fiber) {
  for (var provider = fiber.return; null !== provider; ) {
    switch (provider.tag) {
      case 24:
      case 3:
        var lane = requestUpdateLane();
        fiber = createUpdate(lane);
        var root$63 = enqueueUpdate(provider, fiber, lane);
        null !== root$63 &&
          (scheduleUpdateOnFiber(root$63, provider, lane),
          entangleTransitions(root$63, provider, lane));
        provider = { cache: createCache() };
        fiber.payload = provider;
        return;
    }
    provider = provider.return;
  }
}
function dispatchReducerAction(fiber, queue, action) {
  var lane = requestUpdateLane();
  action = {
    lane: lane,
    revertLane: 0,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  isRenderPhaseUpdate(fiber)
    ? enqueueRenderPhaseUpdate(queue, action)
    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
      null !== action &&
        (scheduleUpdateOnFiber(action, fiber, lane),
        entangleTransitionUpdate(action, queue, lane)));
}
function dispatchSetState(fiber, queue, action) {
  var lane = requestUpdateLane();
  dispatchSetStateInternal(fiber, queue, action, lane);
}
function dispatchSetStateInternal(fiber, queue, action, lane) {
  var update = {
    lane: lane,
    revertLane: 0,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
  else {
    var alternate = fiber.alternate;
    if (
      0 === fiber.lanes &&
      (null === alternate || 0 === alternate.lanes) &&
      ((alternate = queue.lastRenderedReducer), null !== alternate)
    )
      try {
        var currentState = queue.lastRenderedState,
          eagerState = alternate(currentState, action);
        update.hasEagerState = !0;
        update.eagerState = eagerState;
        if (objectIs(eagerState, currentState))
          return (
            enqueueUpdate$1(fiber, queue, update, 0),
            null === workInProgressRoot && finishQueueingConcurrentUpdates(),
            !1
          );
      } catch (error) {
      } finally {
      }
    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (null !== action)
      return (
        scheduleUpdateOnFiber(action, fiber, lane),
        entangleTransitionUpdate(action, queue, lane),
        !0
      );
  }
  return !1;
}
function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
  action = {
    lane: 2,
    revertLane: requestTransitionLane(),
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
  } else
    (throwIfDuringRender = enqueueConcurrentHookUpdate(
      fiber,
      queue,
      action,
      2
    )),
      null !== throwIfDuringRender &&
        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
}
function isRenderPhaseUpdate(fiber) {
  var alternate = fiber.alternate;
  return (
    fiber === currentlyRenderingFiber$1 ||
    (null !== alternate && alternate === currentlyRenderingFiber$1)
  );
}
function enqueueRenderPhaseUpdate(queue, update) {
  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
    !0;
  var pending = queue.pending;
  null === pending
    ? (update.next = update)
    : ((update.next = pending.next), (pending.next = update));
  queue.pending = update;
}
function entangleTransitionUpdate(root, queue, lane) {
  if (0 !== (lane & 4194176)) {
    var queueLanes = queue.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    queue.lanes = lane;
    markRootEntangled(root, lane);
  }
}
var ContextOnlyDispatcher = {
  readContext: readContext,
  use: use,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useInsertionEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useSyncExternalStore: throwInvalidHookError,
  useId: throwInvalidHookError
};
ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
ContextOnlyDispatcher.useFormState = throwInvalidHookError;
ContextOnlyDispatcher.useActionState = throwInvalidHookError;
ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
var HooksDispatcherOnMount = {
  readContext: readContext,
  use: use,
  useCallback: function (callback, deps) {
    mountWorkInProgressHook().memoizedState = [
      callback,
      void 0 === deps ? null : deps
    ];
    return callback;
  },
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: function (ref, create, deps) {
    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
    mountEffectImpl(
      4194308,
      4,
      imperativeHandleEffect.bind(null, create, ref),
      deps
    );
  },
  useLayoutEffect: function (create, deps) {
    return mountEffectImpl(4194308, 4, create, deps);
  },
  useInsertionEffect: function (create, deps) {
    mountEffectImpl(4, 2, create, deps);
  },
  useMemo: function (nextCreate, deps) {
    var hook = mountWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var nextValue = nextCreate();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        nextCreate();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    hook.memoizedState = [nextValue, deps];
    return nextValue;
  },
  useReducer: function (reducer, initialArg, init) {
    var hook = mountWorkInProgressHook();
    if (void 0 !== init) {
      var initialState = init(initialArg);
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          init(initialArg);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
    } else initialState = initialArg;
    hook.memoizedState = hook.baseState = initialState;
    reducer = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: reducer,
      lastRenderedState: initialState
    };
    hook.queue = reducer;
    reducer = reducer.dispatch = dispatchReducerAction.bind(
      null,
      currentlyRenderingFiber$1,
      reducer
    );
    return [hook.memoizedState, reducer];
  },
  useRef: function (initialValue) {
    var hook = mountWorkInProgressHook();
    initialValue = { current: initialValue };
    return (hook.memoizedState = initialValue);
  },
  useState: function (initialState) {
    initialState = mountStateImpl(initialState);
    var queue = initialState.queue,
      dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
    queue.dispatch = dispatch;
    return [initialState.memoizedState, dispatch];
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = mountWorkInProgressHook();
    return mountDeferredValueImpl(hook, value, initialValue);
  },
  useTransition: function () {
    var stateHook = mountStateImpl(!1);
    stateHook = startTransition.bind(
      null,
      currentlyRenderingFiber$1,
      stateHook.queue,
      !0,
      !1
    );
    mountWorkInProgressHook().memoizedState = stateHook;
    return [!1, stateHook];
  },
  useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
    var fiber = currentlyRenderingFiber$1,
      hook = mountWorkInProgressHook();
    if (isHydrating) {
      if (void 0 === getServerSnapshot)
        throw Error(formatProdErrorMessage(407));
      getServerSnapshot = getServerSnapshot();
    } else {
      getServerSnapshot = getSnapshot();
      if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
      0 !== (workInProgressRootRenderLanes & 60) ||
        pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
    }
    hook.memoizedState = getServerSnapshot;
    var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
    hook.queue = inst;
    mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
      subscribe
    ]);
    fiber.flags |= 2048;
    pushEffect(
      9,
      updateStoreInstance.bind(
        null,
        fiber,
        inst,
        getServerSnapshot,
        getSnapshot
      ),
      { destroy: void 0 },
      null
    );
    return getServerSnapshot;
  },
  useId: function () {
    var hook = mountWorkInProgressHook(),
      identifierPrefix = workInProgressRoot.identifierPrefix;
    if (isHydrating) {
      var JSCompiler_inline_result = treeContextOverflow;
      var idWithLeadingBit = treeContextId;
      JSCompiler_inline_result =
        (
          idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
        ).toString(32) + JSCompiler_inline_result;
      identifierPrefix =
        ":" + identifierPrefix + "R" + JSCompiler_inline_result;
      JSCompiler_inline_result = localIdCounter++;
      0 < JSCompiler_inline_result &&
        (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
      identifierPrefix += ":";
    } else
      (JSCompiler_inline_result = globalClientIdCounter++),
        (identifierPrefix =
          ":" +
          identifierPrefix +
          "r" +
          JSCompiler_inline_result.toString(32) +
          ":");
    return (hook.memoizedState = identifierPrefix);
  },
  useCacheRefresh: function () {
    return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
      null,
      currentlyRenderingFiber$1
    ));
  }
};
HooksDispatcherOnMount.useMemoCache = useMemoCache;
HooksDispatcherOnMount.useHostTransitionStatus = useHostTransitionStatus;
HooksDispatcherOnMount.useFormState = mountActionState;
HooksDispatcherOnMount.useActionState = mountActionState;
HooksDispatcherOnMount.useOptimistic = function (passthrough) {
  var hook = mountWorkInProgressHook();
  hook.memoizedState = hook.baseState = passthrough;
  var queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: null,
    lastRenderedState: null
  };
  hook.queue = queue;
  hook = dispatchOptimisticSetState.bind(
    null,
    currentlyRenderingFiber$1,
    !0,
    queue
  );
  queue.dispatch = hook;
  return [passthrough, hook];
};
var HooksDispatcherOnUpdate = {
  readContext: readContext,
  use: use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: function () {
    return updateReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = updateWorkInProgressHook();
    return updateDeferredValueImpl(
      hook,
      currentHook.memoizedState,
      value,
      initialValue
    );
  },
  useTransition: function () {
    var booleanOrThenable = updateReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return [
      "boolean" === typeof booleanOrThenable
        ? booleanOrThenable
        : useThenable(booleanOrThenable),
      start
    ];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId
};
HooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;
HooksDispatcherOnUpdate.useMemoCache = useMemoCache;
HooksDispatcherOnUpdate.useHostTransitionStatus = useHostTransitionStatus;
HooksDispatcherOnUpdate.useFormState = updateActionState;
HooksDispatcherOnUpdate.useActionState = updateActionState;
HooksDispatcherOnUpdate.useOptimistic = function (passthrough, reducer) {
  var hook = updateWorkInProgressHook();
  return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
};
var HooksDispatcherOnRerender = {
  readContext: readContext,
  use: use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: rerenderReducer,
  useRef: updateRef,
  useState: function () {
    return rerenderReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = updateWorkInProgressHook();
    return null === currentHook
      ? mountDeferredValueImpl(hook, value, initialValue)
      : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
  },
  useTransition: function () {
    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return [
      "boolean" === typeof booleanOrThenable
        ? booleanOrThenable
        : useThenable(booleanOrThenable),
      start
    ];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId
};
HooksDispatcherOnRerender.useCacheRefresh = updateRefresh;
HooksDispatcherOnRerender.useMemoCache = useMemoCache;
HooksDispatcherOnRerender.useHostTransitionStatus = useHostTransitionStatus;
HooksDispatcherOnRerender.useFormState = rerenderActionState;
HooksDispatcherOnRerender.useActionState = rerenderActionState;
HooksDispatcherOnRerender.useOptimistic = function (passthrough, reducer) {
  var hook = updateWorkInProgressHook();
  if (null !== currentHook)
    return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
  hook.baseState = passthrough;
  return [passthrough, hook.queue.dispatch];
};
function applyDerivedStateFromProps(
  workInProgress,
  ctor,
  getDerivedStateFromProps,
  nextProps
) {
  ctor = workInProgress.memoizedState;
  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
  getDerivedStateFromProps =
    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
      ? ctor
      : assign({}, ctor, getDerivedStateFromProps);
  workInProgress.memoizedState = getDerivedStateFromProps;
  0 === workInProgress.lanes &&
    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
}
var classComponentUpdater = {
  isMounted: function (component) {
    return (component = component._reactInternals)
      ? getNearestMountedFiber(component) === component
      : !1;
  },
  enqueueSetState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload &&
      (scheduleUpdateOnFiber(payload, inst, lane),
      entangleTransitions(payload, inst, lane));
  },
  enqueueReplaceState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 1;
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload &&
      (scheduleUpdateOnFiber(payload, inst, lane),
      entangleTransitions(payload, inst, lane));
  },
  enqueueForceUpdate: function (inst, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 2;
    void 0 !== callback && null !== callback && (update.callback = callback);
    callback = enqueueUpdate(inst, update, lane);
    null !== callback &&
      (scheduleUpdateOnFiber(callback, inst, lane),
      entangleTransitions(callback, inst, lane));
  }
};
function checkShouldComponentUpdate(
  workInProgress,
  ctor,
  oldProps,
  newProps,
  oldState,
  newState,
  nextContext
) {
  workInProgress = workInProgress.stateNode;
  return "function" === typeof workInProgress.shouldComponentUpdate
    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
    : ctor.prototype && ctor.prototype.isPureReactComponent
      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
      : !0;
}
function callComponentWillReceiveProps(
  workInProgress,
  instance,
  newProps,
  nextContext
) {
  workInProgress = instance.state;
  "function" === typeof instance.componentWillReceiveProps &&
    instance.componentWillReceiveProps(newProps, nextContext);
  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  instance.state !== workInProgress &&
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
}
function resolveClassComponentProps(Component, baseProps) {
  var newProps = baseProps;
  if ("ref" in baseProps) {
    newProps = {};
    for (var propName in baseProps)
      "ref" !== propName && (newProps[propName] = baseProps[propName]);
  }
  if ((Component = Component.defaultProps)) {
    newProps === baseProps && (newProps = assign({}, newProps));
    for (var propName$67 in Component)
      void 0 === newProps[propName$67] &&
        (newProps[propName$67] = Component[propName$67]);
  }
  return newProps;
}
var reportGlobalError =
  "function" === typeof reportError
    ? reportError
    : function (error) {
        if (
          "object" === typeof window &&
          "function" === typeof window.ErrorEvent
        ) {
          var event = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message:
              "object" === typeof error &&
              null !== error &&
              "string" === typeof error.message
                ? String(error.message)
                : String(error),
            error: error
          });
          if (!window.dispatchEvent(event)) return;
        } else if (
          "object" === typeof process &&
          "function" === typeof process.emit
        ) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
function defaultOnUncaughtError(error) {
  reportGlobalError(error);
}
function defaultOnCaughtError(error) {
  console.error(error);
}
function defaultOnRecoverableError(error) {
  reportGlobalError(error);
}
function logUncaughtError(root, errorInfo) {
  try {
    var onUncaughtError = root.onUncaughtError;
    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
  } catch (e$68) {
    setTimeout(function () {
      throw e$68;
    });
  }
}
function logCaughtError(root, boundary, errorInfo) {
  try {
    var onCaughtError = root.onCaughtError;
    onCaughtError(errorInfo.value, {
      componentStack: errorInfo.stack,
      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
    });
  } catch (e$69) {
    setTimeout(function () {
      throw e$69;
    });
  }
}
function createRootErrorUpdate(root, errorInfo, lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  lane.payload = { element: null };
  lane.callback = function () {
    logUncaughtError(root, errorInfo);
  };
  return lane;
}
function createClassErrorUpdate(lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  return lane;
}
function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
  if ("function" === typeof getDerivedStateFromError) {
    var error = errorInfo.value;
    update.payload = function () {
      return getDerivedStateFromError(error);
    };
    update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
    };
  }
  var inst = fiber.stateNode;
  null !== inst &&
    "function" === typeof inst.componentDidCatch &&
    (update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
      "function" !== typeof getDerivedStateFromError &&
        (null === legacyErrorBoundariesThatAlreadyFailed
          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
          : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
}
function throwException(
  root,
  returnFiber,
  sourceFiber,
  value,
  rootRenderLanes
) {
  sourceFiber.flags |= 32768;
  if (
    null !== value &&
    "object" === typeof value &&
    "function" === typeof value.then
  ) {
    returnFiber = sourceFiber.alternate;
    null !== returnFiber &&
      propagateParentContextChanges(
        returnFiber,
        sourceFiber,
        rootRenderLanes,
        !0
      );
    sourceFiber = suspenseHandlerStackCursor.current;
    if (null !== sourceFiber) {
      switch (sourceFiber.tag) {
        case 13:
          return (
            null === shellBoundary
              ? renderDidSuspendDelayIfPossible()
              : null === sourceFiber.alternate &&
                0 === workInProgressRootExitStatus &&
                (workInProgressRootExitStatus = 3),
            (sourceFiber.flags &= -257),
            (sourceFiber.flags |= 65536),
            (sourceFiber.lanes = rootRenderLanes),
            value === noopSuspenseyCommitThenable
              ? (sourceFiber.flags |= 16384)
              : ((returnFiber = sourceFiber.updateQueue),
                null === returnFiber
                  ? (sourceFiber.updateQueue = new Set([value]))
                  : returnFiber.add(value),
                attachPingListener(root, value, rootRenderLanes)),
            !1
          );
        case 22:
          return (
            (sourceFiber.flags |= 65536),
            value === noopSuspenseyCommitThenable
              ? (sourceFiber.flags |= 16384)
              : ((returnFiber = sourceFiber.updateQueue),
                null === returnFiber
                  ? ((returnFiber = {
                      transitions: null,
                      markerInstances: null,
                      retryQueue: new Set([value])
                    }),
                    (sourceFiber.updateQueue = returnFiber))
                  : ((sourceFiber = returnFiber.retryQueue),
                    null === sourceFiber
                      ? (returnFiber.retryQueue = new Set([value]))
                      : sourceFiber.add(value)),
                attachPingListener(root, value, rootRenderLanes)),
            !1
          );
      }
      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
    }
    attachPingListener(root, value, rootRenderLanes);
    renderDidSuspendDelayIfPossible();
    return !1;
  }
  if (isHydrating)
    return (
      (returnFiber = suspenseHandlerStackCursor.current),
      null !== returnFiber
        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
          (returnFiber.flags |= 65536),
          (returnFiber.lanes = rootRenderLanes),
          value !== HydrationMismatchException &&
            ((root = Error(formatProdErrorMessage(422), { cause: value })),
            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
        : (value !== HydrationMismatchException &&
            ((returnFiber = Error(formatProdErrorMessage(423), {
              cause: value
            })),
            queueHydrationError(
              createCapturedValueAtFiber(returnFiber, sourceFiber)
            )),
          (root = root.current.alternate),
          (root.flags |= 65536),
          (rootRenderLanes &= -rootRenderLanes),
          (root.lanes |= rootRenderLanes),
          (value = createCapturedValueAtFiber(value, sourceFiber)),
          (rootRenderLanes = createRootErrorUpdate(
            root.stateNode,
            value,
            rootRenderLanes
          )),
          enqueueCapturedUpdate(root, rootRenderLanes),
          4 !== workInProgressRootExitStatus &&
            (workInProgressRootExitStatus = 2)),
      !1
    );
  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
  null === workInProgressRootConcurrentErrors
    ? (workInProgressRootConcurrentErrors = [wrapperError])
    : workInProgressRootConcurrentErrors.push(wrapperError);
  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
  if (null === returnFiber) return !0;
  value = createCapturedValueAtFiber(value, sourceFiber);
  sourceFiber = returnFiber;
  do {
    switch (sourceFiber.tag) {
      case 3:
        return (
          (sourceFiber.flags |= 65536),
          (root = rootRenderLanes & -rootRenderLanes),
          (sourceFiber.lanes |= root),
          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
          enqueueCapturedUpdate(sourceFiber, root),
          !1
        );
      case 1:
        if (
          ((returnFiber = sourceFiber.type),
          (wrapperError = sourceFiber.stateNode),
          0 === (sourceFiber.flags & 128) &&
            ("function" === typeof returnFiber.getDerivedStateFromError ||
              (null !== wrapperError &&
                "function" === typeof wrapperError.componentDidCatch &&
                (null === legacyErrorBoundariesThatAlreadyFailed ||
                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
        )
          return (
            (sourceFiber.flags |= 65536),
            (rootRenderLanes &= -rootRenderLanes),
            (sourceFiber.lanes |= rootRenderLanes),
            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
            initializeClassErrorUpdate(
              rootRenderLanes,
              root,
              sourceFiber,
              value
            ),
            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
            !1
          );
    }
    sourceFiber = sourceFiber.return;
  } while (null !== sourceFiber);
  return !1;
}
var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
  didReceiveUpdate = !1;
function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  workInProgress.child =
    null === current
      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
      : reconcileChildFibers(
          workInProgress,
          current.child,
          nextChildren,
          renderLanes
        );
}
function updateForwardRef(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  Component = Component.render;
  var ref = workInProgress.ref;
  if ("ref" in nextProps) {
    var propsWithoutRef = {};
    for (var key in nextProps)
      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
  } else propsWithoutRef = nextProps;
  prepareToReadContext(workInProgress);
  nextProps = renderWithHooks(
    current,
    workInProgress,
    Component,
    propsWithoutRef,
    ref,
    renderLanes
  );
  key = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && key && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  if (null === current) {
    var type = Component.type;
    if (
      "function" === typeof type &&
      !shouldConstruct(type) &&
      void 0 === type.defaultProps &&
      null === Component.compare
    )
      return (
        (workInProgress.tag = 15),
        (workInProgress.type = type),
        updateSimpleMemoComponent(
          current,
          workInProgress,
          type,
          nextProps,
          renderLanes
        )
      );
    current = createFiberFromTypeAndProps(
      Component.type,
      null,
      nextProps,
      workInProgress,
      workInProgress.mode,
      renderLanes
    );
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return (workInProgress.child = current);
  }
  type = current.child;
  if (!checkScheduledUpdateOrContext(current, renderLanes)) {
    var prevProps = type.memoizedProps;
    Component = Component.compare;
    Component = null !== Component ? Component : shallowEqual;
    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  workInProgress.flags |= 1;
  current = createWorkInProgress(type, nextProps);
  current.ref = workInProgress.ref;
  current.return = workInProgress;
  return (workInProgress.child = current);
}
function updateSimpleMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  if (null !== current) {
    var prevProps = current.memoizedProps;
    if (
      shallowEqual(prevProps, nextProps) &&
      current.ref === workInProgress.ref
    )
      if (
        ((didReceiveUpdate = !1),
        (workInProgress.pendingProps = nextProps = prevProps),
        checkScheduledUpdateOrContext(current, renderLanes))
      )
        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
      else
        return (
          (workInProgress.lanes = current.lanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
  }
  return updateFunctionComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    renderLanes
  );
}
function updateOffscreenComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    nextChildren = nextProps.children,
    nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),
    prevState = null !== current ? current.memoizedState : null;
  markRef(current, workInProgress);
  if ("hidden" === nextProps.mode || nextIsDetached) {
    if (0 !== (workInProgress.flags & 128)) {
      nextProps =
        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
      if (null !== current) {
        nextChildren = workInProgress.child = current.child;
        for (nextIsDetached = 0; null !== nextChildren; )
          (nextIsDetached =
            nextIsDetached | nextChildren.lanes | nextChildren.childLanes),
            (nextChildren = nextChildren.sibling);
        workInProgress.childLanes = nextIsDetached & ~nextProps;
      } else (workInProgress.childLanes = 0), (workInProgress.child = null);
      return deferHiddenOffscreenComponent(
        current,
        workInProgress,
        nextProps,
        renderLanes
      );
    }
    if (0 !== (renderLanes & 536870912))
      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
        null !== current &&
          pushTransition(
            workInProgress,
            null !== prevState ? prevState.cachePool : null
          ),
        null !== prevState
          ? pushHiddenContext(workInProgress, prevState)
          : reuseHiddenContextOnStack(),
        pushOffscreenSuspenseHandler(workInProgress);
    else
      return (
        (workInProgress.lanes = workInProgress.childLanes = 536870912),
        deferHiddenOffscreenComponent(
          current,
          workInProgress,
          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,
          renderLanes
        )
      );
  } else
    null !== prevState
      ? (pushTransition(workInProgress, prevState.cachePool),
        pushHiddenContext(workInProgress, prevState),
        reuseSuspenseHandlerOnStack(workInProgress),
        (workInProgress.memoizedState = null))
      : (null !== current && pushTransition(workInProgress, null),
        reuseHiddenContextOnStack(),
        reuseSuspenseHandlerOnStack(workInProgress));
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
function deferHiddenOffscreenComponent(
  current,
  workInProgress,
  nextBaseLanes,
  renderLanes
) {
  var JSCompiler_inline_result = peekCacheFromPool();
  JSCompiler_inline_result =
    null === JSCompiler_inline_result
      ? null
      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
  workInProgress.memoizedState = {
    baseLanes: nextBaseLanes,
    cachePool: JSCompiler_inline_result
  };
  null !== current && pushTransition(workInProgress, null);
  reuseHiddenContextOnStack();
  pushOffscreenSuspenseHandler(workInProgress);
  null !== current &&
    propagateParentContextChanges(current, workInProgress, renderLanes, !0);
  return null;
}
function markRef(current, workInProgress) {
  var ref = workInProgress.ref;
  if (null === ref)
    null !== current &&
      null !== current.ref &&
      (workInProgress.flags |= 2097664);
  else {
    if ("function" !== typeof ref && "object" !== typeof ref)
      throw Error(formatProdErrorMessage(284));
    if (null === current || current.ref !== ref)
      workInProgress.flags |= 2097664;
  }
}
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  Component = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    void 0,
    renderLanes
  );
  nextProps = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, Component, renderLanes);
  return workInProgress.child;
}
function replayFunctionComponent(
  current,
  workInProgress,
  nextProps,
  Component,
  secondArg,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  workInProgress.updateQueue = null;
  nextProps = renderWithHooksAgain(
    workInProgress,
    Component,
    nextProps,
    secondArg
  );
  finishRenderingHooks(current);
  Component = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && Component && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateClassComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  if (null === workInProgress.stateNode) {
    var context = emptyContextObject,
      contextType = Component.contextType;
    "object" === typeof contextType &&
      null !== contextType &&
      (context = readContext(contextType));
    context = new Component(nextProps, context);
    workInProgress.memoizedState =
      null !== context.state && void 0 !== context.state ? context.state : null;
    context.updater = classComponentUpdater;
    workInProgress.stateNode = context;
    context._reactInternals = workInProgress;
    context = workInProgress.stateNode;
    context.props = nextProps;
    context.state = workInProgress.memoizedState;
    context.refs = {};
    initializeUpdateQueue(workInProgress);
    contextType = Component.contextType;
    context.context =
      "object" === typeof contextType && null !== contextType
        ? readContext(contextType)
        : emptyContextObject;
    context.state = workInProgress.memoizedState;
    contextType = Component.getDerivedStateFromProps;
    "function" === typeof contextType &&
      (applyDerivedStateFromProps(
        workInProgress,
        Component,
        contextType,
        nextProps
      ),
      (context.state = workInProgress.memoizedState));
    "function" === typeof Component.getDerivedStateFromProps ||
      "function" === typeof context.getSnapshotBeforeUpdate ||
      ("function" !== typeof context.UNSAFE_componentWillMount &&
        "function" !== typeof context.componentWillMount) ||
      ((contextType = context.state),
      "function" === typeof context.componentWillMount &&
        context.componentWillMount(),
      "function" === typeof context.UNSAFE_componentWillMount &&
        context.UNSAFE_componentWillMount(),
      contextType !== context.state &&
        classComponentUpdater.enqueueReplaceState(context, context.state, null),
      processUpdateQueue(workInProgress, nextProps, context, renderLanes),
      suspendIfUpdateReadFromEntangledAsyncAction(),
      (context.state = workInProgress.memoizedState));
    "function" === typeof context.componentDidMount &&
      (workInProgress.flags |= 4194308);
    nextProps = !0;
  } else if (null === current) {
    context = workInProgress.stateNode;
    var unresolvedOldProps = workInProgress.memoizedProps,
      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
    context.props = oldProps;
    var oldContext = context.context,
      contextType$jscomp$0 = Component.contextType;
    contextType = emptyContextObject;
    "object" === typeof contextType$jscomp$0 &&
      null !== contextType$jscomp$0 &&
      (contextType = readContext(contextType$jscomp$0));
    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
    contextType$jscomp$0 =
      "function" === typeof getDerivedStateFromProps ||
      "function" === typeof context.getSnapshotBeforeUpdate;
    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
    contextType$jscomp$0 ||
      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
        "function" !== typeof context.componentWillReceiveProps) ||
      ((unresolvedOldProps || oldContext !== contextType) &&
        callComponentWillReceiveProps(
          workInProgress,
          context,
          nextProps,
          contextType
        ));
    hasForceUpdate = !1;
    var oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    oldContext = workInProgress.memoizedState;
    unresolvedOldProps || oldState !== oldContext || hasForceUpdate
      ? ("function" === typeof getDerivedStateFromProps &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            getDerivedStateFromProps,
            nextProps
          ),
          (oldContext = workInProgress.memoizedState)),
        (oldProps =
          hasForceUpdate ||
          checkShouldComponentUpdate(
            workInProgress,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          ))
          ? (contextType$jscomp$0 ||
              ("function" !== typeof context.UNSAFE_componentWillMount &&
                "function" !== typeof context.componentWillMount) ||
              ("function" === typeof context.componentWillMount &&
                context.componentWillMount(),
              "function" === typeof context.UNSAFE_componentWillMount &&
                context.UNSAFE_componentWillMount()),
            "function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308))
          : ("function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308),
            (workInProgress.memoizedProps = nextProps),
            (workInProgress.memoizedState = oldContext)),
        (context.props = nextProps),
        (context.state = oldContext),
        (context.context = contextType),
        (nextProps = oldProps))
      : ("function" === typeof context.componentDidMount &&
          (workInProgress.flags |= 4194308),
        (nextProps = !1));
  } else {
    context = workInProgress.stateNode;
    cloneUpdateQueue(current, workInProgress);
    contextType = workInProgress.memoizedProps;
    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
    context.props = contextType$jscomp$0;
    getDerivedStateFromProps = workInProgress.pendingProps;
    oldState = context.context;
    oldContext = Component.contextType;
    oldProps = emptyContextObject;
    "object" === typeof oldContext &&
      null !== oldContext &&
      (oldProps = readContext(oldContext));
    unresolvedOldProps = Component.getDerivedStateFromProps;
    (oldContext =
      "function" === typeof unresolvedOldProps ||
      "function" === typeof context.getSnapshotBeforeUpdate) ||
      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
        "function" !== typeof context.componentWillReceiveProps) ||
      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
        callComponentWillReceiveProps(
          workInProgress,
          context,
          nextProps,
          oldProps
        ));
    hasForceUpdate = !1;
    oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    var newState = workInProgress.memoizedState;
    contextType !== getDerivedStateFromProps ||
    oldState !== newState ||
    hasForceUpdate ||
    (null !== current &&
      null !== current.dependencies &&
      checkIfContextChanged(current.dependencies))
      ? ("function" === typeof unresolvedOldProps &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            unresolvedOldProps,
            nextProps
          ),
          (newState = workInProgress.memoizedState)),
        (contextType$jscomp$0 =
          hasForceUpdate ||
          checkShouldComponentUpdate(
            workInProgress,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) ||
          (null !== current &&
            null !== current.dependencies &&
            checkIfContextChanged(current.dependencies)))
          ? (oldContext ||
              ("function" !== typeof context.UNSAFE_componentWillUpdate &&
                "function" !== typeof context.componentWillUpdate) ||
              ("function" === typeof context.componentWillUpdate &&
                context.componentWillUpdate(nextProps, newState, oldProps),
              "function" === typeof context.UNSAFE_componentWillUpdate &&
                context.UNSAFE_componentWillUpdate(
                  nextProps,
                  newState,
                  oldProps
                )),
            "function" === typeof context.componentDidUpdate &&
              (workInProgress.flags |= 4),
            "function" === typeof context.getSnapshotBeforeUpdate &&
              (workInProgress.flags |= 1024))
          : ("function" !== typeof context.componentDidUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 4),
            "function" !== typeof context.getSnapshotBeforeUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 1024),
            (workInProgress.memoizedProps = nextProps),
            (workInProgress.memoizedState = newState)),
        (context.props = nextProps),
        (context.state = newState),
        (context.context = oldProps),
        (nextProps = contextType$jscomp$0))
      : ("function" !== typeof context.componentDidUpdate ||
          (contextType === current.memoizedProps &&
            oldState === current.memoizedState) ||
          (workInProgress.flags |= 4),
        "function" !== typeof context.getSnapshotBeforeUpdate ||
          (contextType === current.memoizedProps &&
            oldState === current.memoizedState) ||
          (workInProgress.flags |= 1024),
        (nextProps = !1));
  }
  context = nextProps;
  markRef(current, workInProgress);
  nextProps = 0 !== (workInProgress.flags & 128);
  context || nextProps
    ? ((context = workInProgress.stateNode),
      (Component =
        nextProps && "function" !== typeof Component.getDerivedStateFromError
          ? null
          : context.render()),
      (workInProgress.flags |= 1),
      null !== current && nextProps
        ? ((workInProgress.child = reconcileChildFibers(
            workInProgress,
            current.child,
            null,
            renderLanes
          )),
          (workInProgress.child = reconcileChildFibers(
            workInProgress,
            null,
            Component,
            renderLanes
          )))
        : reconcileChildren(current, workInProgress, Component, renderLanes),
      (workInProgress.memoizedState = context.state),
      (current = workInProgress.child))
    : (current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress,
        renderLanes
      ));
  return current;
}
function mountHostRootWithoutHydrating(
  current,
  workInProgress,
  nextChildren,
  renderLanes
) {
  resetHydrationState();
  workInProgress.flags |= 256;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
var SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 };
function mountSuspenseOffscreenState(renderLanes) {
  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
}
function getRemainingWorkInPrimaryTree(
  current,
  primaryTreeDidDefer,
  renderLanes
) {
  current = null !== current ? current.childLanes & ~renderLanes : 0;
  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
  return current;
}
function updateSuspenseComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    showFallback = !1,
    didSuspend = 0 !== (workInProgress.flags & 128),
    JSCompiler_temp;
  (JSCompiler_temp = didSuspend) ||
    (JSCompiler_temp =
      null !== current && null === current.memoizedState
        ? !1
        : 0 !== (suspenseStackCursor.current & 2));
  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));
  JSCompiler_temp = 0 !== (workInProgress.flags & 32);
  workInProgress.flags &= -33;
  if (null === current) {
    if (isHydrating) {
      showFallback
        ? pushPrimaryTreeSuspenseHandler(workInProgress)
        : reuseSuspenseHandlerOnStack(workInProgress);
      if (isHydrating) {
        var nextInstance = nextHydratableInstance,
          JSCompiler_temp$jscomp$0;
        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {
          c: {
            JSCompiler_temp$jscomp$0 = nextInstance;
            for (
              nextInstance = rootOrSingletonContext;
              8 !== JSCompiler_temp$jscomp$0.nodeType;

            ) {
              if (!nextInstance) {
                nextInstance = null;
                break c;
              }
              JSCompiler_temp$jscomp$0 = getNextHydratable(
                JSCompiler_temp$jscomp$0.nextSibling
              );
              if (null === JSCompiler_temp$jscomp$0) {
                nextInstance = null;
                break c;
              }
            }
            nextInstance = JSCompiler_temp$jscomp$0;
          }
          null !== nextInstance
            ? ((workInProgress.memoizedState = {
                dehydrated: nextInstance,
                treeContext:
                  null !== treeContextProvider
                    ? { id: treeContextId, overflow: treeContextOverflow }
                    : null,
                retryLane: 536870912
              }),
              (JSCompiler_temp$jscomp$0 = createFiberImplClass(
                18,
                null,
                null,
                0
              )),
              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),
              (JSCompiler_temp$jscomp$0.return = workInProgress),
              (workInProgress.child = JSCompiler_temp$jscomp$0),
              (hydrationParentFiber = workInProgress),
              (nextHydratableInstance = null),
              (JSCompiler_temp$jscomp$0 = !0))
            : (JSCompiler_temp$jscomp$0 = !1);
        }
        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
      }
      nextInstance = workInProgress.memoizedState;
      if (
        null !== nextInstance &&
        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)
      )
        return (
          "$!" === nextInstance.data
            ? (workInProgress.lanes = 16)
            : (workInProgress.lanes = 536870912),
          null
        );
      popSuspenseHandler(workInProgress);
    }
    nextInstance = nextProps.children;
    nextProps = nextProps.fallback;
    if (showFallback)
      return (
        reuseSuspenseHandlerOnStack(workInProgress),
        (showFallback = workInProgress.mode),
        (nextInstance = mountWorkInProgressOffscreenFiber(
          { mode: "hidden", children: nextInstance },
          showFallback
        )),
        (nextProps = createFiberFromFragment(
          nextProps,
          showFallback,
          renderLanes,
          null
        )),
        (nextInstance.return = workInProgress),
        (nextProps.return = workInProgress),
        (nextInstance.sibling = nextProps),
        (workInProgress.child = nextInstance),
        (showFallback = workInProgress.child),
        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
        (showFallback.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes
        )),
        (workInProgress.memoizedState = SUSPENDED_MARKER),
        nextProps
      );
    pushPrimaryTreeSuspenseHandler(workInProgress);
    return mountSuspensePrimaryChildren(workInProgress, nextInstance);
  }
  JSCompiler_temp$jscomp$0 = current.memoizedState;
  if (
    null !== JSCompiler_temp$jscomp$0 &&
    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),
    null !== nextInstance)
  ) {
    if (didSuspend)
      workInProgress.flags & 256
        ? (pushPrimaryTreeSuspenseHandler(workInProgress),
          (workInProgress.flags &= -257),
          (workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          )))
        : null !== workInProgress.memoizedState
          ? (reuseSuspenseHandlerOnStack(workInProgress),
            (workInProgress.child = current.child),
            (workInProgress.flags |= 128),
            (workInProgress = null))
          : (reuseSuspenseHandlerOnStack(workInProgress),
            (showFallback = nextProps.fallback),
            (nextInstance = workInProgress.mode),
            (nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              nextInstance
            )),
            (showFallback = createFiberFromFragment(
              showFallback,
              nextInstance,
              renderLanes,
              null
            )),
            (showFallback.flags |= 2),
            (nextProps.return = workInProgress),
            (showFallback.return = workInProgress),
            (nextProps.sibling = showFallback),
            (workInProgress.child = nextProps),
            reconcileChildFibers(
              workInProgress,
              current.child,
              null,
              renderLanes
            ),
            (nextProps = workInProgress.child),
            (nextProps.memoizedState =
              mountSuspenseOffscreenState(renderLanes)),
            (nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes
            )),
            (workInProgress.memoizedState = SUSPENDED_MARKER),
            (workInProgress = showFallback));
    else if (
      (pushPrimaryTreeSuspenseHandler(workInProgress),
      "$!" === nextInstance.data)
    ) {
      JSCompiler_temp =
        nextInstance.nextSibling && nextInstance.nextSibling.dataset;
      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
      JSCompiler_temp = digest;
      nextProps = Error(formatProdErrorMessage(419));
      nextProps.stack = "";
      nextProps.digest = JSCompiler_temp;
      queueHydrationError({ value: nextProps, source: null, stack: null });
      workInProgress = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else if (
      (didReceiveUpdate ||
        propagateParentContextChanges(current, workInProgress, renderLanes, !1),
      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
      didReceiveUpdate || JSCompiler_temp)
    ) {
      JSCompiler_temp = workInProgressRoot;
      if (null !== JSCompiler_temp) {
        nextProps = renderLanes & -renderLanes;
        if (0 !== (nextProps & 42)) nextProps = 1;
        else
          switch (nextProps) {
            case 2:
              nextProps = 1;
              break;
            case 8:
              nextProps = 4;
              break;
            case 32:
              nextProps = 16;
              break;
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              nextProps = 64;
              break;
            case 268435456:
              nextProps = 134217728;
              break;
            default:
              nextProps = 0;
          }
        nextProps =
          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))
            ? 0
            : nextProps;
        if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)
          throw (
            ((JSCompiler_temp$jscomp$0.retryLane = nextProps),
            enqueueConcurrentRenderForLane(current, nextProps),
            scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
            SelectiveHydrationException)
          );
      }
      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
      workInProgress = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else
      "$?" === nextInstance.data
        ? ((workInProgress.flags |= 128),
          (workInProgress.child = current.child),
          (workInProgress = retryDehydratedSuspenseBoundary.bind(
            null,
            current
          )),
          (nextInstance._reactRetry = workInProgress),
          (workInProgress = null))
        : ((current = JSCompiler_temp$jscomp$0.treeContext),
          (nextHydratableInstance = getNextHydratable(
            nextInstance.nextSibling
          )),
          (hydrationParentFiber = workInProgress),
          (isHydrating = !0),
          (hydrationErrors = null),
          (rootOrSingletonContext = !1),
          null !== current &&
            ((idStack[idStackIndex++] = treeContextId),
            (idStack[idStackIndex++] = treeContextOverflow),
            (idStack[idStackIndex++] = treeContextProvider),
            (treeContextId = current.id),
            (treeContextOverflow = current.overflow),
            (treeContextProvider = workInProgress)),
          (workInProgress = mountSuspensePrimaryChildren(
            workInProgress,
            nextProps.children
          )),
          (workInProgress.flags |= 4096));
    return workInProgress;
  }
  if (showFallback)
    return (
      reuseSuspenseHandlerOnStack(workInProgress),
      (showFallback = nextProps.fallback),
      (nextInstance = workInProgress.mode),
      (JSCompiler_temp$jscomp$0 = current.child),
      (digest = JSCompiler_temp$jscomp$0.sibling),
      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
        mode: "hidden",
        children: nextProps.children
      })),
      (nextProps.subtreeFlags =
        JSCompiler_temp$jscomp$0.subtreeFlags & 31457280),
      null !== digest
        ? (showFallback = createWorkInProgress(digest, showFallback))
        : ((showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes,
            null
          )),
          (showFallback.flags |= 2)),
      (showFallback.return = workInProgress),
      (nextProps.return = workInProgress),
      (nextProps.sibling = showFallback),
      (workInProgress.child = nextProps),
      (nextProps = showFallback),
      (showFallback = workInProgress.child),
      (nextInstance = current.child.memoizedState),
      null === nextInstance
        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))
        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),
          null !== JSCompiler_temp$jscomp$0
            ? ((digest = CacheContext._currentValue),
              (JSCompiler_temp$jscomp$0 =
                JSCompiler_temp$jscomp$0.parent !== digest
                  ? { parent: digest, pool: digest }
                  : JSCompiler_temp$jscomp$0))
            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),
          (nextInstance = {
            baseLanes: nextInstance.baseLanes | renderLanes,
            cachePool: JSCompiler_temp$jscomp$0
          })),
      (showFallback.memoizedState = nextInstance),
      (showFallback.childLanes = getRemainingWorkInPrimaryTree(
        current,
        JSCompiler_temp,
        renderLanes
      )),
      (workInProgress.memoizedState = SUSPENDED_MARKER),
      nextProps
    );
  pushPrimaryTreeSuspenseHandler(workInProgress);
  renderLanes = current.child;
  current = renderLanes.sibling;
  renderLanes = createWorkInProgress(renderLanes, {
    mode: "visible",
    children: nextProps.children
  });
  renderLanes.return = workInProgress;
  renderLanes.sibling = null;
  null !== current &&
    ((JSCompiler_temp = workInProgress.deletions),
    null === JSCompiler_temp
      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
      : JSCompiler_temp.push(current));
  workInProgress.child = renderLanes;
  workInProgress.memoizedState = null;
  return renderLanes;
}
function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
  primaryChildren = mountWorkInProgressOffscreenFiber(
    { mode: "visible", children: primaryChildren },
    workInProgress.mode
  );
  primaryChildren.return = workInProgress;
  return (workInProgress.child = primaryChildren);
}
function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
  return createFiberFromOffscreen(offscreenProps, mode, 0, null);
}
function retrySuspenseComponentWithoutHydrating(
  current,
  workInProgress,
  renderLanes
) {
  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
  current = mountSuspensePrimaryChildren(
    workInProgress,
    workInProgress.pendingProps.children
  );
  current.flags |= 2;
  workInProgress.memoizedState = null;
  return current;
}
function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
  fiber.lanes |= renderLanes;
  var alternate = fiber.alternate;
  null !== alternate && (alternate.lanes |= renderLanes);
  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
}
function initSuspenseListRenderState(
  workInProgress,
  isBackwards,
  tail,
  lastContentRow,
  tailMode
) {
  var renderState = workInProgress.memoizedState;
  null === renderState
    ? (workInProgress.memoizedState = {
        isBackwards: isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail: tail,
        tailMode: tailMode
      })
    : ((renderState.isBackwards = isBackwards),
      (renderState.rendering = null),
      (renderState.renderingStartTime = 0),
      (renderState.last = lastContentRow),
      (renderState.tail = tail),
      (renderState.tailMode = tailMode));
}
function updateSuspenseListComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    revealOrder = nextProps.revealOrder,
    tailMode = nextProps.tail;
  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
  nextProps = suspenseStackCursor.current;
  if (0 !== (nextProps & 2))
    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);
  else {
    if (null !== current && 0 !== (current.flags & 128))
      a: for (current = workInProgress.child; null !== current; ) {
        if (13 === current.tag)
          null !== current.memoizedState &&
            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
        else if (19 === current.tag)
          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
        else if (null !== current.child) {
          current.child.return = current;
          current = current.child;
          continue;
        }
        if (current === workInProgress) break a;
        for (; null === current.sibling; ) {
          if (null === current.return || current.return === workInProgress)
            break a;
          current = current.return;
        }
        current.sibling.return = current.return;
        current = current.sibling;
      }
    nextProps &= 1;
  }
  push(suspenseStackCursor, nextProps);
  switch (revealOrder) {
    case "forwards":
      renderLanes = workInProgress.child;
      for (revealOrder = null; null !== renderLanes; )
        (current = renderLanes.alternate),
          null !== current &&
            null === findFirstSuspended(current) &&
            (revealOrder = renderLanes),
          (renderLanes = renderLanes.sibling);
      renderLanes = revealOrder;
      null === renderLanes
        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))
        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
      initSuspenseListRenderState(
        workInProgress,
        !1,
        revealOrder,
        renderLanes,
        tailMode
      );
      break;
    case "backwards":
      renderLanes = null;
      revealOrder = workInProgress.child;
      for (workInProgress.child = null; null !== revealOrder; ) {
        current = revealOrder.alternate;
        if (null !== current && null === findFirstSuspended(current)) {
          workInProgress.child = revealOrder;
          break;
        }
        current = revealOrder.sibling;
        revealOrder.sibling = renderLanes;
        renderLanes = revealOrder;
        revealOrder = current;
      }
      initSuspenseListRenderState(
        workInProgress,
        !0,
        renderLanes,
        null,
        tailMode
      );
      break;
    case "together":
      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
      break;
    default:
      workInProgress.memoizedState = null;
  }
  return workInProgress.child;
}
function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  null !== current && (workInProgress.dependencies = current.dependencies);
  workInProgressRootSkippedLanes |= workInProgress.lanes;
  if (0 === (renderLanes & workInProgress.childLanes))
    if (null !== current) {
      if (
        (propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          !1
        ),
        0 === (renderLanes & workInProgress.childLanes))
      )
        return null;
    } else return null;
  if (null !== current && workInProgress.child !== current.child)
    throw Error(formatProdErrorMessage(153));
  if (null !== workInProgress.child) {
    current = workInProgress.child;
    renderLanes = createWorkInProgress(current, current.pendingProps);
    workInProgress.child = renderLanes;
    for (renderLanes.return = workInProgress; null !== current.sibling; )
      (current = current.sibling),
        (renderLanes = renderLanes.sibling =
          createWorkInProgress(current, current.pendingProps)),
        (renderLanes.return = workInProgress);
    renderLanes.sibling = null;
  }
  return workInProgress.child;
}
function checkScheduledUpdateOrContext(current, renderLanes) {
  if (0 !== (current.lanes & renderLanes)) return !0;
  current = current.dependencies;
  return null !== current && checkIfContextChanged(current) ? !0 : !1;
}
function attemptEarlyBailoutIfNoScheduledUpdate(
  current,
  workInProgress,
  renderLanes
) {
  switch (workInProgress.tag) {
    case 3:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
      resetHydrationState();
      break;
    case 27:
    case 5:
      pushHostContext(workInProgress);
      break;
    case 4:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      break;
    case 10:
      pushProvider(
        workInProgress,
        workInProgress.type,
        workInProgress.memoizedProps.value
      );
      break;
    case 13:
      var state = workInProgress.memoizedState;
      if (null !== state) {
        if (null !== state.dehydrated)
          return (
            pushPrimaryTreeSuspenseHandler(workInProgress),
            (workInProgress.flags |= 128),
            null
          );
        if (0 !== (renderLanes & workInProgress.child.childLanes))
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        pushPrimaryTreeSuspenseHandler(workInProgress);
        current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderLanes
        );
        return null !== current ? current.sibling : null;
      }
      pushPrimaryTreeSuspenseHandler(workInProgress);
      break;
    case 19:
      var didSuspendBefore = 0 !== (current.flags & 128);
      state = 0 !== (renderLanes & workInProgress.childLanes);
      state ||
        (propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          !1
        ),
        (state = 0 !== (renderLanes & workInProgress.childLanes)));
      if (didSuspendBefore) {
        if (state)
          return updateSuspenseListComponent(
            current,
            workInProgress,
            renderLanes
          );
        workInProgress.flags |= 128;
      }
      didSuspendBefore = workInProgress.memoizedState;
      null !== didSuspendBefore &&
        ((didSuspendBefore.rendering = null),
        (didSuspendBefore.tail = null),
        (didSuspendBefore.lastEffect = null));
      push(suspenseStackCursor, suspenseStackCursor.current);
      if (state) break;
      else return null;
    case 22:
    case 23:
      return (
        (workInProgress.lanes = 0),
        updateOffscreenComponent(current, workInProgress, renderLanes)
      );
    case 24:
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
  }
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
}
function beginWork(current, workInProgress, renderLanes) {
  if (null !== current)
    if (current.memoizedProps !== workInProgress.pendingProps)
      didReceiveUpdate = !0;
    else {
      if (
        !checkScheduledUpdateOrContext(current, renderLanes) &&
        0 === (workInProgress.flags & 128)
      )
        return (
          (didReceiveUpdate = !1),
          attemptEarlyBailoutIfNoScheduledUpdate(
            current,
            workInProgress,
            renderLanes
          )
        );
      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
    }
  else
    (didReceiveUpdate = !1),
      isHydrating &&
        0 !== (workInProgress.flags & 1048576) &&
        pushTreeId(workInProgress, treeForkCount, workInProgress.index);
  workInProgress.lanes = 0;
  switch (workInProgress.tag) {
    case 16:
      a: {
        current = workInProgress.pendingProps;
        var lazyComponent = workInProgress.elementType,
          init = lazyComponent._init;
        lazyComponent = init(lazyComponent._payload);
        workInProgress.type = lazyComponent;
        if ("function" === typeof lazyComponent)
          shouldConstruct(lazyComponent)
            ? ((current = resolveClassComponentProps(lazyComponent, current)),
              (workInProgress.tag = 1),
              (workInProgress = updateClassComponent(
                null,
                workInProgress,
                lazyComponent,
                current,
                renderLanes
              )))
            : ((workInProgress.tag = 0),
              (workInProgress = updateFunctionComponent(
                null,
                workInProgress,
                lazyComponent,
                current,
                renderLanes
              )));
        else {
          if (void 0 !== lazyComponent && null !== lazyComponent)
            if (
              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)
            ) {
              workInProgress.tag = 11;
              workInProgress = updateForwardRef(
                null,
                workInProgress,
                lazyComponent,
                current,
                renderLanes
              );
              break a;
            } else if (init === REACT_MEMO_TYPE) {
              workInProgress.tag = 14;
              workInProgress = updateMemoComponent(
                null,
                workInProgress,
                lazyComponent,
                current,
                renderLanes
              );
              break a;
            }
          workInProgress =
            getComponentNameFromType(lazyComponent) || lazyComponent;
          throw Error(formatProdErrorMessage(306, workInProgress, ""));
        }
      }
      return workInProgress;
    case 0:
      return updateFunctionComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 1:
      return (
        (lazyComponent = workInProgress.type),
        (init = resolveClassComponentProps(
          lazyComponent,
          workInProgress.pendingProps
        )),
        updateClassComponent(
          current,
          workInProgress,
          lazyComponent,
          init,
          renderLanes
        )
      );
    case 3:
      a: {
        pushHostContainer(
          workInProgress,
          workInProgress.stateNode.containerInfo
        );
        if (null === current) throw Error(formatProdErrorMessage(387));
        var nextProps = workInProgress.pendingProps;
        init = workInProgress.memoizedState;
        lazyComponent = init.element;
        cloneUpdateQueue(current, workInProgress);
        processUpdateQueue(workInProgress, nextProps, null, renderLanes);
        var nextState = workInProgress.memoizedState;
        nextProps = nextState.cache;
        pushProvider(workInProgress, CacheContext, nextProps);
        nextProps !== init.cache &&
          propagateContextChanges(
            workInProgress,
            [CacheContext],
            renderLanes,
            !0
          );
        suspendIfUpdateReadFromEntangledAsyncAction();
        nextProps = nextState.element;
        if (init.isDehydrated)
          if (
            ((init = {
              element: nextProps,
              isDehydrated: !1,
              cache: nextState.cache
            }),
            (workInProgress.updateQueue.baseState = init),
            (workInProgress.memoizedState = init),
            workInProgress.flags & 256)
          ) {
            workInProgress = mountHostRootWithoutHydrating(
              current,
              workInProgress,
              nextProps,
              renderLanes
            );
            break a;
          } else if (nextProps !== lazyComponent) {
            lazyComponent = createCapturedValueAtFiber(
              Error(formatProdErrorMessage(424)),
              workInProgress
            );
            queueHydrationError(lazyComponent);
            workInProgress = mountHostRootWithoutHydrating(
              current,
              workInProgress,
              nextProps,
              renderLanes
            );
            break a;
          } else
            for (
              nextHydratableInstance = getNextHydratable(
                workInProgress.stateNode.containerInfo.firstChild
              ),
                hydrationParentFiber = workInProgress,
                isHydrating = !0,
                hydrationErrors = null,
                rootOrSingletonContext = !0,
                renderLanes = mountChildFibers(
                  workInProgress,
                  null,
                  nextProps,
                  renderLanes
                ),
                workInProgress.child = renderLanes;
              renderLanes;

            )
              (renderLanes.flags = (renderLanes.flags & -3) | 4096),
                (renderLanes = renderLanes.sibling);
        else {
          resetHydrationState();
          if (nextProps === lazyComponent) {
            workInProgress = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderLanes
            );
            break a;
          }
          reconcileChildren(current, workInProgress, nextProps, renderLanes);
        }
        workInProgress = workInProgress.child;
      }
      return workInProgress;
    case 26:
      return (
        markRef(current, workInProgress),
        null === current
          ? (renderLanes = getResource(
              workInProgress.type,
              null,
              workInProgress.pendingProps,
              null
            ))
            ? (workInProgress.memoizedState = renderLanes)
            : isHydrating ||
              ((renderLanes = workInProgress.type),
              (current = workInProgress.pendingProps),
              (lazyComponent = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              ).createElement(renderLanes)),
              (lazyComponent[internalInstanceKey] = workInProgress),
              (lazyComponent[internalPropsKey] = current),
              setInitialProperties(lazyComponent, renderLanes, current),
              markNodeAsHoistable(lazyComponent),
              (workInProgress.stateNode = lazyComponent))
          : (workInProgress.memoizedState = getResource(
              workInProgress.type,
              current.memoizedProps,
              workInProgress.pendingProps,
              current.memoizedState
            )),
        null
      );
    case 27:
      return (
        pushHostContext(workInProgress),
        null === current &&
          isHydrating &&
          ((lazyComponent = workInProgress.stateNode =
            resolveSingletonInstance(
              workInProgress.type,
              workInProgress.pendingProps,
              rootInstanceStackCursor.current
            )),
          (hydrationParentFiber = workInProgress),
          (rootOrSingletonContext = !0),
          (nextHydratableInstance = getNextHydratable(
            lazyComponent.firstChild
          ))),
        (lazyComponent = workInProgress.pendingProps.children),
        null !== current || isHydrating
          ? reconcileChildren(
              current,
              workInProgress,
              lazyComponent,
              renderLanes
            )
          : (workInProgress.child = reconcileChildFibers(
              workInProgress,
              null,
              lazyComponent,
              renderLanes
            )),
        markRef(current, workInProgress),
        workInProgress.child
      );
    case 5:
      if (null === current && isHydrating) {
        if ((init = lazyComponent = nextHydratableInstance))
          (lazyComponent = canHydrateInstance(
            lazyComponent,
            workInProgress.type,
            workInProgress.pendingProps,
            rootOrSingletonContext
          )),
            null !== lazyComponent
              ? ((workInProgress.stateNode = lazyComponent),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = getNextHydratable(
                  lazyComponent.firstChild
                )),
                (rootOrSingletonContext = !1),
                (init = !0))
              : (init = !1);
        init || throwOnHydrationMismatch(workInProgress);
      }
      pushHostContext(workInProgress);
      init = workInProgress.type;
      nextProps = workInProgress.pendingProps;
      nextState = null !== current ? current.memoizedProps : null;
      lazyComponent = nextProps.children;
      shouldSetTextContent(init, nextProps)
        ? (lazyComponent = null)
        : null !== nextState &&
          shouldSetTextContent(init, nextState) &&
          (workInProgress.flags |= 32);
      null !== workInProgress.memoizedState &&
        ((init = renderWithHooks(
          current,
          workInProgress,
          TransitionAwareHostComponent,
          null,
          null,
          renderLanes
        )),
        (HostTransitionContext._currentValue = init));
      markRef(current, workInProgress);
      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
      return workInProgress.child;
    case 6:
      if (null === current && isHydrating) {
        if ((current = renderLanes = nextHydratableInstance))
          (renderLanes = canHydrateTextInstance(
            renderLanes,
            workInProgress.pendingProps,
            rootOrSingletonContext
          )),
            null !== renderLanes
              ? ((workInProgress.stateNode = renderLanes),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = null),
                (current = !0))
              : (current = !1);
        current || throwOnHydrationMismatch(workInProgress);
      }
      return null;
    case 13:
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    case 4:
      return (
        pushHostContainer(
          workInProgress,
          workInProgress.stateNode.containerInfo
        ),
        (lazyComponent = workInProgress.pendingProps),
        null === current
          ? (workInProgress.child = reconcileChildFibers(
              workInProgress,
              null,
              lazyComponent,
              renderLanes
            ))
          : reconcileChildren(
              current,
              workInProgress,
              lazyComponent,
              renderLanes
            ),
        workInProgress.child
      );
    case 11:
      return updateForwardRef(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 7:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps,
          renderLanes
        ),
        workInProgress.child
      );
    case 8:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 12:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 10:
      return (
        (lazyComponent = workInProgress.pendingProps),
        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),
        reconcileChildren(
          current,
          workInProgress,
          lazyComponent.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 9:
      return (
        (init = workInProgress.type._context),
        (lazyComponent = workInProgress.pendingProps.children),
        prepareToReadContext(workInProgress),
        (init = readContext(init)),
        (lazyComponent = lazyComponent(init)),
        (workInProgress.flags |= 1),
        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),
        workInProgress.child
      );
    case 14:
      return updateMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 15:
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 19:
      return updateSuspenseListComponent(current, workInProgress, renderLanes);
    case 22:
      return updateOffscreenComponent(current, workInProgress, renderLanes);
    case 24:
      return (
        prepareToReadContext(workInProgress),
        (lazyComponent = readContext(CacheContext)),
        null === current
          ? ((init = peekCacheFromPool()),
            null === init &&
              ((init = workInProgressRoot),
              (nextProps = createCache()),
              (init.pooledCache = nextProps),
              nextProps.refCount++,
              null !== nextProps && (init.pooledCacheLanes |= renderLanes),
              (init = nextProps)),
            (workInProgress.memoizedState = {
              parent: lazyComponent,
              cache: init
            }),
            initializeUpdateQueue(workInProgress),
            pushProvider(workInProgress, CacheContext, init))
          : (0 !== (current.lanes & renderLanes) &&
              (cloneUpdateQueue(current, workInProgress),
              processUpdateQueue(workInProgress, null, null, renderLanes),
              suspendIfUpdateReadFromEntangledAsyncAction()),
            (init = current.memoizedState),
            (nextProps = workInProgress.memoizedState),
            init.parent !== lazyComponent
              ? ((init = { parent: lazyComponent, cache: lazyComponent }),
                (workInProgress.memoizedState = init),
                0 === workInProgress.lanes &&
                  (workInProgress.memoizedState =
                    workInProgress.updateQueue.baseState =
                      init),
                pushProvider(workInProgress, CacheContext, lazyComponent))
              : ((lazyComponent = nextProps.cache),
                pushProvider(workInProgress, CacheContext, lazyComponent),
                lazyComponent !== init.cache &&
                  propagateContextChanges(
                    workInProgress,
                    [CacheContext],
                    renderLanes,
                    !0
                  ))),
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 29:
      throw workInProgress.pendingProps;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
var valueCursor = createCursor(null),
  currentlyRenderingFiber = null,
  lastContextDependency = null;
function pushProvider(providerFiber, context, nextValue) {
  push(valueCursor, context._currentValue);
  context._currentValue = nextValue;
}
function popProvider(context) {
  context._currentValue = valueCursor.current;
  pop(valueCursor);
}
function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
  for (; null !== parent; ) {
    var alternate = parent.alternate;
    (parent.childLanes & renderLanes) !== renderLanes
      ? ((parent.childLanes |= renderLanes),
        null !== alternate && (alternate.childLanes |= renderLanes))
      : null !== alternate &&
        (alternate.childLanes & renderLanes) !== renderLanes &&
        (alternate.childLanes |= renderLanes);
    if (parent === propagationRoot) break;
    parent = parent.return;
  }
}
function propagateContextChanges(
  workInProgress,
  contexts,
  renderLanes,
  forcePropagateEntireTree
) {
  var fiber = workInProgress.child;
  null !== fiber && (fiber.return = workInProgress);
  for (; null !== fiber; ) {
    var list = fiber.dependencies;
    if (null !== list) {
      var nextFiber = fiber.child;
      list = list.firstContext;
      a: for (; null !== list; ) {
        var dependency = list;
        list = fiber;
        for (var i = 0; i < contexts.length; i++)
          if (dependency.context === contexts[i]) {
            list.lanes |= renderLanes;
            dependency = list.alternate;
            null !== dependency && (dependency.lanes |= renderLanes);
            scheduleContextWorkOnParentPath(
              list.return,
              renderLanes,
              workInProgress
            );
            forcePropagateEntireTree || (nextFiber = null);
            break a;
          }
        list = dependency.next;
      }
    } else if (18 === fiber.tag) {
      nextFiber = fiber.return;
      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
      nextFiber.lanes |= renderLanes;
      list = nextFiber.alternate;
      null !== list && (list.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
      nextFiber = null;
    } else nextFiber = fiber.child;
    if (null !== nextFiber) nextFiber.return = fiber;
    else
      for (nextFiber = fiber; null !== nextFiber; ) {
        if (nextFiber === workInProgress) {
          nextFiber = null;
          break;
        }
        fiber = nextFiber.sibling;
        if (null !== fiber) {
          fiber.return = nextFiber.return;
          nextFiber = fiber;
          break;
        }
        nextFiber = nextFiber.return;
      }
    fiber = nextFiber;
  }
}
function propagateParentContextChanges(
  current,
  workInProgress,
  renderLanes,
  forcePropagateEntireTree
) {
  current = null;
  for (
    var parent = workInProgress, isInsidePropagationBailout = !1;
    null !== parent;

  ) {
    if (!isInsidePropagationBailout)
      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
      else if (0 !== (parent.flags & 262144)) break;
    if (10 === parent.tag) {
      var currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent = currentParent.memoizedProps;
      if (null !== currentParent) {
        var context = parent.type;
        objectIs(parent.pendingProps.value, currentParent.value) ||
          (null !== current ? current.push(context) : (current = [context]));
      }
    } else if (parent === hostTransitionProviderCursor.current) {
      currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent.memoizedState.memoizedState !==
        parent.memoizedState.memoizedState &&
        (null !== current
          ? current.push(HostTransitionContext)
          : (current = [HostTransitionContext]));
    }
    parent = parent.return;
  }
  null !== current &&
    propagateContextChanges(
      workInProgress,
      current,
      renderLanes,
      forcePropagateEntireTree
    );
  workInProgress.flags |= 262144;
}
function checkIfContextChanged(currentDependencies) {
  for (
    currentDependencies = currentDependencies.firstContext;
    null !== currentDependencies;

  ) {
    if (
      !objectIs(
        currentDependencies.context._currentValue,
        currentDependencies.memoizedValue
      )
    )
      return !0;
    currentDependencies = currentDependencies.next;
  }
  return !1;
}
function prepareToReadContext(workInProgress) {
  currentlyRenderingFiber = workInProgress;
  lastContextDependency = null;
  workInProgress = workInProgress.dependencies;
  null !== workInProgress && (workInProgress.firstContext = null);
}
function readContext(context) {
  return readContextForConsumer(currentlyRenderingFiber, context);
}
function readContextDuringReconciliation(consumer, context) {
  null === currentlyRenderingFiber && prepareToReadContext(consumer);
  return readContextForConsumer(consumer, context);
}
function readContextForConsumer(consumer, context) {
  var value = context._currentValue;
  context = { context: context, memoizedValue: value, next: null };
  if (null === lastContextDependency) {
    if (null === consumer) throw Error(formatProdErrorMessage(308));
    lastContextDependency = context;
    consumer.dependencies = { lanes: 0, firstContext: context };
    consumer.flags |= 524288;
  } else lastContextDependency = lastContextDependency.next = context;
  return value;
}
var hasForceUpdate = !1;
function initializeUpdateQueue(fiber) {
  fiber.updateQueue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
    callbacks: null
  };
}
function cloneUpdateQueue(current, workInProgress) {
  current = current.updateQueue;
  workInProgress.updateQueue === current &&
    (workInProgress.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      callbacks: null
    });
}
function createUpdate(lane) {
  return { lane: lane, tag: 0, payload: null, callback: null, next: null };
}
function enqueueUpdate(fiber, update, lane) {
  var updateQueue = fiber.updateQueue;
  if (null === updateQueue) return null;
  updateQueue = updateQueue.shared;
  if (0 !== (executionContext & 2)) {
    var pending = updateQueue.pending;
    null === pending
      ? (update.next = update)
      : ((update.next = pending.next), (pending.next = update));
    updateQueue.pending = update;
    update = getRootForUpdatedFiber(fiber);
    markUpdateLaneFromFiberToRoot(fiber, null, lane);
    return update;
  }
  enqueueUpdate$1(fiber, updateQueue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function entangleTransitions(root, fiber, lane) {
  fiber = fiber.updateQueue;
  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194176))) {
    var queueLanes = fiber.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    fiber.lanes = lane;
    markRootEntangled(root, lane);
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  var queue = workInProgress.updateQueue,
    current = workInProgress.alternate;
  if (
    null !== current &&
    ((current = current.updateQueue), queue === current)
  ) {
    var newFirst = null,
      newLast = null;
    queue = queue.firstBaseUpdate;
    if (null !== queue) {
      do {
        var clone = {
          lane: queue.lane,
          tag: queue.tag,
          payload: queue.payload,
          callback: null,
          next: null
        };
        null === newLast
          ? (newFirst = newLast = clone)
          : (newLast = newLast.next = clone);
        queue = queue.next;
      } while (null !== queue);
      null === newLast
        ? (newFirst = newLast = capturedUpdate)
        : (newLast = newLast.next = capturedUpdate);
    } else newFirst = newLast = capturedUpdate;
    queue = {
      baseState: current.baseState,
      firstBaseUpdate: newFirst,
      lastBaseUpdate: newLast,
      shared: current.shared,
      callbacks: current.callbacks
    };
    workInProgress.updateQueue = queue;
    return;
  }
  workInProgress = queue.lastBaseUpdate;
  null === workInProgress
    ? (queue.firstBaseUpdate = capturedUpdate)
    : (workInProgress.next = capturedUpdate);
  queue.lastBaseUpdate = capturedUpdate;
}
var didReadFromEntangledAsyncAction = !1;
function suspendIfUpdateReadFromEntangledAsyncAction() {
  if (didReadFromEntangledAsyncAction) {
    var entangledActionThenable = currentEntangledActionThenable;
    if (null !== entangledActionThenable) throw entangledActionThenable;
  }
}
function processUpdateQueue(
  workInProgress$jscomp$0,
  props,
  instance$jscomp$0,
  renderLanes
) {
  didReadFromEntangledAsyncAction = !1;
  var queue = workInProgress$jscomp$0.updateQueue;
  hasForceUpdate = !1;
  var firstBaseUpdate = queue.firstBaseUpdate,
    lastBaseUpdate = queue.lastBaseUpdate,
    pendingQueue = queue.shared.pending;
  if (null !== pendingQueue) {
    queue.shared.pending = null;
    var lastPendingUpdate = pendingQueue,
      firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    null === lastBaseUpdate
      ? (firstBaseUpdate = firstPendingUpdate)
      : (lastBaseUpdate.next = firstPendingUpdate);
    lastBaseUpdate = lastPendingUpdate;
    var current = workInProgress$jscomp$0.alternate;
    null !== current &&
      ((current = current.updateQueue),
      (pendingQueue = current.lastBaseUpdate),
      pendingQueue !== lastBaseUpdate &&
        (null === pendingQueue
          ? (current.firstBaseUpdate = firstPendingUpdate)
          : (pendingQueue.next = firstPendingUpdate),
        (current.lastBaseUpdate = lastPendingUpdate)));
  }
  if (null !== firstBaseUpdate) {
    var newState = queue.baseState;
    lastBaseUpdate = 0;
    current = firstPendingUpdate = lastPendingUpdate = null;
    pendingQueue = firstBaseUpdate;
    do {
      var updateLane = pendingQueue.lane & -536870913,
        isHiddenUpdate = updateLane !== pendingQueue.lane;
      if (
        isHiddenUpdate
          ? (workInProgressRootRenderLanes & updateLane) === updateLane
          : (renderLanes & updateLane) === updateLane
      ) {
        0 !== updateLane &&
          updateLane === currentEntangledLane &&
          (didReadFromEntangledAsyncAction = !0);
        null !== current &&
          (current = current.next =
            {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
        a: {
          var workInProgress = workInProgress$jscomp$0,
            update = pendingQueue;
          updateLane = props;
          var instance = instance$jscomp$0;
          switch (update.tag) {
            case 1:
              workInProgress = update.payload;
              if ("function" === typeof workInProgress) {
                newState = workInProgress.call(instance, newState, updateLane);
                break a;
              }
              newState = workInProgress;
              break a;
            case 3:
              workInProgress.flags = (workInProgress.flags & -65537) | 128;
            case 0:
              workInProgress = update.payload;
              updateLane =
                "function" === typeof workInProgress
                  ? workInProgress.call(instance, newState, updateLane)
                  : workInProgress;
              if (null === updateLane || void 0 === updateLane) break a;
              newState = assign({}, newState, updateLane);
              break a;
            case 2:
              hasForceUpdate = !0;
          }
        }
        updateLane = pendingQueue.callback;
        null !== updateLane &&
          ((workInProgress$jscomp$0.flags |= 64),
          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
          (isHiddenUpdate = queue.callbacks),
          null === isHiddenUpdate
            ? (queue.callbacks = [updateLane])
            : isHiddenUpdate.push(updateLane));
      } else
        (isHiddenUpdate = {
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }),
          null === current
            ? ((firstPendingUpdate = current = isHiddenUpdate),
              (lastPendingUpdate = newState))
            : (current = current.next = isHiddenUpdate),
          (lastBaseUpdate |= updateLane);
      pendingQueue = pendingQueue.next;
      if (null === pendingQueue)
        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
          break;
        else
          (isHiddenUpdate = pendingQueue),
            (pendingQueue = isHiddenUpdate.next),
            (isHiddenUpdate.next = null),
            (queue.lastBaseUpdate = isHiddenUpdate),
            (queue.shared.pending = null);
    } while (1);
    null === current && (lastPendingUpdate = newState);
    queue.baseState = lastPendingUpdate;
    queue.firstBaseUpdate = firstPendingUpdate;
    queue.lastBaseUpdate = current;
    null === firstBaseUpdate && (queue.shared.lanes = 0);
    workInProgressRootSkippedLanes |= lastBaseUpdate;
    workInProgress$jscomp$0.lanes = lastBaseUpdate;
    workInProgress$jscomp$0.memoizedState = newState;
  }
}
function callCallback(callback, context) {
  if ("function" !== typeof callback)
    throw Error(formatProdErrorMessage(191, callback));
  callback.call(context);
}
function commitCallbacks(updateQueue, context) {
  var callbacks = updateQueue.callbacks;
  if (null !== callbacks)
    for (
      updateQueue.callbacks = null, updateQueue = 0;
      updateQueue < callbacks.length;
      updateQueue++
    )
      callCallback(callbacks[updateQueue], context);
}
function commitHookEffectListMount(flags, finishedWork) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          lastEffect = void 0;
          var create = updateQueue.create,
            inst = updateQueue.inst;
          lastEffect = create();
          inst.destroy = lastEffect;
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHookEffectListUnmount(
  flags,
  finishedWork,
  nearestMountedAncestor$jscomp$0
) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          var inst = updateQueue.inst,
            destroy = inst.destroy;
          if (void 0 !== destroy) {
            inst.destroy = void 0;
            lastEffect = finishedWork;
            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;
            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(
                lastEffect,
                nearestMountedAncestor,
                error
              );
            }
          }
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitClassCallbacks(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  if (null !== updateQueue) {
    var instance = finishedWork.stateNode;
    try {
      commitCallbacks(updateQueue, instance);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function safelyCallComponentWillUnmount(
  current,
  nearestMountedAncestor,
  instance
) {
  instance.props = resolveClassComponentProps(
    current.type,
    current.memoizedProps
  );
  instance.state = current.memoizedState;
  try {
    instance.componentWillUnmount();
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyAttachRef(current, nearestMountedAncestor) {
  try {
    var ref = current.ref;
    if (null !== ref) {
      var instance = current.stateNode;
      switch (current.tag) {
        case 26:
        case 27:
        case 5:
          var instanceToUse = instance;
          break;
        default:
          instanceToUse = instance;
      }
      "function" === typeof ref
        ? (current.refCleanup = ref(instanceToUse))
        : (ref.current = instanceToUse);
    }
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyDetachRef(current, nearestMountedAncestor) {
  var ref = current.ref,
    refCleanup = current.refCleanup;
  if (null !== ref)
    if ("function" === typeof refCleanup)
      try {
        refCleanup();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      } finally {
        (current.refCleanup = null),
          (current = current.alternate),
          null != current && (current.refCleanup = null);
      }
    else if ("function" === typeof ref)
      try {
        ref(null);
      } catch (error$112) {
        captureCommitPhaseError(current, nearestMountedAncestor, error$112);
      }
    else ref.current = null;
}
function commitHostMount(finishedWork) {
  var type = finishedWork.type,
    props = finishedWork.memoizedProps,
    instance = finishedWork.stateNode;
  try {
    a: switch (type) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        props.autoFocus && instance.focus();
        break a;
      case "img":
        props.src
          ? (instance.src = props.src)
          : props.srcSet && (instance.srcset = props.srcSet);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostUpdate(finishedWork, newProps, oldProps) {
  try {
    var domElement = finishedWork.stateNode;
    updateProperties(domElement, finishedWork.type, oldProps, newProps);
    domElement[internalPropsKey] = newProps;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function isHostParent(fiber) {
  return (
    5 === fiber.tag ||
    3 === fiber.tag ||
    26 === fiber.tag ||
    27 === fiber.tag ||
    4 === fiber.tag
  );
}
function getHostSibling(fiber) {
  a: for (;;) {
    for (; null === fiber.sibling; ) {
      if (null === fiber.return || isHostParent(fiber.return)) return null;
      fiber = fiber.return;
    }
    fiber.sibling.return = fiber.return;
    for (
      fiber = fiber.sibling;
      5 !== fiber.tag &&
      6 !== fiber.tag &&
      27 !== fiber.tag &&
      18 !== fiber.tag;

    ) {
      if (fiber.flags & 2) continue a;
      if (null === fiber.child || 4 === fiber.tag) continue a;
      else (fiber.child.return = fiber), (fiber = fiber.child);
    }
    if (!(fiber.flags & 2)) return fiber.stateNode;
  }
}
function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    (node = node.stateNode),
      before
        ? 8 === parent.nodeType
          ? parent.parentNode.insertBefore(node, before)
          : parent.insertBefore(node, before)
        : (8 === parent.nodeType
            ? ((before = parent.parentNode), before.insertBefore(node, parent))
            : ((before = parent), before.appendChild(node)),
          (parent = parent._reactRootContainer),
          (null !== parent && void 0 !== parent) ||
            null !== before.onclick ||
            (before.onclick = noop$1));
  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
    for (
      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
        node = node.sibling;
      null !== node;

    )
      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
        (node = node.sibling);
}
function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    (node = node.stateNode),
      before ? parent.insertBefore(node, before) : parent.appendChild(node);
  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
    for (
      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      null !== node;

    )
      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
}
var offscreenSubtreeIsHidden = !1,
  offscreenSubtreeWasHidden = !1,
  needsFormReset = !1,
  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
  nextEffect = null,
  shouldFireAfterActiveInstanceBlur = !1;
function commitBeforeMutationEffects(root, firstChild) {
  root = root.containerInfo;
  eventsEnabled = _enabled;
  root = getActiveElementDeep(root);
  if (hasSelectionCapabilities(root)) {
    if ("selectionStart" in root)
      var JSCompiler_temp = {
        start: root.selectionStart,
        end: root.selectionEnd
      };
    else
      a: {
        JSCompiler_temp =
          ((JSCompiler_temp = root.ownerDocument) &&
            JSCompiler_temp.defaultView) ||
          window;
        var selection =
          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
        if (selection && 0 !== selection.rangeCount) {
          JSCompiler_temp = selection.anchorNode;
          var anchorOffset = selection.anchorOffset,
            focusNode = selection.focusNode;
          selection = selection.focusOffset;
          try {
            JSCompiler_temp.nodeType, focusNode.nodeType;
          } catch (e$20) {
            JSCompiler_temp = null;
            break a;
          }
          var length = 0,
            start = -1,
            end = -1,
            indexWithinAnchor = 0,
            indexWithinFocus = 0,
            node = root,
            parentNode = null;
          b: for (;;) {
            for (var next; ; ) {
              node !== JSCompiler_temp ||
                (0 !== anchorOffset && 3 !== node.nodeType) ||
                (start = length + anchorOffset);
              node !== focusNode ||
                (0 !== selection && 3 !== node.nodeType) ||
                (end = length + selection);
              3 === node.nodeType && (length += node.nodeValue.length);
              if (null === (next = node.firstChild)) break;
              parentNode = node;
              node = next;
            }
            for (;;) {
              if (node === root) break b;
              parentNode === JSCompiler_temp &&
                ++indexWithinAnchor === anchorOffset &&
                (start = length);
              parentNode === focusNode &&
                ++indexWithinFocus === selection &&
                (end = length);
              if (null !== (next = node.nextSibling)) break;
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
          JSCompiler_temp =
            -1 === start || -1 === end ? null : { start: start, end: end };
        } else JSCompiler_temp = null;
      }
    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
  } else JSCompiler_temp = null;
  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
  _enabled = !1;
  for (nextEffect = firstChild; null !== nextEffect; )
    if (
      ((firstChild = nextEffect),
      (root = firstChild.child),
      0 !== (firstChild.subtreeFlags & 1028) && null !== root)
    )
      (root.return = firstChild), (nextEffect = root);
    else
      for (; null !== nextEffect; ) {
        firstChild = nextEffect;
        focusNode = firstChild.alternate;
        root = firstChild.flags;
        switch (firstChild.tag) {
          case 0:
            break;
          case 11:
          case 15:
            break;
          case 1:
            if (0 !== (root & 1024) && null !== focusNode) {
              root = void 0;
              JSCompiler_temp = firstChild;
              anchorOffset = focusNode.memoizedProps;
              focusNode = focusNode.memoizedState;
              selection = JSCompiler_temp.stateNode;
              try {
                var resolvedPrevProps = resolveClassComponentProps(
                  JSCompiler_temp.type,
                  anchorOffset,
                  JSCompiler_temp.elementType === JSCompiler_temp.type
                );
                root = selection.getSnapshotBeforeUpdate(
                  resolvedPrevProps,
                  focusNode
                );
                selection.__reactInternalSnapshotBeforeUpdate = root;
              } catch (error) {
                captureCommitPhaseError(
                  JSCompiler_temp,
                  JSCompiler_temp.return,
                  error
                );
              }
            }
            break;
          case 3:
            if (0 !== (root & 1024))
              if (
                ((root = firstChild.stateNode.containerInfo),
                (JSCompiler_temp = root.nodeType),
                9 === JSCompiler_temp)
              )
                clearContainerSparingly(root);
              else if (1 === JSCompiler_temp)
                switch (root.nodeName) {
                  case "HEAD":
                  case "HTML":
                  case "BODY":
                    clearContainerSparingly(root);
                    break;
                  default:
                    root.textContent = "";
                }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
        }
        root = firstChild.sibling;
        if (null !== root) {
          root.return = firstChild.return;
          nextEffect = root;
          break;
        }
        nextEffect = firstChild.return;
      }
  resolvedPrevProps = shouldFireAfterActiveInstanceBlur;
  shouldFireAfterActiveInstanceBlur = !1;
  return resolvedPrevProps;
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitHookEffectListMount(5, finishedWork);
      break;
    case 1:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 4)
        if (((finishedRoot = finishedWork.stateNode), null === current))
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        else {
          var prevProps = resolveClassComponentProps(
            finishedWork.type,
            current.memoizedProps
          );
          current = current.memoizedState;
          try {
            finishedRoot.componentDidUpdate(
              prevProps,
              current,
              finishedRoot.__reactInternalSnapshotBeforeUpdate
            );
          } catch (error$111) {
            captureCommitPhaseError(
              finishedWork,
              finishedWork.return,
              error$111
            );
          }
        }
      flags & 64 && commitClassCallbacks(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
        finishedRoot = null;
        if (null !== finishedWork.child)
          switch (finishedWork.child.tag) {
            case 27:
            case 5:
              finishedRoot = finishedWork.child.stateNode;
              break;
            case 1:
              finishedRoot = finishedWork.child.stateNode;
          }
        try {
          commitCallbacks(flags, finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 26:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 27:
    case 5:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      null === current && flags & 4 && commitHostMount(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 12:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    case 13:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
      break;
    case 22:
      prevProps =
        null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
      if (!prevProps) {
        current =
          (null !== current && null !== current.memoizedState) ||
          offscreenSubtreeWasHidden;
        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevProps;
        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
          ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            )
          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      }
      flags & 512 &&
        ("manual" === finishedWork.memoizedProps.mode
          ? safelyAttachRef(finishedWork, finishedWork.return)
          : safelyDetachRef(finishedWork, finishedWork.return));
      break;
    default:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
  }
}
function detachFiberAfterEffects(fiber) {
  var alternate = fiber.alternate;
  null !== alternate &&
    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
  fiber.child = null;
  fiber.deletions = null;
  fiber.sibling = null;
  5 === fiber.tag &&
    ((alternate = fiber.stateNode),
    null !== alternate && detachDeletedInstance(alternate));
  fiber.stateNode = null;
  fiber.return = null;
  fiber.dependencies = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.stateNode = null;
  fiber.updateQueue = null;
}
var hostParent = null,
  hostParentIsContainer = !1;
function recursivelyTraverseDeletionEffects(
  finishedRoot,
  nearestMountedAncestor,
  parent
) {
  for (parent = parent.child; null !== parent; )
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
      (parent = parent.sibling);
}
function commitDeletionEffectsOnFiber(
  finishedRoot,
  nearestMountedAncestor,
  deletedFiber
) {
  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
    try {
      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
    } catch (err) {}
  switch (deletedFiber.tag) {
    case 26:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      deletedFiber.memoizedState
        ? deletedFiber.memoizedState.count--
        : deletedFiber.stateNode &&
          ((deletedFiber = deletedFiber.stateNode),
          deletedFiber.parentNode.removeChild(deletedFiber));
      break;
    case 27:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      var prevHostParent = hostParent,
        prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      deletedFiber = deletedFiber.stateNode;
      for (
        nearestMountedAncestor = deletedFiber.attributes;
        nearestMountedAncestor.length;

      )
        deletedFiber.removeAttributeNode(nearestMountedAncestor[0]);
      detachDeletedInstance(deletedFiber);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 5:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
    case 6:
      prevHostParentIsContainer = hostParent;
      var prevHostParentIsContainer$119 = hostParentIsContainer;
      hostParent = null;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParentIsContainer;
      hostParentIsContainer = prevHostParentIsContainer$119;
      if (null !== hostParent)
        if (hostParentIsContainer)
          try {
            (finishedRoot = hostParent),
              (prevHostParent = deletedFiber.stateNode),
              8 === finishedRoot.nodeType
                ? finishedRoot.parentNode.removeChild(prevHostParent)
                : finishedRoot.removeChild(prevHostParent);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
        else
          try {
            hostParent.removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
      break;
    case 18:
      null !== hostParent &&
        (hostParentIsContainer
          ? ((nearestMountedAncestor = hostParent),
            (deletedFiber = deletedFiber.stateNode),
            8 === nearestMountedAncestor.nodeType
              ? clearSuspenseBoundary(
                  nearestMountedAncestor.parentNode,
                  deletedFiber
                )
              : 1 === nearestMountedAncestor.nodeType &&
                clearSuspenseBoundary(nearestMountedAncestor, deletedFiber),
            retryIfBlockedOn(nearestMountedAncestor))
          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
      break;
    case 4:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode.containerInfo;
      hostParentIsContainer = !0;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      offscreenSubtreeWasHidden ||
        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden ||
        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 1:
      offscreenSubtreeWasHidden ||
        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
        (prevHostParent = deletedFiber.stateNode),
        "function" === typeof prevHostParent.componentWillUnmount &&
          safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 21:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 22:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden =
        (prevHostParent = offscreenSubtreeWasHidden) ||
        null !== deletedFiber.memoizedState;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      offscreenSubtreeWasHidden = prevHostParent;
      break;
    default:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
  }
}
function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
  if (
    null === finishedWork.memoizedState &&
    ((finishedRoot = finishedWork.alternate),
    null !== finishedRoot &&
      ((finishedRoot = finishedRoot.memoizedState),
      null !== finishedRoot &&
        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
  )
    try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
}
function getRetryCache(finishedWork) {
  switch (finishedWork.tag) {
    case 13:
    case 19:
      var retryCache = finishedWork.stateNode;
      null === retryCache &&
        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
      return retryCache;
    case 22:
      return (
        (finishedWork = finishedWork.stateNode),
        (retryCache = finishedWork._retryCache),
        null === retryCache &&
          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
        retryCache
      );
    default:
      throw Error(formatProdErrorMessage(435, finishedWork.tag));
  }
}
function attachSuspenseRetryListeners(finishedWork, wakeables) {
  var retryCache = getRetryCache(finishedWork);
  wakeables.forEach(function (wakeable) {
    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
    retryCache.has(wakeable) ||
      (retryCache.add(wakeable), wakeable.then(retry, retry));
  });
}
function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
  var deletions = parentFiber.deletions;
  if (null !== deletions)
    for (var i = 0; i < deletions.length; i++) {
      var childToDelete = deletions[i],
        root = root$jscomp$0,
        returnFiber = parentFiber,
        parent = returnFiber;
      a: for (; null !== parent; ) {
        switch (parent.tag) {
          case 27:
          case 5:
            hostParent = parent.stateNode;
            hostParentIsContainer = !1;
            break a;
          case 3:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = !0;
            break a;
          case 4:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = !0;
            break a;
        }
        parent = parent.return;
      }
      if (null === hostParent) throw Error(formatProdErrorMessage(160));
      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
      hostParent = null;
      hostParentIsContainer = !1;
      root = childToDelete.alternate;
      null !== root && (root.return = null);
      childToDelete.return = null;
    }
  if (parentFiber.subtreeFlags & 13878)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
        (parentFiber = parentFiber.sibling);
}
var currentHoistableRoot = null;
function commitMutationEffectsOnFiber(finishedWork, root) {
  var current = finishedWork.alternate,
    flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
        commitHookEffectListMount(3, finishedWork),
        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
      break;
    case 1:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      flags & 64 &&
        offscreenSubtreeIsHidden &&
        ((finishedWork = finishedWork.updateQueue),
        null !== finishedWork &&
          ((flags = finishedWork.callbacks),
          null !== flags &&
            ((current = finishedWork.shared.hiddenCallbacks),
            (finishedWork.shared.hiddenCallbacks =
              null === current ? flags : current.concat(flags)))));
      break;
    case 26:
      var hoistableRoot = currentHoistableRoot;
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      if (flags & 4) {
        var currentResource = null !== current ? current.memoizedState : null;
        flags = finishedWork.memoizedState;
        if (null === current)
          if (null === flags)
            if (null === finishedWork.stateNode) {
              a: {
                flags = finishedWork.type;
                current = finishedWork.memoizedProps;
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                b: switch (flags) {
                  case "title":
                    currentResource =
                      hoistableRoot.getElementsByTagName("title")[0];
                    if (
                      !currentResource ||
                      currentResource[internalHoistableMarker] ||
                      currentResource[internalInstanceKey] ||
                      "http://www.w3.org/2000/svg" ===
                        currentResource.namespaceURI ||
                      currentResource.hasAttribute("itemprop")
                    )
                      (currentResource = hoistableRoot.createElement(flags)),
                        hoistableRoot.head.insertBefore(
                          currentResource,
                          hoistableRoot.querySelector("head > title")
                        );
                    setInitialProperties(currentResource, flags, current);
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                    break a;
                  case "link":
                    var maybeNodes = getHydratableHoistableCache(
                      "link",
                      "href",
                      hoistableRoot
                    ).get(flags + (current.href || ""));
                    if (maybeNodes)
                      for (var i = 0; i < maybeNodes.length; i++)
                        if (
                          ((currentResource = maybeNodes[i]),
                          currentResource.getAttribute("href") ===
                            (null == current.href ? null : current.href) &&
                            currentResource.getAttribute("rel") ===
                              (null == current.rel ? null : current.rel) &&
                            currentResource.getAttribute("title") ===
                              (null == current.title ? null : current.title) &&
                            currentResource.getAttribute("crossorigin") ===
                              (null == current.crossOrigin
                                ? null
                                : current.crossOrigin))
                        ) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  case "meta":
                    if (
                      (maybeNodes = getHydratableHoistableCache(
                        "meta",
                        "content",
                        hoistableRoot
                      ).get(flags + (current.content || "")))
                    )
                      for (i = 0; i < maybeNodes.length; i++)
                        if (
                          ((currentResource = maybeNodes[i]),
                          currentResource.getAttribute("content") ===
                            (null == current.content
                              ? null
                              : "" + current.content) &&
                            currentResource.getAttribute("name") ===
                              (null == current.name ? null : current.name) &&
                            currentResource.getAttribute("property") ===
                              (null == current.property
                                ? null
                                : current.property) &&
                            currentResource.getAttribute("http-equiv") ===
                              (null == current.httpEquiv
                                ? null
                                : current.httpEquiv) &&
                            currentResource.getAttribute("charset") ===
                              (null == current.charSet
                                ? null
                                : current.charSet))
                        ) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  default:
                    throw Error(formatProdErrorMessage(468, flags));
                }
                currentResource[internalInstanceKey] = finishedWork;
                markNodeAsHoistable(currentResource);
                flags = currentResource;
              }
              finishedWork.stateNode = flags;
            } else
              mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              );
          else
            finishedWork.stateNode = acquireResource(
              hoistableRoot,
              flags,
              finishedWork.memoizedProps
            );
        else
          currentResource !== flags
            ? (null === currentResource
                ? null !== current.stateNode &&
                  ((current = current.stateNode),
                  current.parentNode.removeChild(current))
                : currentResource.count--,
              null === flags
                ? mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  )
                : acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  ))
            : null === flags &&
              null !== finishedWork.stateNode &&
              commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
      }
      break;
    case 27:
      if (flags & 4 && null === finishedWork.alternate) {
        hoistableRoot = finishedWork.stateNode;
        currentResource = finishedWork.memoizedProps;
        try {
          for (var node = hoistableRoot.firstChild; node; ) {
            var nextNode = node.nextSibling,
              nodeName = node.nodeName;
            node[internalHoistableMarker] ||
              "HEAD" === nodeName ||
              "BODY" === nodeName ||
              "SCRIPT" === nodeName ||
              "STYLE" === nodeName ||
              ("LINK" === nodeName &&
                "stylesheet" === node.rel.toLowerCase()) ||
              hoistableRoot.removeChild(node);
            node = nextNode;
          }
          for (
            var type = finishedWork.type, attributes = hoistableRoot.attributes;
            attributes.length;

          )
            hoistableRoot.removeAttributeNode(attributes[0]);
          setInitialProperties(hoistableRoot, type, currentResource);
          hoistableRoot[internalInstanceKey] = finishedWork;
          hoistableRoot[internalPropsKey] = currentResource;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    case 5:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      if (finishedWork.flags & 32) {
        hoistableRoot = finishedWork.stateNode;
        try {
          setTextContent(hoistableRoot, "");
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      flags & 4 &&
        null != finishedWork.stateNode &&
        ((hoistableRoot = finishedWork.memoizedProps),
        commitHostUpdate(
          finishedWork,
          hoistableRoot,
          null !== current ? current.memoizedProps : hoistableRoot
        ));
      flags & 1024 && (needsFormReset = !0);
      break;
    case 6:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags & 4) {
        if (null === finishedWork.stateNode)
          throw Error(formatProdErrorMessage(162));
        flags = finishedWork.memoizedProps;
        current = finishedWork.stateNode;
        try {
          current.nodeValue = flags;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 3:
      tagCaches = null;
      hoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(root.containerInfo);
      recursivelyTraverseMutationEffects(root, finishedWork);
      currentHoistableRoot = hoistableRoot;
      commitReconciliationEffects(finishedWork);
      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
        try {
          retryIfBlockedOn(root.containerInfo);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      needsFormReset &&
        ((needsFormReset = !1), recursivelyResetForms(finishedWork));
      break;
    case 4:
      flags = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(
        finishedWork.stateNode.containerInfo
      );
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      currentHoistableRoot = flags;
      break;
    case 12:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    case 13:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      finishedWork.child.flags & 8192 &&
        (null !== finishedWork.memoizedState) !==
          (null !== current && null !== current.memoizedState) &&
        (globalMostRecentFallbackTime = now());
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 22:
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      node = null !== finishedWork.memoizedState;
      nextNode = null !== current && null !== current.memoizedState;
      nodeName = offscreenSubtreeIsHidden;
      type = offscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = nodeName || node;
      offscreenSubtreeWasHidden = type || nextNode;
      recursivelyTraverseMutationEffects(root, finishedWork);
      offscreenSubtreeWasHidden = type;
      offscreenSubtreeIsHidden = nodeName;
      commitReconciliationEffects(finishedWork);
      root = finishedWork.stateNode;
      root._current = finishedWork;
      root._visibility &= -3;
      root._visibility |= root._pendingVisibility & 2;
      if (
        flags & 8192 &&
        ((root._visibility = node
          ? root._visibility & -2
          : root._visibility | 1),
        node &&
          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
          null === current ||
            nextNode ||
            root ||
            recursivelyTraverseDisappearLayoutEffects(finishedWork)),
        null === finishedWork.memoizedProps ||
          "manual" !== finishedWork.memoizedProps.mode)
      )
        a: for (current = null, root = finishedWork; ; ) {
          if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
            if (null === current) {
              nextNode = current = root;
              try {
                if (((hoistableRoot = nextNode.stateNode), node))
                  (currentResource = hoistableRoot.style),
                    "function" === typeof currentResource.setProperty
                      ? currentResource.setProperty(
                          "display",
                          "none",
                          "important"
                        )
                      : (currentResource.display = "none");
                else {
                  maybeNodes = nextNode.stateNode;
                  i = nextNode.memoizedProps.style;
                  var display =
                    void 0 !== i && null !== i && i.hasOwnProperty("display")
                      ? i.display
                      : null;
                  maybeNodes.style.display =
                    null == display || "boolean" === typeof display
                      ? ""
                      : ("" + display).trim();
                }
              } catch (error) {
                captureCommitPhaseError(nextNode, nextNode.return, error);
              }
            }
          } else if (6 === root.tag) {
            if (null === current) {
              nextNode = root;
              try {
                nextNode.stateNode.nodeValue = node
                  ? ""
                  : nextNode.memoizedProps;
              } catch (error) {
                captureCommitPhaseError(nextNode, nextNode.return, error);
              }
            }
          } else if (
            ((22 !== root.tag && 23 !== root.tag) ||
              null === root.memoizedState ||
              root === finishedWork) &&
            null !== root.child
          ) {
            root.child.return = root;
            root = root.child;
            continue;
          }
          if (root === finishedWork) break a;
          for (; null === root.sibling; ) {
            if (null === root.return || root.return === finishedWork) break a;
            current === root && (current = null);
            root = root.return;
          }
          current === root && (current = null);
          root.sibling.return = root.return;
          root = root.sibling;
        }
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((current = flags.retryQueue),
          null !== current &&
            ((flags.retryQueue = null),
            attachSuspenseRetryListeners(finishedWork, current))));
      break;
    case 19:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 21:
      break;
    default:
      recursivelyTraverseMutationEffects(root, finishedWork),
        commitReconciliationEffects(finishedWork);
  }
}
function commitReconciliationEffects(finishedWork) {
  var flags = finishedWork.flags;
  if (flags & 2) {
    try {
      if (27 !== finishedWork.tag) {
        a: {
          for (var parent = finishedWork.return; null !== parent; ) {
            if (isHostParent(parent)) {
              var JSCompiler_inline_result = parent;
              break a;
            }
            parent = parent.return;
          }
          throw Error(formatProdErrorMessage(160));
        }
        switch (JSCompiler_inline_result.tag) {
          case 27:
            var parent$jscomp$0 = JSCompiler_inline_result.stateNode,
              before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
            break;
          case 5:
            var parent$113 = JSCompiler_inline_result.stateNode;
            JSCompiler_inline_result.flags & 32 &&
              (setTextContent(parent$113, ""),
              (JSCompiler_inline_result.flags &= -33));
            var before$114 = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before$114, parent$113);
            break;
          case 3:
          case 4:
            var parent$115 = JSCompiler_inline_result.stateNode.containerInfo,
              before$116 = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(
              finishedWork,
              before$116,
              parent$115
            );
            break;
          default:
            throw Error(formatProdErrorMessage(161));
        }
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    finishedWork.flags &= -3;
  }
  flags & 4096 && (finishedWork.flags &= -4097);
}
function recursivelyResetForms(parentFiber) {
  if (parentFiber.subtreeFlags & 1024)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var fiber = parentFiber;
      recursivelyResetForms(fiber);
      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
      parentFiber = parentFiber.sibling;
    }
}
function recursivelyTraverseLayoutEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags & 8772)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
        (parentFiber = parentFiber.sibling);
}
function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedWork = parentFiber;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 1:
        safelyDetachRef(finishedWork, finishedWork.return);
        var instance = finishedWork.stateNode;
        "function" === typeof instance.componentWillUnmount &&
          safelyCallComponentWillUnmount(
            finishedWork,
            finishedWork.return,
            instance
          );
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 26:
      case 27:
      case 5:
        safelyDetachRef(finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 22:
        safelyDetachRef(finishedWork, finishedWork.return);
        null === finishedWork.memoizedState &&
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      default:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseReappearLayoutEffects(
  finishedRoot$jscomp$0,
  parentFiber,
  includeWorkInProgressEffects
) {
  includeWorkInProgressEffects =
    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var current = parentFiber.alternate,
      finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(4, finishedWork);
        break;
      case 1:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        current = finishedWork;
        finishedRoot = current.stateNode;
        if ("function" === typeof finishedRoot.componentDidMount)
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        current = finishedWork;
        finishedRoot = current.updateQueue;
        if (null !== finishedRoot) {
          var instance = current.stateNode;
          try {
            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
            if (null !== hiddenCallbacks)
              for (
                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
                finishedRoot < hiddenCallbacks.length;
                finishedRoot++
              )
                callCallback(hiddenCallbacks[finishedRoot], instance);
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        }
        includeWorkInProgressEffects &&
          flags & 64 &&
          commitClassCallbacks(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 26:
      case 27:
      case 5:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          null === current &&
          flags & 4 &&
          commitHostMount(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        break;
      case 13:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 4 &&
          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState &&
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      default:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitOffscreenPassiveMountEffects(current, finishedWork) {
  var previousCache = null;
  null !== current &&
    null !== current.memoizedState &&
    null !== current.memoizedState.cachePool &&
    (previousCache = current.memoizedState.cachePool.pool);
  current = null;
  null !== finishedWork.memoizedState &&
    null !== finishedWork.memoizedState.cachePool &&
    (current = finishedWork.memoizedState.cachePool.pool);
  current !== previousCache &&
    (null != current && current.refCount++,
    null != previousCache && releaseCache(previousCache));
}
function commitCachePassiveMountEffect(current, finishedWork) {
  current = null;
  null !== finishedWork.alternate &&
    (current = finishedWork.alternate.memoizedState.cache);
  finishedWork = finishedWork.memoizedState.cache;
  finishedWork !== current &&
    (finishedWork.refCount++, null != current && releaseCache(current));
}
function recursivelyTraversePassiveMountEffects(
  root,
  parentFiber,
  committedLanes,
  committedTransitions
) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveMountOnFiber(
        root,
        parentFiber,
        committedLanes,
        committedTransitions
      ),
        (parentFiber = parentFiber.sibling);
}
function commitPassiveMountOnFiber(
  finishedRoot,
  finishedWork,
  committedLanes,
  committedTransitions
) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 && commitHookEffectListMount(9, finishedWork);
      break;
    case 3:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 &&
        ((finishedRoot = null),
        null !== finishedWork.alternate &&
          (finishedRoot = finishedWork.alternate.memoizedState.cache),
        (finishedWork = finishedWork.memoizedState.cache),
        finishedWork !== finishedRoot &&
          (finishedWork.refCount++,
          null != finishedRoot && releaseCache(finishedRoot)));
      break;
    case 12:
      if (flags & 2048) {
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        finishedRoot = finishedWork.stateNode;
        try {
          var _finishedWork$memoize2 = finishedWork.memoizedProps,
            id = _finishedWork$memoize2.id,
            onPostCommit = _finishedWork$memoize2.onPostCommit;
          "function" === typeof onPostCommit &&
            onPostCommit(
              id,
              null === finishedWork.alternate ? "mount" : "update",
              finishedRoot.passiveEffectDuration,
              -0
            );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      } else
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
      break;
    case 23:
      break;
    case 22:
      _finishedWork$memoize2 = finishedWork.stateNode;
      null !== finishedWork.memoizedState
        ? _finishedWork$memoize2._visibility & 4
          ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            )
          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
        : _finishedWork$memoize2._visibility & 4
          ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            )
          : ((_finishedWork$memoize2._visibility |= 4),
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256)
            ));
      flags & 2048 &&
        commitOffscreenPassiveMountEffects(
          finishedWork.alternate,
          finishedWork
        );
      break;
    case 24:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 &&
        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
      break;
    default:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
  }
}
function recursivelyTraverseReconnectPassiveEffects(
  finishedRoot$jscomp$0,
  parentFiber,
  committedLanes$jscomp$0,
  committedTransitions$jscomp$0,
  includeWorkInProgressEffects
) {
  includeWorkInProgressEffects =
    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      committedLanes = committedLanes$jscomp$0,
      committedTransitions = committedTransitions$jscomp$0,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(8, finishedWork);
        break;
      case 23:
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState
          ? instance._visibility & 4
            ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              )
            : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              )
          : ((instance._visibility |= 4),
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
        includeWorkInProgressEffects &&
          flags & 2048 &&
          commitOffscreenPassiveMountEffects(
            finishedWork.alternate,
            finishedWork
          );
        break;
      case 24:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 2048 &&
          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseAtomicPassiveEffects(
  finishedRoot$jscomp$0,
  parentFiber
) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedRoot = finishedRoot$jscomp$0,
        finishedWork = parentFiber,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 22:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 &&
            commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
          break;
        case 24:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
}
var suspenseyCommitFlag = 8192;
function recursivelyAccumulateSuspenseyCommit(parentFiber) {
  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      accumulateSuspenseyCommitOnFiber(parentFiber),
        (parentFiber = parentFiber.sibling);
}
function accumulateSuspenseyCommitOnFiber(fiber) {
  switch (fiber.tag) {
    case 26:
      recursivelyAccumulateSuspenseyCommit(fiber);
      fiber.flags & suspenseyCommitFlag &&
        null !== fiber.memoizedState &&
        suspendResource(
          currentHoistableRoot,
          fiber.memoizedState,
          fiber.memoizedProps
        );
      break;
    case 5:
      recursivelyAccumulateSuspenseyCommit(fiber);
      break;
    case 3:
    case 4:
      var previousHoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
      recursivelyAccumulateSuspenseyCommit(fiber);
      currentHoistableRoot = previousHoistableRoot;
      break;
    case 22:
      null === fiber.memoizedState &&
        ((previousHoistableRoot = fiber.alternate),
        null !== previousHoistableRoot &&
        null !== previousHoistableRoot.memoizedState
          ? ((previousHoistableRoot = suspenseyCommitFlag),
            (suspenseyCommitFlag = 16777216),
            recursivelyAccumulateSuspenseyCommit(fiber),
            (suspenseyCommitFlag = previousHoistableRoot))
          : recursivelyAccumulateSuspenseyCommit(fiber));
      break;
    default:
      recursivelyAccumulateSuspenseyCommit(fiber);
  }
}
function detachAlternateSiblings(parentFiber) {
  var previousFiber = parentFiber.alternate;
  if (
    null !== previousFiber &&
    ((parentFiber = previousFiber.child), null !== parentFiber)
  ) {
    previousFiber.child = null;
    do
      (previousFiber = parentFiber.sibling),
        (parentFiber.sibling = null),
        (parentFiber = previousFiber);
    while (null !== parentFiber);
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveUnmountOnFiber(parentFiber),
        (parentFiber = parentFiber.sibling);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      finishedWork.flags & 2048 &&
        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 12:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 22:
      var instance = finishedWork.stateNode;
      null !== finishedWork.memoizedState &&
      instance._visibility & 4 &&
      (null === finishedWork.return || 13 !== finishedWork.return.tag)
        ? ((instance._visibility &= -5),
          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
        : recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    default:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
  }
}
function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    deletions = parentFiber;
    switch (deletions.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, deletions, deletions.return);
        recursivelyTraverseDisconnectPassiveEffects(deletions);
        break;
      case 22:
        i = deletions.stateNode;
        i._visibility & 4 &&
          ((i._visibility &= -5),
          recursivelyTraverseDisconnectPassiveEffects(deletions));
        break;
      default:
        recursivelyTraverseDisconnectPassiveEffects(deletions);
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
  deletedSubtreeRoot,
  nearestMountedAncestor
) {
  for (; null !== nextEffect; ) {
    var fiber = nextEffect;
    switch (fiber.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
        break;
      case 23:
      case 22:
        if (
          null !== fiber.memoizedState &&
          null !== fiber.memoizedState.cachePool
        ) {
          var cache = fiber.memoizedState.cachePool.pool;
          null != cache && cache.refCount++;
        }
        break;
      case 24:
        releaseCache(fiber.memoizedState.cache);
    }
    cache = fiber.child;
    if (null !== cache) (cache.return = fiber), (nextEffect = cache);
    else
      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
        cache = nextEffect;
        var sibling = cache.sibling,
          returnFiber = cache.return;
        detachFiberAfterEffects(cache);
        if (cache === fiber) {
          nextEffect = null;
          break a;
        }
        if (null !== sibling) {
          sibling.return = returnFiber;
          nextEffect = sibling;
          break a;
        }
        nextEffect = returnFiber;
      }
  }
}
function FiberNode(tag, pendingProps, key, mode) {
  this.tag = tag;
  this.key = key;
  this.sibling =
    this.child =
    this.return =
    this.stateNode =
    this.type =
    this.elementType =
      null;
  this.index = 0;
  this.refCleanup = this.ref = null;
  this.pendingProps = pendingProps;
  this.dependencies =
    this.memoizedState =
    this.updateQueue =
    this.memoizedProps =
      null;
  this.mode = mode;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function createFiberImplClass(tag, pendingProps, key, mode) {
  return new FiberNode(tag, pendingProps, key, mode);
}
function shouldConstruct(Component) {
  Component = Component.prototype;
  return !(!Component || !Component.isReactComponent);
}
function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;
  null === workInProgress
    ? ((workInProgress = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      )),
      (workInProgress.elementType = current.elementType),
      (workInProgress.type = current.type),
      (workInProgress.stateNode = current.stateNode),
      (workInProgress.alternate = current),
      (current.alternate = workInProgress))
    : ((workInProgress.pendingProps = pendingProps),
      (workInProgress.type = current.type),
      (workInProgress.flags = 0),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.deletions = null));
  workInProgress.flags = current.flags & 31457280;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  pendingProps = current.dependencies;
  workInProgress.dependencies =
    null === pendingProps
      ? null
      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.refCleanup = current.refCleanup;
  return workInProgress;
}
function resetWorkInProgress(workInProgress, renderLanes) {
  workInProgress.flags &= 31457282;
  var current = workInProgress.alternate;
  null === current
    ? ((workInProgress.childLanes = 0),
      (workInProgress.lanes = renderLanes),
      (workInProgress.child = null),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.memoizedProps = null),
      (workInProgress.memoizedState = null),
      (workInProgress.updateQueue = null),
      (workInProgress.dependencies = null),
      (workInProgress.stateNode = null))
    : ((workInProgress.childLanes = current.childLanes),
      (workInProgress.lanes = current.lanes),
      (workInProgress.child = current.child),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.deletions = null),
      (workInProgress.memoizedProps = current.memoizedProps),
      (workInProgress.memoizedState = current.memoizedState),
      (workInProgress.updateQueue = current.updateQueue),
      (workInProgress.type = current.type),
      (renderLanes = current.dependencies),
      (workInProgress.dependencies =
        null === renderLanes
          ? null
          : {
              lanes: renderLanes.lanes,
              firstContext: renderLanes.firstContext
            }));
  return workInProgress;
}
function createFiberFromTypeAndProps(
  type,
  key,
  pendingProps,
  owner,
  mode,
  lanes
) {
  var fiberTag = 0;
  owner = type;
  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
  else if ("string" === typeof type)
    fiberTag = isHostHoistableType(
      type,
      pendingProps,
      contextStackCursor.current
    )
      ? 26
      : "html" === type || "head" === type || "body" === type
        ? 27
        : 5;
  else
    a: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        fiberTag = 8;
        mode |= 24;
        break;
      case REACT_PROFILER_TYPE:
        return (
          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
          (type.elementType = REACT_PROFILER_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_SUSPENSE_TYPE:
        return (
          (type = createFiberImplClass(13, pendingProps, key, mode)),
          (type.elementType = REACT_SUSPENSE_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_SUSPENSE_LIST_TYPE:
        return (
          (type = createFiberImplClass(19, pendingProps, key, mode)),
          (type.elementType = REACT_SUSPENSE_LIST_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_OFFSCREEN_TYPE:
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
      default:
        if ("object" === typeof type && null !== type)
          switch (type.$$typeof) {
            case REACT_PROVIDER_TYPE:
            case REACT_CONTEXT_TYPE:
              fiberTag = 10;
              break a;
            case REACT_CONSUMER_TYPE:
              fiberTag = 9;
              break a;
            case REACT_FORWARD_REF_TYPE:
              fiberTag = 11;
              break a;
            case REACT_MEMO_TYPE:
              fiberTag = 14;
              break a;
            case REACT_LAZY_TYPE:
              fiberTag = 16;
              owner = null;
              break a;
          }
        fiberTag = 29;
        pendingProps = Error(
          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
        );
        owner = null;
    }
  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
  key.elementType = type;
  key.type = owner;
  key.lanes = lanes;
  return key;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  elements = createFiberImplClass(7, elements, key, mode);
  elements.lanes = lanes;
  return elements;
}
function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
  pendingProps = createFiberImplClass(22, pendingProps, key, mode);
  pendingProps.elementType = REACT_OFFSCREEN_TYPE;
  pendingProps.lanes = lanes;
  var primaryChildInstance = {
    _visibility: 1,
    _pendingVisibility: 1,
    _pendingMarkers: null,
    _retryCache: null,
    _transitions: null,
    _current: null,
    detach: function () {
      var fiber = primaryChildInstance._current;
      if (null === fiber) throw Error(formatProdErrorMessage(456));
      if (0 === (primaryChildInstance._pendingVisibility & 2)) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root &&
          ((primaryChildInstance._pendingVisibility |= 2),
          scheduleUpdateOnFiber(root, fiber, 2));
      }
    },
    attach: function () {
      var fiber = primaryChildInstance._current;
      if (null === fiber) throw Error(formatProdErrorMessage(456));
      if (0 !== (primaryChildInstance._pendingVisibility & 2)) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root &&
          ((primaryChildInstance._pendingVisibility &= -3),
          scheduleUpdateOnFiber(root, fiber, 2));
      }
    }
  };
  pendingProps.stateNode = primaryChildInstance;
  return pendingProps;
}
function createFiberFromText(content, mode, lanes) {
  content = createFiberImplClass(6, content, null, mode);
  content.lanes = lanes;
  return content;
}
function createFiberFromPortal(portal, mode, lanes) {
  mode = createFiberImplClass(
    4,
    null !== portal.children ? portal.children : [],
    portal.key,
    mode
  );
  mode.lanes = lanes;
  mode.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    implementation: portal.implementation
  };
  return mode;
}
function markUpdate(workInProgress) {
  workInProgress.flags |= 4;
}
function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
    workInProgress.flags &= -16777217;
  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {
    resource = suspenseHandlerStackCursor.current;
    if (
      null !== resource &&
      ((workInProgressRootRenderLanes & 4194176) ===
      workInProgressRootRenderLanes
        ? null !== shellBoundary
        : ((workInProgressRootRenderLanes & 62914560) !==
            workInProgressRootRenderLanes &&
            0 === (workInProgressRootRenderLanes & 536870912)) ||
          resource !== shellBoundary)
    )
      throw (
        ((suspendedThenable = noopSuspenseyCommitThenable),
        SuspenseyCommitException)
      );
    workInProgress.flags |= 8192;
  }
}
function scheduleRetryEffect(workInProgress, retryQueue) {
  null !== retryQueue && (workInProgress.flags |= 4);
  workInProgress.flags & 16384 &&
    ((retryQueue =
      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
    (workInProgress.lanes |= retryQueue),
    (workInProgressSuspendedRetryLanes |= retryQueue));
}
function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (!isHydrating)
    switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;
        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
          null !== hasRenderedATailFallback.alternate &&
            (lastTailNode = hasRenderedATailFallback),
            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
        null === lastTailNode
          ? (renderState.tail = null)
          : (lastTailNode.sibling = null);
        break;
      case "collapsed":
        lastTailNode = renderState.tail;
        for (var lastTailNode$131 = null; null !== lastTailNode; )
          null !== lastTailNode.alternate && (lastTailNode$131 = lastTailNode),
            (lastTailNode = lastTailNode.sibling);
        null === lastTailNode$131
          ? hasRenderedATailFallback || null === renderState.tail
            ? (renderState.tail = null)
            : (renderState.tail.sibling = null)
          : (lastTailNode$131.sibling = null);
    }
}
function bubbleProperties(completedWork) {
  var didBailout =
      null !== completedWork.alternate &&
      completedWork.alternate.child === completedWork.child,
    newChildLanes = 0,
    subtreeFlags = 0;
  if (didBailout)
    for (var child$132 = completedWork.child; null !== child$132; )
      (newChildLanes |= child$132.lanes | child$132.childLanes),
        (subtreeFlags |= child$132.subtreeFlags & 31457280),
        (subtreeFlags |= child$132.flags & 31457280),
        (child$132.return = completedWork),
        (child$132 = child$132.sibling);
  else
    for (child$132 = completedWork.child; null !== child$132; )
      (newChildLanes |= child$132.lanes | child$132.childLanes),
        (subtreeFlags |= child$132.subtreeFlags),
        (subtreeFlags |= child$132.flags),
        (child$132.return = completedWork),
        (child$132 = child$132.sibling);
  completedWork.subtreeFlags |= subtreeFlags;
  completedWork.childLanes = newChildLanes;
  return didBailout;
}
function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return bubbleProperties(workInProgress), null;
    case 1:
      return bubbleProperties(workInProgress), null;
    case 3:
      renderLanes = workInProgress.stateNode;
      newProps = null;
      null !== current && (newProps = current.memoizedState.cache);
      workInProgress.memoizedState.cache !== newProps &&
        (workInProgress.flags |= 2048);
      popProvider(CacheContext);
      popHostContainer();
      renderLanes.pendingContext &&
        ((renderLanes.context = renderLanes.pendingContext),
        (renderLanes.pendingContext = null));
      if (null === current || null === current.child)
        popHydrationState(workInProgress)
          ? markUpdate(workInProgress)
          : null === current ||
            (current.memoizedState.isDehydrated &&
              0 === (workInProgress.flags & 256)) ||
            ((workInProgress.flags |= 1024),
            null !== hydrationErrors &&
              (queueRecoverableErrors(hydrationErrors),
              (hydrationErrors = null)));
      bubbleProperties(workInProgress);
      return null;
    case 26:
      return (
        (renderLanes = workInProgress.memoizedState),
        null === current
          ? (markUpdate(workInProgress),
            null !== renderLanes
              ? (bubbleProperties(workInProgress),
                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
              : (bubbleProperties(workInProgress),
                (workInProgress.flags &= -16777217)))
          : renderLanes
            ? renderLanes !== current.memoizedState
              ? (markUpdate(workInProgress),
                bubbleProperties(workInProgress),
                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
              : (bubbleProperties(workInProgress),
                (workInProgress.flags &= -16777217))
            : (current.memoizedProps !== newProps && markUpdate(workInProgress),
              bubbleProperties(workInProgress),
              (workInProgress.flags &= -16777217)),
        null
      );
    case 27:
      popHostContext(workInProgress);
      renderLanes = rootInstanceStackCursor.current;
      var type = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (null === workInProgress.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        popHydrationState(workInProgress)
          ? prepareToHydrateHostInstance(workInProgress, current)
          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),
            (workInProgress.stateNode = current),
            markUpdate(workInProgress));
      }
      bubbleProperties(workInProgress);
      return null;
    case 5:
      popHostContext(workInProgress);
      renderLanes = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (null === workInProgress.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        if (popHydrationState(workInProgress))
          prepareToHydrateHostInstance(workInProgress, current);
        else {
          type = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          );
          switch (current) {
            case 1:
              current = type.createElementNS(
                "http://www.w3.org/2000/svg",
                renderLanes
              );
              break;
            case 2:
              current = type.createElementNS(
                "http://www.w3.org/1998/Math/MathML",
                renderLanes
              );
              break;
            default:
              switch (renderLanes) {
                case "svg":
                  current = type.createElementNS(
                    "http://www.w3.org/2000/svg",
                    renderLanes
                  );
                  break;
                case "math":
                  current = type.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    renderLanes
                  );
                  break;
                case "script":
                  current = type.createElement("div");
                  current.innerHTML = "<script>\x3c/script>";
                  current = current.removeChild(current.firstChild);
                  break;
                case "select":
                  current =
                    "string" === typeof newProps.is
                      ? type.createElement("select", { is: newProps.is })
                      : type.createElement("select");
                  newProps.multiple
                    ? (current.multiple = !0)
                    : newProps.size && (current.size = newProps.size);
                  break;
                default:
                  current =
                    "string" === typeof newProps.is
                      ? type.createElement(renderLanes, { is: newProps.is })
                      : type.createElement(renderLanes);
              }
          }
          current[internalInstanceKey] = workInProgress;
          current[internalPropsKey] = newProps;
          a: for (type = workInProgress.child; null !== type; ) {
            if (5 === type.tag || 6 === type.tag)
              current.appendChild(type.stateNode);
            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
              type.child.return = type;
              type = type.child;
              continue;
            }
            if (type === workInProgress) break a;
            for (; null === type.sibling; ) {
              if (null === type.return || type.return === workInProgress)
                break a;
              type = type.return;
            }
            type.sibling.return = type.return;
            type = type.sibling;
          }
          workInProgress.stateNode = current;
          a: switch (
            (setInitialProperties(current, renderLanes, newProps), renderLanes)
          ) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              current = !!newProps.autoFocus;
              break a;
            case "img":
              current = !0;
              break a;
            default:
              current = !1;
          }
          current && markUpdate(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      workInProgress.flags &= -16777217;
      return null;
    case 6:
      if (current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if ("string" !== typeof newProps && null === workInProgress.stateNode)
          throw Error(formatProdErrorMessage(166));
        current = rootInstanceStackCursor.current;
        if (popHydrationState(workInProgress)) {
          current = workInProgress.stateNode;
          renderLanes = workInProgress.memoizedProps;
          newProps = null;
          type = hydrationParentFiber;
          if (null !== type)
            switch (type.tag) {
              case 27:
              case 5:
                newProps = type.memoizedProps;
            }
          current[internalInstanceKey] = workInProgress;
          current =
            current.nodeValue === renderLanes ||
            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||
            checkForUnmatchedText(current.nodeValue, renderLanes)
              ? !0
              : !1;
          current || throwOnHydrationMismatch(workInProgress);
        } else
          (current =
            getOwnerDocumentFromRootContainer(current).createTextNode(
              newProps
            )),
            (current[internalInstanceKey] = workInProgress),
            (workInProgress.stateNode = current);
      }
      bubbleProperties(workInProgress);
      return null;
    case 13:
      newProps = workInProgress.memoizedState;
      if (
        null === current ||
        (null !== current.memoizedState &&
          null !== current.memoizedState.dehydrated)
      ) {
        type = popHydrationState(workInProgress);
        if (null !== newProps && null !== newProps.dehydrated) {
          if (null === current) {
            if (!type) throw Error(formatProdErrorMessage(318));
            type = workInProgress.memoizedState;
            type = null !== type ? type.dehydrated : null;
            if (!type) throw Error(formatProdErrorMessage(317));
            type[internalInstanceKey] = workInProgress;
          } else
            resetHydrationState(),
              0 === (workInProgress.flags & 128) &&
                (workInProgress.memoizedState = null),
              (workInProgress.flags |= 4);
          bubbleProperties(workInProgress);
          type = !1;
        } else
          null !== hydrationErrors &&
            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),
            (type = !0);
        if (!type) {
          if (workInProgress.flags & 256)
            return popSuspenseHandler(workInProgress), workInProgress;
          popSuspenseHandler(workInProgress);
          return null;
        }
      }
      popSuspenseHandler(workInProgress);
      if (0 !== (workInProgress.flags & 128))
        return (workInProgress.lanes = renderLanes), workInProgress;
      renderLanes = null !== newProps;
      current = null !== current && null !== current.memoizedState;
      if (renderLanes) {
        newProps = workInProgress.child;
        type = null;
        null !== newProps.alternate &&
          null !== newProps.alternate.memoizedState &&
          null !== newProps.alternate.memoizedState.cachePool &&
          (type = newProps.alternate.memoizedState.cachePool.pool);
        var cache$144 = null;
        null !== newProps.memoizedState &&
          null !== newProps.memoizedState.cachePool &&
          (cache$144 = newProps.memoizedState.cachePool.pool);
        cache$144 !== type && (newProps.flags |= 2048);
      }
      renderLanes !== current &&
        renderLanes &&
        (workInProgress.child.flags |= 8192);
      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
      bubbleProperties(workInProgress);
      return null;
    case 4:
      return (
        popHostContainer(),
        null === current &&
          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),
        bubbleProperties(workInProgress),
        null
      );
    case 10:
      return (
        popProvider(workInProgress.type), bubbleProperties(workInProgress), null
      );
    case 19:
      pop(suspenseStackCursor);
      type = workInProgress.memoizedState;
      if (null === type) return bubbleProperties(workInProgress), null;
      newProps = 0 !== (workInProgress.flags & 128);
      cache$144 = type.rendering;
      if (null === cache$144)
        if (newProps) cutOffTailIfNeeded(type, !1);
        else {
          if (
            0 !== workInProgressRootExitStatus ||
            (null !== current && 0 !== (current.flags & 128))
          )
            for (current = workInProgress.child; null !== current; ) {
              cache$144 = findFirstSuspended(current);
              if (null !== cache$144) {
                workInProgress.flags |= 128;
                cutOffTailIfNeeded(type, !1);
                current = cache$144.updateQueue;
                workInProgress.updateQueue = current;
                scheduleRetryEffect(workInProgress, current);
                workInProgress.subtreeFlags = 0;
                current = renderLanes;
                for (renderLanes = workInProgress.child; null !== renderLanes; )
                  resetWorkInProgress(renderLanes, current),
                    (renderLanes = renderLanes.sibling);
                push(
                  suspenseStackCursor,
                  (suspenseStackCursor.current & 1) | 2
                );
                return workInProgress.child;
              }
              current = current.sibling;
            }
          null !== type.tail &&
            now() > workInProgressRootRenderTargetTime &&
            ((workInProgress.flags |= 128),
            (newProps = !0),
            cutOffTailIfNeeded(type, !1),
            (workInProgress.lanes = 4194304));
        }
      else {
        if (!newProps)
          if (((current = findFirstSuspended(cache$144)), null !== current)) {
            if (
              ((workInProgress.flags |= 128),
              (newProps = !0),
              (current = current.updateQueue),
              (workInProgress.updateQueue = current),
              scheduleRetryEffect(workInProgress, current),
              cutOffTailIfNeeded(type, !0),
              null === type.tail &&
                "hidden" === type.tailMode &&
                !cache$144.alternate &&
                !isHydrating)
            )
              return bubbleProperties(workInProgress), null;
          } else
            2 * now() - type.renderingStartTime >
              workInProgressRootRenderTargetTime &&
              536870912 !== renderLanes &&
              ((workInProgress.flags |= 128),
              (newProps = !0),
              cutOffTailIfNeeded(type, !1),
              (workInProgress.lanes = 4194304));
        type.isBackwards
          ? ((cache$144.sibling = workInProgress.child),
            (workInProgress.child = cache$144))
          : ((current = type.last),
            null !== current
              ? (current.sibling = cache$144)
              : (workInProgress.child = cache$144),
            (type.last = cache$144));
      }
      if (null !== type.tail)
        return (
          (workInProgress = type.tail),
          (type.rendering = workInProgress),
          (type.tail = workInProgress.sibling),
          (type.renderingStartTime = now()),
          (workInProgress.sibling = null),
          (current = suspenseStackCursor.current),
          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
          workInProgress
        );
      bubbleProperties(workInProgress);
      return null;
    case 22:
    case 23:
      return (
        popSuspenseHandler(workInProgress),
        popHiddenContext(),
        (newProps = null !== workInProgress.memoizedState),
        null !== current
          ? (null !== current.memoizedState) !== newProps &&
            (workInProgress.flags |= 8192)
          : newProps && (workInProgress.flags |= 8192),
        newProps
          ? 0 !== (renderLanes & 536870912) &&
            0 === (workInProgress.flags & 128) &&
            (bubbleProperties(workInProgress),
            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
          : bubbleProperties(workInProgress),
        (renderLanes = workInProgress.updateQueue),
        null !== renderLanes &&
          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
        (renderLanes = null),
        null !== current &&
          null !== current.memoizedState &&
          null !== current.memoizedState.cachePool &&
          (renderLanes = current.memoizedState.cachePool.pool),
        (newProps = null),
        null !== workInProgress.memoizedState &&
          null !== workInProgress.memoizedState.cachePool &&
          (newProps = workInProgress.memoizedState.cachePool.pool),
        newProps !== renderLanes && (workInProgress.flags |= 2048),
        null !== current && pop(resumedCache),
        null
      );
    case 24:
      return (
        (renderLanes = null),
        null !== current && (renderLanes = current.memoizedState.cache),
        workInProgress.memoizedState.cache !== renderLanes &&
          (workInProgress.flags |= 2048),
        popProvider(CacheContext),
        bubbleProperties(workInProgress),
        null
      );
    case 25:
      return null;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
function unwindWork(current, workInProgress) {
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 1:
      return (
        (current = workInProgress.flags),
        current & 65536
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 3:
      return (
        popProvider(CacheContext),
        popHostContainer(),
        (current = workInProgress.flags),
        0 !== (current & 65536) && 0 === (current & 128)
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 26:
    case 27:
    case 5:
      return popHostContext(workInProgress), null;
    case 13:
      popSuspenseHandler(workInProgress);
      current = workInProgress.memoizedState;
      if (null !== current && null !== current.dehydrated) {
        if (null === workInProgress.alternate)
          throw Error(formatProdErrorMessage(340));
        resetHydrationState();
      }
      current = workInProgress.flags;
      return current & 65536
        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
        : null;
    case 19:
      return pop(suspenseStackCursor), null;
    case 4:
      return popHostContainer(), null;
    case 10:
      return popProvider(workInProgress.type), null;
    case 22:
    case 23:
      return (
        popSuspenseHandler(workInProgress),
        popHiddenContext(),
        null !== current && pop(resumedCache),
        (current = workInProgress.flags),
        current & 65536
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 24:
      return popProvider(CacheContext), null;
    case 25:
      return null;
    default:
      return null;
  }
}
function unwindInterruptedWork(current, interruptedWork) {
  popTreeContext(interruptedWork);
  switch (interruptedWork.tag) {
    case 3:
      popProvider(CacheContext);
      popHostContainer();
      break;
    case 26:
    case 27:
    case 5:
      popHostContext(interruptedWork);
      break;
    case 4:
      popHostContainer();
      break;
    case 13:
      popSuspenseHandler(interruptedWork);
      break;
    case 19:
      pop(suspenseStackCursor);
      break;
    case 10:
      popProvider(interruptedWork.type);
      break;
    case 22:
    case 23:
      popSuspenseHandler(interruptedWork);
      popHiddenContext();
      null !== current && pop(resumedCache);
      break;
    case 24:
      popProvider(CacheContext);
  }
}
var DefaultAsyncDispatcher = {
    getCacheForType: function (resourceType) {
      var cache = readContext(CacheContext),
        cacheForType = cache.data.get(resourceType);
      void 0 === cacheForType &&
        ((cacheForType = resourceType()),
        cache.data.set(resourceType, cacheForType));
      return cacheForType;
    }
  },
  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
  executionContext = 0,
  workInProgressRoot = null,
  workInProgress = null,
  workInProgressRootRenderLanes = 0,
  workInProgressSuspendedReason = 0,
  workInProgressThrownValue = null,
  workInProgressRootDidSkipSuspendedSiblings = !1,
  workInProgressRootIsPrerendering = !1,
  workInProgressRootDidAttachPingListener = !1,
  entangledRenderLanes = 0,
  workInProgressRootExitStatus = 0,
  workInProgressRootSkippedLanes = 0,
  workInProgressRootInterleavedUpdatedLanes = 0,
  workInProgressRootPingedLanes = 0,
  workInProgressDeferredLane = 0,
  workInProgressSuspendedRetryLanes = 0,
  workInProgressRootConcurrentErrors = null,
  workInProgressRootRecoverableErrors = null,
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
  globalMostRecentFallbackTime = 0,
  workInProgressRootRenderTargetTime = Infinity,
  workInProgressTransitions = null,
  legacyErrorBoundariesThatAlreadyFailed = null,
  rootDoesHavePassiveEffects = !1,
  rootWithPendingPassiveEffects = null,
  pendingPassiveEffectsLanes = 0,
  pendingPassiveEffectsRemainingLanes = 0,
  pendingPassiveTransitions = null,
  nestedUpdateCount = 0,
  rootWithNestedUpdates = null;
function requestUpdateLane() {
  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
  if (null !== ReactSharedInternals.T) {
    var actionScopeLane = currentEntangledLane;
    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
  }
  return resolveUpdatePriority();
}
function requestDeferredLane() {
  0 === workInProgressDeferredLane &&
    (workInProgressDeferredLane =
      0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
        ? claimNextTransitionLane()
        : 536870912);
  var suspenseHandler = suspenseHandlerStackCursor.current;
  null !== suspenseHandler && (suspenseHandler.flags |= 32);
  return workInProgressDeferredLane;
}
function scheduleUpdateOnFiber(root, fiber, lane) {
  if (
    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
    null !== root.cancelPendingCommit
  )
    prepareFreshStack(root, 0),
      markRootSuspended(
        root,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        !1
      );
  markRootUpdated$1(root, lane);
  if (0 === (executionContext & 2) || root !== workInProgressRoot)
    root === workInProgressRoot &&
      (0 === (executionContext & 2) &&
        (workInProgressRootInterleavedUpdatedLanes |= lane),
      4 === workInProgressRootExitStatus &&
        markRootSuspended(
          root,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          !1
        )),
      ensureRootIsScheduled(root);
}
function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  var shouldTimeSlice =
      (!forceSync &&
        0 === (lanes & 60) &&
        0 === (lanes & root$jscomp$0.expiredLanes)) ||
      checkIfRootIsPrerendering(root$jscomp$0, lanes),
    exitStatus = shouldTimeSlice
      ? renderRootConcurrent(root$jscomp$0, lanes)
      : renderRootSync(root$jscomp$0, lanes, !0),
    renderWasConcurrent = shouldTimeSlice;
  do {
    if (0 === exitStatus) {
      workInProgressRootIsPrerendering &&
        !shouldTimeSlice &&
        markRootSuspended(root$jscomp$0, lanes, 0, !1);
      break;
    } else if (6 === exitStatus)
      markRootSuspended(
        root$jscomp$0,
        lanes,
        0,
        !workInProgressRootDidSkipSuspendedSiblings
      );
    else {
      forceSync = root$jscomp$0.current.alternate;
      if (
        renderWasConcurrent &&
        !isRenderConsistentWithExternalStores(forceSync)
      ) {
        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
        renderWasConcurrent = !1;
        continue;
      }
      if (2 === exitStatus) {
        renderWasConcurrent = lanes;
        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
          var JSCompiler_inline_result = 0;
        else
          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
            (JSCompiler_inline_result =
              0 !== JSCompiler_inline_result
                ? JSCompiler_inline_result
                : JSCompiler_inline_result & 536870912
                  ? 536870912
                  : 0);
        if (0 !== JSCompiler_inline_result) {
          lanes = JSCompiler_inline_result;
          a: {
            var root = root$jscomp$0;
            exitStatus = workInProgressRootConcurrentErrors;
            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
            wasRootDehydrated &&
              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
            JSCompiler_inline_result = renderRootSync(
              root,
              JSCompiler_inline_result,
              !1
            );
            if (2 !== JSCompiler_inline_result) {
              if (
                workInProgressRootDidAttachPingListener &&
                !wasRootDehydrated
              ) {
                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                workInProgressRootInterleavedUpdatedLanes |=
                  renderWasConcurrent;
                exitStatus = 4;
                break a;
              }
              renderWasConcurrent = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = exitStatus;
              null !== renderWasConcurrent &&
                queueRecoverableErrors(renderWasConcurrent);
            }
            exitStatus = JSCompiler_inline_result;
          }
          renderWasConcurrent = !1;
          if (2 !== exitStatus) continue;
        }
      }
      if (1 === exitStatus) {
        prepareFreshStack(root$jscomp$0, 0);
        markRootSuspended(root$jscomp$0, lanes, 0, !0);
        break;
      }
      a: {
        shouldTimeSlice = root$jscomp$0;
        switch (exitStatus) {
          case 0:
          case 1:
            throw Error(formatProdErrorMessage(345));
          case 4:
            if ((lanes & 4194176) === lanes) {
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              break a;
            }
            break;
          case 2:
            workInProgressRootRecoverableErrors = null;
            break;
          case 3:
          case 5:
            break;
          default:
            throw Error(formatProdErrorMessage(329));
        }
        shouldTimeSlice.finishedWork = forceSync;
        shouldTimeSlice.finishedLanes = lanes;
        if (
          (lanes & 62914560) === lanes &&
          ((renderWasConcurrent = globalMostRecentFallbackTime + 300 - now()),
          10 < renderWasConcurrent)
        ) {
          markRootSuspended(
            shouldTimeSlice,
            lanes,
            workInProgressDeferredLane,
            !workInProgressRootDidSkipSuspendedSiblings
          );
          if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
          shouldTimeSlice.timeoutHandle = scheduleTimeout(
            commitRootWhenReady.bind(
              null,
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              2,
              -0,
              0
            ),
            renderWasConcurrent
          );
          break a;
        }
        commitRootWhenReady(
          shouldTimeSlice,
          forceSync,
          workInProgressRootRecoverableErrors,
          workInProgressTransitions,
          workInProgressRootDidIncludeRecursiveRenderUpdate,
          lanes,
          workInProgressDeferredLane,
          workInProgressRootInterleavedUpdatedLanes,
          workInProgressSuspendedRetryLanes,
          workInProgressRootDidSkipSuspendedSiblings,
          0,
          -0,
          0
        );
      }
    }
    break;
  } while (1);
  ensureRootIsScheduled(root$jscomp$0);
}
function queueRecoverableErrors(errors) {
  null === workInProgressRootRecoverableErrors
    ? (workInProgressRootRecoverableErrors = errors)
    : workInProgressRootRecoverableErrors.push.apply(
        workInProgressRootRecoverableErrors,
        errors
      );
}
function commitRootWhenReady(
  root,
  finishedWork,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  lanes,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes,
  didSkipSuspendedSiblings,
  suspendedCommitReason,
  completedRenderStartTime,
  completedRenderEndTime
) {
  var subtreeFlags = finishedWork.subtreeFlags;
  if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408))
    if (
      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),
      accumulateSuspenseyCommitOnFiber(finishedWork),
      (finishedWork = waitForCommitToBeReady()),
      null !== finishedWork)
    ) {
      root.cancelPendingCommit = finishedWork(
        commitRoot.bind(
          null,
          root,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
          1,
          completedRenderStartTime,
          completedRenderEndTime
        )
      );
      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
      return;
    }
  commitRoot(
    root,
    recoverableErrors,
    transitions,
    didIncludeRenderPhaseUpdate,
    spawnedLane,
    updatedLanes,
    suspendedRetryLanes,
    suspendedCommitReason,
    completedRenderStartTime,
    completedRenderEndTime
  );
}
function isRenderConsistentWithExternalStores(finishedWork) {
  for (var node = finishedWork; ; ) {
    var tag = node.tag;
    if (
      (0 === tag || 11 === tag || 15 === tag) &&
      node.flags & 16384 &&
      ((tag = node.updateQueue),
      null !== tag && ((tag = tag.stores), null !== tag))
    )
      for (var i = 0; i < tag.length; i++) {
        var check = tag[i],
          getSnapshot = check.getSnapshot;
        check = check.value;
        try {
          if (!objectIs(getSnapshot(), check)) return !1;
        } catch (error) {
          return !1;
        }
      }
    tag = node.child;
    if (node.subtreeFlags & 16384 && null !== tag)
      (tag.return = node), (node = tag);
    else {
      if (node === finishedWork) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === finishedWork) return !0;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  return !0;
}
function markRootSuspended(
  root,
  suspendedLanes,
  spawnedLane,
  didAttemptEntireTree
) {
  suspendedLanes &= ~workInProgressRootPingedLanes;
  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
  root.suspendedLanes |= suspendedLanes;
  root.pingedLanes &= ~suspendedLanes;
  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
  didAttemptEntireTree = root.expirationTimes;
  for (var lanes = suspendedLanes; 0 < lanes; ) {
    var index$6 = 31 - clz32(lanes),
      lane = 1 << index$6;
    didAttemptEntireTree[index$6] = -1;
    lanes &= ~lane;
  }
  0 !== spawnedLane &&
    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
}
function flushSyncWork$1() {
  return 0 === (executionContext & 6)
    ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
    : !0;
}
function resetWorkInProgressStack() {
  if (null !== workInProgress) {
    if (0 === workInProgressSuspendedReason)
      var interruptedWork = workInProgress.return;
    else
      (interruptedWork = workInProgress),
        (lastContextDependency = currentlyRenderingFiber = null),
        resetHooksOnUnwind(interruptedWork),
        (thenableState$1 = null),
        (thenableIndexCounter$1 = 0),
        (interruptedWork = workInProgress);
    for (; null !== interruptedWork; )
      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
        (interruptedWork = interruptedWork.return);
    workInProgress = null;
  }
}
function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = 0;
  var timeoutHandle = root.timeoutHandle;
  -1 !== timeoutHandle &&
    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
  timeoutHandle = root.cancelPendingCommit;
  null !== timeoutHandle &&
    ((root.cancelPendingCommit = null), timeoutHandle());
  resetWorkInProgressStack();
  workInProgressRoot = root;
  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  workInProgressSuspendedReason = 0;
  workInProgressThrownValue = null;
  workInProgressRootDidSkipSuspendedSiblings = !1;
  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
  workInProgressRootDidAttachPingListener = !1;
  workInProgressSuspendedRetryLanes =
    workInProgressDeferredLane =
    workInProgressRootPingedLanes =
    workInProgressRootInterleavedUpdatedLanes =
    workInProgressRootSkippedLanes =
    workInProgressRootExitStatus =
      0;
  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
    null;
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
  0 !== (lanes & 8) && (lanes |= lanes & 32);
  var allEntangledLanes = root.entangledLanes;
  if (0 !== allEntangledLanes)
    for (
      root = root.entanglements, allEntangledLanes &= lanes;
      0 < allEntangledLanes;

    ) {
      var index$4 = 31 - clz32(allEntangledLanes),
        lane = 1 << index$4;
      lanes |= root[index$4];
      allEntangledLanes &= ~lane;
    }
  entangledRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
  return timeoutHandle;
}
function handleThrow(root, thrownValue) {
  currentlyRenderingFiber$1 = null;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  thrownValue === SuspenseException
    ? ((thrownValue = getSuspendedThenable()),
      (workInProgressSuspendedReason = 3))
    : thrownValue === SuspenseyCommitException
      ? ((thrownValue = getSuspendedThenable()),
        (workInProgressSuspendedReason = 4))
      : (workInProgressSuspendedReason =
          thrownValue === SelectiveHydrationException
            ? 8
            : null !== thrownValue &&
                "object" === typeof thrownValue &&
                "function" === typeof thrownValue.then
              ? 6
              : 1);
  workInProgressThrownValue = thrownValue;
  null === workInProgress &&
    ((workInProgressRootExitStatus = 1),
    logUncaughtError(
      root,
      createCapturedValueAtFiber(thrownValue, root.current)
    ));
}
function pushDispatcher() {
  var prevDispatcher = ReactSharedInternals.H;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
}
function pushAsyncDispatcher() {
  var prevAsyncDispatcher = ReactSharedInternals.A;
  ReactSharedInternals.A = DefaultAsyncDispatcher;
  return prevAsyncDispatcher;
}
function renderDidSuspendDelayIfPossible() {
  workInProgressRootExitStatus = 4;
  workInProgressRootDidSkipSuspendedSiblings ||
    ((workInProgressRootRenderLanes & 4194176) !==
      workInProgressRootRenderLanes &&
      null !== suspenseHandlerStackCursor.current) ||
    (workInProgressRootIsPrerendering = !0);
  (0 === (workInProgressRootSkippedLanes & 134217727) &&
    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
    null === workInProgressRoot ||
    markRootSuspended(
      workInProgressRoot,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      !1
    );
}
function renderRootSync(root, lanes, shouldYieldForPrerendering) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
  lanes = !1;
  var exitStatus = workInProgressRootExitStatus;
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        var unitOfWork = workInProgress,
          thrownValue = workInProgressThrownValue;
        switch (workInProgressSuspendedReason) {
          case 8:
            resetWorkInProgressStack();
            exitStatus = 6;
            break a;
          case 3:
          case 2:
          case 6:
            null === suspenseHandlerStackCursor.current && (lanes = !0);
            var reason = workInProgressSuspendedReason;
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
            if (
              shouldYieldForPrerendering &&
              workInProgressRootIsPrerendering
            ) {
              exitStatus = 0;
              break a;
            }
            break;
          default:
            (reason = workInProgressSuspendedReason),
              (workInProgressSuspendedReason = 0),
              (workInProgressThrownValue = null),
              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
        }
      }
      workLoopSync();
      exitStatus = workInProgressRootExitStatus;
      break;
    } catch (thrownValue$164) {
      handleThrow(root, thrownValue$164);
    }
  while (1);
  lanes && root.shellSuspendCounter++;
  lastContextDependency = currentlyRenderingFiber = null;
  executionContext = prevExecutionContext;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  null === workInProgress &&
    ((workInProgressRoot = null),
    (workInProgressRootRenderLanes = 0),
    finishQueueingConcurrentUpdates());
  return exitStatus;
}
function workLoopSync() {
  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
}
function renderRootConcurrent(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
    ? ((workInProgressTransitions = null),
      (workInProgressRootRenderTargetTime = now() + 500),
      prepareFreshStack(root, lanes))
    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root,
        lanes
      ));
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        lanes = workInProgress;
        var thrownValue = workInProgressThrownValue;
        b: switch (workInProgressSuspendedReason) {
          case 1:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
            break;
          case 2:
            if (isThenableResolved(thrownValue)) {
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(lanes);
              break;
            }
            lanes = function () {
              2 === workInProgressSuspendedReason &&
                workInProgressRoot === root &&
                (workInProgressSuspendedReason = 7);
              ensureRootIsScheduled(root);
            };
            thrownValue.then(lanes, lanes);
            break a;
          case 3:
            workInProgressSuspendedReason = 7;
            break a;
          case 4:
            workInProgressSuspendedReason = 5;
            break a;
          case 7:
            isThenableResolved(thrownValue)
              ? ((workInProgressSuspendedReason = 0),
                (workInProgressThrownValue = null),
                replaySuspendedUnitOfWork(lanes))
              : ((workInProgressSuspendedReason = 0),
                (workInProgressThrownValue = null),
                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
            break;
          case 5:
            var resource = null;
            switch (workInProgress.tag) {
              case 26:
                resource = workInProgress.memoizedState;
              case 5:
              case 27:
                var hostFiber = workInProgress;
                if (resource ? preloadResource(resource) : 1) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  var sibling = hostFiber.sibling;
                  if (null !== sibling) workInProgress = sibling;
                  else {
                    var returnFiber = hostFiber.return;
                    null !== returnFiber
                      ? ((workInProgress = returnFiber),
                        completeUnitOfWork(returnFiber))
                      : (workInProgress = null);
                  }
                  break b;
                }
            }
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
            break;
          case 6:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
            break;
          case 8:
            resetWorkInProgressStack();
            workInProgressRootExitStatus = 6;
            break a;
          default:
            throw Error(formatProdErrorMessage(462));
        }
      }
      workLoopConcurrent();
      break;
    } catch (thrownValue$166) {
      handleThrow(root, thrownValue$166);
    }
  while (1);
  lastContextDependency = currentlyRenderingFiber = null;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  executionContext = prevExecutionContext;
  if (null !== workInProgress) return 0;
  workInProgressRoot = null;
  workInProgressRootRenderLanes = 0;
  finishQueueingConcurrentUpdates();
  return workInProgressRootExitStatus;
}
function workLoopConcurrent() {
  for (; null !== workInProgress && !shouldYield(); )
    performUnitOfWork(workInProgress);
}
function performUnitOfWork(unitOfWork) {
  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
}
function replaySuspendedUnitOfWork(unitOfWork) {
  var next = unitOfWork;
  var current = next.alternate;
  switch (next.tag) {
    case 15:
    case 0:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type,
        void 0,
        workInProgressRootRenderLanes
      );
      break;
    case 11:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type.render,
        next.ref,
        workInProgressRootRenderLanes
      );
      break;
    case 5:
      resetHooksOnUnwind(next);
    default:
      unwindInterruptedWork(current, next),
        (next = workInProgress =
          resetWorkInProgress(next, entangledRenderLanes)),
        (next = beginWork(current, next, entangledRenderLanes));
  }
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
}
function throwAndUnwindWorkLoop(
  root,
  unitOfWork,
  thrownValue,
  suspendedReason
) {
  lastContextDependency = currentlyRenderingFiber = null;
  resetHooksOnUnwind(unitOfWork);
  thenableState$1 = null;
  thenableIndexCounter$1 = 0;
  var returnFiber = unitOfWork.return;
  try {
    if (
      throwException(
        root,
        returnFiber,
        unitOfWork,
        thrownValue,
        workInProgressRootRenderLanes
      )
    ) {
      workInProgressRootExitStatus = 1;
      logUncaughtError(
        root,
        createCapturedValueAtFiber(thrownValue, root.current)
      );
      workInProgress = null;
      return;
    }
  } catch (error) {
    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
    workInProgressRootExitStatus = 1;
    logUncaughtError(
      root,
      createCapturedValueAtFiber(thrownValue, root.current)
    );
    workInProgress = null;
    return;
  }
  if (unitOfWork.flags & 32768) {
    if (isHydrating || 1 === suspendedReason) root = !0;
    else if (
      workInProgressRootIsPrerendering ||
      0 !== (workInProgressRootRenderLanes & 536870912)
    )
      root = !1;
    else if (
      ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
      2 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
    )
      (suspendedReason = suspenseHandlerStackCursor.current),
        null !== suspendedReason &&
          13 === suspendedReason.tag &&
          (suspendedReason.flags |= 16384);
    unwindUnitOfWork(unitOfWork, root);
  } else completeUnitOfWork(unitOfWork);
}
function completeUnitOfWork(unitOfWork) {
  var completedWork = unitOfWork;
  do {
    if (0 !== (completedWork.flags & 32768)) {
      unwindUnitOfWork(
        completedWork,
        workInProgressRootDidSkipSuspendedSiblings
      );
      return;
    }
    unitOfWork = completedWork.return;
    var next = completeWork(
      completedWork.alternate,
      completedWork,
      entangledRenderLanes
    );
    if (null !== next) {
      workInProgress = next;
      return;
    }
    completedWork = completedWork.sibling;
    if (null !== completedWork) {
      workInProgress = completedWork;
      return;
    }
    workInProgress = completedWork = unitOfWork;
  } while (null !== completedWork);
  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
}
function unwindUnitOfWork(unitOfWork, skipSiblings) {
  do {
    var next = unwindWork(unitOfWork.alternate, unitOfWork);
    if (null !== next) {
      next.flags &= 32767;
      workInProgress = next;
      return;
    }
    next = unitOfWork.return;
    null !== next &&
      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
    if (
      !skipSiblings &&
      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
    ) {
      workInProgress = unitOfWork;
      return;
    }
    workInProgress = unitOfWork = next;
  } while (null !== unitOfWork);
  workInProgressRootExitStatus = 6;
  workInProgress = null;
}
function commitRoot(
  root,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes,
  suspendedCommitReason,
  completedRenderStartTime,
  completedRenderEndTime
) {
  var prevTransition = ReactSharedInternals.T,
    previousUpdateLanePriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 2),
      (ReactSharedInternals.T = null),
      commitRootImpl(
        root,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        previousUpdateLanePriority,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes,
        suspendedCommitReason,
        completedRenderStartTime,
        completedRenderEndTime
      );
  } finally {
    (ReactSharedInternals.T = prevTransition),
      (ReactDOMSharedInternals.p = previousUpdateLanePriority);
  }
}
function commitRootImpl(
  root,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  renderPriorityLevel,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes
) {
  do flushPassiveEffects();
  while (null !== rootWithPendingPassiveEffects);
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  var finishedWork = root.finishedWork;
  didIncludeRenderPhaseUpdate = root.finishedLanes;
  if (null === finishedWork) return null;
  root.finishedWork = null;
  root.finishedLanes = 0;
  if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
  root.callbackNode = null;
  root.callbackPriority = 0;
  root.cancelPendingCommit = null;
  var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
  remainingLanes |= concurrentlyUpdatedLanes;
  markRootFinished(
    root,
    didIncludeRenderPhaseUpdate,
    remainingLanes,
    spawnedLane,
    updatedLanes,
    suspendedRetryLanes
  );
  root === workInProgressRoot &&
    ((workInProgress = workInProgressRoot = null),
    (workInProgressRootRenderLanes = 0));
  (0 === (finishedWork.subtreeFlags & 10256) &&
    0 === (finishedWork.flags & 10256)) ||
    rootDoesHavePassiveEffects ||
    ((rootDoesHavePassiveEffects = !0),
    (pendingPassiveEffectsRemainingLanes = remainingLanes),
    (pendingPassiveTransitions = transitions),
    scheduleCallback$1(NormalPriority$1, function () {
      flushPassiveEffects(!0);
      return null;
    }));
  transitions = 0 !== (finishedWork.flags & 15990);
  0 !== (finishedWork.subtreeFlags & 15990) || transitions
    ? ((transitions = ReactSharedInternals.T),
      (ReactSharedInternals.T = null),
      (spawnedLane = ReactDOMSharedInternals.p),
      (ReactDOMSharedInternals.p = 2),
      (updatedLanes = executionContext),
      (executionContext |= 4),
      commitBeforeMutationEffects(root, finishedWork),
      commitMutationEffectsOnFiber(finishedWork, root),
      restoreSelection(selectionInformation, root.containerInfo),
      (_enabled = !!eventsEnabled),
      (selectionInformation = eventsEnabled = null),
      (root.current = finishedWork),
      commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork),
      requestPaint(),
      (executionContext = updatedLanes),
      (ReactDOMSharedInternals.p = spawnedLane),
      (ReactSharedInternals.T = transitions))
    : (root.current = finishedWork);
  rootDoesHavePassiveEffects
    ? ((rootDoesHavePassiveEffects = !1),
      (rootWithPendingPassiveEffects = root),
      (pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate))
    : releaseRootPooledCache(root, remainingLanes);
  remainingLanes = root.pendingLanes;
  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
  ensureRootIsScheduled(root);
  if (null !== recoverableErrors)
    for (
      renderPriorityLevel = root.onRecoverableError, finishedWork = 0;
      finishedWork < recoverableErrors.length;
      finishedWork++
    )
      (remainingLanes = recoverableErrors[finishedWork]),
        renderPriorityLevel(remainingLanes.value, {
          componentStack: remainingLanes.stack
        });
  0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
  remainingLanes = root.pendingLanes;
  0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42)
    ? root === rootWithNestedUpdates
      ? nestedUpdateCount++
      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
    : (nestedUpdateCount = 0);
  flushSyncWorkAcrossRoots_impl(0, !1);
  return null;
}
function releaseRootPooledCache(root, remainingLanes) {
  0 === (root.pooledCacheLanes &= remainingLanes) &&
    ((remainingLanes = root.pooledCache),
    null != remainingLanes &&
      ((root.pooledCache = null), releaseCache(remainingLanes)));
}
function flushPassiveEffects() {
  if (null !== rootWithPendingPassiveEffects) {
    var root$170 = rootWithPendingPassiveEffects,
      remainingLanes = pendingPassiveEffectsRemainingLanes;
    pendingPassiveEffectsRemainingLanes = 0;
    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
      prevTransition = ReactSharedInternals.T,
      previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
      ReactSharedInternals.T = null;
      if (null === rootWithPendingPassiveEffects)
        var JSCompiler_inline_result = !1;
      else {
        renderPriority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root = rootWithPendingPassiveEffects,
          lanes = pendingPassiveEffectsLanes;
        rootWithPendingPassiveEffects = null;
        pendingPassiveEffectsLanes = 0;
        if (0 !== (executionContext & 6))
          throw Error(formatProdErrorMessage(331));
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        commitPassiveUnmountOnFiber(root.current);
        commitPassiveMountOnFiber(root, root.current, lanes, renderPriority);
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, !1);
        if (
          injectedHook &&
          "function" === typeof injectedHook.onPostCommitFiberRoot
        )
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root);
          } catch (err) {}
        JSCompiler_inline_result = !0;
      }
      return JSCompiler_inline_result;
    } finally {
      (ReactDOMSharedInternals.p = previousPriority),
        (ReactSharedInternals.T = prevTransition),
        releaseRootPooledCache(root$170, remainingLanes);
    }
  }
  return !1;
}
function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
  null !== rootFiber &&
    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
}
function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
  if (3 === sourceFiber.tag)
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
  else
    for (; null !== nearestMountedAncestor; ) {
      if (3 === nearestMountedAncestor.tag) {
        captureCommitPhaseErrorOnRoot(
          nearestMountedAncestor,
          sourceFiber,
          error
        );
        break;
      } else if (1 === nearestMountedAncestor.tag) {
        var instance = nearestMountedAncestor.stateNode;
        if (
          "function" ===
            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
          ("function" === typeof instance.componentDidCatch &&
            (null === legacyErrorBoundariesThatAlreadyFailed ||
              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
        ) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          error = createClassErrorUpdate(2);
          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
          null !== instance &&
            (initializeClassErrorUpdate(
              error,
              instance,
              nearestMountedAncestor,
              sourceFiber
            ),
            markRootUpdated$1(instance, 2),
            ensureRootIsScheduled(instance));
          break;
        }
      }
      nearestMountedAncestor = nearestMountedAncestor.return;
    }
}
function attachPingListener(root, wakeable, lanes) {
  var pingCache = root.pingCache;
  if (null === pingCache) {
    pingCache = root.pingCache = new PossiblyWeakMap();
    var threadIDs = new Set();
    pingCache.set(wakeable, threadIDs);
  } else
    (threadIDs = pingCache.get(wakeable)),
      void 0 === threadIDs &&
        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
  threadIDs.has(lanes) ||
    ((workInProgressRootDidAttachPingListener = !0),
    threadIDs.add(lanes),
    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
    wakeable.then(root, root));
}
function pingSuspendedRoot(root, wakeable, pingedLanes) {
  var pingCache = root.pingCache;
  null !== pingCache && pingCache.delete(wakeable);
  root.pingedLanes |= root.suspendedLanes & pingedLanes;
  root.warmLanes &= ~pingedLanes;
  workInProgressRoot === root &&
    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
    (4 === workInProgressRootExitStatus ||
    (3 === workInProgressRootExitStatus &&
      (workInProgressRootRenderLanes & 62914560) ===
        workInProgressRootRenderLanes &&
      300 > now() - globalMostRecentFallbackTime)
      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
      : (workInProgressRootPingedLanes |= pingedLanes),
    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
      (workInProgressSuspendedRetryLanes = 0));
  ensureRootIsScheduled(root);
}
function retryTimedOutBoundary(boundaryFiber, retryLane) {
  0 === retryLane && (retryLane = claimNextRetryLane());
  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
  null !== boundaryFiber &&
    (markRootUpdated$1(boundaryFiber, retryLane),
    ensureRootIsScheduled(boundaryFiber));
}
function retryDehydratedSuspenseBoundary(boundaryFiber) {
  var suspenseState = boundaryFiber.memoizedState,
    retryLane = 0;
  null !== suspenseState && (retryLane = suspenseState.retryLane);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = 0;
  switch (boundaryFiber.tag) {
    case 13:
      var retryCache = boundaryFiber.stateNode;
      var suspenseState = boundaryFiber.memoizedState;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      break;
    case 19:
      retryCache = boundaryFiber.stateNode;
      break;
    case 22:
      retryCache = boundaryFiber.stateNode._retryCache;
      break;
    default:
      throw Error(formatProdErrorMessage(314));
  }
  null !== retryCache && retryCache.delete(wakeable);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function scheduleCallback$1(priorityLevel, callback) {
  return scheduleCallback$3(priorityLevel, callback);
}
var firstScheduledRoot = null,
  lastScheduledRoot = null,
  didScheduleMicrotask = !1,
  mightHavePendingSyncWork = !1,
  isFlushingWork = !1,
  currentEventTransitionLane = 0;
function ensureRootIsScheduled(root) {
  root !== lastScheduledRoot &&
    null === root.next &&
    (null === lastScheduledRoot
      ? (firstScheduledRoot = lastScheduledRoot = root)
      : (lastScheduledRoot = lastScheduledRoot.next = root));
  mightHavePendingSyncWork = !0;
  didScheduleMicrotask ||
    ((didScheduleMicrotask = !0),
    scheduleImmediateTask(processRootScheduleInMicrotask));
}
function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
  if (!isFlushingWork && mightHavePendingSyncWork) {
    isFlushingWork = !0;
    do {
      var didPerformSomeWork = !1;
      for (var root$172 = firstScheduledRoot; null !== root$172; ) {
        if (!onlyLegacy)
          if (0 !== syncTransitionLanes) {
            var pendingLanes = root$172.pendingLanes;
            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
            else {
              var suspendedLanes = root$172.suspendedLanes,
                pingedLanes = root$172.pingedLanes;
              JSCompiler_inline_result =
                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
              JSCompiler_inline_result &=
                pendingLanes & ~(suspendedLanes & ~pingedLanes);
              JSCompiler_inline_result =
                JSCompiler_inline_result & 201326677
                  ? (JSCompiler_inline_result & 201326677) | 1
                  : JSCompiler_inline_result
                    ? JSCompiler_inline_result | 2
                    : 0;
            }
            0 !== JSCompiler_inline_result &&
              ((didPerformSomeWork = !0),
              performSyncWorkOnRoot(root$172, JSCompiler_inline_result));
          } else
            (JSCompiler_inline_result = workInProgressRootRenderLanes),
              (JSCompiler_inline_result = getNextLanes(
                root$172,
                root$172 === workInProgressRoot ? JSCompiler_inline_result : 0
              )),
              0 === (JSCompiler_inline_result & 3) ||
                checkIfRootIsPrerendering(root$172, JSCompiler_inline_result) ||
                ((didPerformSomeWork = !0),
                performSyncWorkOnRoot(root$172, JSCompiler_inline_result));
        root$172 = root$172.next;
      }
    } while (didPerformSomeWork);
    isFlushingWork = !1;
  }
}
function processRootScheduleInMicrotask() {
  mightHavePendingSyncWork = didScheduleMicrotask = !1;
  var syncTransitionLanes = 0;
  0 !== currentEventTransitionLane &&
    (shouldAttemptEagerTransition() &&
      (syncTransitionLanes = currentEventTransitionLane),
    (currentEventTransitionLane = 0));
  for (
    var currentTime = now(), prev = null, root = firstScheduledRoot;
    null !== root;

  ) {
    var next = root.next,
      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
    if (0 === nextLanes)
      (root.next = null),
        null === prev ? (firstScheduledRoot = next) : (prev.next = next),
        null === next && (lastScheduledRoot = prev);
    else if (
      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
    )
      mightHavePendingSyncWork = !0;
    root = next;
  }
  flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
}
function scheduleTaskForRootDuringMicrotask(root, currentTime) {
  for (
    var suspendedLanes = root.suspendedLanes,
      pingedLanes = root.pingedLanes,
      expirationTimes = root.expirationTimes,
      lanes = root.pendingLanes & -62914561;
    0 < lanes;

  ) {
    var index$5 = 31 - clz32(lanes),
      lane = 1 << index$5,
      expirationTime = expirationTimes[index$5];
    if (-1 === expirationTime) {
      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
        expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
    lanes &= ~lane;
  }
  currentTime = workInProgressRoot;
  suspendedLanes = workInProgressRootRenderLanes;
  suspendedLanes = getNextLanes(
    root,
    root === currentTime ? suspendedLanes : 0
  );
  pingedLanes = root.callbackNode;
  if (
    0 === suspendedLanes ||
    (root === currentTime && 2 === workInProgressSuspendedReason) ||
    null !== root.cancelPendingCommit
  )
    return (
      null !== pingedLanes &&
        null !== pingedLanes &&
        cancelCallback$1(pingedLanes),
      (root.callbackNode = null),
      (root.callbackPriority = 0)
    );
  if (
    0 === (suspendedLanes & 3) ||
    checkIfRootIsPrerendering(root, suspendedLanes)
  ) {
    currentTime = suspendedLanes & -suspendedLanes;
    if (currentTime === root.callbackPriority) return currentTime;
    null !== pingedLanes && cancelCallback$1(pingedLanes);
    switch (lanesToEventPriority(suspendedLanes)) {
      case 2:
      case 8:
        suspendedLanes = UserBlockingPriority;
        break;
      case 32:
        suspendedLanes = NormalPriority$1;
        break;
      case 268435456:
        suspendedLanes = IdlePriority;
        break;
      default:
        suspendedLanes = NormalPriority$1;
    }
    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
    root.callbackPriority = currentTime;
    root.callbackNode = suspendedLanes;
    return currentTime;
  }
  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
  root.callbackPriority = 2;
  root.callbackNode = null;
  return 2;
}
function performWorkOnRootViaSchedulerTask(root, didTimeout) {
  var originalCallbackNode = root.callbackNode;
  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
    return null;
  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0
  );
  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
  scheduleTaskForRootDuringMicrotask(root, now());
  return null != root.callbackNode && root.callbackNode === originalCallbackNode
    ? performWorkOnRootViaSchedulerTask.bind(null, root)
    : null;
}
function performSyncWorkOnRoot(root, lanes) {
  if (flushPassiveEffects()) return null;
  performWorkOnRoot(root, lanes, !0);
}
function scheduleImmediateTask(cb) {
  scheduleMicrotask(function () {
    0 !== (executionContext & 6)
      ? scheduleCallback$3(ImmediatePriority, cb)
      : cb();
  });
}
function requestTransitionLane() {
  0 === currentEventTransitionLane &&
    (currentEventTransitionLane = claimNextTransitionLane());
  return currentEventTransitionLane;
}
function coerceFormActionProp(actionProp) {
  return null == actionProp ||
    "symbol" === typeof actionProp ||
    "boolean" === typeof actionProp
    ? null
    : "function" === typeof actionProp
      ? actionProp
      : sanitizeURL("" + actionProp);
}
function createFormDataWithSubmitter(form, submitter) {
  var temp = submitter.ownerDocument.createElement("input");
  temp.name = submitter.name;
  temp.value = submitter.value;
  form.id && temp.setAttribute("form", form.id);
  submitter.parentNode.insertBefore(temp, submitter);
  form = new FormData(form);
  temp.parentNode.removeChild(temp);
  return form;
}
function extractEvents$1(
  dispatchQueue,
  domEventName,
  maybeTargetInst,
  nativeEvent,
  nativeEventTarget
) {
  if (
    "submit" === domEventName &&
    maybeTargetInst &&
    maybeTargetInst.stateNode === nativeEventTarget
  ) {
    var action = coerceFormActionProp(
        (nativeEventTarget[internalPropsKey] || null).action
      ),
      submitter = nativeEvent.submitter;
    submitter &&
      ((domEventName = (domEventName = submitter[internalPropsKey] || null)
        ? coerceFormActionProp(domEventName.formAction)
        : submitter.getAttribute("formAction")),
      null !== domEventName && ((action = domEventName), (submitter = null)));
    var event = new SyntheticEvent(
      "action",
      "action",
      null,
      nativeEvent,
      nativeEventTarget
    );
    dispatchQueue.push({
      event: event,
      listeners: [
        {
          instance: null,
          listener: function () {
            if (nativeEvent.defaultPrevented) {
              if (0 !== currentEventTransitionLane) {
                var formData = submitter
                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                  : new FormData(nativeEventTarget);
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  },
                  null,
                  formData
                );
              }
            } else
              "function" === typeof action &&
                (event.preventDefault(),
                (formData = submitter
                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                  : new FormData(nativeEventTarget)),
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  },
                  action,
                  formData
                ));
          },
          currentTarget: nativeEventTarget
        }
      ]
    });
  }
}
for (
  var i$jscomp$inline_1439 = 0;
  i$jscomp$inline_1439 < simpleEventPluginEvents.length;
  i$jscomp$inline_1439++
) {
  var eventName$jscomp$inline_1440 =
      simpleEventPluginEvents[i$jscomp$inline_1439],
    domEventName$jscomp$inline_1441 =
      eventName$jscomp$inline_1440.toLowerCase(),
    capitalizedEvent$jscomp$inline_1442 =
      eventName$jscomp$inline_1440[0].toUpperCase() +
      eventName$jscomp$inline_1440.slice(1);
  registerSimpleEvent(
    domEventName$jscomp$inline_1441,
    "on" + capitalizedEvent$jscomp$inline_1442
  );
}
registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
registerSimpleEvent(ANIMATION_START, "onAnimationStart");
registerSimpleEvent("dblclick", "onDoubleClick");
registerSimpleEvent("focusin", "onFocus");
registerSimpleEvent("focusout", "onBlur");
registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
registerSimpleEvent(TRANSITION_START, "onTransitionStart");
registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
registerTwoPhaseEvent(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
registerTwoPhaseEvent(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
registerTwoPhaseEvent("onBeforeInput", [
  "compositionend",
  "keypress",
  "textInput",
  "paste"
]);
registerTwoPhaseEvent(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var mediaEventTypes =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  nonDelegatedEvents = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle"
      .split(" ")
      .concat(mediaEventTypes)
  );
function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  eventSystemFlags = 0 !== (eventSystemFlags & 4);
  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i],
      event = _dispatchQueue$i.event;
    _dispatchQueue$i = _dispatchQueue$i.listeners;
    a: {
      var previousInstance = void 0;
      if (eventSystemFlags)
        for (
          var i$jscomp$0 = _dispatchQueue$i.length - 1;
          0 <= i$jscomp$0;
          i$jscomp$0--
        ) {
          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
            instance = _dispatchListeners$i.instance,
            currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
      else
        for (
          i$jscomp$0 = 0;
          i$jscomp$0 < _dispatchQueue$i.length;
          i$jscomp$0++
        ) {
          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
          instance = _dispatchListeners$i.instance;
          currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
    }
  }
}
function listenToNonDelegatedEvent(domEventName, targetElement) {
  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
  void 0 === JSCompiler_inline_result &&
    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =
      new Set());
  var listenerSetKey = domEventName + "__bubble";
  JSCompiler_inline_result.has(listenerSetKey) ||
    (addTrappedEventListener(targetElement, domEventName, 2, !1),
    JSCompiler_inline_result.add(listenerSetKey));
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  var eventSystemFlags = 0;
  isCapturePhaseListener && (eventSystemFlags |= 4);
  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener
  );
}
var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = !0;
    allNativeEvents.forEach(function (domEventName) {
      "selectionchange" !== domEventName &&
        (nonDelegatedEvents.has(domEventName) ||
          listenToNativeEvent(domEventName, !1, rootContainerElement),
        listenToNativeEvent(domEventName, !0, rootContainerElement));
    });
    var ownerDocument =
      9 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    null === ownerDocument ||
      ownerDocument[listeningMarker] ||
      ((ownerDocument[listeningMarker] = !0),
      listenToNativeEvent("selectionchange", !1, ownerDocument));
  }
}
function addTrappedEventListener(
  targetContainer,
  domEventName,
  eventSystemFlags,
  isCapturePhaseListener
) {
  switch (getEventPriority(domEventName)) {
    case 2:
      var listenerWrapper = dispatchDiscreteEvent;
      break;
    case 8:
      listenerWrapper = dispatchContinuousEvent;
      break;
    default:
      listenerWrapper = dispatchEvent;
  }
  eventSystemFlags = listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer
  );
  listenerWrapper = void 0;
  !passiveBrowserEventsSupported ||
    ("touchstart" !== domEventName &&
      "touchmove" !== domEventName &&
      "wheel" !== domEventName) ||
    (listenerWrapper = !0);
  isCapturePhaseListener
    ? void 0 !== listenerWrapper
      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: !0,
          passive: listenerWrapper
        })
      : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
    : void 0 !== listenerWrapper
      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        })
      : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
}
function dispatchEventForPluginEventSystem(
  domEventName,
  eventSystemFlags,
  nativeEvent,
  targetInst$jscomp$0,
  targetContainer
) {
  var ancestorInst = targetInst$jscomp$0;
  if (
    0 === (eventSystemFlags & 1) &&
    0 === (eventSystemFlags & 2) &&
    null !== targetInst$jscomp$0
  )
    a: for (;;) {
      if (null === targetInst$jscomp$0) return;
      var nodeTag = targetInst$jscomp$0.tag;
      if (3 === nodeTag || 4 === nodeTag) {
        var container = targetInst$jscomp$0.stateNode.containerInfo;
        if (
          container === targetContainer ||
          (8 === container.nodeType && container.parentNode === targetContainer)
        )
          break;
        if (4 === nodeTag)
          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
            var grandTag = nodeTag.tag;
            if (3 === grandTag || 4 === grandTag)
              if (
                ((grandTag = nodeTag.stateNode.containerInfo),
                grandTag === targetContainer ||
                  (8 === grandTag.nodeType &&
                    grandTag.parentNode === targetContainer))
              )
                return;
            nodeTag = nodeTag.return;
          }
        for (; null !== container; ) {
          nodeTag = getClosestInstanceFromNode(container);
          if (null === nodeTag) return;
          grandTag = nodeTag.tag;
          if (
            5 === grandTag ||
            6 === grandTag ||
            26 === grandTag ||
            27 === grandTag
          ) {
            targetInst$jscomp$0 = ancestorInst = nodeTag;
            continue a;
          }
          container = container.parentNode;
        }
      }
      targetInst$jscomp$0 = targetInst$jscomp$0.return;
    }
  batchedUpdates$1(function () {
    var targetInst = ancestorInst,
      nativeEventTarget = getEventTarget(nativeEvent),
      dispatchQueue = [];
    a: {
      var reactName = topLevelEventsToReactNames.get(domEventName);
      if (void 0 !== reactName) {
        var SyntheticEventCtor = SyntheticEvent,
          reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (0 === getEventCharCode(nativeEvent)) break a;
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (2 === nativeEvent.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
          case "scrollend":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
          case "toggle":
          case "beforetoggle":
            SyntheticEventCtor = SyntheticToggleEvent;
        }
        var inCapturePhase = 0 !== (eventSystemFlags & 4),
          accumulateTargetOnly =
            !inCapturePhase &&
            ("scroll" === domEventName || "scrollend" === domEventName),
          reactEventName = inCapturePhase
            ? null !== reactName
              ? reactName + "Capture"
              : null
            : reactName;
        inCapturePhase = [];
        for (
          var instance = targetInst, lastHostComponent;
          null !== instance;

        ) {
          var _instance = instance;
          lastHostComponent = _instance.stateNode;
          _instance = _instance.tag;
          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
            null === lastHostComponent ||
            null === reactEventName ||
            ((_instance = getListener(instance, reactEventName)),
            null != _instance &&
              inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
          if (accumulateTargetOnly) break;
          instance = instance.return;
        }
        0 < inCapturePhase.length &&
          ((reactName = new SyntheticEventCtor(
            reactName,
            reactEventType,
            null,
            nativeEvent,
            nativeEventTarget
          )),
          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
      }
    }
    if (0 === (eventSystemFlags & 7)) {
      a: {
        reactName =
          "mouseover" === domEventName || "pointerover" === domEventName;
        SyntheticEventCtor =
          "mouseout" === domEventName || "pointerout" === domEventName;
        if (
          reactName &&
          nativeEvent !== currentReplayingEvent &&
          (reactEventType =
            nativeEvent.relatedTarget || nativeEvent.fromElement) &&
          (getClosestInstanceFromNode(reactEventType) ||
            reactEventType[internalContainerInstanceKey])
        )
          break a;
        if (SyntheticEventCtor || reactName) {
          reactName =
            nativeEventTarget.window === nativeEventTarget
              ? nativeEventTarget
              : (reactName = nativeEventTarget.ownerDocument)
                ? reactName.defaultView || reactName.parentWindow
                : window;
          if (SyntheticEventCtor) {
            if (
              ((reactEventType =
                nativeEvent.relatedTarget || nativeEvent.toElement),
              (SyntheticEventCtor = targetInst),
              (reactEventType = reactEventType
                ? getClosestInstanceFromNode(reactEventType)
                : null),
              null !== reactEventType &&
                ((accumulateTargetOnly =
                  getNearestMountedFiber(reactEventType)),
                (inCapturePhase = reactEventType.tag),
                reactEventType !== accumulateTargetOnly ||
                  (5 !== inCapturePhase &&
                    27 !== inCapturePhase &&
                    6 !== inCapturePhase)))
            )
              reactEventType = null;
          } else (SyntheticEventCtor = null), (reactEventType = targetInst);
          if (SyntheticEventCtor !== reactEventType) {
            inCapturePhase = SyntheticMouseEvent;
            _instance = "onMouseLeave";
            reactEventName = "onMouseEnter";
            instance = "mouse";
            if ("pointerout" === domEventName || "pointerover" === domEventName)
              (inCapturePhase = SyntheticPointerEvent),
                (_instance = "onPointerLeave"),
                (reactEventName = "onPointerEnter"),
                (instance = "pointer");
            accumulateTargetOnly =
              null == SyntheticEventCtor
                ? reactName
                : getNodeFromInstance(SyntheticEventCtor);
            lastHostComponent =
              null == reactEventType
                ? reactName
                : getNodeFromInstance(reactEventType);
            reactName = new inCapturePhase(
              _instance,
              instance + "leave",
              SyntheticEventCtor,
              nativeEvent,
              nativeEventTarget
            );
            reactName.target = accumulateTargetOnly;
            reactName.relatedTarget = lastHostComponent;
            _instance = null;
            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
              ((inCapturePhase = new inCapturePhase(
                reactEventName,
                instance + "enter",
                reactEventType,
                nativeEvent,
                nativeEventTarget
              )),
              (inCapturePhase.target = lastHostComponent),
              (inCapturePhase.relatedTarget = accumulateTargetOnly),
              (_instance = inCapturePhase));
            accumulateTargetOnly = _instance;
            if (SyntheticEventCtor && reactEventType)
              b: {
                inCapturePhase = SyntheticEventCtor;
                reactEventName = reactEventType;
                instance = 0;
                for (
                  lastHostComponent = inCapturePhase;
                  lastHostComponent;
                  lastHostComponent = getParent(lastHostComponent)
                )
                  instance++;
                lastHostComponent = 0;
                for (
                  _instance = reactEventName;
                  _instance;
                  _instance = getParent(_instance)
                )
                  lastHostComponent++;
                for (; 0 < instance - lastHostComponent; )
                  (inCapturePhase = getParent(inCapturePhase)), instance--;
                for (; 0 < lastHostComponent - instance; )
                  (reactEventName = getParent(reactEventName)),
                    lastHostComponent--;
                for (; instance--; ) {
                  if (
                    inCapturePhase === reactEventName ||
                    (null !== reactEventName &&
                      inCapturePhase === reactEventName.alternate)
                  )
                    break b;
                  inCapturePhase = getParent(inCapturePhase);
                  reactEventName = getParent(reactEventName);
                }
                inCapturePhase = null;
              }
            else inCapturePhase = null;
            null !== SyntheticEventCtor &&
              accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                reactName,
                SyntheticEventCtor,
                inCapturePhase,
                !1
              );
            null !== reactEventType &&
              null !== accumulateTargetOnly &&
              accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                accumulateTargetOnly,
                reactEventType,
                inCapturePhase,
                !0
              );
          }
        }
      }
      a: {
        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
        SyntheticEventCtor =
          reactName.nodeName && reactName.nodeName.toLowerCase();
        if (
          "select" === SyntheticEventCtor ||
          ("input" === SyntheticEventCtor && "file" === reactName.type)
        )
          var getTargetInstFunc = getTargetInstForChangeEvent;
        else if (isTextInputElement(reactName))
          if (isInputEventSupported)
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            var handleEventFunc = handleEventsForInputEventPolyfill;
          }
        else
          (SyntheticEventCtor = reactName.nodeName),
            !SyntheticEventCtor ||
            "input" !== SyntheticEventCtor.toLowerCase() ||
            ("checkbox" !== reactName.type && "radio" !== reactName.type)
              ? targetInst &&
                isCustomElement(targetInst.elementType) &&
                (getTargetInstFunc = getTargetInstForChangeEvent)
              : (getTargetInstFunc = getTargetInstForClickEvent);
        if (
          getTargetInstFunc &&
          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
        ) {
          createAndAccumulateChangeEvent(
            dispatchQueue,
            getTargetInstFunc,
            nativeEvent,
            nativeEventTarget
          );
          break a;
        }
        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
        "focusout" === domEventName &&
          targetInst &&
          "number" === reactName.type &&
          null != targetInst.memoizedProps.value &&
          setDefaultValue(reactName, "number", reactName.value);
      }
      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
      switch (domEventName) {
        case "focusin":
          if (
            isTextInputElement(handleEventFunc) ||
            "true" === handleEventFunc.contentEditable
          )
            (activeElement = handleEventFunc),
              (activeElementInst = targetInst),
              (lastSelection = null);
          break;
        case "focusout":
          lastSelection = activeElementInst = activeElement = null;
          break;
        case "mousedown":
          mouseDown = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          mouseDown = !1;
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          break;
        case "selectionchange":
          if (skipSelectionChangeEvent) break;
        case "keydown":
        case "keyup":
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      }
      var fallbackData;
      if (canUseCompositionEvent)
        b: {
          switch (domEventName) {
            case "compositionstart":
              var eventType = "onCompositionStart";
              break b;
            case "compositionend":
              eventType = "onCompositionEnd";
              break b;
            case "compositionupdate":
              eventType = "onCompositionUpdate";
              break b;
          }
          eventType = void 0;
        }
      else
        isComposing
          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
            (eventType = "onCompositionEnd")
          : "keydown" === domEventName &&
            229 === nativeEvent.keyCode &&
            (eventType = "onCompositionStart");
      eventType &&
        (useFallbackCompositionData &&
          "ko" !== nativeEvent.locale &&
          (isComposing || "onCompositionStart" !== eventType
            ? "onCompositionEnd" === eventType &&
              isComposing &&
              (fallbackData = getData())
            : ((root = nativeEventTarget),
              (startText = "value" in root ? root.value : root.textContent),
              (isComposing = !0))),
        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),
        0 < handleEventFunc.length &&
          ((eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          )),
          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
          fallbackData
            ? (eventType.data = fallbackData)
            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
              null !== fallbackData && (eventType.data = fallbackData))));
      if (
        (fallbackData = canUseTextInputEvent
          ? getNativeBeforeInputChars(domEventName, nativeEvent)
          : getFallbackBeforeInputChars(domEventName, nativeEvent))
      )
        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),
          0 < eventType.length &&
            ((handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            )),
            dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }),
            (handleEventFunc.data = fallbackData));
      extractEvents$1(
        dispatchQueue,
        domEventName,
        targetInst,
        nativeEvent,
        nativeEventTarget
      );
    }
    processDispatchQueue(dispatchQueue, eventSystemFlags);
  });
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance: instance,
    listener: listener,
    currentTarget: currentTarget
  };
}
function accumulateTwoPhaseListeners(targetFiber, reactName) {
  for (
    var captureName = reactName + "Capture", listeners = [];
    null !== targetFiber;

  ) {
    var _instance2 = targetFiber,
      stateNode = _instance2.stateNode;
    _instance2 = _instance2.tag;
    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
      null === stateNode ||
      ((_instance2 = getListener(targetFiber, captureName)),
      null != _instance2 &&
        listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ),
      (_instance2 = getListener(targetFiber, reactName)),
      null != _instance2 &&
        listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
    targetFiber = targetFiber.return;
  }
  return listeners;
}
function getParent(inst) {
  if (null === inst) return null;
  do inst = inst.return;
  while (inst && 5 !== inst.tag && 27 !== inst.tag);
  return inst ? inst : null;
}
function accumulateEnterLeaveListenersForEvent(
  dispatchQueue,
  event,
  target,
  common,
  inCapturePhase
) {
  for (
    var registrationName = event._reactName, listeners = [];
    null !== target && target !== common;

  ) {
    var _instance3 = target,
      alternate = _instance3.alternate,
      stateNode = _instance3.stateNode;
    _instance3 = _instance3.tag;
    if (null !== alternate && alternate === common) break;
    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
      null === stateNode ||
      ((alternate = stateNode),
      inCapturePhase
        ? ((stateNode = getListener(target, registrationName)),
          null != stateNode &&
            listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            ))
        : inCapturePhase ||
          ((stateNode = getListener(target, registrationName)),
          null != stateNode &&
            listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
    target = target.return;
  }
  0 !== listeners.length &&
    dispatchQueue.push({ event: event, listeners: listeners });
}
var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
function normalizeMarkupForTextOrAttribute(markup) {
  return ("string" === typeof markup ? markup : "" + markup)
    .replace(NORMALIZE_NEWLINES_REGEX, "\n")
    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
}
function checkForUnmatchedText(serverText, clientText) {
  clientText = normalizeMarkupForTextOrAttribute(clientText);
  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
}
function noop$1() {}
function setProp(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "children":
      "string" === typeof value
        ? "body" === tag ||
          ("textarea" === tag && "" === value) ||
          setTextContent(domElement, value)
        : ("number" === typeof value || "bigint" === typeof value) &&
          "body" !== tag &&
          setTextContent(domElement, "" + value);
      break;
    case "className":
      setValueForKnownAttribute(domElement, "class", value);
      break;
    case "tabIndex":
      setValueForKnownAttribute(domElement, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      setValueForKnownAttribute(domElement, key, value);
      break;
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "data":
      if ("object" !== tag) {
        setValueForKnownAttribute(domElement, "data", value);
        break;
      }
    case "src":
    case "href":
      if ("" === value && ("a" !== tag || "href" !== key)) {
        domElement.removeAttribute(key);
        break;
      }
      if (
        null == value ||
        "function" === typeof value ||
        "symbol" === typeof value ||
        "boolean" === typeof value
      ) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "action":
    case "formAction":
      if ("function" === typeof value) {
        domElement.setAttribute(
          key,
          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
        );
        break;
      } else
        "function" === typeof prevValue &&
          ("formAction" === key
            ? ("input" !== tag &&
                setProp(domElement, tag, "name", props.name, props, null),
              setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ),
              setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ),
              setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              ))
            : (setProp(domElement, tag, "encType", props.encType, props, null),
              setProp(domElement, tag, "method", props.method, props, null),
              setProp(domElement, tag, "target", props.target, props, null)));
      if (
        null == value ||
        "symbol" === typeof value ||
        "boolean" === typeof value
      ) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "multiple":
      domElement.multiple =
        value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "muted":
      domElement.muted =
        value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      break;
    case "autoFocus":
      break;
    case "xlinkHref":
      if (
        null == value ||
        "function" === typeof value ||
        "boolean" === typeof value ||
        "symbol" === typeof value
      ) {
        domElement.removeAttribute("xlink:href");
        break;
      }
      key = sanitizeURL("" + value);
      domElement.setAttributeNS(
        "http://www.w3.org/1999/xlink",
        "xlink:href",
        key
      );
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      null != value && "function" !== typeof value && "symbol" !== typeof value
        ? domElement.setAttribute(key, "" + value)
        : domElement.removeAttribute(key);
      break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      value && "function" !== typeof value && "symbol" !== typeof value
        ? domElement.setAttribute(key, "")
        : domElement.removeAttribute(key);
      break;
    case "capture":
    case "download":
      !0 === value
        ? domElement.setAttribute(key, "")
        : !1 !== value &&
            null != value &&
            "function" !== typeof value &&
            "symbol" !== typeof value
          ? domElement.setAttribute(key, value)
          : domElement.removeAttribute(key);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      null != value &&
      "function" !== typeof value &&
      "symbol" !== typeof value &&
      !isNaN(value) &&
      1 <= value
        ? domElement.setAttribute(key, value)
        : domElement.removeAttribute(key);
      break;
    case "rowSpan":
    case "start":
      null == value ||
      "function" === typeof value ||
      "symbol" === typeof value ||
      isNaN(value)
        ? domElement.removeAttribute(key)
        : domElement.setAttribute(key, value);
      break;
    case "popover":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      setValueForAttribute(domElement, "popover", value);
      break;
    case "xlinkActuate":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:actuate",
        value
      );
      break;
    case "xlinkArcrole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:arcrole",
        value
      );
      break;
    case "xlinkRole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:role",
        value
      );
      break;
    case "xlinkShow":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:show",
        value
      );
      break;
    case "xlinkTitle":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:title",
        value
      );
      break;
    case "xlinkType":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:type",
        value
      );
      break;
    case "xmlBase":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:base",
        value
      );
      break;
    case "xmlLang":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:lang",
        value
      );
      break;
    case "xmlSpace":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:space",
        value
      );
      break;
    case "is":
      setValueForAttribute(domElement, "is", value);
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (
        !(2 < key.length) ||
        ("o" !== key[0] && "O" !== key[0]) ||
        ("n" !== key[1] && "N" !== key[1])
      )
        (key = aliases.get(key) || key),
          setValueForAttribute(domElement, key, value);
  }
}
function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "children":
      "string" === typeof value
        ? setTextContent(domElement, value)
        : ("number" === typeof value || "bigint" === typeof value) &&
          setTextContent(domElement, "" + value);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!registrationNameDependencies.hasOwnProperty(key))
        a: {
          if (
            "o" === key[0] &&
            "n" === key[1] &&
            ((props = key.endsWith("Capture")),
            (tag = key.slice(2, props ? key.length - 7 : void 0)),
            (prevValue = domElement[internalPropsKey] || null),
            (prevValue = null != prevValue ? prevValue[key] : null),
            "function" === typeof prevValue &&
              domElement.removeEventListener(tag, prevValue, props),
            "function" === typeof value)
          ) {
            "function" !== typeof prevValue &&
              null !== prevValue &&
              (key in domElement
                ? (domElement[key] = null)
                : domElement.hasAttribute(key) &&
                  domElement.removeAttribute(key));
            domElement.addEventListener(tag, value, props);
            break a;
          }
          key in domElement
            ? (domElement[key] = value)
            : !0 === value
              ? domElement.setAttribute(key, "")
              : setValueForAttribute(domElement, key, value);
        }
  }
}
function setInitialProperties(domElement, tag, props) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "img":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      var hasSrc = !1,
        hasSrcSet = !1,
        propKey;
      for (propKey in props)
        if (props.hasOwnProperty(propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "src":
                hasSrc = !0;
                break;
              case "srcSet":
                hasSrcSet = !0;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(formatProdErrorMessage(137, tag));
              default:
                setProp(domElement, tag, propKey, propValue, props, null);
            }
        }
      hasSrcSet &&
        setProp(domElement, tag, "srcSet", props.srcSet, props, null);
      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
      return;
    case "input":
      listenToNonDelegatedEvent("invalid", domElement);
      var defaultValue = (propKey = propValue = hasSrcSet = null),
        checked = null,
        defaultChecked = null;
      for (hasSrc in props)
        if (props.hasOwnProperty(hasSrc)) {
          var propValue$186 = props[hasSrc];
          if (null != propValue$186)
            switch (hasSrc) {
              case "name":
                hasSrcSet = propValue$186;
                break;
              case "type":
                propValue = propValue$186;
                break;
              case "checked":
                checked = propValue$186;
                break;
              case "defaultChecked":
                defaultChecked = propValue$186;
                break;
              case "value":
                propKey = propValue$186;
                break;
              case "defaultValue":
                defaultValue = propValue$186;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propValue$186)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                setProp(domElement, tag, hasSrc, propValue$186, props, null);
            }
        }
      initInput(
        domElement,
        propKey,
        defaultValue,
        checked,
        defaultChecked,
        propValue,
        hasSrcSet,
        !1
      );
      track(domElement);
      return;
    case "select":
      listenToNonDelegatedEvent("invalid", domElement);
      hasSrc = propValue = propKey = null;
      for (hasSrcSet in props)
        if (
          props.hasOwnProperty(hasSrcSet) &&
          ((defaultValue = props[hasSrcSet]), null != defaultValue)
        )
          switch (hasSrcSet) {
            case "value":
              propKey = defaultValue;
              break;
            case "defaultValue":
              propValue = defaultValue;
              break;
            case "multiple":
              hasSrc = defaultValue;
            default:
              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
          }
      tag = propKey;
      props = propValue;
      domElement.multiple = !!hasSrc;
      null != tag
        ? updateOptions(domElement, !!hasSrc, tag, !1)
        : null != props && updateOptions(domElement, !!hasSrc, props, !0);
      return;
    case "textarea":
      listenToNonDelegatedEvent("invalid", domElement);
      propKey = hasSrcSet = hasSrc = null;
      for (propValue in props)
        if (
          props.hasOwnProperty(propValue) &&
          ((defaultValue = props[propValue]), null != defaultValue)
        )
          switch (propValue) {
            case "value":
              hasSrc = defaultValue;
              break;
            case "defaultValue":
              hasSrcSet = defaultValue;
              break;
            case "children":
              propKey = defaultValue;
              break;
            case "dangerouslySetInnerHTML":
              if (null != defaultValue) throw Error(formatProdErrorMessage(91));
              break;
            default:
              setProp(domElement, tag, propValue, defaultValue, props, null);
          }
      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
      track(domElement);
      return;
    case "option":
      for (checked in props)
        if (
          props.hasOwnProperty(checked) &&
          ((hasSrc = props[checked]), null != hasSrc)
        )
          switch (checked) {
            case "selected":
              domElement.selected =
                hasSrc &&
                "function" !== typeof hasSrc &&
                "symbol" !== typeof hasSrc;
              break;
            default:
              setProp(domElement, tag, checked, hasSrc, props, null);
          }
      return;
    case "dialog":
      listenToNonDelegatedEvent("cancel", domElement);
      listenToNonDelegatedEvent("close", domElement);
      break;
    case "iframe":
    case "object":
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "video":
    case "audio":
      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
      break;
    case "image":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", domElement);
      break;
    case "embed":
    case "source":
    case "link":
      listenToNonDelegatedEvent("error", domElement),
        listenToNonDelegatedEvent("load", domElement);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
      for (defaultChecked in props)
        if (
          props.hasOwnProperty(defaultChecked) &&
          ((hasSrc = props[defaultChecked]), null != hasSrc)
        )
          switch (defaultChecked) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(137, tag));
            default:
              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (propValue$186 in props)
          props.hasOwnProperty(propValue$186) &&
            ((hasSrc = props[propValue$186]),
            void 0 !== hasSrc &&
              setPropOnCustomElement(
                domElement,
                tag,
                propValue$186,
                hasSrc,
                props,
                void 0
              ));
        return;
      }
  }
  for (defaultValue in props)
    props.hasOwnProperty(defaultValue) &&
      ((hasSrc = props[defaultValue]),
      null != hasSrc &&
        setProp(domElement, tag, defaultValue, hasSrc, props, null));
}
function updateProperties(domElement, tag, lastProps, nextProps) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "input":
      var name = null,
        type = null,
        value = null,
        defaultValue = null,
        lastDefaultValue = null,
        checked = null,
        defaultChecked = null;
      for (propKey in lastProps) {
        var lastProp = lastProps[propKey];
        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
          switch (propKey) {
            case "checked":
              break;
            case "value":
              break;
            case "defaultValue":
              lastDefaultValue = lastProp;
            default:
              nextProps.hasOwnProperty(propKey) ||
                setProp(domElement, tag, propKey, null, nextProps, lastProp);
          }
      }
      for (var propKey$203 in nextProps) {
        var propKey = nextProps[propKey$203];
        lastProp = lastProps[propKey$203];
        if (
          nextProps.hasOwnProperty(propKey$203) &&
          (null != propKey || null != lastProp)
        )
          switch (propKey$203) {
            case "type":
              type = propKey;
              break;
            case "name":
              name = propKey;
              break;
            case "checked":
              checked = propKey;
              break;
            case "defaultChecked":
              defaultChecked = propKey;
              break;
            case "value":
              value = propKey;
              break;
            case "defaultValue":
              defaultValue = propKey;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              propKey !== lastProp &&
                setProp(
                  domElement,
                  tag,
                  propKey$203,
                  propKey,
                  nextProps,
                  lastProp
                );
          }
      }
      updateInput(
        domElement,
        value,
        defaultValue,
        lastDefaultValue,
        checked,
        defaultChecked,
        type,
        name
      );
      return;
    case "select":
      propKey = value = defaultValue = propKey$203 = null;
      for (type in lastProps)
        if (
          ((lastDefaultValue = lastProps[type]),
          lastProps.hasOwnProperty(type) && null != lastDefaultValue)
        )
          switch (type) {
            case "value":
              break;
            case "multiple":
              propKey = lastDefaultValue;
            default:
              nextProps.hasOwnProperty(type) ||
                setProp(
                  domElement,
                  tag,
                  type,
                  null,
                  nextProps,
                  lastDefaultValue
                );
          }
      for (name in nextProps)
        if (
          ((type = nextProps[name]),
          (lastDefaultValue = lastProps[name]),
          nextProps.hasOwnProperty(name) &&
            (null != type || null != lastDefaultValue))
        )
          switch (name) {
            case "value":
              propKey$203 = type;
              break;
            case "defaultValue":
              defaultValue = type;
              break;
            case "multiple":
              value = type;
            default:
              type !== lastDefaultValue &&
                setProp(
                  domElement,
                  tag,
                  name,
                  type,
                  nextProps,
                  lastDefaultValue
                );
          }
      tag = defaultValue;
      lastProps = value;
      nextProps = propKey;
      null != propKey$203
        ? updateOptions(domElement, !!lastProps, propKey$203, !1)
        : !!nextProps !== !!lastProps &&
          (null != tag
            ? updateOptions(domElement, !!lastProps, tag, !0)
            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
      return;
    case "textarea":
      propKey = propKey$203 = null;
      for (defaultValue in lastProps)
        if (
          ((name = lastProps[defaultValue]),
          lastProps.hasOwnProperty(defaultValue) &&
            null != name &&
            !nextProps.hasOwnProperty(defaultValue))
        )
          switch (defaultValue) {
            case "value":
              break;
            case "children":
              break;
            default:
              setProp(domElement, tag, defaultValue, null, nextProps, name);
          }
      for (value in nextProps)
        if (
          ((name = nextProps[value]),
          (type = lastProps[value]),
          nextProps.hasOwnProperty(value) && (null != name || null != type))
        )
          switch (value) {
            case "value":
              propKey$203 = name;
              break;
            case "defaultValue":
              propKey = name;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (null != name) throw Error(formatProdErrorMessage(91));
              break;
            default:
              name !== type &&
                setProp(domElement, tag, value, name, nextProps, type);
          }
      updateTextarea(domElement, propKey$203, propKey);
      return;
    case "option":
      for (var propKey$219 in lastProps)
        if (
          ((propKey$203 = lastProps[propKey$219]),
          lastProps.hasOwnProperty(propKey$219) &&
            null != propKey$203 &&
            !nextProps.hasOwnProperty(propKey$219))
        )
          switch (propKey$219) {
            case "selected":
              domElement.selected = !1;
              break;
            default:
              setProp(
                domElement,
                tag,
                propKey$219,
                null,
                nextProps,
                propKey$203
              );
          }
      for (lastDefaultValue in nextProps)
        if (
          ((propKey$203 = nextProps[lastDefaultValue]),
          (propKey = lastProps[lastDefaultValue]),
          nextProps.hasOwnProperty(lastDefaultValue) &&
            propKey$203 !== propKey &&
            (null != propKey$203 || null != propKey))
        )
          switch (lastDefaultValue) {
            case "selected":
              domElement.selected =
                propKey$203 &&
                "function" !== typeof propKey$203 &&
                "symbol" !== typeof propKey$203;
              break;
            default:
              setProp(
                domElement,
                tag,
                lastDefaultValue,
                propKey$203,
                nextProps,
                propKey
              );
          }
      return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
      for (var propKey$224 in lastProps)
        (propKey$203 = lastProps[propKey$224]),
          lastProps.hasOwnProperty(propKey$224) &&
            null != propKey$203 &&
            !nextProps.hasOwnProperty(propKey$224) &&
            setProp(domElement, tag, propKey$224, null, nextProps, propKey$203);
      for (checked in nextProps)
        if (
          ((propKey$203 = nextProps[checked]),
          (propKey = lastProps[checked]),
          nextProps.hasOwnProperty(checked) &&
            propKey$203 !== propKey &&
            (null != propKey$203 || null != propKey))
        )
          switch (checked) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey$203)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              setProp(
                domElement,
                tag,
                checked,
                propKey$203,
                nextProps,
                propKey
              );
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (var propKey$229 in lastProps)
          (propKey$203 = lastProps[propKey$229]),
            lastProps.hasOwnProperty(propKey$229) &&
              void 0 !== propKey$203 &&
              !nextProps.hasOwnProperty(propKey$229) &&
              setPropOnCustomElement(
                domElement,
                tag,
                propKey$229,
                void 0,
                nextProps,
                propKey$203
              );
        for (defaultChecked in nextProps)
          (propKey$203 = nextProps[defaultChecked]),
            (propKey = lastProps[defaultChecked]),
            !nextProps.hasOwnProperty(defaultChecked) ||
              propKey$203 === propKey ||
              (void 0 === propKey$203 && void 0 === propKey) ||
              setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$203,
                nextProps,
                propKey
              );
        return;
      }
  }
  for (var propKey$234 in lastProps)
    (propKey$203 = lastProps[propKey$234]),
      lastProps.hasOwnProperty(propKey$234) &&
        null != propKey$203 &&
        !nextProps.hasOwnProperty(propKey$234) &&
        setProp(domElement, tag, propKey$234, null, nextProps, propKey$203);
  for (lastProp in nextProps)
    (propKey$203 = nextProps[lastProp]),
      (propKey = lastProps[lastProp]),
      !nextProps.hasOwnProperty(lastProp) ||
        propKey$203 === propKey ||
        (null == propKey$203 && null == propKey) ||
        setProp(domElement, tag, lastProp, propKey$203, nextProps, propKey);
}
var eventsEnabled = null,
  selectionInformation = null;
function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return 9 === rootContainerElement.nodeType
    ? rootContainerElement
    : rootContainerElement.ownerDocument;
}
function getOwnHostContext(namespaceURI) {
  switch (namespaceURI) {
    case "http://www.w3.org/2000/svg":
      return 1;
    case "http://www.w3.org/1998/Math/MathML":
      return 2;
    default:
      return 0;
  }
}
function getChildHostContextProd(parentNamespace, type) {
  if (0 === parentNamespace)
    switch (type) {
      case "svg":
        return 1;
      case "math":
        return 2;
      default:
        return 0;
    }
  return 1 === parentNamespace && "foreignObject" === type
    ? 0
    : parentNamespace;
}
function shouldSetTextContent(type, props) {
  return (
    "textarea" === type ||
    "noscript" === type ||
    "string" === typeof props.children ||
    "number" === typeof props.children ||
    "bigint" === typeof props.children ||
    ("object" === typeof props.dangerouslySetInnerHTML &&
      null !== props.dangerouslySetInnerHTML &&
      null != props.dangerouslySetInnerHTML.__html)
  );
}
var currentPopstateTransitionEvent = null;
function shouldAttemptEagerTransition() {
  var event = window.event;
  if (event && "popstate" === event.type) {
    if (event === currentPopstateTransitionEvent) return !1;
    currentPopstateTransitionEvent = event;
    return !0;
  }
  currentPopstateTransitionEvent = null;
  return !1;
}
var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
  localPromise = "function" === typeof Promise ? Promise : void 0,
  scheduleMicrotask =
    "function" === typeof queueMicrotask
      ? queueMicrotask
      : "undefined" !== typeof localPromise
        ? function (callback) {
            return localPromise
              .resolve(null)
              .then(callback)
              .catch(handleErrorInNextTick);
          }
        : scheduleTimeout;
function handleErrorInNextTick(error) {
  setTimeout(function () {
    throw error;
  });
}
function clearSuspenseBoundary(parentInstance, suspenseInstance) {
  var node = suspenseInstance,
    depth = 0;
  do {
    var nextNode = node.nextSibling;
    parentInstance.removeChild(node);
    if (nextNode && 8 === nextNode.nodeType)
      if (((node = nextNode.data), "/$" === node)) {
        if (0 === depth) {
          parentInstance.removeChild(nextNode);
          retryIfBlockedOn(suspenseInstance);
          return;
        }
        depth--;
      } else ("$" !== node && "$?" !== node && "$!" !== node) || depth++;
    node = nextNode;
  } while (node);
  retryIfBlockedOn(suspenseInstance);
}
function clearContainerSparingly(container) {
  var nextNode = container.firstChild;
  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
  for (; nextNode; ) {
    var node = nextNode;
    nextNode = nextNode.nextSibling;
    switch (node.nodeName) {
      case "HTML":
      case "HEAD":
      case "BODY":
        clearContainerSparingly(node);
        detachDeletedInstance(node);
        continue;
      case "SCRIPT":
      case "STYLE":
        continue;
      case "LINK":
        if ("stylesheet" === node.rel.toLowerCase()) continue;
    }
    container.removeChild(node);
  }
}
function canHydrateInstance(instance, type, props, inRootOrSingleton) {
  for (; 1 === instance.nodeType; ) {
    var anyProps = props;
    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
      if (
        !inRootOrSingleton &&
        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
      )
        break;
    } else if (!inRootOrSingleton)
      if ("input" === type && "hidden" === instance.type) {
        var name = null == anyProps.name ? null : "" + anyProps.name;
        if (
          "hidden" === anyProps.type &&
          instance.getAttribute("name") === name
        )
          return instance;
      } else return instance;
    else if (!instance[internalHoistableMarker])
      switch (type) {
        case "meta":
          if (!instance.hasAttribute("itemprop")) break;
          return instance;
        case "link":
          name = instance.getAttribute("rel");
          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
            break;
          else if (
            name !== anyProps.rel ||
            instance.getAttribute("href") !==
              (null == anyProps.href ? null : anyProps.href) ||
            instance.getAttribute("crossorigin") !==
              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||
            instance.getAttribute("title") !==
              (null == anyProps.title ? null : anyProps.title)
          )
            break;
          return instance;
        case "style":
          if (instance.hasAttribute("data-precedence")) break;
          return instance;
        case "script":
          name = instance.getAttribute("src");
          if (
            (name !== (null == anyProps.src ? null : anyProps.src) ||
              instance.getAttribute("type") !==
                (null == anyProps.type ? null : anyProps.type) ||
              instance.getAttribute("crossorigin") !==
                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&
            name &&
            instance.hasAttribute("async") &&
            !instance.hasAttribute("itemprop")
          )
            break;
          return instance;
        default:
          return instance;
      }
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) break;
  }
  return null;
}
function canHydrateTextInstance(instance, text, inRootOrSingleton) {
  if ("" === text) return null;
  for (; 3 !== instance.nodeType; ) {
    if (
      (1 !== instance.nodeType ||
        "INPUT" !== instance.nodeName ||
        "hidden" !== instance.type) &&
      !inRootOrSingleton
    )
      return null;
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) return null;
  }
  return instance;
}
function getNextHydratable(node) {
  for (; null != node; node = node.nextSibling) {
    var nodeType = node.nodeType;
    if (1 === nodeType || 3 === nodeType) break;
    if (8 === nodeType) {
      nodeType = node.data;
      if (
        "$" === nodeType ||
        "$!" === nodeType ||
        "$?" === nodeType ||
        "F!" === nodeType ||
        "F" === nodeType
      )
        break;
      if ("/$" === nodeType) return null;
    }
  }
  return node;
}
function getParentSuspenseInstance(targetInstance) {
  targetInstance = targetInstance.previousSibling;
  for (var depth = 0; targetInstance; ) {
    if (8 === targetInstance.nodeType) {
      var data = targetInstance.data;
      if ("$" === data || "$!" === data || "$?" === data) {
        if (0 === depth) return targetInstance;
        depth--;
      } else "/$" === data && depth++;
    }
    targetInstance = targetInstance.previousSibling;
  }
  return null;
}
function resolveSingletonInstance(type, props, rootContainerInstance) {
  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
  switch (type) {
    case "html":
      type = props.documentElement;
      if (!type) throw Error(formatProdErrorMessage(452));
      return type;
    case "head":
      type = props.head;
      if (!type) throw Error(formatProdErrorMessage(453));
      return type;
    case "body":
      type = props.body;
      if (!type) throw Error(formatProdErrorMessage(454));
      return type;
    default:
      throw Error(formatProdErrorMessage(451));
  }
}
var preloadPropsMap = new Map(),
  preconnectsSet = new Set();
function getHoistableRoot(container) {
  return "function" === typeof container.getRootNode
    ? container.getRootNode()
    : container.ownerDocument;
}
var previousDispatcher = ReactDOMSharedInternals.d;
ReactDOMSharedInternals.d = {
  f: flushSyncWork,
  r: requestFormReset,
  D: prefetchDNS,
  C: preconnect,
  L: preload,
  m: preloadModule,
  X: preinitScript,
  S: preinitStyle,
  M: preinitModuleScript
};
function flushSyncWork() {
  var previousWasRendering = previousDispatcher.f(),
    wasRendering = flushSyncWork$1();
  return previousWasRendering || wasRendering;
}
function requestFormReset(form) {
  var formInst = getInstanceFromNode(form);
  null !== formInst && 5 === formInst.tag && "form" === formInst.type
    ? requestFormReset$1(formInst)
    : previousDispatcher.r(form);
}
var globalDocument = "undefined" === typeof document ? null : document;
function preconnectAs(rel, href, crossOrigin) {
  var ownerDocument = globalDocument;
  if (ownerDocument && "string" === typeof href && href) {
    var limitedEscapedHref =
      escapeSelectorAttributeValueInsideDoubleQuotes(href);
    limitedEscapedHref =
      'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
    "string" === typeof crossOrigin &&
      (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
    preconnectsSet.has(limitedEscapedHref) ||
      (preconnectsSet.add(limitedEscapedHref),
      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
      null === ownerDocument.querySelector(limitedEscapedHref) &&
        ((href = ownerDocument.createElement("link")),
        setInitialProperties(href, "link", rel),
        markNodeAsHoistable(href),
        ownerDocument.head.appendChild(href)));
  }
}
function prefetchDNS(href) {
  previousDispatcher.D(href);
  preconnectAs("dns-prefetch", href, null);
}
function preconnect(href, crossOrigin) {
  previousDispatcher.C(href, crossOrigin);
  preconnectAs("preconnect", href, crossOrigin);
}
function preload(href, as, options) {
  previousDispatcher.L(href, as, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href && as) {
    var preloadSelector =
      'link[rel="preload"][as="' +
      escapeSelectorAttributeValueInsideDoubleQuotes(as) +
      '"]';
    "image" === as
      ? options && options.imageSrcSet
        ? ((preloadSelector +=
            '[imagesrcset="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(
              options.imageSrcSet
            ) +
            '"]'),
          "string" === typeof options.imageSizes &&
            (preloadSelector +=
              '[imagesizes="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) +
              '"]'))
        : (preloadSelector +=
            '[href="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
            '"]')
      : (preloadSelector +=
          '[href="' +
          escapeSelectorAttributeValueInsideDoubleQuotes(href) +
          '"]');
    var key = preloadSelector;
    switch (as) {
      case "style":
        key = getStyleKey(href);
        break;
      case "script":
        key = getScriptKey(href);
    }
    preloadPropsMap.has(key) ||
      ((href = assign(
        {
          rel: "preload",
          href:
            "image" === as && options && options.imageSrcSet ? void 0 : href,
          as: as
        },
        options
      )),
      preloadPropsMap.set(key, href),
      null !== ownerDocument.querySelector(preloadSelector) ||
        ("style" === as &&
          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
        ("script" === as &&
          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
        ((as = ownerDocument.createElement("link")),
        setInitialProperties(as, "link", href),
        markNodeAsHoistable(as),
        ownerDocument.head.appendChild(as)));
  }
}
function preloadModule(href, options) {
  previousDispatcher.m(href, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var as = options && "string" === typeof options.as ? options.as : "script",
      preloadSelector =
        'link[rel="modulepreload"][as="' +
        escapeSelectorAttributeValueInsideDoubleQuotes(as) +
        '"][href="' +
        escapeSelectorAttributeValueInsideDoubleQuotes(href) +
        '"]',
      key = preloadSelector;
    switch (as) {
      case "audioworklet":
      case "paintworklet":
      case "serviceworker":
      case "sharedworker":
      case "worker":
      case "script":
        key = getScriptKey(href);
    }
    if (
      !preloadPropsMap.has(key) &&
      ((href = assign({ rel: "modulepreload", href: href }, options)),
      preloadPropsMap.set(key, href),
      null === ownerDocument.querySelector(preloadSelector))
    ) {
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
            return;
      }
      as = ownerDocument.createElement("link");
      setInitialProperties(as, "link", href);
      markNodeAsHoistable(as);
      ownerDocument.head.appendChild(as);
    }
  }
}
function preinitStyle(href, precedence, options) {
  previousDispatcher.S(href, precedence, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
      key = getStyleKey(href);
    precedence = precedence || "default";
    var resource = styles.get(key);
    if (!resource) {
      var state = { loading: 0, preload: null };
      if (
        (resource = ownerDocument.querySelector(
          getStylesheetSelectorFromKey(key)
        ))
      )
        state.loading = 5;
      else {
        href = assign(
          { rel: "stylesheet", href: href, "data-precedence": precedence },
          options
        );
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForStylesheet(href, options);
        var link = (resource = ownerDocument.createElement("link"));
        markNodeAsHoistable(link);
        setInitialProperties(link, "link", href);
        link._p = new Promise(function (resolve, reject) {
          link.onload = resolve;
          link.onerror = reject;
        });
        link.addEventListener("load", function () {
          state.loading |= 1;
        });
        link.addEventListener("error", function () {
          state.loading |= 2;
        });
        state.loading |= 4;
        insertStylesheet(resource, precedence, ownerDocument);
      }
      resource = {
        type: "stylesheet",
        instance: resource,
        count: 1,
        state: state
      };
      styles.set(key, resource);
    }
  }
}
function preinitScript(src, options) {
  previousDispatcher.X(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource ||
      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
      resource ||
        ((src = assign({ src: src, async: !0 }, options)),
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForScript(src, options),
        (resource = ownerDocument.createElement("script")),
        markNodeAsHoistable(resource),
        setInitialProperties(resource, "link", src),
        ownerDocument.head.appendChild(resource)),
      (resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }),
      scripts.set(key, resource));
  }
}
function preinitModuleScript(src, options) {
  previousDispatcher.M(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource ||
      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
      resource ||
        ((src = assign({ src: src, async: !0, type: "module" }, options)),
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForScript(src, options),
        (resource = ownerDocument.createElement("script")),
        markNodeAsHoistable(resource),
        setInitialProperties(resource, "link", src),
        ownerDocument.head.appendChild(resource)),
      (resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }),
      scripts.set(key, resource));
  }
}
function getResource(type, currentProps, pendingProps, currentResource) {
  var JSCompiler_inline_result = (JSCompiler_inline_result =
    rootInstanceStackCursor.current)
    ? getHoistableRoot(JSCompiler_inline_result)
    : null;
  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
  switch (type) {
    case "meta":
    case "title":
      return null;
    case "style":
      return "string" === typeof pendingProps.precedence &&
        "string" === typeof pendingProps.href
        ? ((currentProps = getStyleKey(pendingProps.href)),
          (pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles),
          (currentResource = pendingProps.get(currentProps)),
          currentResource ||
            ((currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }),
            pendingProps.set(currentProps, currentResource)),
          currentResource)
        : { type: "void", instance: null, count: 0, state: null };
    case "link":
      if (
        "stylesheet" === pendingProps.rel &&
        "string" === typeof pendingProps.href &&
        "string" === typeof pendingProps.precedence
      ) {
        type = getStyleKey(pendingProps.href);
        var styles$242 = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles,
          resource$243 = styles$242.get(type);
        resource$243 ||
          ((JSCompiler_inline_result =
            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
          (resource$243 = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }),
          styles$242.set(type, resource$243),
          (styles$242 = JSCompiler_inline_result.querySelector(
            getStylesheetSelectorFromKey(type)
          )) &&
            !styles$242._p &&
            ((resource$243.instance = styles$242),
            (resource$243.state.loading = 5)),
          preloadPropsMap.has(type) ||
            ((pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }),
            preloadPropsMap.set(type, pendingProps),
            styles$242 ||
              preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$243.state
              )));
        if (currentProps && null === currentResource)
          throw Error(formatProdErrorMessage(528, ""));
        return resource$243;
      }
      if (currentProps && null !== currentResource)
        throw Error(formatProdErrorMessage(529, ""));
      return null;
    case "script":
      return (
        (currentProps = pendingProps.async),
        (pendingProps = pendingProps.src),
        "string" === typeof pendingProps &&
        currentProps &&
        "function" !== typeof currentProps &&
        "symbol" !== typeof currentProps
          ? ((currentProps = getScriptKey(pendingProps)),
            (pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts),
            (currentResource = pendingProps.get(currentProps)),
            currentResource ||
              ((currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }),
              pendingProps.set(currentProps, currentResource)),
            currentResource)
          : { type: "void", instance: null, count: 0, state: null }
      );
    default:
      throw Error(formatProdErrorMessage(444, type));
  }
}
function getStyleKey(href) {
  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
}
function getStylesheetSelectorFromKey(key) {
  return 'link[rel="stylesheet"][' + key + "]";
}
function stylesheetPropsFromRawProps(rawProps) {
  return assign({}, rawProps, {
    "data-precedence": rawProps.precedence,
    precedence: null
  });
}
function preloadStylesheet(ownerDocument, key, preloadProps, state) {
  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]")
    ? (state.loading = 1)
    : ((key = ownerDocument.createElement("link")),
      (state.preload = key),
      key.addEventListener("load", function () {
        return (state.loading |= 1);
      }),
      key.addEventListener("error", function () {
        return (state.loading |= 2);
      }),
      setInitialProperties(key, "link", preloadProps),
      markNodeAsHoistable(key),
      ownerDocument.head.appendChild(key));
}
function getScriptKey(src) {
  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
}
function getScriptSelectorFromKey(key) {
  return "script[async]" + key;
}
function acquireResource(hoistableRoot, resource, props) {
  resource.count++;
  if (null === resource.instance)
    switch (resource.type) {
      case "style":
        var instance = hoistableRoot.querySelector(
          'style[data-href~="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
            '"]'
        );
        if (instance)
          return (
            (resource.instance = instance),
            markNodeAsHoistable(instance),
            instance
          );
        var styleProps = assign({}, props, {
          "data-href": props.href,
          "data-precedence": props.precedence,
          href: null,
          precedence: null
        });
        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
          "style"
        );
        markNodeAsHoistable(instance);
        setInitialProperties(instance, "style", styleProps);
        insertStylesheet(instance, props.precedence, hoistableRoot);
        return (resource.instance = instance);
      case "stylesheet":
        styleProps = getStyleKey(props.href);
        var instance$248 = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(styleProps)
        );
        if (instance$248)
          return (
            (resource.state.loading |= 4),
            (resource.instance = instance$248),
            markNodeAsHoistable(instance$248),
            instance$248
          );
        instance = stylesheetPropsFromRawProps(props);
        (styleProps = preloadPropsMap.get(styleProps)) &&
          adoptPreloadPropsForStylesheet(instance, styleProps);
        instance$248 = (
          hoistableRoot.ownerDocument || hoistableRoot
        ).createElement("link");
        markNodeAsHoistable(instance$248);
        var linkInstance = instance$248;
        linkInstance._p = new Promise(function (resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance$248, "link", instance);
        resource.state.loading |= 4;
        insertStylesheet(instance$248, props.precedence, hoistableRoot);
        return (resource.instance = instance$248);
      case "script":
        instance$248 = getScriptKey(props.src);
        if (
          (styleProps = hoistableRoot.querySelector(
            getScriptSelectorFromKey(instance$248)
          ))
        )
          return (
            (resource.instance = styleProps),
            markNodeAsHoistable(styleProps),
            styleProps
          );
        instance = props;
        if ((styleProps = preloadPropsMap.get(instance$248)))
          (instance = assign({}, props)),
            adoptPreloadPropsForScript(instance, styleProps);
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        styleProps = hoistableRoot.createElement("script");
        markNodeAsHoistable(styleProps);
        setInitialProperties(styleProps, "link", instance);
        hoistableRoot.head.appendChild(styleProps);
        return (resource.instance = styleProps);
      case "void":
        return null;
      default:
        throw Error(formatProdErrorMessage(443, resource.type));
    }
  else
    "stylesheet" === resource.type &&
      0 === (resource.state.loading & 4) &&
      ((instance = resource.instance),
      (resource.state.loading |= 4),
      insertStylesheet(instance, props.precedence, hoistableRoot));
  return resource.instance;
}
function insertStylesheet(instance, precedence, root) {
  for (
    var nodes = root.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ),
      last = nodes.length ? nodes[nodes.length - 1] : null,
      prior = last,
      i = 0;
    i < nodes.length;
    i++
  ) {
    var node = nodes[i];
    if (node.dataset.precedence === precedence) prior = node;
    else if (prior !== last) break;
  }
  prior
    ? prior.parentNode.insertBefore(instance, prior.nextSibling)
    : ((precedence = 9 === root.nodeType ? root.head : root),
      precedence.insertBefore(instance, precedence.firstChild));
}
function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
  null == stylesheetProps.crossOrigin &&
    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
  null == stylesheetProps.referrerPolicy &&
    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
}
function adoptPreloadPropsForScript(scriptProps, preloadProps) {
  null == scriptProps.crossOrigin &&
    (scriptProps.crossOrigin = preloadProps.crossOrigin);
  null == scriptProps.referrerPolicy &&
    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
  null == scriptProps.integrity &&
    (scriptProps.integrity = preloadProps.integrity);
}
var tagCaches = null;
function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
  if (null === tagCaches) {
    var cache = new Map();
    var caches = (tagCaches = new Map());
    caches.set(ownerDocument, cache);
  } else
    (caches = tagCaches),
      (cache = caches.get(ownerDocument)),
      cache || ((cache = new Map()), caches.set(ownerDocument, cache));
  if (cache.has(type)) return cache;
  cache.set(type, null);
  ownerDocument = ownerDocument.getElementsByTagName(type);
  for (caches = 0; caches < ownerDocument.length; caches++) {
    var node = ownerDocument[caches];
    if (
      !(
        node[internalHoistableMarker] ||
        node[internalInstanceKey] ||
        ("link" === type && "stylesheet" === node.getAttribute("rel"))
      ) &&
      "http://www.w3.org/2000/svg" !== node.namespaceURI
    ) {
      var nodeKey = node.getAttribute(keyAttribute) || "";
      nodeKey = type + nodeKey;
      var existing = cache.get(nodeKey);
      existing ? existing.push(node) : cache.set(nodeKey, [node]);
    }
  }
  return cache;
}
function mountHoistable(hoistableRoot, type, instance) {
  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
  hoistableRoot.head.insertBefore(
    instance,
    "title" === type ? hoistableRoot.querySelector("head > title") : null
  );
}
function isHostHoistableType(type, props, hostContext) {
  if (1 === hostContext || null != props.itemProp) return !1;
  switch (type) {
    case "meta":
    case "title":
      return !0;
    case "style":
      if (
        "string" !== typeof props.precedence ||
        "string" !== typeof props.href ||
        "" === props.href
      )
        break;
      return !0;
    case "link":
      if (
        "string" !== typeof props.rel ||
        "string" !== typeof props.href ||
        "" === props.href ||
        props.onLoad ||
        props.onError
      )
        break;
      switch (props.rel) {
        case "stylesheet":
          return (
            (type = props.disabled),
            "string" === typeof props.precedence && null == type
          );
        default:
          return !0;
      }
    case "script":
      if (
        props.async &&
        "function" !== typeof props.async &&
        "symbol" !== typeof props.async &&
        !props.onLoad &&
        !props.onError &&
        props.src &&
        "string" === typeof props.src
      )
        return !0;
  }
  return !1;
}
function preloadResource(resource) {
  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)
    ? !1
    : !0;
}
var suspendedState = null;
function noop() {}
function suspendResource(hoistableRoot, resource, props) {
  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
  var state = suspendedState;
  if (
    "stylesheet" === resource.type &&
    ("string" !== typeof props.media ||
      !1 !== matchMedia(props.media).matches) &&
    0 === (resource.state.loading & 4)
  ) {
    if (null === resource.instance) {
      var key = getStyleKey(props.href),
        instance = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(key)
        );
      if (instance) {
        hoistableRoot = instance._p;
        null !== hoistableRoot &&
          "object" === typeof hoistableRoot &&
          "function" === typeof hoistableRoot.then &&
          (state.count++,
          (state = onUnsuspend.bind(state)),
          hoistableRoot.then(state, state));
        resource.state.loading |= 4;
        resource.instance = instance;
        markNodeAsHoistable(instance);
        return;
      }
      instance = hoistableRoot.ownerDocument || hoistableRoot;
      props = stylesheetPropsFromRawProps(props);
      (key = preloadPropsMap.get(key)) &&
        adoptPreloadPropsForStylesheet(props, key);
      instance = instance.createElement("link");
      markNodeAsHoistable(instance);
      var linkInstance = instance;
      linkInstance._p = new Promise(function (resolve, reject) {
        linkInstance.onload = resolve;
        linkInstance.onerror = reject;
      });
      setInitialProperties(instance, "link", props);
      resource.instance = instance;
    }
    null === state.stylesheets && (state.stylesheets = new Map());
    state.stylesheets.set(resource, hoistableRoot);
    (hoistableRoot = resource.state.preload) &&
      0 === (resource.state.loading & 3) &&
      (state.count++,
      (resource = onUnsuspend.bind(state)),
      hoistableRoot.addEventListener("load", resource),
      hoistableRoot.addEventListener("error", resource));
  }
}
function waitForCommitToBeReady() {
  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
  var state = suspendedState;
  state.stylesheets &&
    0 === state.count &&
    insertSuspendedStylesheets(state, state.stylesheets);
  return 0 < state.count
    ? function (commit) {
        var stylesheetTimer = setTimeout(function () {
          state.stylesheets &&
            insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4);
        state.unsuspend = commit;
        return function () {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
        };
      }
    : null;
}
function onUnsuspend() {
  this.count--;
  if (0 === this.count)
    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
    else if (this.unsuspend) {
      var unsuspend = this.unsuspend;
      this.unsuspend = null;
      unsuspend();
    }
}
var precedencesByRoot = null;
function insertSuspendedStylesheets(state, resources) {
  state.stylesheets = null;
  null !== state.unsuspend &&
    (state.count++,
    (precedencesByRoot = new Map()),
    resources.forEach(insertStylesheetIntoRoot, state),
    (precedencesByRoot = null),
    onUnsuspend.call(state));
}
function insertStylesheetIntoRoot(root, resource) {
  if (!(resource.state.loading & 4)) {
    var precedences = precedencesByRoot.get(root);
    if (precedences) var last = precedences.get(null);
    else {
      precedences = new Map();
      precedencesByRoot.set(root, precedences);
      for (
        var nodes = root.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ),
          i = 0;
        i < nodes.length;
        i++
      ) {
        var node = nodes[i];
        if (
          "LINK" === node.nodeName ||
          "not all" !== node.getAttribute("media")
        )
          precedences.set(node.dataset.precedence, node), (last = node);
      }
      last && precedences.set(null, last);
    }
    nodes = resource.instance;
    node = nodes.getAttribute("data-precedence");
    i = precedences.get(node) || last;
    i === last && precedences.set(null, nodes);
    precedences.set(node, nodes);
    this.count++;
    last = onUnsuspend.bind(this);
    nodes.addEventListener("load", last);
    nodes.addEventListener("error", last);
    i
      ? i.parentNode.insertBefore(nodes, i.nextSibling)
      : ((root = 9 === root.nodeType ? root.head : root),
        root.insertBefore(nodes, root.firstChild));
    resource.state.loading |= 4;
  }
}
var HostTransitionContext = {
  $$typeof: REACT_CONTEXT_TYPE,
  Provider: null,
  Consumer: null,
  _currentValue: sharedNotPendingObject,
  _currentValue2: sharedNotPendingObject,
  _threadCount: 0
};
function FiberRootNode(
  containerInfo,
  tag,
  hydrate,
  identifierPrefix,
  onUncaughtError,
  onCaughtError,
  onRecoverableError,
  formState
) {
  this.tag = 1;
  this.containerInfo = containerInfo;
  this.finishedWork =
    this.pingCache =
    this.current =
    this.pendingChildren =
      null;
  this.timeoutHandle = -1;
  this.callbackNode =
    this.next =
    this.pendingContext =
    this.context =
    this.cancelPendingCommit =
      null;
  this.callbackPriority = 0;
  this.expirationTimes = createLaneMap(-1);
  this.entangledLanes =
    this.shellSuspendCounter =
    this.errorRecoveryDisabledLanes =
    this.finishedLanes =
    this.expiredLanes =
    this.warmLanes =
    this.pingedLanes =
    this.suspendedLanes =
    this.pendingLanes =
      0;
  this.entanglements = createLaneMap(0);
  this.hiddenUpdates = createLaneMap(null);
  this.identifierPrefix = identifierPrefix;
  this.onUncaughtError = onUncaughtError;
  this.onCaughtError = onCaughtError;
  this.onRecoverableError = onRecoverableError;
  this.pooledCache = null;
  this.pooledCacheLanes = 0;
  this.formState = formState;
  this.incompleteTransitions = new Map();
}
function createFiberRoot(
  containerInfo,
  tag,
  hydrate,
  initialChildren,
  hydrationCallbacks,
  isStrictMode,
  identifierPrefix,
  onUncaughtError,
  onCaughtError,
  onRecoverableError,
  transitionCallbacks,
  formState
) {
  containerInfo = new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    formState
  );
  tag = 1;
  !0 === isStrictMode && (tag |= 24);
  isStrictMode = createFiberImplClass(3, null, null, tag);
  containerInfo.current = isStrictMode;
  isStrictMode.stateNode = containerInfo;
  tag = createCache();
  tag.refCount++;
  containerInfo.pooledCache = tag;
  tag.refCount++;
  isStrictMode.memoizedState = {
    element: initialChildren,
    isDehydrated: hydrate,
    cache: tag
  };
  initializeUpdateQueue(isStrictMode);
  return containerInfo;
}
function getContextForSubtree(parentComponent) {
  if (!parentComponent) return emptyContextObject;
  parentComponent = emptyContextObject;
  return parentComponent;
}
function updateContainerImpl(
  rootFiber,
  lane,
  element,
  container,
  parentComponent,
  callback
) {
  parentComponent = getContextForSubtree(parentComponent);
  null === container.context
    ? (container.context = parentComponent)
    : (container.pendingContext = parentComponent);
  container = createUpdate(lane);
  container.payload = { element: element };
  callback = void 0 === callback ? null : callback;
  null !== callback && (container.callback = callback);
  element = enqueueUpdate(rootFiber, container, lane);
  null !== element &&
    (scheduleUpdateOnFiber(element, rootFiber, lane),
    entangleTransitions(element, rootFiber, lane));
}
function markRetryLaneImpl(fiber, retryLane) {
  fiber = fiber.memoizedState;
  if (null !== fiber && null !== fiber.dehydrated) {
    var a = fiber.retryLane;
    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
  }
}
function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
}
function attemptContinuousHydration(fiber) {
  if (13 === fiber.tag) {
    var root = enqueueConcurrentRenderForLane(fiber, 67108864);
    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
    markRetryLaneIfNotHydrated(fiber, 67108864);
  }
}
var _enabled = !0;
function dispatchDiscreteEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 2),
      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function dispatchContinuousEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 8),
      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function dispatchEvent(
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (_enabled) {
    var blockedOn = findInstanceBlockingEvent(nativeEvent);
    if (null === blockedOn)
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        return_targetInst,
        targetContainer
      ),
        clearIfContinuousEvent(domEventName, nativeEvent);
    else if (
      queueIfContinuousEvent(
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      )
    )
      nativeEvent.stopPropagation();
    else if (
      (clearIfContinuousEvent(domEventName, nativeEvent),
      eventSystemFlags & 4 &&
        -1 < discreteReplayableEvents.indexOf(domEventName))
    ) {
      for (; null !== blockedOn; ) {
        var fiber = getInstanceFromNode(blockedOn);
        if (null !== fiber)
          switch (fiber.tag) {
            case 3:
              fiber = fiber.stateNode;
              if (fiber.current.memoizedState.isDehydrated) {
                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                if (0 !== lanes) {
                  var root = fiber;
                  root.pendingLanes |= 2;
                  for (root.entangledLanes |= 2; lanes; ) {
                    var lane = 1 << (31 - clz32(lanes));
                    root.entanglements[1] |= lane;
                    lanes &= ~lane;
                  }
                  ensureRootIsScheduled(fiber);
                  0 === (executionContext & 6) &&
                    ((workInProgressRootRenderTargetTime = now() + 500),
                    flushSyncWorkAcrossRoots_impl(0, !1));
                }
              }
              break;
            case 13:
              (root = enqueueConcurrentRenderForLane(fiber, 2)),
                null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                flushSyncWork$1(),
                markRetryLaneIfNotHydrated(fiber, 2);
          }
        fiber = findInstanceBlockingEvent(nativeEvent);
        null === fiber &&
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          );
        if (fiber === blockedOn) break;
        blockedOn = fiber;
      }
      null !== blockedOn && nativeEvent.stopPropagation();
    } else
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        null,
        targetContainer
      );
  }
}
function findInstanceBlockingEvent(nativeEvent) {
  nativeEvent = getEventTarget(nativeEvent);
  return findInstanceBlockingTarget(nativeEvent);
}
var return_targetInst = null;
function findInstanceBlockingTarget(targetNode) {
  return_targetInst = null;
  targetNode = getClosestInstanceFromNode(targetNode);
  if (null !== targetNode) {
    var nearestMounted = getNearestMountedFiber(targetNode);
    if (null === nearestMounted) targetNode = null;
    else {
      var tag = nearestMounted.tag;
      if (13 === tag) {
        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
        if (null !== targetNode) return targetNode;
        targetNode = null;
      } else if (3 === tag) {
        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
          return 3 === nearestMounted.tag
            ? nearestMounted.stateNode.containerInfo
            : null;
        targetNode = null;
      } else nearestMounted !== targetNode && (targetNode = null);
    }
  }
  return_targetInst = targetNode;
  return null;
}
function getEventPriority(domEventName) {
  switch (domEventName) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 8;
    case "message":
      switch (getCurrentPriorityLevel()) {
        case ImmediatePriority:
          return 2;
        case UserBlockingPriority:
          return 8;
        case NormalPriority$1:
        case LowPriority:
          return 32;
        case IdlePriority:
          return 268435456;
        default:
          return 32;
      }
    default:
      return 32;
  }
}
var hasScheduledReplayAttempt = !1,
  queuedFocus = null,
  queuedDrag = null,
  queuedMouse = null,
  queuedPointers = new Map(),
  queuedPointerCaptures = new Map(),
  queuedExplicitHydrationTargets = [],
  discreteReplayableEvents =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case "focusin":
    case "focusout":
      queuedFocus = null;
      break;
    case "dragenter":
    case "dragleave":
      queuedDrag = null;
      break;
    case "mouseover":
    case "mouseout":
      queuedMouse = null;
      break;
    case "pointerover":
    case "pointerout":
      queuedPointers.delete(nativeEvent.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      queuedPointerCaptures.delete(nativeEvent.pointerId);
  }
}
function accumulateOrCreateContinuousQueuedReplayableEvent(
  existingQueuedEvent,
  blockedOn,
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (
    null === existingQueuedEvent ||
    existingQueuedEvent.nativeEvent !== nativeEvent
  )
    return (
      (existingQueuedEvent = {
        blockedOn: blockedOn,
        domEventName: domEventName,
        eventSystemFlags: eventSystemFlags,
        nativeEvent: nativeEvent,
        targetContainers: [targetContainer]
      }),
      null !== blockedOn &&
        ((blockedOn = getInstanceFromNode(blockedOn)),
        null !== blockedOn && attemptContinuousHydration(blockedOn)),
      existingQueuedEvent
    );
  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  blockedOn = existingQueuedEvent.targetContainers;
  null !== targetContainer &&
    -1 === blockedOn.indexOf(targetContainer) &&
    blockedOn.push(targetContainer);
  return existingQueuedEvent;
}
function queueIfContinuousEvent(
  blockedOn,
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  switch (domEventName) {
    case "focusin":
      return (
        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedFocus,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "dragenter":
      return (
        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedDrag,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "mouseover":
      return (
        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedMouse,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "pointerover":
      var pointerId = nativeEvent.pointerId;
      queuedPointers.set(
        pointerId,
        accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedPointers.get(pointerId) || null,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )
      );
      return !0;
    case "gotpointercapture":
      return (
        (pointerId = nativeEvent.pointerId),
        queuedPointerCaptures.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointerCaptures.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        ),
        !0
      );
  }
  return !1;
}
function attemptExplicitHydrationTarget(queuedTarget) {
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
  if (null !== targetInst) {
    var nearestMounted = getNearestMountedFiber(targetInst);
    if (null !== nearestMounted)
      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
        if (
          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
          null !== targetInst)
        ) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function () {
            if (13 === nearestMounted.tag) {
              var lane = requestUpdateLane(),
                root = enqueueConcurrentRenderForLane(nearestMounted, lane);
              null !== root &&
                scheduleUpdateOnFiber(root, nearestMounted, lane);
              markRetryLaneIfNotHydrated(nearestMounted, lane);
            }
          });
          return;
        }
      } else if (
        3 === targetInst &&
        nearestMounted.stateNode.current.memoizedState.isDehydrated
      ) {
        queuedTarget.blockedOn =
          3 === nearestMounted.tag
            ? nearestMounted.stateNode.containerInfo
            : null;
        return;
      }
  }
  queuedTarget.blockedOn = null;
}
function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (null !== queuedEvent.blockedOn) return !1;
  for (
    var targetContainers = queuedEvent.targetContainers;
    0 < targetContainers.length;

  ) {
    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
    if (null === nextBlockedOn) {
      nextBlockedOn = queuedEvent.nativeEvent;
      var nativeEventClone = new nextBlockedOn.constructor(
        nextBlockedOn.type,
        nextBlockedOn
      );
      currentReplayingEvent = nativeEventClone;
      nextBlockedOn.target.dispatchEvent(nativeEventClone);
      currentReplayingEvent = null;
    } else
      return (
        (targetContainers = getInstanceFromNode(nextBlockedOn)),
        null !== targetContainers &&
          attemptContinuousHydration(targetContainers),
        (queuedEvent.blockedOn = nextBlockedOn),
        !1
      );
    targetContainers.shift();
  }
  return !0;
}
function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
}
function replayUnblockedEvents() {
  hasScheduledReplayAttempt = !1;
  null !== queuedFocus &&
    attemptReplayContinuousQueuedEvent(queuedFocus) &&
    (queuedFocus = null);
  null !== queuedDrag &&
    attemptReplayContinuousQueuedEvent(queuedDrag) &&
    (queuedDrag = null);
  null !== queuedMouse &&
    attemptReplayContinuousQueuedEvent(queuedMouse) &&
    (queuedMouse = null);
  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}
function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  queuedEvent.blockedOn === unblocked &&
    ((queuedEvent.blockedOn = null),
    hasScheduledReplayAttempt ||
      ((hasScheduledReplayAttempt = !0),
      Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
}
var lastScheduledReplayQueue = null;
function scheduleReplayQueueIfNeeded(formReplayingQueue) {
  lastScheduledReplayQueue !== formReplayingQueue &&
    ((lastScheduledReplayQueue = formReplayingQueue),
    Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      function () {
        lastScheduledReplayQueue === formReplayingQueue &&
          (lastScheduledReplayQueue = null);
        for (var i = 0; i < formReplayingQueue.length; i += 3) {
          var form = formReplayingQueue[i],
            submitterOrAction = formReplayingQueue[i + 1],
            formData = formReplayingQueue[i + 2];
          if ("function" !== typeof submitterOrAction)
            if (null === findInstanceBlockingTarget(submitterOrAction || form))
              continue;
            else break;
          var formInst = getInstanceFromNode(form);
          null !== formInst &&
            (formReplayingQueue.splice(i, 3),
            (i -= 3),
            startHostTransition(
              formInst,
              {
                pending: !0,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
        }
      }
    ));
}
function retryIfBlockedOn(unblocked) {
  function unblock(queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  }
  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);
  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
    var queuedTarget = queuedExplicitHydrationTargets[i];
    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
  }
  for (
    ;
    0 < queuedExplicitHydrationTargets.length &&
    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

  )
    attemptExplicitHydrationTarget(i),
      null === i.blockedOn && queuedExplicitHydrationTargets.shift();
  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
  if (null != i)
    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
      var form = i[queuedTarget],
        submitterOrAction = i[queuedTarget + 1],
        formProps = form[internalPropsKey] || null;
      if ("function" === typeof submitterOrAction)
        formProps || scheduleReplayQueueIfNeeded(i);
      else if (formProps) {
        var action = null;
        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
          if (
            ((form = submitterOrAction),
            (formProps = submitterOrAction[internalPropsKey] || null))
          )
            action = formProps.formAction;
          else {
            if (null !== findInstanceBlockingTarget(form)) continue;
          }
        else action = formProps.action;
        "function" === typeof action
          ? (i[queuedTarget + 1] = action)
          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
        scheduleReplayQueueIfNeeded(i);
      }
    }
}
function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
  function (children) {
    var root = this._internalRoot;
    if (null === root) throw Error(formatProdErrorMessage(409));
    var current = root.current,
      lane = requestUpdateLane();
    updateContainerImpl(current, lane, children, root, null, null);
  };
ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
  function () {
    var root = this._internalRoot;
    if (null !== root) {
      this._internalRoot = null;
      var container = root.containerInfo;
      0 === root.tag && flushPassiveEffects();
      updateContainerImpl(root.current, 2, null, root, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
function ReactDOMHydrationRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
  if (target) {
    var updatePriority = resolveUpdatePriority();
    target = { blockedOn: null, target: target, priority: updatePriority };
    for (
      var i = 0;
      i < queuedExplicitHydrationTargets.length &&
      0 !== updatePriority &&
      updatePriority < queuedExplicitHydrationTargets[i].priority;
      i++
    );
    queuedExplicitHydrationTargets.splice(i, 0, target);
    0 === i && attemptExplicitHydrationTarget(target);
  }
};
var isomorphicReactPackageVersion$jscomp$inline_1686 = React.version;
if (
  "19.0.0" !==
  isomorphicReactPackageVersion$jscomp$inline_1686
)
  throw Error(
    formatProdErrorMessage(
      527,
      isomorphicReactPackageVersion$jscomp$inline_1686,
      "19.0.0"
    )
  );
ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
  var fiber = componentOrElement._reactInternals;
  if (void 0 === fiber) {
    if ("function" === typeof componentOrElement.render)
      throw Error(formatProdErrorMessage(188));
    componentOrElement = Object.keys(componentOrElement).join(",");
    throw Error(formatProdErrorMessage(268, componentOrElement));
  }
  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
  componentOrElement =
    null !== componentOrElement
      ? findCurrentHostFiberImpl(componentOrElement)
      : null;
  componentOrElement =
    null === componentOrElement ? null : componentOrElement.stateNode;
  return componentOrElement;
};
var internals$jscomp$inline_2165 = {
  bundleType: 0,
  version: "19.0.0",
  rendererPackageName: "react-dom",
  currentDispatcherRef: ReactSharedInternals,
  findFiberByHostInstance: getClosestInstanceFromNode,
  reconcilerVersion: "19.0.0"
};
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var hook$jscomp$inline_2166 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (
    !hook$jscomp$inline_2166.isDisabled &&
    hook$jscomp$inline_2166.supportsFiber
  )
    try {
      (rendererID = hook$jscomp$inline_2166.inject(
        internals$jscomp$inline_2165
      )),
        (injectedHook = hook$jscomp$inline_2166);
    } catch (err) {}
}
exports.createRoot = function (container, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError,
    transitionCallbacks = null;
  null !== options &&
    void 0 !== options &&
    (!0 === options.unstable_strictMode && (isStrictMode = !0),
    void 0 !== options.identifierPrefix &&
      (identifierPrefix = options.identifierPrefix),
    void 0 !== options.onUncaughtError &&
      (onUncaughtError = options.onUncaughtError),
    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
    void 0 !== options.onRecoverableError &&
      (onRecoverableError = options.onRecoverableError),
    void 0 !== options.unstable_transitionCallbacks &&
      (transitionCallbacks = options.unstable_transitionCallbacks));
  options = createFiberRoot(
    container,
    1,
    !1,
    null,
    null,
    isStrictMode,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    transitionCallbacks,
    null
  );
  container[internalContainerInstanceKey] = options.current;
  listenToAllSupportedEvents(
    8 === container.nodeType ? container.parentNode : container
  );
  return new ReactDOMRoot(options);
};
__webpack_unused_export__ = function (container, initialChildren, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError,
    transitionCallbacks = null,
    formState = null;
  null !== options &&
    void 0 !== options &&
    (!0 === options.unstable_strictMode && (isStrictMode = !0),
    void 0 !== options.identifierPrefix &&
      (identifierPrefix = options.identifierPrefix),
    void 0 !== options.onUncaughtError &&
      (onUncaughtError = options.onUncaughtError),
    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
    void 0 !== options.onRecoverableError &&
      (onRecoverableError = options.onRecoverableError),
    void 0 !== options.unstable_transitionCallbacks &&
      (transitionCallbacks = options.unstable_transitionCallbacks),
    void 0 !== options.formState && (formState = options.formState));
  initialChildren = createFiberRoot(
    container,
    1,
    !0,
    initialChildren,
    null != options ? options : null,
    isStrictMode,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    transitionCallbacks,
    formState
  );
  initialChildren.context = getContextForSubtree(null);
  options = initialChildren.current;
  isStrictMode = requestUpdateLane();
  identifierPrefix = createUpdate(isStrictMode);
  identifierPrefix.callback = null;
  enqueueUpdate(options, identifierPrefix, isStrictMode);
  initialChildren.current.lanes = isStrictMode;
  markRootUpdated$1(initialChildren, isStrictMode);
  ensureRootIsScheduled(initialChildren);
  container[internalContainerInstanceKey] = initialChildren.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMHydrationRoot(initialChildren);
};
__webpack_unused_export__ = "19.0.0";


/***/ }),

/***/ 221:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var React = __webpack_require__(540);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return (
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
function noop() {}
var Internals = {
    d: {
      f: noop,
      r: function () {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  },
  REACT_PORTAL_TYPE = Symbol.for("react.portal");
function createPortal$1(children, containerInfo, implementation) {
  var key =
    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE,
    key: null == key ? null : "" + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}
var ReactSharedInternals =
  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
function getCrossOriginStringAs(as, input) {
  if ("font" === as) return "";
  if ("string" === typeof input)
    return "use-credentials" === input ? input : "";
}
exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
  Internals;
exports.createPortal = function (children, container) {
  var key =
    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (
    !container ||
    (1 !== container.nodeType &&
      9 !== container.nodeType &&
      11 !== container.nodeType)
  )
    throw Error(formatProdErrorMessage(299));
  return createPortal$1(children, container, null, key);
};
exports.flushSync = function (fn) {
  var previousTransition = ReactSharedInternals.T,
    previousUpdatePriority = Internals.p;
  try {
    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();
  } finally {
    (ReactSharedInternals.T = previousTransition),
      (Internals.p = previousUpdatePriority),
      Internals.d.f();
  }
};
exports.preconnect = function (href, options) {
  "string" === typeof href &&
    (options
      ? ((options = options.crossOrigin),
        (options =
          "string" === typeof options
            ? "use-credentials" === options
              ? options
              : ""
            : void 0))
      : (options = null),
    Internals.d.C(href, options));
};
exports.prefetchDNS = function (href) {
  "string" === typeof href && Internals.d.D(href);
};
exports.preinit = function (href, options) {
  if ("string" === typeof href && options && "string" === typeof options.as) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
      integrity =
        "string" === typeof options.integrity ? options.integrity : void 0,
      fetchPriority =
        "string" === typeof options.fetchPriority
          ? options.fetchPriority
          : void 0;
    "style" === as
      ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin: crossOrigin,
            integrity: integrity,
            fetchPriority: fetchPriority
          }
        )
      : "script" === as &&
        Internals.d.X(href, {
          crossOrigin: crossOrigin,
          integrity: integrity,
          fetchPriority: fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
  }
};
exports.preinitModule = function (href, options) {
  if ("string" === typeof href)
    if ("object" === typeof options && null !== options) {
      if (null == options.as || "script" === options.as) {
        var crossOrigin = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        );
        Internals.d.M(href, {
          crossOrigin: crossOrigin,
          integrity:
            "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    } else null == options && Internals.d.M(href);
};
exports.preload = function (href, options) {
  if (
    "string" === typeof href &&
    "object" === typeof options &&
    null !== options &&
    "string" === typeof options.as
  ) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
    Internals.d.L(href, as, {
      crossOrigin: crossOrigin,
      integrity:
        "string" === typeof options.integrity ? options.integrity : void 0,
      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
      type: "string" === typeof options.type ? options.type : void 0,
      fetchPriority:
        "string" === typeof options.fetchPriority
          ? options.fetchPriority
          : void 0,
      referrerPolicy:
        "string" === typeof options.referrerPolicy
          ? options.referrerPolicy
          : void 0,
      imageSrcSet:
        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
      imageSizes:
        "string" === typeof options.imageSizes ? options.imageSizes : void 0,
      media: "string" === typeof options.media ? options.media : void 0
    });
  }
};
exports.preloadModule = function (href, options) {
  if ("string" === typeof href)
    if (options) {
      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
      Internals.d.m(href, {
        as:
          "string" === typeof options.as && "script" !== options.as
            ? options.as
            : void 0,
        crossOrigin: crossOrigin,
        integrity:
          "string" === typeof options.integrity ? options.integrity : void 0
      });
    } else Internals.d.m(href);
};
exports.requestFormReset = function (form) {
  Internals.d.r(form);
};
exports.unstable_batchedUpdates = function (fn, a) {
  return fn(a);
};
exports.useFormState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
};
exports.useFormStatus = function () {
  return ReactSharedInternals.H.useHostTransitionStatus();
};
exports.version = "19.0.0";


/***/ }),

/***/ 338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(247);
} else {}


/***/ }),

/***/ 961:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(221);
} else {}


/***/ }),

/***/ 698:
/***/ ((__unused_webpack_module, exports) => {

/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
function jsxProd(type, config, maybeKey) {
  var key = null;
  void 0 !== maybeKey && (key = "" + maybeKey);
  void 0 !== config.key && (key = "" + config.key);
  if ("key" in config) {
    maybeKey = {};
    for (var propName in config)
      "key" !== propName && (maybeKey[propName] = config[propName]);
  } else maybeKey = config;
  config = maybeKey.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== config ? config : null,
    props: maybeKey
  };
}
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.jsx = jsxProd;
exports.jsxs = jsxProd;


/***/ }),

/***/ 869:
/***/ ((__unused_webpack_module, exports) => {

/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable =
    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
    maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var ReactNoopUpdateQueue = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  assign = Object.assign,
  emptyObject = {};
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
Component.prototype.isReactComponent = {};
Component.prototype.setState = function (partialState, callback) {
  if (
    "object" !== typeof partialState &&
    "function" !== typeof partialState &&
    null != partialState
  )
    throw Error(
      "takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, partialState, callback, "setState");
};
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
};
function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
pureComponentPrototype.constructor = PureComponent;
assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = !0;
var isArrayImpl = Array.isArray,
  ReactSharedInternals = { H: null, A: null, T: null, S: null },
  hasOwnProperty = Object.prototype.hasOwnProperty;
function ReactElement(type, key, self, source, owner, props) {
  self = props.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== self ? self : null,
    props: props
  };
}
function cloneAndReplaceKey(oldElement, newKey) {
  return ReactElement(
    oldElement.type,
    newKey,
    void 0,
    void 0,
    void 0,
    oldElement.props
  );
}
function isValidElement(object) {
  return (
    "object" === typeof object &&
    null !== object &&
    object.$$typeof === REACT_ELEMENT_TYPE
  );
}
function escape(key) {
  var escaperLookup = { "=": "=0", ":": "=2" };
  return (
    "$" +
    key.replace(/[=:]/g, function (match) {
      return escaperLookup[match];
    })
  );
}
var userProvidedKeyEscapeRegex = /\/+/g;
function getElementKey(element, index) {
  return "object" === typeof element && null !== element && null != element.key
    ? escape("" + element.key)
    : index.toString(36);
}
function noop$1() {}
function resolveThenable(thenable) {
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      switch (
        ("string" === typeof thenable.status
          ? thenable.then(noop$1, noop$1)
          : ((thenable.status = "pending"),
            thenable.then(
              function (fulfilledValue) {
                "pending" === thenable.status &&
                  ((thenable.status = "fulfilled"),
                  (thenable.value = fulfilledValue));
              },
              function (error) {
                "pending" === thenable.status &&
                  ((thenable.status = "rejected"), (thenable.reason = error));
              }
            )),
        thenable.status)
      ) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
      }
  }
  throw thenable;
}
function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;
  if ("undefined" === type || "boolean" === type) children = null;
  var invokeCallback = !1;
  if (null === children) invokeCallback = !0;
  else
    switch (type) {
      case "bigint":
      case "string":
      case "number":
        invokeCallback = !0;
        break;
      case "object":
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = !0;
            break;
          case REACT_LAZY_TYPE:
            return (
              (invokeCallback = children._init),
              mapIntoArray(
                invokeCallback(children._payload),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              )
            );
        }
    }
  if (invokeCallback)
    return (
      (callback = callback(children)),
      (invokeCallback =
        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
      isArrayImpl(callback)
        ? ((escapedPrefix = ""),
          null != invokeCallback &&
            (escapedPrefix =
              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
            return c;
          }))
        : null != callback &&
          (isValidElement(callback) &&
            (callback = cloneAndReplaceKey(
              callback,
              escapedPrefix +
                (null == callback.key ||
                (children && children.key === callback.key)
                  ? ""
                  : ("" + callback.key).replace(
                      userProvidedKeyEscapeRegex,
                      "$&/"
                    ) + "/") +
                invokeCallback
            )),
          array.push(callback)),
      1
    );
  invokeCallback = 0;
  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
  if (isArrayImpl(children))
    for (var i = 0; i < children.length; i++)
      (nameSoFar = children[i]),
        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
        (invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        ));
  else if (((i = getIteratorFn(children)), "function" === typeof i))
    for (
      children = i.call(children), i = 0;
      !(nameSoFar = children.next()).done;

    )
      (nameSoFar = nameSoFar.value),
        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
        (invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        ));
  else if ("object" === type) {
    if ("function" === typeof children.then)
      return mapIntoArray(
        resolveThenable(children),
        array,
        escapedPrefix,
        nameSoFar,
        callback
      );
    array = String(children);
    throw Error(
      "Objects are not valid as a React child (found: " +
        ("[object Object]" === array
          ? "object with keys {" + Object.keys(children).join(", ") + "}"
          : array) +
        "). If you meant to render a collection of children, use an array instead."
    );
  }
  return invokeCallback;
}
function mapChildren(children, func, context) {
  if (null == children) return children;
  var result = [],
    count = 0;
  mapIntoArray(children, result, "", "", function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
function lazyInitializer(payload) {
  if (-1 === payload._status) {
    var ctor = payload._result;
    ctor = ctor();
    ctor.then(
      function (moduleObject) {
        if (0 === payload._status || -1 === payload._status)
          (payload._status = 1), (payload._result = moduleObject);
      },
      function (error) {
        if (0 === payload._status || -1 === payload._status)
          (payload._status = 2), (payload._result = error);
      }
    );
    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
  }
  if (1 === payload._status) return payload._result.default;
  throw payload._result;
}
var reportGlobalError =
  "function" === typeof reportError
    ? reportError
    : function (error) {
        if (
          "object" === typeof window &&
          "function" === typeof window.ErrorEvent
        ) {
          var event = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message:
              "object" === typeof error &&
              null !== error &&
              "string" === typeof error.message
                ? String(error.message)
                : String(error),
            error: error
          });
          if (!window.dispatchEvent(event)) return;
        } else if (
          "object" === typeof process &&
          "function" === typeof process.emit
        ) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
function noop() {}
exports.Children = {
  map: mapChildren,
  forEach: function (children, forEachFunc, forEachContext) {
    mapChildren(
      children,
      function () {
        forEachFunc.apply(this, arguments);
      },
      forEachContext
    );
  },
  count: function (children) {
    var n = 0;
    mapChildren(children, function () {
      n++;
    });
    return n;
  },
  toArray: function (children) {
    return (
      mapChildren(children, function (child) {
        return child;
      }) || []
    );
  },
  only: function (children) {
    if (!isValidElement(children))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return children;
  }
};
exports.Component = Component;
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.Profiler = REACT_PROFILER_TYPE;
exports.PureComponent = PureComponent;
exports.StrictMode = REACT_STRICT_MODE_TYPE;
exports.Suspense = REACT_SUSPENSE_TYPE;
exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
  ReactSharedInternals;
exports.act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
exports.cache = function (fn) {
  return function () {
    return fn.apply(null, arguments);
  };
};
exports.cloneElement = function (element, config, children) {
  if (null === element || void 0 === element)
    throw Error(
      "The argument must be a React element, but you passed " + element + "."
    );
  var props = assign({}, element.props),
    key = element.key,
    owner = void 0;
  if (null != config)
    for (propName in (void 0 !== config.ref && (owner = void 0),
    void 0 !== config.key && (key = "" + config.key),
    config))
      !hasOwnProperty.call(config, propName) ||
        "key" === propName ||
        "__self" === propName ||
        "__source" === propName ||
        ("ref" === propName && void 0 === config.ref) ||
        (props[propName] = config[propName]);
  var propName = arguments.length - 2;
  if (1 === propName) props.children = children;
  else if (1 < propName) {
    for (var childArray = Array(propName), i = 0; i < propName; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  return ReactElement(element.type, key, void 0, void 0, owner, props);
};
exports.createContext = function (defaultValue) {
  defaultValue = {
    $$typeof: REACT_CONTEXT_TYPE,
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  defaultValue.Provider = defaultValue;
  defaultValue.Consumer = {
    $$typeof: REACT_CONSUMER_TYPE,
    _context: defaultValue
  };
  return defaultValue;
};
exports.createElement = function (type, config, children) {
  var propName,
    props = {},
    key = null;
  if (null != config)
    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
      hasOwnProperty.call(config, propName) &&
        "key" !== propName &&
        "__self" !== propName &&
        "__source" !== propName &&
        (props[propName] = config[propName]);
  var childrenLength = arguments.length - 2;
  if (1 === childrenLength) props.children = children;
  else if (1 < childrenLength) {
    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  if (type && type.defaultProps)
    for (propName in ((childrenLength = type.defaultProps), childrenLength))
      void 0 === props[propName] &&
        (props[propName] = childrenLength[propName]);
  return ReactElement(type, key, void 0, void 0, null, props);
};
exports.createRef = function () {
  return { current: null };
};
exports.forwardRef = function (render) {
  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
};
exports.isValidElement = isValidElement;
exports.lazy = function (ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE,
    _payload: { _status: -1, _result: ctor },
    _init: lazyInitializer
  };
};
exports.memo = function (type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: void 0 === compare ? null : compare
  };
};
exports.startTransition = function (scope) {
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  try {
    var returnValue = scope(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish &&
      onStartTransitionFinish(currentTransition, returnValue);
    "object" === typeof returnValue &&
      null !== returnValue &&
      "function" === typeof returnValue.then &&
      returnValue.then(noop, reportGlobalError);
  } catch (error) {
    reportGlobalError(error);
  } finally {
    ReactSharedInternals.T = prevTransition;
  }
};
exports.unstable_useCacheRefresh = function () {
  return ReactSharedInternals.H.useCacheRefresh();
};
exports.use = function (usable) {
  return ReactSharedInternals.H.use(usable);
};
exports.useActionState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
};
exports.useCallback = function (callback, deps) {
  return ReactSharedInternals.H.useCallback(callback, deps);
};
exports.useContext = function (Context) {
  return ReactSharedInternals.H.useContext(Context);
};
exports.useDebugValue = function () {};
exports.useDeferredValue = function (value, initialValue) {
  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
};
exports.useEffect = function (create, deps) {
  return ReactSharedInternals.H.useEffect(create, deps);
};
exports.useId = function () {
  return ReactSharedInternals.H.useId();
};
exports.useImperativeHandle = function (ref, create, deps) {
  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
};
exports.useInsertionEffect = function (create, deps) {
  return ReactSharedInternals.H.useInsertionEffect(create, deps);
};
exports.useLayoutEffect = function (create, deps) {
  return ReactSharedInternals.H.useLayoutEffect(create, deps);
};
exports.useMemo = function (create, deps) {
  return ReactSharedInternals.H.useMemo(create, deps);
};
exports.useOptimistic = function (passthrough, reducer) {
  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
};
exports.useReducer = function (reducer, initialArg, init) {
  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
};
exports.useRef = function (initialValue) {
  return ReactSharedInternals.H.useRef(initialValue);
};
exports.useState = function (initialState) {
  return ReactSharedInternals.H.useState(initialState);
};
exports.useSyncExternalStore = function (
  subscribe,
  getSnapshot,
  getServerSnapshot
) {
  return ReactSharedInternals.H.useSyncExternalStore(
    subscribe,
    getSnapshot,
    getServerSnapshot
  );
};
exports.useTransition = function () {
  return ReactSharedInternals.H.useTransition();
};
exports.version = "19.0.0";


/***/ }),

/***/ 540:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (true) {
  module.exports = __webpack_require__(869);
} else {}


/***/ }),

/***/ 848:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (true) {
  module.exports = __webpack_require__(698);
} else {}


/***/ }),

/***/ 477:
/***/ ((__unused_webpack_module, exports) => {

/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  a: for (; 0 < index; ) {
    var parentIndex = (index - 1) >>> 1,
      parent = heap[parentIndex];
    if (0 < compare(parent, node))
      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
    else break a;
  }
}
function peek(heap) {
  return 0 === heap.length ? null : heap[0];
}
function pop(heap) {
  if (0 === heap.length) return null;
  var first = heap[0],
    last = heap.pop();
  if (last !== first) {
    heap[0] = last;
    a: for (
      var index = 0, length = heap.length, halfLength = length >>> 1;
      index < halfLength;

    ) {
      var leftIndex = 2 * (index + 1) - 1,
        left = heap[leftIndex],
        rightIndex = leftIndex + 1,
        right = heap[rightIndex];
      if (0 > compare(left, last))
        rightIndex < length && 0 > compare(right, left)
          ? ((heap[index] = right),
            (heap[rightIndex] = last),
            (index = rightIndex))
          : ((heap[index] = left),
            (heap[leftIndex] = last),
            (index = leftIndex));
      else if (rightIndex < length && 0 > compare(right, last))
        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
      else break a;
    }
  }
  return first;
}
function compare(a, b) {
  var diff = a.sortIndex - b.sortIndex;
  return 0 !== diff ? diff : a.id - b.id;
}
exports.unstable_now = void 0;
if ("object" === typeof performance && "function" === typeof performance.now) {
  var localPerformance = performance;
  exports.unstable_now = function () {
    return localPerformance.now();
  };
} else {
  var localDate = Date,
    initialTime = localDate.now();
  exports.unstable_now = function () {
    return localDate.now() - initialTime;
  };
}
var taskQueue = [],
  timerQueue = [],
  taskIdCounter = 1,
  currentTask = null,
  currentPriorityLevel = 3,
  isPerformingWork = !1,
  isHostCallbackScheduled = !1,
  isHostTimeoutScheduled = !1,
  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
function advanceTimers(currentTime) {
  for (var timer = peek(timerQueue); null !== timer; ) {
    if (null === timer.callback) pop(timerQueue);
    else if (timer.startTime <= currentTime)
      pop(timerQueue),
        (timer.sortIndex = timer.expirationTime),
        push(taskQueue, timer);
    else break;
    timer = peek(timerQueue);
  }
}
function handleTimeout(currentTime) {
  isHostTimeoutScheduled = !1;
  advanceTimers(currentTime);
  if (!isHostCallbackScheduled)
    if (null !== peek(taskQueue))
      (isHostCallbackScheduled = !0), requestHostCallback();
    else {
      var firstTimer = peek(timerQueue);
      null !== firstTimer &&
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
}
var isMessageLoopRunning = !1,
  taskTimeoutID = -1,
  frameInterval = 5,
  startTime = -1;
function shouldYieldToHost() {
  return exports.unstable_now() - startTime < frameInterval ? !1 : !0;
}
function performWorkUntilDeadline() {
  if (isMessageLoopRunning) {
    var currentTime = exports.unstable_now();
    startTime = currentTime;
    var hasMoreWork = !0;
    try {
      a: {
        isHostCallbackScheduled = !1;
        isHostTimeoutScheduled &&
          ((isHostTimeoutScheduled = !1),
          localClearTimeout(taskTimeoutID),
          (taskTimeoutID = -1));
        isPerformingWork = !0;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          b: {
            advanceTimers(currentTime);
            for (
              currentTask = peek(taskQueue);
              null !== currentTask &&
              !(
                currentTask.expirationTime > currentTime && shouldYieldToHost()
              );

            ) {
              var callback = currentTask.callback;
              if ("function" === typeof callback) {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var continuationCallback = callback(
                  currentTask.expirationTime <= currentTime
                );
                currentTime = exports.unstable_now();
                if ("function" === typeof continuationCallback) {
                  currentTask.callback = continuationCallback;
                  advanceTimers(currentTime);
                  hasMoreWork = !0;
                  break b;
                }
                currentTask === peek(taskQueue) && pop(taskQueue);
                advanceTimers(currentTime);
              } else pop(taskQueue);
              currentTask = peek(taskQueue);
            }
            if (null !== currentTask) hasMoreWork = !0;
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer &&
                requestHostTimeout(
                  handleTimeout,
                  firstTimer.startTime - currentTime
                );
              hasMoreWork = !1;
            }
          }
          break a;
        } finally {
          (currentTask = null),
            (currentPriorityLevel = previousPriorityLevel),
            (isPerformingWork = !1);
        }
        hasMoreWork = void 0;
      }
    } finally {
      hasMoreWork
        ? schedulePerformWorkUntilDeadline()
        : (isMessageLoopRunning = !1);
    }
  }
}
var schedulePerformWorkUntilDeadline;
if ("function" === typeof localSetImmediate)
  schedulePerformWorkUntilDeadline = function () {
    localSetImmediate(performWorkUntilDeadline);
  };
else if ("undefined" !== typeof MessageChannel) {
  var channel = new MessageChannel(),
    port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;
  schedulePerformWorkUntilDeadline = function () {
    port.postMessage(null);
  };
} else
  schedulePerformWorkUntilDeadline = function () {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
function requestHostCallback() {
  isMessageLoopRunning ||
    ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());
}
function requestHostTimeout(callback, ms) {
  taskTimeoutID = localSetTimeout(function () {
    callback(exports.unstable_now());
  }, ms);
}
exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;
exports.unstable_cancelCallback = function (task) {
  task.callback = null;
};
exports.unstable_continueExecution = function () {
  isHostCallbackScheduled ||
    isPerformingWork ||
    ((isHostCallbackScheduled = !0), requestHostCallback());
};
exports.unstable_forceFrameRate = function (fps) {
  0 > fps || 125 < fps
    ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      )
    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
};
exports.unstable_getCurrentPriorityLevel = function () {
  return currentPriorityLevel;
};
exports.unstable_getFirstCallbackNode = function () {
  return peek(taskQueue);
};
exports.unstable_next = function (eventHandler) {
  switch (currentPriorityLevel) {
    case 1:
    case 2:
    case 3:
      var priorityLevel = 3;
      break;
    default:
      priorityLevel = currentPriorityLevel;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_pauseExecution = function () {};
exports.unstable_requestPaint = function () {};
exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;
    default:
      priorityLevel = 3;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_scheduleCallback = function (
  priorityLevel,
  callback,
  options
) {
  var currentTime = exports.unstable_now();
  "object" === typeof options && null !== options
    ? ((options = options.delay),
      (options =
        "number" === typeof options && 0 < options
          ? currentTime + options
          : currentTime))
    : (options = currentTime);
  switch (priorityLevel) {
    case 1:
      var timeout = -1;
      break;
    case 2:
      timeout = 250;
      break;
    case 5:
      timeout = 1073741823;
      break;
    case 4:
      timeout = 1e4;
      break;
    default:
      timeout = 5e3;
  }
  timeout = options + timeout;
  priorityLevel = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: options,
    expirationTime: timeout,
    sortIndex: -1
  };
  options > currentTime
    ? ((priorityLevel.sortIndex = options),
      push(timerQueue, priorityLevel),
      null === peek(taskQueue) &&
        priorityLevel === peek(timerQueue) &&
        (isHostTimeoutScheduled
          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
          : (isHostTimeoutScheduled = !0),
        requestHostTimeout(handleTimeout, options - currentTime)))
    : ((priorityLevel.sortIndex = timeout),
      push(taskQueue, priorityLevel),
      isHostCallbackScheduled ||
        isPerformingWork ||
        ((isHostCallbackScheduled = !0), requestHostCallback()));
  return priorityLevel;
};
exports.unstable_shouldYield = shouldYieldToHost;
exports.unstable_wrapCallback = function (callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;
    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
};


/***/ }),

/***/ 982:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (true) {
  module.exports = __webpack_require__(477);
} else {}


/***/ }),

/***/ 493:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var React = __webpack_require__(540);
function is(x, y) {
  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is,
  useState = React.useState,
  useEffect = React.useEffect,
  useLayoutEffect = React.useLayoutEffect,
  useDebugValue = React.useDebugValue;
function useSyncExternalStore$2(subscribe, getSnapshot) {
  var value = getSnapshot(),
    _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }),
    inst = _useState[0].inst,
    forceUpdate = _useState[1];
  useLayoutEffect(
    function () {
      inst.value = value;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
    },
    [subscribe, value, getSnapshot]
  );
  useEffect(
    function () {
      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
      return subscribe(function () {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
      });
    },
    [subscribe]
  );
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return !0;
  }
}
function useSyncExternalStore$1(subscribe, getSnapshot) {
  return getSnapshot();
}
var shim =
  "undefined" === typeof window ||
  "undefined" === typeof window.document ||
  "undefined" === typeof window.document.createElement
    ? useSyncExternalStore$1
    : useSyncExternalStore$2;
exports.useSyncExternalStore =
  void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;


/***/ }),

/***/ 888:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (true) {
  module.exports = __webpack_require__(493);
} else {}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(848);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(338);
;// ./src/widgets/sidebar-navigation/ui/SidebarNavigation.css
// extracted by mini-css-extract-plugin
var _1 = "v22U7mMXi1ftKCNC3HhP";
var _2 = "_RrNOqJcdzB10bpur9j5";
var _3 = "bmm89n6Y_VQMVwH7027G";


;// ./src/shared/ui/assets/images/logo.png
const logo_namespaceObject = __webpack_require__.p + "2d9d733bf6dc11c87b23.png";
;// ./src/shared/ui/assets/images/navigation/home.svg
const home_namespaceObject = __webpack_require__.p + "50a8b901e1b6143cf19f.svg";
;// ./src/shared/ui/assets/images/navigation/profile.svg
const profile_namespaceObject = __webpack_require__.p + "66a436bc7de333d6e482.svg";
;// ./src/shared/ui/assets/images/navigation/project.svg
const project_namespaceObject = __webpack_require__.p + "4fbc4ac89c16fd054bab.svg";
;// ./src/shared/ui/assets/images/navigation/settings.svg
const settings_namespaceObject = __webpack_require__.p + "4e7ed90859177b7bab76.svg";
;// ./src/shared/ui/assets/images/navigation/task.svg
const task_namespaceObject = __webpack_require__.p + "7b874e9c28e03e00a56e.svg";
;// ./src/shared/ui/assets/images/navigation/bell.svg
const bell_namespaceObject = __webpack_require__.p + "dabe63cbc36e3c1acfdd.svg";
;// ./src/shared/ui/tooltip/Tooltip.css
// extracted by mini-css-extract-plugin
var Tooltip_1 = "KRb81p5an8fWa3i9DnKW";
var Tooltip_2 = "hpalVQh_i72ar2O8mad5";
var Tooltip_3 = "gGsEbSngG6jWW95EyIpV";
var _4 = "FbKupGibetOhk4e_dGTW";


// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(540);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(961);
;// ./src/shared/ui/tooltip/Tooltip.tsx




const Tooltip = (p) => {
    const [mouseOver, setMouseOver] = (0,react.useState)(false);
    const [leaved, setLeaved] = (0,react.useState)(false);
    const bounds = (0,react.useRef)({
        top: 0,
        left: 0,
    });
    const callbackRef = (node) => {
        if (node) {
            const { left, bottom } = node.getBoundingClientRect();
            bounds.current.top = bottom;
            bounds.current.left = left;
        }
    };
    const handleMouseLeave = () => {
        const timeCall = performance.now();
        setLeaved(true);
        const animate = () => {
            if (performance.now() - timeCall >= 200) {
                setMouseOver(false);
            }
            else {
                requestAnimationFrame(animate);
            }
        };
        requestAnimationFrame(animate);
    };
    return ((0,jsx_runtime.jsxs)("div", { className: Tooltip_2, onMouseEnter: () => {
            setMouseOver(true);
            setLeaved(false);
        }, onMouseLeave: handleMouseLeave, ref: callbackRef, children: [p.children, mouseOver && (0,react_dom.createPortal)(((0,jsx_runtime.jsx)("div", { className: _4, "data-leaved": leaved, style: {
                    left: bounds.current.left,
                    top: bounds.current.top
                }, children: p.title })), document.getElementById('tooltip-portal'))] }));
};

;// ./src/shared/ui/tooltip/index.ts


;// ./src/widgets/sidebar-navigation/ui/SidebarNavigation.tsx










const SidebarNavigation = () => {
    return ((0,jsx_runtime.jsxs)("div", { className: _1, children: [(0,jsx_runtime.jsx)("div", { className: _2, children: (0,jsx_runtime.jsx)("img", { src: logo_namespaceObject, alt: "" }) }), (0,jsx_runtime.jsxs)("div", { className: _3, children: [(0,jsx_runtime.jsx)(Tooltip, { title: "\u0414\u043E\u043C\u0430\u0448\u043D\u044F\u044F \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0430 (\u0432 \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u043A\u0435)", children: (0,jsx_runtime.jsx)("img", { src: home_namespaceObject, alt: "" }) }), (0,jsx_runtime.jsx)(Tooltip, { title: "\u041F\u0440\u043E\u0444\u0438\u043B\u044C (\u0432 \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u043A\u0435)", children: (0,jsx_runtime.jsx)("img", { src: profile_namespaceObject, alt: "" }) }), (0,jsx_runtime.jsx)(Tooltip, { title: "\u0417\u0430\u0434\u0430\u0447\u0438 (\u0432 \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u043A\u0435)", children: (0,jsx_runtime.jsx)("img", { src: task_namespaceObject, alt: "" }) }), (0,jsx_runtime.jsx)(Tooltip, { title: "\u041F\u0440\u043E\u0435\u043A\u0442\u044B (\u0432 \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u043A\u0435)", children: (0,jsx_runtime.jsx)("img", { src: project_namespaceObject, alt: "" }) }), (0,jsx_runtime.jsx)(Tooltip, { title: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 (\u0432 \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u043A\u0435)", children: (0,jsx_runtime.jsx)("img", { src: settings_namespaceObject, alt: "" }) }), (0,jsx_runtime.jsx)(Tooltip, { title: "\u0423\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u044F (\u0432 \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u043A\u0435)", children: (0,jsx_runtime.jsx)("img", { src: bell_namespaceObject, alt: "" }) })] })] }));
};

;// ./src/widgets/sidebar-navigation/ui/index.ts


;// ./src/widgets/sidebar-tasks/ui/SidebarTasks.css
// extracted by mini-css-extract-plugin
var SidebarTasks_1 = "WdBJtnh_uwlnp3lsegoa";
var SidebarTasks_2 = "QomryXB5_6slAufJKynf";
var SidebarTasks_3 = "ImvAvtiV6ZgroDkMiHRX";
var SidebarTasks_4 = "poNju6YaDg9XZU6LHS_g";
var _5 = "pVbMSpC6C67WhjCBV8t6";
var _6 = "oIekHs5td8jx_X8szjkK";


;// ./src/shared/ui/typography/Typography.css
// extracted by mini-css-extract-plugin
var Typography_1 = "dsVID3jH1DPhVoVHyJDw";
var Typography_2 = "hatUzWsN7DVj7NuhBh3g";


;// ./src/shared/ui/typography/Typography.tsx


const Heading = (p) => {
    let classNames = Typography_1;
    if (p.className) {
        classNames += ' ' + p.className;
    }
    const elems = {
        'h1': (0,jsx_runtime.jsx)("h1", { ...p, className: classNames, children: p.children }),
        'h2': (0,jsx_runtime.jsx)("h2", { ...p, className: classNames, children: p.children }),
        'h3': (0,jsx_runtime.jsx)("h3", { ...p, className: classNames, children: p.children }),
        'h4': (0,jsx_runtime.jsx)("h4", { ...p, className: classNames, children: p.children }),
        'h5': (0,jsx_runtime.jsx)("h5", { ...p, className: classNames, children: p.children }),
        'h6': (0,jsx_runtime.jsx)("h6", { ...p, className: classNames, children: p.children }),
    };
    return elems[p.as || 'h2'];
};
const Paragraph = (p) => {
    let classNames = Typography_2;
    if (p.className) {
        classNames += ' ' + p.className;
    }
    return (0,jsx_runtime.jsx)("p", { ...p, className: classNames, children: p.children });
};
const Text = (p) => {
    let classNames = Typography_2;
    if (p.className) {
        classNames += ' ' + p.className;
    }
    const elems = {
        'div': (0,jsx_runtime.jsx)("div", { ...p, className: classNames, children: p.children }),
        'span': (0,jsx_runtime.jsx)("span", { ...p, className: classNames, children: p.children }),
    };
    return elems[p.as || 'div'];
};
const Link = (p) => {
    let classNames = Typography_2;
    if (p.className) {
        classNames += ' ' + p.className;
    }
    return (0,jsx_runtime.jsx)("a", { ...p, className: classNames, children: p.children });
};
const Typography = { Heading, Text, Paragraph, Link };

;// ./src/shared/ui/typography/index.ts


;// ./src/shared/ui/sidebar-task/SidebarTask.css
// extracted by mini-css-extract-plugin
var SidebarTask_1 = "R2mLnVw0N7CQJuCqqPmw";
var SidebarTask_2 = "GRxOFtZQ4f0FiBDd71YF";


;// ./src/shared/ui/diagram/Diagram.css
// extracted by mini-css-extract-plugin
var Diagram_1 = "pP_X3CRTrKFgXbnW5JEQ";
var Diagram_2 = "qQN0tdzqzDvaHWXIBrXf";


;// ./src/shared/ui/diagram/Diagram.tsx


const Diagram = (p) => {
    return ((0,jsx_runtime.jsx)("svg", { className: Diagram_2, width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0,jsx_runtime.jsx)("circle", { cx: 20, cy: 20, r: 15, className: Diagram_1, strokeDasharray: `${p.value * 47 / 50}, 100`, strokeDashoffset: 0 }) }));
};

;// ./src/shared/ui/diagram/index.ts


;// ./src/shared/ui/sidebar-task/SidebarTask.tsx




const SidebarTask = (p) => {
    return ((0,jsx_runtime.jsxs)("div", { className: SidebarTask_1, children: [(0,jsx_runtime.jsx)(Typography.Text, { children: p.taskName }), (0,jsx_runtime.jsx)("div", { className: SidebarTask_2, children: (0,jsx_runtime.jsx)(Diagram, { value: p.percent }) }), (0,jsx_runtime.jsxs)(Typography.Text, { children: [p.percent, "%"] })] }));
};

;// ./src/shared/ui/sidebar-task/index.ts


;// ./node_modules/mobx/dist/mobx.esm.js
var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function _(annotationType, key) {
    return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
  },
  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function _(index, length) {
    return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function _(other) {
    return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
  },
  20: function _(other) {
    return "Cannot initialize map from " + other;
  },
  21: function _(dataStructure) {
    return "Cannot convert to map from '" + dataStructure + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function _(thing) {
    return "Cannot obtain administration from " + thing;
  },
  25: function _(property, name) {
    return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
  },
  26: "please specify a property",
  27: function _(property, name) {
    return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
  },
  28: function _(thing) {
    return "Cannot obtain atom from " + thing;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function _(name, derivation) {
    return "Cycle detected in computation " + name + ": " + derivation;
  },
  33: function _(name) {
    return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function _(name) {
    return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function _(method) {
    return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
};
var errors =  false ? 0 : {};
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (false) { var e; }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}

var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof __webpack_require__.g !== "undefined") {
    return __webpack_require__.g;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}

// We shorten anything used > 5 times
var mobx_esm_assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /*#__PURE__*/Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die( false ? 0 : "Proxy not available");
  }
}
function warnAboutProxyRequirement(msg) {
  if (false) {}
}
function getNextId() {
  return ++globalState.mobxGuid;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */
function once(func) {
  var invoked = false;
  return function () {
    if (invoked) {
      return;
    }
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop() {};
function isFunction(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t = typeof value;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  if (!isObject(value)) {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto == null) {
    return true;
  }
  var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
}
// https://stackoverflow.com/a/37865170
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) {
    return false;
  }
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
    return true;
  }
  return false;
}
function addHiddenProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value: value
  });
}
function addHiddenFinalProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function (x) {
    return isObject(x) && x[propName] === true;
  };
}
/**
 * Yields true for both native and observable Map, even across different windows.
 */
function isES6Map(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Map]";
}
/**
 * Makes sure a Map is an instance of non-inherited native or observable Map.
 */
function isPlainES6Map(thing) {
  var mapProto = Object.getPrototypeOf(thing);
  var objectProto = Object.getPrototypeOf(mapProto);
  var nullProto = Object.getPrototypeOf(objectProto);
  return nullProto === null;
}
/**
 * Yields true for both native and observable Set, even across different windows.
 */
function isES6Set(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Set]";
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
/**
 * Returns the following: own enumerable keys and symbols.
 */
function getPlainObjectKeys(object) {
  var keys = Object.keys(object);
  // Not supported in IE, so there are not going to be symbol props anyway...
  if (!hasGetOwnPropertySymbols) {
    return keys;
  }
  var symbols = Object.getOwnPropertySymbols(object);
  if (!symbols.length) {
    return keys;
  }
  return [].concat(keys, symbols.filter(function (s) {
    return objectPrototype.propertyIsEnumerable.call(object, s);
  }));
}
// From Immer utils
// Returns all own keys, including non-enumerable and symbolic
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : /* istanbul ignore next */Object.getOwnPropertyNames;
function stringifyKey(key) {
  if (typeof key === "string") {
    return key;
  }
  if (typeof key === "symbol") {
    return key.toString();
  }
  return new String(key).toString();
}
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
}
// From Immer utils
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
  var res = {};
  // Note: without polyfill for ownKeys, symbols won't be picked up
  ownKeys(target).forEach(function (key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};
function getFlag(flags, mask) {
  return !!(flags & mask);
}
function setFlag(flags, mask, newValue) {
  if (newValue) {
    flags |= mask;
  } else {
    flags &= ~mask;
  }
  return flags;
}

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t) return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function () {
      return o >= r.length ? {
        done: !0
      } : {
        done: !1,
        value: r[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

var storedAnnotationsSymbol = /*#__PURE__*/Symbol("mobx-stored-annotations");
/**
 * Creates a function that acts as
 * - decorator
 * - annotation object
 */
function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    if (is20223Decorator(property)) {
      return annotation.decorate_20223_(target, property);
    } else {
      storeAnnotation(target, property, annotation);
    }
  }
  return Object.assign(decorator, annotation);
}
/**
 * Stores annotation to prototype,
 * so it can be inspected later by `makeObservable` called from constructor
 */
function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  }
  // @override must override something
  if (false) { var fieldName; }
  // Cannot re-decorate
  assertNotDecorated(prototype, annotation, key);
  // Ignore override
  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}
function assertNotDecorated(prototype, annotation, key) {
  if (false) { var requestedAnnotationType, currentAnnotationType, fieldName; }
}
/**
 * Collects annotations from prototypes and stores them on target (instance)
 */
function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    // if (__DEV__ && !target[storedAnnotationsSymbol]) {
    //     die(
    //         `No annotations were passed to makeObservable, but no decorated members have been found either`
    //     )
    // }
    // We need a copy as we will remove annotation from the list once it's applied.
    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }
  return target[storedAnnotationsSymbol];
}
function is20223Decorator(context) {
  return typeof context == "object" && typeof context["kind"] == "string";
}
function assert20223DecoratorType(context, types) {
  if (false) {}
}

var $mobx = /*#__PURE__*/Symbol("mobx administration");
var Atom = /*#__PURE__*/function () {
  /**
   * Create a new atom. For debugging purposes it is recommended to give it a name.
   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
   */
  function Atom(name_) {
    if (name_ === void 0) {
      name_ =  false ? 0 : "Atom";
    }
    this.name_ = void 0;
    this.flags_ = 0;
    this.observers_ = new Set();
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    // onBecomeObservedListeners
    this.onBOL = void 0;
    // onBecomeUnobservedListeners
    this.onBUOL = void 0;
    this.name_ = name_;
  }
  // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed
  var _proto = Atom.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Invoke this method to notify mobx that your atom has been used somehow.
   * Returns true if there is currently a reactive context.
   */;
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  }
  /**
   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
   */;
  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };
  _proto.toString = function toString() {
    return this.name_;
  };
  return _createClass(Atom, [{
    key: "isBeingObserved",
    get: function get() {
      return getFlag(this.flags_, Atom.isBeingObservedMask_);
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, Atom.isBeingObservedMask_, newValue);
    }
  }, {
    key: "isPendingUnobservation",
    get: function get() {
      return getFlag(this.flags_, Atom.isPendingUnobservationMask_);
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, Atom.isPendingUnobservationMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get() {
      return getFlag(this.flags_, Atom.diffValueMask_) ? 1 : 0;
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, Atom.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
Atom.isBeingObservedMask_ = 1;
Atom.isPendingUnobservationMask_ = 2;
Atom.diffValueMask_ = 4;
var isAtom = /*#__PURE__*/createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }
  var atom = new Atom(name);
  // default `noop` listener will not initialize the hook Set
  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}

function identityComparer(a, b) {
  return a === b;
}
function structuralComparer(a, b) {
  return deepEqual(a, b);
}
function shallowComparer(a, b) {
  return deepEqual(a, b, 1);
}
function defaultComparer(a, b) {
  if (Object.is) {
    return Object.is(a, b);
  }
  return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};

function deepEnhancer(v, _, name) {
  // it is an observable already, done
  if (isObservable(v)) {
    return v;
  }
  // something that can be converted and mutated?
  if (Array.isArray(v)) {
    return mobx_esm_observable.array(v, {
      name: name
    });
  }
  if (isPlainObject(v)) {
    return mobx_esm_observable.object(v, undefined, {
      name: name
    });
  }
  if (isES6Map(v)) {
    return mobx_esm_observable.map(v, {
      name: name
    });
  }
  if (isES6Set(v)) {
    return mobx_esm_observable.set(v, {
      name: name
    });
  }
  if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
    if (isGenerator(v)) {
      return flow(v);
    } else {
      return autoAction(name, v);
    }
  }
  return v;
}
function shallowEnhancer(v, _, name) {
  if (v === undefined || v === null) {
    return v;
  }
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {
    return v;
  }
  if (Array.isArray(v)) {
    return mobx_esm_observable.array(v, {
      name: name,
      deep: false
    });
  }
  if (isPlainObject(v)) {
    return mobx_esm_observable.object(v, undefined, {
      name: name,
      deep: false
    });
  }
  if (isES6Map(v)) {
    return mobx_esm_observable.map(v, {
      name: name,
      deep: false
    });
  }
  if (isES6Set(v)) {
    return mobx_esm_observable.set(v, {
      name: name,
      deep: false
    });
  }
  if (false) {}
}
function referenceEnhancer(newValue) {
  // never turn into an observable
  return newValue;
}
function refStructEnhancer(v, oldValue) {
  if (false) {}
  if (deepEqual(v, oldValue)) {
    return oldValue;
  }
  return v;
}

var OVERRIDE = "override";
var override = /*#__PURE__*/createDecoratorAnnotation({
  annotationType_: OVERRIDE,
  make_: make_,
  extend_: extend_,
  decorate_20223_: decorate_20223_
});
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function make_(adm, key) {
  // Must not be plain object
  if (false) {}
  // Must override something
  if (false) {}
  return 0 /* MakeResult.Cancel */;
}
function extend_(adm, key, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}
function decorate_20223_(desc, context) {
  console.warn("'" + this.annotationType_ + "' cannot be used with decorators - this is a no-op");
}

function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1,
    decorate_20223_: decorate_20223_$1
  };
}
function make_$1(adm, key, descriptor, source) {
  var _this$options_;
  // bound
  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */ : 1 /* MakeResult.Break */;
  }
  // own
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */ : 2 /* MakeResult.Continue */;
  }
  // prototype
  if (isAction(descriptor.value)) {
    // A prototype could have been annotated already by other constructor,
    // rest of the proto chain must be annotated already
    return 1 /* MakeResult.Break */;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2 /* MakeResult.Continue */;
}
function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function decorate_20223_$1(mthd, context) {
  if (false) {}
  var kind = context.kind,
    name = context.name,
    addInitializer = context.addInitializer;
  var ann = this;
  var _createAction = function _createAction(m) {
    var _ann$options_$name, _ann$options_, _ann$options_$autoAct, _ann$options_2;
    return createAction((_ann$options_$name = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.name) != null ? _ann$options_$name : name.toString(), m, (_ann$options_$autoAct = (_ann$options_2 = ann.options_) == null ? void 0 : _ann$options_2.autoAction) != null ? _ann$options_$autoAct : false);
  };
  if (kind == "field") {
    return function (initMthd) {
      var _ann$options_3;
      var mthd = initMthd;
      if (!isAction(mthd)) {
        mthd = _createAction(mthd);
      }
      if ((_ann$options_3 = ann.options_) != null && _ann$options_3.bound) {
        mthd = mthd.bind(this);
        mthd.isMobxAction = true;
      }
      return mthd;
    };
  }
  if (kind == "method") {
    var _this$options_2;
    if (!isAction(mthd)) {
      mthd = _createAction(mthd);
    }
    if ((_this$options_2 = this.options_) != null && _this$options_2.bound) {
      addInitializer(function () {
        var self = this;
        var bound = self[name].bind(self);
        bound.isMobxAction = true;
        self[name] = bound;
      });
    }
    return mthd;
  }
  die("Cannot apply '" + ann.annotationType_ + "' to '" + String(name) + "' (kind: " + kind + "):" + ("\n'" + ann.annotationType_ + "' can only be used on properties with a function value."));
}
function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (false) {}
}
function createActionDescriptor(adm, annotation, key, descriptor,
// provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
    // https://github.com/mobxjs/mobx/discussions/3140
    (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : undefined),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2,
    decorate_20223_: decorate_20223_$2
  };
}
function make_$2(adm, key, descriptor, source) {
  var _this$options_;
  // own
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */ : 2 /* MakeResult.Continue */;
  }
  // prototype
  // bound - must annotate protos to support super.flow()
  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
    if (this.extend_(adm, key, descriptor, false) === null) {
      return 0 /* MakeResult.Cancel */;
    }
  }
  if (isFlow(descriptor.value)) {
    // A prototype could have been annotated already by other constructor,
    // rest of the proto chain must be annotated already
    return 1 /* MakeResult.Break */;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2 /* MakeResult.Continue */;
}
function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function decorate_20223_$2(mthd, context) {
  var _this$options_3;
  if (false) {}
  var name = context.name,
    addInitializer = context.addInitializer;
  if (!isFlow(mthd)) {
    mthd = flow(mthd);
  }
  if ((_this$options_3 = this.options_) != null && _this$options_3.bound) {
    addInitializer(function () {
      var self = this;
      var bound = self[name].bind(self);
      bound.isMobXFlow = true;
      self[name] = bound;
    });
  }
  return mthd;
}
function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (false) {}
}
function createFlowDescriptor(adm, annotation, key, descriptor, bound,
// provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  // In case of flow.bound, the descriptor can be from already annotated prototype
  if (!isFlow(value)) {
    value = flow(value);
  }
  if (bound) {
    var _adm$proxy_;
    // We do not keep original function around, so we bind the existing flow
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    // This is normally set by `flow`, but `bind` returns new function...
    value.isMobXFlow = true;
  }
  return {
    value: value,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3,
    decorate_20223_: decorate_20223_$3
  };
}
function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */ : 1 /* MakeResult.Break */;
}
function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function decorate_20223_$3(get, context) {
  if (false) {}
  var ann = this;
  var key = context.name,
    addInitializer = context.addInitializer;
  addInitializer(function () {
    var adm = asObservableObject(this)[$mobx];
    var options = _extends({}, ann.options_, {
      get: get,
      context: this
    });
    options.name || (options.name =  false ? 0 : "ObservableObject." + key.toString());
    adm.values_.set(key, new ComputedValue(options));
  });
  return function () {
    return this[$mobx].getObservablePropValue_(key);
  };
}
function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get = _ref2.get;
  if (false) {}
}

function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4,
    decorate_20223_: decorate_20223_$4
  };
}
function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */ : 1 /* MakeResult.Break */;
}
function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function decorate_20223_$4(desc, context) {
  if (false) {}
  var ann = this;
  var kind = context.kind,
    name = context.name;
  // The laziness here is not ideal... It's a workaround to how 2022.3 Decorators are implemented:
  //   `addInitializer` callbacks are executed _before_ any accessors are defined (instead of the ideal-for-us right after each).
  //   This means that, if we were to do our stuff in an `addInitializer`, we'd attempt to read a private slot
  //   before it has been initialized. The runtime doesn't like that and throws a `Cannot read private member
  //   from an object whose class did not declare it` error.
  // TODO: it seems that this will not be required anymore in the final version of the spec
  // See TODO: link
  var initializedObjects = new WeakSet();
  function initializeObservable(target, value) {
    var _ann$options_$enhance, _ann$options_;
    var adm = asObservableObject(target)[$mobx];
    var observable = new ObservableValue(value, (_ann$options_$enhance = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.enhancer) != null ? _ann$options_$enhance : deepEnhancer,  false ? 0 : "ObservableObject." + name.toString(), false);
    adm.values_.set(name, observable);
    initializedObjects.add(target);
  }
  if (kind == "accessor") {
    return {
      get: function get() {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, desc.get.call(this));
        }
        return this[$mobx].getObservablePropValue_(name);
      },
      set: function set(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return this[$mobx].setObservablePropValue_(name, value);
      },
      init: function init(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return value;
      }
    };
  }
  return;
}
function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;
  if (false) {}
}

var AUTO = "true";
var autoAnnotation = /*#__PURE__*/createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5,
    decorate_20223_: decorate_20223_$5
  };
}
function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  // getter -> computed
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  }
  // lone setter -> action setter
  if (descriptor.set) {
    // TODO make action applicable to setter and delegate to action.make_
    var set = createAction(key.toString(), descriptor.set);
    // own
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set
      }) === null ? 0 /* MakeResult.Cancel */ : 2 /* MakeResult.Continue */;
    }
    // proto
    defineProperty(source, key, {
      configurable: true,
      set: set
    });
    return 2 /* MakeResult.Continue */;
  }
  // function on proto -> autoAction/flow
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
      return flowAnnotation.make_(adm, key, descriptor, source);
    }
    var actionAnnotation = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
    return actionAnnotation.make_(adm, key, descriptor, source);
  }
  // other -> observable
  // Copy props from proto as well, see test:
  // "decorate should work with Object.create"
  var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? mobx_esm_observable.ref : mobx_esm_observable;
  // if function respect autoBind option
  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation.make_(adm, key, descriptor, source);
}
function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  // getter -> computed
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  }
  // lone setter -> action setter
  if (descriptor.set) {
    // TODO make action applicable to setter and delegate to action.extend_
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  // other -> observable
  // if function respect autoBind option
  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? mobx_esm_observable.ref : mobx_esm_observable;
  return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);
}
function decorate_20223_$5(desc, context) {
  die("'" + this.annotationType_ + "' cannot be used as a decorator");
}

var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct";
// Predefined bags of create observable options, to avoid allocating temporarily option objects
// in the majority of cases
var defaultCreateObservableOptions = {
  deep: true,
  name: undefined,
  defaultDecorator: undefined,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /*#__PURE__*/createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;
  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */
function createObservable(v, arg2, arg3) {
  // @observable someProp; (2022.3 Decorators)
  if (is20223Decorator(arg2)) {
    return observableAnnotation.decorate_20223_(v, arg2);
  }
  // @observable someProp;
  if (isStringish(arg2)) {
    storeAnnotation(v, arg2, observableAnnotation);
    return;
  }
  // already observable - ignore
  if (isObservable(v)) {
    return v;
  }
  // plain object
  if (isPlainObject(v)) {
    return mobx_esm_observable.object(v, arg2, arg3);
  }
  // Array
  if (Array.isArray(v)) {
    return mobx_esm_observable.array(v, arg2);
  }
  // Map
  if (isES6Map(v)) {
    return mobx_esm_observable.map(v, arg2);
  }
  // Set
  if (isES6Set(v)) {
    return mobx_esm_observable.set(v, arg2);
  }
  // other object - ignore
  if (typeof v === "object" && v !== null) {
    return v;
  }
  // anything else
  return mobx_esm_observable.box(v, arg2);
}
mobx_esm_assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return initObservable(function () {
      return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
    });
  },
  ref: /*#__PURE__*/createDecoratorAnnotation(observableRefAnnotation),
  shallow: /*#__PURE__*/createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /*#__PURE__*/createDecoratorAnnotation(observableStructAnnotation)
};
// eslint-disable-next-line
var mobx_esm_observable = /*#__PURE__*/mobx_esm_assign(createObservable, observableFactories);

var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */
var computed = function computed(arg1, arg2) {
  if (is20223Decorator(arg2)) {
    // @computed (2022.3 Decorators)
    return computedAnnotation.decorate_20223_(arg1, arg2);
  }
  if (isStringish(arg2)) {
    // @computed
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }
  if (isPlainObject(arg1)) {
    // @computed({ options })
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  }
  // computed(expr, options?)
  if (false) {}
  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || ""); /* for generated name */
  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /*#__PURE__*/createDecoratorAnnotation(computedStructAnnotation);

var _getDescriptor$config, _getDescriptor;
// we don't use globalState for these in order to avoid possible issues with multiple
// mobx versions
var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/getDescriptor(function () {}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
// we can safely recycle this object
var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction, ref) {
  if (autoAction === void 0) {
    autoAction = false;
  }
  if (false) {}
  function res() {
    return executeAction(actionName, autoAction, fn, ref || this, arguments);
  }
  res.isMobxAction = true;
  res.toString = function () {
    return fn.toString();
  };
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);
  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation,
// true for autoAction
scope, args) {
  var notifySpy_ =  false && 0;
  var startTime_ = 0;
  if (false) { var flattenedArgs; }
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_: prevDerivation_,
    prevAllowStateChanges_: prevAllowStateChanges_,
    prevAllowStateReads_: prevAllowStateReads_,
    notifySpy_: notifySpy_,
    startTime_: startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== undefined) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) {
    untrackedEnd(runInfo.prevDerivation_);
  }
  if (false) {}
  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges, func) {
  var prev = allowStateChangesStart(allowStateChanges);
  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}

var CREATE = "create";
var ObservableValue = /*#__PURE__*/function (_Atom) {
  function ObservableValue(value, enhancer, name_, notifySpy, equals) {
    var _this;
    if (name_ === void 0) {
      name_ =  false ? 0 : "ObservableValue";
    }
    if (notifySpy === void 0) {
      notifySpy = true;
    }
    if (equals === void 0) {
      equals = comparer["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, undefined, name_);
    if (false) {}
    return _this;
  }
  _inheritsLoose(ObservableValue, _Atom);
  var _proto = ObservableValue.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.set = function set(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      if (false) {}
      this.setNewValue_(newValue);
      if (false) {}
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue: newValue
      });
      if (!change) {
        return globalState.UNCHANGED;
      }
      newValue = change.newValue;
    }
    // apply modifier
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue: newValue,
        oldValue: oldValue
      });
    }
  };
  _proto.get = function get() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) {
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE,
        newValue: this.value_,
        oldValue: undefined
      });
    }
    return registerListener(this, listener);
  };
  _proto.raw = function raw() {
    // used by MST ot get undehanced value
    return this.value_;
  };
  _proto.toJSON = function toJSON() {
    return this.get();
  };
  _proto.toString = function toString() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[Symbol.toPrimitive] = function () {
    return this.valueOf();
  };
  return ObservableValue;
}(Atom);
var isObservableValue = /*#__PURE__*/(/* unused pure expression or super */ null && (createInstanceofPredicate("ObservableValue", ObservableValue)));

/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */
var ComputedValue = /*#__PURE__*/function () {
  /**
   * Create a new computed value based on a function expression.
   *
   * The `name` property is for debug purposes only.
   *
   * The `equals` property specifies the comparer function to use to determine if a newly produced
   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
   * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.
   * Structural comparison can be convenient if you always produce a new aggregated object and
   * don't want to notify observers if it is structurally the same.
   * This is useful for working with vectors, mouse coordinates etc.
   */
  function ComputedValue(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    // nodes we are looking at. Our value depends on these nodes
    this.newObserving_ = null;
    // during tracking it's an array with new observed observers
    this.observers_ = new Set();
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.flags_ = 0;
    this.derivation = void 0;
    // N.B: unminified as it is used by MST
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) {
      die(31);
    }
    this.derivation = options.get;
    this.name_ = options.name || ( false ? 0 : "ComputedValue");
    if (options.set) {
      this.setter_ = createAction( false ? 0 : "ComputedValue-setter", options.set);
    }
    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }
  var _proto = ComputedValue.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  // to check for cycles
  ;
  /**
   * Returns the current value of this computed value.
   * Will evaluate its computation first if needed.
   */
  _proto.get = function get() {
    if (this.isComputing) {
      die(32, this.name_, this.derivation);
    }
    if (globalState.inBatch === 0 &&
    // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch(); // See perf test 'computed memoization'
        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) {
          globalState.trackingContext = this;
        }
        if (this.trackAndCompute()) {
          propagateChangeConfirmed(this);
        }
        globalState.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException(result)) {
      throw result.cause;
    }
    return result;
  };
  _proto.set = function set(value) {
    if (this.setter_) {
      if (this.isRunningSetter) {
        die(33, this.name_);
      }
      this.isRunningSetter = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter = false;
      }
    } else {
      die(34, this.name_);
    }
  };
  _proto.trackAndCompute = function trackAndCompute() {
    // N.B: unminified as it is used by MST
    var oldValue = this.value_;
    var wasSuspended = /* see #1208 */this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
      if (false) {}
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing = true;
    // don't allow state changes during computation
    var prev = allowStateChangesStart(false);
    var res;
    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }
    allowStateChangesEnd(prev);
    this.isComputing = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = undefined; // don't hold on to computed value!
      if (false) {}
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = undefined;
    return autorun(function () {
      // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue: newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    if (true) {
      return;
    }
    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
    if (typeof this.requiresReaction_ === "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };
  _proto.toString = function toString() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[Symbol.toPrimitive] = function () {
    return this.valueOf();
  };
  return _createClass(ComputedValue, [{
    key: "isComputing",
    get: function get() {
      return getFlag(this.flags_, ComputedValue.isComputingMask_);
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue.isComputingMask_, newValue);
    }
  }, {
    key: "isRunningSetter",
    get: function get() {
      return getFlag(this.flags_, ComputedValue.isRunningSetterMask_);
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue.isRunningSetterMask_, newValue);
    }
  }, {
    key: "isBeingObserved",
    get: function get() {
      return getFlag(this.flags_, ComputedValue.isBeingObservedMask_);
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue.isBeingObservedMask_, newValue);
    }
  }, {
    key: "isPendingUnobservation",
    get: function get() {
      return getFlag(this.flags_, ComputedValue.isPendingUnobservationMask_);
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue.isPendingUnobservationMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get() {
      return getFlag(this.flags_, ComputedValue.diffValueMask_) ? 1 : 0;
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
ComputedValue.isComputingMask_ = 1;
ComputedValue.isRunningSetterMask_ = 2;
ComputedValue.isBeingObservedMask_ = 4;
ComputedValue.isPendingUnobservationMask_ = 8;
ComputedValue.diffValueMask_ = 16;
var isComputedValue = /*#__PURE__*/createInstanceofPredicate("ComputedValue", ComputedValue);

var IDerivationState_;
(function (IDerivationState_) {
  // before being run or (outside batch and not being observed)
  // at this point derivation is not holding any data about dependency tree
  IDerivationState_[IDerivationState_["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  // no shallow dependency changed since last computation
  // won't recalculate derivation
  // this is what makes mobx fast
  IDerivationState_[IDerivationState_["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  // some deep dependency changed, but don't know if shallow dependency changed
  // will require to check first if UP_TO_DATE or POSSIBLY_STALE
  // currently only ComputedValue will propagate POSSIBLY_STALE
  //
  // having this state is second big optimization:
  // don't have to recompute on every dependency change, but only when it's needed
  IDerivationState_[IDerivationState_["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  // A shallow dependency has changed since last computation and the derivation
  // will need to recompute when it's needed next.
  IDerivationState_[IDerivationState_["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function (TraceMode) {
  TraceMode[TraceMode["NONE"] = 0] = "NONE";
  TraceMode[TraceMode["LOG"] = 1] = "LOG";
  TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function CaughtException(cause) {
  this.cause = void 0;
  this.cause = cause;
  // Empty
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_:
      {
        // state propagation can occur outside of action/reactive context #2195
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.
        var obs = derivation.observing_,
          l = obs.length;
        for (var i = 0; i < l; i++) {
          var obj = obs[i];
          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e) {
                // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            }
            // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
            // and `derivation` is an observer of `obj`
            // invariantShouldCompute(derivation)
            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }
        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
  }
}
function isComputingDerivation() {
  return globalState.trackingDerivation !== null; // filter out actions inside computations
}
function checkIfStateModificationsAreAllowed(atom) {
  if (true) {
    return;
  }
  var hasObservers = atom.observers_.size > 0;
  // Should not be possible to change observed state outside strict mode, except during initialization, see #563
  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always")) {
    console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
  }
}
function checkIfStateReadsAreAllowed(observable) {
  if (false) {}
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */
function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  // Preallocate array; will be trimmed by bindDependencies.
  derivation.newObserving_ = new Array(
  // Reserve constant space for initial dependencies, dynamic space otherwise.
  // See https://github.com/mobxjs/mobx/pull/3833
  derivation.runId_ === 0 ? 100 : derivation.observing_.length);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f.call(context);
  } else {
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function warnAboutDerivationWithoutDependencies(derivation) {
  if (true) {
    return;
  }
  if (derivation.observing_.length !== 0) {
    return;
  }
  if (typeof derivation.requiresObservable_ === "boolean" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */
function bindDependencies(derivation) {
  // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  // Go through all new observables and check diffValue: (this list can contain duplicates):
  //   0: first occurrence, change to 1 and keep it
  //   1: extra occurrence, drop it
  var i0 = 0,
    l = derivation.unboundDepsCount_;
  for (var i = 0; i < l; i++) {
    var dep = observing[i];
    if (dep.diffValue === 0) {
      dep.diffValue = 1;
      if (i0 !== i) {
        observing[i0] = dep;
      }
      i0++;
    }
    // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
    // not hitting the condition
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
  // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
  //   0: it's not in new observables, unobserve it
  //   1: it keeps being observed, don't want to notify it. change to 0
  l = prevObserving.length;
  while (l--) {
    var _dep = prevObserving[l];
    if (_dep.diffValue === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue = 0;
  }
  // Go through all new observables and check diffValue: (now it should be unique)
  //   0: it was set to 0 in last loop. don't need to do anything.
  //   1: it wasn't observed, let's observe it. set back to 0
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue === 1) {
      _dep2.diffValue = 0;
      addObserver(_dep2, derivation);
    }
  }
  // Some new observed derivations may become stale during this derivation computation
  // so they have had no chance to propagate staleness (#916)
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;
  while (i--) {
    removeObserver(obs[i], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action) {
  var prev = untrackedStart();
  try {
    return action();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
    return;
  }
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;
  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}

/**
 * These values will persist if global state is reset
 */
var persistentKeys = (/* unused pure expression or super */ null && (["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"]));
var MobXGlobals = function MobXGlobals() {
  /**
   * MobXGlobals version.
   * MobX compatiblity with other versions loaded in memory as long as this version matches.
   * It indicates that the global state still stores similar information
   *
   * N.B: this version is unrelated to the package version of MobX, and is only the version of the
   * internal state storage of MobX, and can be the same across many different package versions
   */
  this.version = 6;
  /**
   * globally unique token to signal unchanged
   */
  this.UNCHANGED = {};
  /**
   * Currently running derivation
   */
  this.trackingDerivation = null;
  /**
   * Currently running reaction. This determines if we currently have a reactive context.
   * (Tracking derivation is also set for temporal tracking of computed values inside actions,
   * but trackingReaction can only be set by a form of Reaction)
   */
  this.trackingContext = null;
  /**
   * Each time a derivation is tracked, it is assigned a unique run-id
   */
  this.runId = 0;
  /**
   * 'guid' for general purpose. Will be persisted amongst resets.
   */
  this.mobxGuid = 0;
  /**
   * Are we in a batch block? (and how many of them)
   */
  this.inBatch = 0;
  /**
   * Observables that don't have observers anymore, and are about to be
   * suspended, unless somebody else accesses it in the same batch
   *
   * @type {IObservable[]}
   */
  this.pendingUnobservations = [];
  /**
   * List of scheduled, not yet executed, reactions.
   */
  this.pendingReactions = [];
  /**
   * Are we currently processing reactions?
   */
  this.isRunningReactions = false;
  /**
   * Is it allowed to change observables at this point?
   * In general, MobX doesn't allow that when running computations and React.render.
   * To ensure that those functions stay pure.
   */
  this.allowStateChanges = false;
  /**
   * Is it allowed to read observables at this point?
   * Used to hold the state needed for `observableRequiresReaction`
   */
  this.allowStateReads = true;
  /**
   * If strict mode is enabled, state changes are by default not allowed
   */
  this.enforceActions = true;
  /**
   * Spy callbacks
   */
  this.spyListeners = [];
  /**
   * Globally attached error handlers that react specifically to errors in reactions
   */
  this.globalReactionErrorHandlers = [];
  /**
   * Warn if computed values are accessed outside a reactive context
   */
  this.computedRequiresReaction = false;
  /**
   * (Experimental)
   * Warn if you try to create to derivation / reactive context without accessing any observable.
   */
  this.reactionRequiresObservable = false;
  /**
   * (Experimental)
   * Warn if observables are accessed outside a reactive context
   */
  this.observableRequiresReaction = false;
  /*
   * Don't catch and rethrow exceptions. This is useful for inspecting the state of
   * the stack when an exception occurs while debugging.
   */
  this.disableErrorBoundaries = false;
  /*
   * If true, we are already handling an exception in an action. Any errors in reactions should be suppressed, as
   * they are not the cause, see: https://github.com/mobxjs/mobx/issues/1836
   */
  this.suppressReactionErrors = false;
  this.useProxies = true;
  /*
   * print warnings about code that would fail if proxies weren't available
   */
  this.verifyProxies = false;
  /**
   * False forces all object's descriptors to
   * writable: true
   * configurable: true
   */
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /*#__PURE__*/function () {
  var global = /*#__PURE__*/getGlobal();
  if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) {
    canMergeGlobalState = false;
  }
  if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) {
    canMergeGlobalState = false;
  }
  if (!canMergeGlobalState) {
    // Because this is a IIFE we need to let isolateCalled a chance to change
    // so we run it after the event loop completed at least 1 iteration
    setTimeout(function () {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global.__mobxGlobals) {
    global.__mobxInstanceCount += 1;
    if (!global.__mobxGlobals.UNCHANGED) {
      global.__mobxGlobals.UNCHANGED = {};
    } // make merge backward compatible
    return global.__mobxGlobals;
  } else {
    global.__mobxInstanceCount = 1;
    return global.__mobxGlobals = /*#__PURE__*/new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {
    die(36);
  }
  isolateCalled = true;
  if (canMergeGlobalState) {
    var global = getGlobal();
    if (--global.__mobxInstanceCount === 0) {
      global.__mobxGlobals = undefined;
    }
    globalState = new MobXGlobals();
  }
}
function getGlobalState() {
  return globalState;
}
/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */
function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();
  for (var key in defaultGlobals) {
    if (persistentKeys.indexOf(key) === -1) {
      globalState[key] = defaultGlobals[key];
    }
  }
  globalState.allowStateChanges = !globalState.enforceActions;
}

function hasObservers(observable) {
  return observable.observers_ && observable.observers_.size > 0;
}
function getObservers(observable) {
  return observable.observers_;
}
// function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }
function addObserver(observable, node) {
  // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
  // invariantObservers(observable);
  observable.observers_.add(node);
  if (observable.lowestObserverState_ > node.dependenciesState_) {
    observable.lowestObserverState_ = node.dependenciesState_;
  }
  // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}
function removeObserver(observable, node) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
  // invariantObservers(observable);
  observable.observers_["delete"](node);
  if (observable.observers_.size === 0) {
    // deleting last observer
    queueForUnobservation(observable);
  }
  // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");
}
function queueForUnobservation(observable) {
  if (observable.isPendingUnobservation === false) {
    // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
    observable.isPendingUnobservation = true;
    globalState.pendingUnobservations.push(observable);
  }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    // the batch is actually about to finish, all unobserving should happen here.
    var list = globalState.pendingUnobservations;
    for (var i = 0; i < list.length; i++) {
      var observable = list[i];
      observable.isPendingUnobservation = false;
      if (observable.observers_.size === 0) {
        if (observable.isBeingObserved) {
          // if this observable had reactive observers, trigger the hooks
          observable.isBeingObserved = false;
          observable.onBUO();
        }
        if (observable instanceof ComputedValue) {
          // computed values are automatically teared down when the last observer leaves
          // this process happens recursively, this computed might be the last observabe of another, etc..
          observable.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable) {
  checkIfStateReadsAreAllowed(observable);
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    /**
     * Simple optimization, give each derivation run an unique id (runId)
     * Check if last time this observable was accessed the same runId is used
     * if this is the case, the relation is already known
     */
    if (derivation.runId_ !== observable.lastAccessedBy_) {
      observable.lastAccessedBy_ = derivation.runId_;
      // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable;
      if (!observable.isBeingObserved && globalState.trackingContext) {
        observable.isBeingObserved = true;
        observable.onBO();
      }
    }
    return observable.isBeingObserved;
  } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable);
  }
  return false;
}
// function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }
/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */
// Called by Atom when its value changes
function propagateChanged(observable) {
  // invariantLOS(observable, "changed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable.lowestObserverState_ = IDerivationState_.STALE_;
  // Ideally we use for..of here, but the downcompiled version is really slow...
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if (false) {}
      d.onBecomeStale_();
    }
    d.dependenciesState_ = IDerivationState_.STALE_;
  });
  // invariantLOS(observable, "changed end");
}
// Called by ComputedValue when it recalculate and its value changed
function propagateChangeConfirmed(observable) {
  // invariantLOS(observable, "confirmed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable.lowestObserverState_ = IDerivationState_.STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d.dependenciesState_ = IDerivationState_.STALE_;
      if (false) {}
    } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.
    ) {
      observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
  // invariantLOS(observable, "confirmed end");
}
// Used by computed when its dependency changed, but we don't wan't to immediately recompute.
function propagateMaybeChanged(observable) {
  // invariantLOS(observable, "maybe start");
  if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
    return;
  }
  observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d.onBecomeStale_();
    }
  });
  // invariantLOS(observable, "maybe end");
}
function logTraceInfo(derivation, observable) {
  console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable.name_ + "'");
  if (derivation.isTracing_ === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1);
    // prettier-ignore
    new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}
function printDepTree(tree, lines, depth) {
  if (lines.length >= 1000) {
    lines.push("(and many more)");
    return;
  }
  lines.push("" + "\t".repeat(depth - 1) + tree.name);
  if (tree.dependencies) {
    tree.dependencies.forEach(function (child) {
      return printDepTree(child, lines, depth + 1);
    });
  }
}

var Reaction = /*#__PURE__*/function () {
  function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ =  false ? 0 : "Reaction";
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    // nodes we are looking at. Our value depends on these nodes
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.flags_ = 0;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled) {
      this.isScheduled = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  }
  /**
   * internal, use schedule() if you intend to kick off a reaction
   */;
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed) {
      startBatch();
      this.isScheduled = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;
      if (shouldCompute(this)) {
        this.isTrackPending = true;
        try {
          this.onInvalidate_();
          if (false) {}
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }
      globalState.trackingContext = prev;
      endBatch();
    }
  };
  _proto.track = function track(fn) {
    if (this.isDisposed) {
      return;
      // console.warn("Reaction already disposed") // Note: Not a warning / error in mobx 4 either
    }
    startBatch();
    var notify = isSpyEnabled();
    var startTime;
    if (false) {}
    this.isRunning = true;
    var prevReaction = globalState.trackingContext; // reactions could create reactions...
    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, undefined);
    globalState.trackingContext = prevReaction;
    this.isRunning = false;
    this.isTrackPending = false;
    if (this.isDisposed) {
      // disposed during last run. Clean up everything that was bound after the dispose call.
      clearObserving(this);
    }
    if (isCaughtException(result)) {
      this.reportExceptionInDerivation_(result.cause);
    }
    if (false) {}
    endBatch();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState.disableErrorBoundaries) {
      throw error;
    }
    var message =  false ? 0 : "[mobx] uncaught error in '" + this + "'";
    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
      /** If debugging brought you here, please, read the above message :-). Tnx! */
    } else if (false) {} // prettier-ignore
    if (false) {}
    globalState.globalReactionErrorHandlers.forEach(function (f) {
      return f(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed) {
      this.isDisposed = true;
      if (!this.isRunning) {
        // if disposed while running, clean up later. Maybe not optimal, but rare case
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_(abortSignal) {
    var _this2 = this;
    var dispose = function dispose() {
      _this2.dispose();
      abortSignal == null || abortSignal.removeEventListener == null || abortSignal.removeEventListener("abort", dispose);
    };
    abortSignal == null || abortSignal.addEventListener == null || abortSignal.addEventListener("abort", dispose);
    dispose[$mobx] = this;
    return dispose;
  };
  _proto.toString = function toString() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }
    trace(this, enterBreakPoint);
  };
  return _createClass(Reaction, [{
    key: "isDisposed",
    get: function get() {
      return getFlag(this.flags_, Reaction.isDisposedMask_);
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction.isDisposedMask_, newValue);
    }
  }, {
    key: "isScheduled",
    get: function get() {
      return getFlag(this.flags_, Reaction.isScheduledMask_);
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction.isScheduledMask_, newValue);
    }
  }, {
    key: "isTrackPending",
    get: function get() {
      return getFlag(this.flags_, Reaction.isTrackPendingMask_);
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction.isTrackPendingMask_, newValue);
    }
  }, {
    key: "isRunning",
    get: function get() {
      return getFlag(this.flags_, Reaction.isRunningMask_);
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction.isRunningMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get() {
      return getFlag(this.flags_, Reaction.diffValueMask_) ? 1 : 0;
    },
    set: function set(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
Reaction.isDisposedMask_ = 1;
Reaction.isScheduledMask_ = 2;
Reaction.isTrackPendingMask_ = 4;
Reaction.isRunningMask_ = 8;
Reaction.diffValueMask_ = 16;
function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function () {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0) {
      globalState.globalReactionErrorHandlers.splice(idx, 1);
    }
  };
}
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function reactionScheduler(f) {
  return f();
};
function runReactions() {
  // Trampolining, if runReactions are already running, new reactions will be picked up
  if (globalState.inBatch > 0 || globalState.isRunningReactions) {
    return;
  }
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  // While running reactions, new reactions might be triggered.
  // Hence we work with two variables and check whether
  // we converge to no remaining reactions after a while.
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error( false ? 0 : "[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0); // clear reactions
    }
    var remainingReactions = allReactions.splice(0);
    for (var i = 0, l = remainingReactions.length; i < l; i++) {
      remainingReactions[i].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
var isReaction = /*#__PURE__*/createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function reactionScheduler(f) {
    return fn(function () {
      return baseScheduler(f);
    });
  };
}

function isSpyEnabled() {
  return  false && 0;
}
function spyReport(event) {
  if (true) {
    return;
  } // dead code elimination can do the rest
  if (!globalState.spyListeners.length) {
    return;
  }
  var listeners = globalState.spyListeners;
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](event);
  }
}
function spyReportStart(event) {
  if (true) {
    return;
  }
  var change = _extends({}, event, {
    spyReportStart: true
  });
  spyReport(change);
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: true
};
function spyReportEnd(change) {
  if (true) {
    return;
  }
  if (change) {
    spyReport(_extends({}, change, {
      type: "report-end",
      spyReportEnd: true
    }));
  } else {
    spyReport(END_EVENT);
  }
}
function spy(listener) {
  if (true) {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function () {};
  } else {}
}

var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /*#__PURE__*/createActionAnnotation(ACTION);
var actionBoundAnnotation = /*#__PURE__*/createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});
function createActionFactory(autoAction) {
  var res = function action(arg1, arg2) {
    // action(fn() {})
    if (isFunction(arg1)) {
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction);
    }
    // action("name", fn() {})
    if (isFunction(arg2)) {
      return createAction(arg1, arg2, autoAction);
    }
    // @action (2022.3 Decorators)
    if (is20223Decorator(arg2)) {
      return (autoAction ? autoActionAnnotation : actionAnnotation).decorate_20223_(arg1, arg2);
    }
    // @action
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);
    }
    // action("name") & @action("name")
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction
      }));
    }
    if (false) {}
  };
  return res;
}
var action = /*#__PURE__*/createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /*#__PURE__*/createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /*#__PURE__*/createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /*#__PURE__*/createDecoratorAnnotation(autoActionBoundAnnotation);
function mobx_esm_runInAction(fn) {
  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);
}
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}

/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */
function autorun(view, opts) {
  var _opts$name, _opts, _opts2, _opts3;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (false) {}
  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name :  false ? 0 : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;
  if (runSync) {
    // normal autorun
    reaction = new Reaction(name, function () {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts);
    // debounced autorun
    var isScheduled = false;
    reaction = new Reaction(name, function () {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function () {
          isScheduled = false;
          if (!reaction.isDisposed) {
            reaction.track(reactionRunner);
          }
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction);
  }
  if (!((_opts2 = opts) != null && (_opts2 = _opts2.signal) != null && _opts2.aborted)) {
    reaction.schedule_();
  }
  return reaction.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);
}
var run = function run(f) {
  return f();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {
    return setTimeout(f, opts.delay);
  } : run;
}
function reaction(expression, effect, opts) {
  var _opts$name2, _opts4, _opts5;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (false) {}
  var name = (_opts$name2 = opts.name) != null ? _opts$name2 :  false ? 0 : "Reaction";
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r = new Reaction(name, function () {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);
  function reactionRunner() {
    isScheduled = false;
    if (r.isDisposed) {
      return;
    }
    var changed = false;
    var oldValue = value;
    r.track(function () {
      var nextValue = allowStateChanges(false, function () {
        return expression(r);
      });
      changed = firstTime || !equals(value, nextValue);
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) {
      effectAction(value, oldValue, r);
    } else if (!firstTime && changed) {
      effectAction(value, oldValue, r);
    }
    firstTime = false;
  }
  if (!((_opts4 = opts) != null && (_opts4 = _opts4.signal) != null && _opts4.aborted)) {
    r.schedule_();
  }
  return r.getDisposer_((_opts5 = opts) == null ? void 0 : _opts5.signal);
}
function wrapErrorHandler(errorHandler, baseFn) {
  return function () {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}

var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = new Set([cb]);
  }
  return function () {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}

var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed";
// const IF_AVAILABLE = "ifavailable"
function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }
  var useProxies = options.useProxies,
    enforceActions = options.enforceActions;
  if (useProxies !== undefined) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }
  if (useProxies === "ifavailable") {
    globalState.verifyProxies = true;
  }
  if (enforceActions !== undefined) {
    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function (key) {
    if (key in options) {
      globalState[key] = !!options[key];
    }
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;
  if (false) {}
  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}

function extendObservable(target, properties, annotations, options) {
  if (false) {}
  // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)
  var descriptors = getOwnPropertyDescriptors(properties);
  initObservable(function () {
    var adm = asObservableObject(target, options)[$mobx];
    ownKeys(descriptors).forEach(function (key) {
      adm.extend_(key, descriptors[key],
      // must pass "undefined" for { key: undefined }
      !annotations ? true : key in annotations ? annotations[key] : true);
    });
  });
  return target;
}

function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) {
    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  }
  return result;
}
function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}
function nodeToObserverTree(node) {
  var result = {
    name: node.name_
  };
  if (hasObservers(node)) {
    result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
  }
  return result;
}
function unique(list) {
  return Array.from(new Set(list));
}

var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /*#__PURE__*/Object.create(Error.prototype);
function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}
var flowAnnotation = /*#__PURE__*/createFlowAnnotation("flow");
var flowBoundAnnotation = /*#__PURE__*/createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /*#__PURE__*/Object.assign(function flow(arg1, arg2) {
  // @flow (2022.3 Decorators)
  if (is20223Decorator(arg2)) {
    return flowAnnotation.decorate_20223_(arg1, arg2);
  }
  // @flow
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  }
  // flow(fn)
  if (false) {}
  var generator = arg1;
  var name = generator.name || "<unnamed flow>";
  // Implementation based on https://github.com/tj/co/blob/master/index.js
  var res = function res() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = undefined;
    var promise = new Promise(function (resolve, reject) {
      var stepId = 0;
      rejector = reject;
      function onFulfilled(res) {
        pendingPromise = undefined;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function onRejected(err) {
        pendingPromise = undefined;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          // an async iterator
          ret.then(next, reject);
          return;
        }
        if (ret.done) {
          return resolve(ret.value);
        }
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(undefined); // kick off the process
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function () {
      try {
        if (pendingPromise) {
          cancelPromise(pendingPromise);
        }
        // Finally block can return (or yield) stuff..
        var _res = gen["return"](undefined);
        // eat anything that promise would do, it's cancelled!
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise); // maybe it can be cancelled :)
        // reject our original promise
        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e); // there could be a throwing finally block
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /*#__PURE__*/createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(promise) {
  if (isFunction(promise.cancel)) {
    promise.cancel();
  }
}
function flowResult(result) {
  return result; // just tricking TypeScript :)
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}

function interceptReads(thing, propOrHandler, handler) {
  var target;
  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    if (false) {}
    target = getAdministration(thing, propOrHandler);
  } else if (false) {}
  if (false) {}
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function () {
    target.dehancer = undefined;
  };
}

function intercept(thing, propOrHandler, handler) {
  if (isFunction(handler)) {
    return interceptProperty(thing, propOrHandler, handler);
  } else {
    return interceptInterceptable(thing, propOrHandler);
  }
}
function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept_(handler);
}
function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept_(handler);
}

function _isComputed(value, property) {
  if (property === undefined) {
    return isComputedValue(value);
  }
  if (isObservableObject(value) === false) {
    return false;
  }
  if (!value[$mobx].values_.has(property)) {
    return false;
  }
  var atom = getAtom(value, property);
  return isComputedValue(atom);
}
function isComputed(value) {
  if (false) {}
  return _isComputed(value);
}
function isComputedProp(value, propName) {
  if (false) {}
  return _isComputed(value, propName);
}

function _isObservable(value, property) {
  if (!value) {
    return false;
  }
  if (property !== undefined) {
    if (false) {}
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }
    return false;
  }
  // For first check, see #701
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  if (false) {}
  return _isObservable(value);
}
function isObservableProp(value, propName) {
  if (false) {}
  return _isObservable(value, propName);
}

function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].keys_();
  }
  if (isObservableMap(obj) || isObservableSet(obj)) {
    return Array.from(obj.keys());
  }
  if (isObservableArray(obj)) {
    return obj.map(function (_, index) {
      return index;
    });
  }
  die(5);
}
function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return obj[key];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return obj.get(key);
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }
  if (isObservableArray(obj)) {
    return obj.slice();
  }
  die(6);
}
function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj[key]];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj.get(key)];
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }
  if (isObservableArray(obj)) {
    return obj.map(function (key, index) {
      return [index, key];
    });
  }
  die(7);
}
function set(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var _values = key;
    try {
      for (var _key in _values) {
        set(obj, _key, _values[_key]);
      }
    } finally {
      endBatch();
    }
    return;
  }
  if (isObservableObject(obj)) {
    obj[$mobx].set_(key, value);
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") {
      key = parseInt(key, 10);
    }
    if (key < 0) {
      die("Invalid index: '" + key + "'");
    }
    startBatch();
    if (key >= obj.length) {
      obj.length = key + 1;
    }
    obj[key] = value;
    endBatch();
  } else {
    die(8);
  }
}
function remove(obj, key) {
  if (isObservableObject(obj)) {
    obj[$mobx].delete_(key);
  } else if (isObservableMap(obj)) {
    obj["delete"](key);
  } else if (isObservableSet(obj)) {
    obj["delete"](key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") {
      key = parseInt(key, 10);
    }
    obj.splice(key, 1);
  } else {
    die(9);
  }
}
function has(obj, key) {
  if (isObservableObject(obj)) {
    return obj[$mobx].has_(key);
  } else if (isObservableMap(obj)) {
    return obj.has(key);
  } else if (isObservableSet(obj)) {
    return obj.has(key);
  } else if (isObservableArray(obj)) {
    return key >= 0 && key < obj.length;
  }
  die(10);
}
function get(obj, key) {
  if (!has(obj, key)) {
    return undefined;
  }
  if (isObservableObject(obj)) {
    return obj[$mobx].get_(key);
  } else if (isObservableMap(obj)) {
    return obj.get(key);
  } else if (isObservableArray(obj)) {
    return obj[key];
  }
  die(11);
}
function apiDefineProperty(obj, key, descriptor) {
  if (isObservableObject(obj)) {
    return obj[$mobx].defineProperty_(key, descriptor);
  }
  die(39);
}
function apiOwnKeys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].ownKeys_();
  }
  die(38);
}

function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction(cbOrFire)) {
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
  } else {
    return observeObservable(thing, propOrCb, cbOrFire);
  }
}
function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}

function cache(map, key, value) {
  map.set(key, value);
  return value;
}
function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) {
    return source;
  }
  if (isObservableValue(source) || isComputedValue(source)) {
    return toJSHelper(source.get(), __alreadySeen);
  }
  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }
  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function (value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }
  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, new Set());
    source.forEach(function (value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }
  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, new Map());
    source.forEach(function (value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    // must be observable object
    var _res3 = cache(__alreadySeen, source, {});
    apiOwnKeys(source).forEach(function (key) {
      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
        _res3[key] = toJSHelper(source[key], __alreadySeen);
      }
    });
    return _res3;
  }
}
/**
 * Recursively converts an observable to it's non-observable native counterpart.
 * It does NOT recurse into non-observables, these are left as they are, even if they contain observables.
 * Computed and other non-enumerable properties are completely ignored.
 * Complex scenarios require custom solution, eg implementing `toJSON` or using `serializr` lib.
 */
function toJS(source, options) {
  if (false) {}
  return toJSHelper(source, new Map());
}

function trace() {
  if (true) {
    return;
  }
  var enterBreakPoint = false;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[args.length - 1] === "boolean") {
    enterBreakPoint = args.pop();
  }
  var derivation = getAtomFromArgs(args);
  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }
  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }
  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(args[0]);
    case 2:
      return getAtom(args[0], args[1]);
  }
}

/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */
function transaction(action, thisArg) {
  if (thisArg === void 0) {
    thisArg = undefined;
  }
  startBatch();
  try {
    return action.apply(thisArg);
  } finally {
    endBatch();
  }
}

function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object") {
    return whenPromise(predicate, arg1);
  }
  return _when(predicate, arg1, arg2 || {});
}
function _when(predicate, effect, opts) {
  var timeoutHandle;
  if (typeof opts.timeout === "number") {
    var error = new Error("WHEN_TIMEOUT");
    timeoutHandle = setTimeout(function () {
      if (!disposer[$mobx].isDisposed) {
        disposer();
        if (opts.onError) {
          opts.onError(error);
        } else {
          throw error;
        }
      }
    }, opts.timeout);
  }
  opts.name =  false ? 0 : "When";
  var effectAction = createAction( false ? 0 : "When-effect", effect);
  // eslint-disable-next-line
  var disposer = autorun(function (r) {
    // predicate should not change state
    var cond = allowStateChanges(false, predicate);
    if (cond) {
      r.dispose();
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
      effectAction();
    }
  }, opts);
  return disposer;
}
function whenPromise(predicate, opts) {
  var _opts$signal;
  if (false) {}
  if (opts != null && (_opts$signal = opts.signal) != null && _opts$signal.aborted) {
    return Object.assign(Promise.reject(new Error("WHEN_ABORTED")), {
      cancel: function cancel() {
        return null;
      }
    });
  }
  var cancel;
  var abort;
  var res = new Promise(function (resolve, reject) {
    var _opts$signal2;
    var disposer = _when(predicate, resolve, _extends({}, opts, {
      onError: reject
    }));
    cancel = function cancel() {
      disposer();
      reject(new Error("WHEN_CANCELLED"));
    };
    abort = function abort() {
      disposer();
      reject(new Error("WHEN_ABORTED"));
    };
    opts == null || (_opts$signal2 = opts.signal) == null || _opts$signal2.addEventListener == null || _opts$signal2.addEventListener("abort", abort);
  })["finally"](function () {
    var _opts$signal3;
    return opts == null || (_opts$signal3 = opts.signal) == null || _opts$signal3.removeEventListener == null ? void 0 : _opts$signal3.removeEventListener("abort", abort);
  });
  res.cancel = cancel;
  return res;
}

function getAdm(target) {
  return target[$mobx];
}
// Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,
// and skip either the internal values map, or the base object with its property descriptors!
var objectProxyTraps = {
  has: function has(target, name) {
    if (false) {}
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set(target, name, value) {
    var _getAdm$set_;
    if (!isStringish(name)) {
      return false;
    }
    if (false) {}
    // null (intercepted) -> true (success)
    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;
    if (false) {}
    if (!isStringish(name)) {
      return false;
    }
    // null (intercepted) -> true (success)
    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty(target, name, descriptor) {
    var _getAdm$definePropert;
    if (false) {}
    // null (intercepted) -> true (success)
    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys(target) {
    if (false) {}
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}

function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function () {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) {
      interceptors.splice(idx, 1);
    }
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i = 0, l = interceptors.length; i < l; i++) {
      change = interceptors[i](change);
      if (change && !change.type) {
        die(14);
      }
      if (!change) {
        break;
      }
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}

function hasListeners(listenable) {
  return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function () {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) {
    return;
  }
  listeners = listeners.slice();
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](change);
  }
  untrackedEnd(prevU);
}

function makeObservable(target, annotations, options) {
  initObservable(function () {
    var _annotations;
    var adm = asObservableObject(target, options)[$mobx];
    if (false) {}
    // Default to decorators
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
    // Annotate
    ownKeys(annotations).forEach(function (key) {
      return adm.make_(key, annotations[key]);
    });
  });
  return target;
}
// proto[keysSymbol] = new Set<PropertyKey>()
var keysSymbol = /*#__PURE__*/Symbol("mobx-keys");
function makeAutoObservable(target, overrides, options) {
  if (false) {}
  // Optimization: avoid visiting protos
  // Assumes that annotation.make_/.extend_ works the same for plain objects
  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options);
  }
  initObservable(function () {
    var adm = asObservableObject(target, options)[$mobx];
    // Optimization: cache keys on proto
    // Assumes makeAutoObservable can be called only once per object and can't be used in subclass
    if (!target[keysSymbol]) {
      var proto = Object.getPrototypeOf(target);
      var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));
      keys["delete"]("constructor");
      keys["delete"]($mobx);
      addHiddenProp(proto, keysSymbol, keys);
    }
    target[keysSymbol].forEach(function (key) {
      return adm.make_(key,
      // must pass "undefined" for { key: undefined }
      !overrides ? true : key in overrides ? overrides[key] : true);
    });
  });
  return target;
}

var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859
var arrayTraps = {
  get: function get(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) {
      return adm;
    }
    if (name === "length") {
      return adm.getArrayLength_();
    }
    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }
    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }
    return target[name];
  },
  set: function set(target, name, value) {
    var adm = target[$mobx];
    if (name === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      // numeric string
      adm.set_(parseInt(name), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions() {
    die(15);
  }
};
var ObservableArrayAdministration = /*#__PURE__*/function () {
  function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name =  false ? 0 : "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    // this is the prop that gets proxied, so can't replace it!
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);
    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV,  false ? 0 : "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== undefined && values.length > 0) {
      return values.map(this.dehancer);
    }
    return values;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
      die("Out of range: " + newLength);
    }
    var currentLength = this.values_.length;
    if (newLength === currentLength) {
      return;
    } else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = undefined;
      } // No Array.fill everywhere...
      this.spliceWithArray_(currentLength, 0, newItems);
    } else {
      this.spliceWithArray_(newLength, currentLength - newLength);
    }
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) {
      die(16);
    }
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) {
      reserveArrayBuffer(oldLength + delta + 1);
    }
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index === undefined) {
      index = 0;
    } else if (index > length) {
      index = length;
    } else if (index < 0) {
      index = Math.max(0, length + index);
    }
    if (arguments.length === 1) {
      deleteCount = length - index;
    } else if (deleteCount === undefined || deleteCount === null) {
      deleteCount = 0;
    } else {
      deleteCount = Math.max(0, Math.min(deleteCount, length - index));
    }
    if (newItems === undefined) {
      newItems = EMPTY_ARRAY;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) {
        return EMPTY_ARRAY;
      }
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {
      return _this.enhancer_(v, undefined);
    });
    if (this.legacyMode_ || "production" !== "production") {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified
    }
    var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) {
      this.notifyArraySplice_(index, newItems, res);
    }
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
    } else {
      // The items removed by the splice
      var res = this.values_.slice(index, index + deleteCount);
      // The items that that should remain at the end of the array
      var oldItems = this.values_.slice(index + deleteCount);
      // New length is the previous length + addition count - deletion count
      this.values_.length += newItems.length - deleteCount;
      for (var i = 0; i < newItems.length; i++) {
        this.values_[index + i] = newItems[i];
      }
      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index + newItems.length + _i] = oldItems[_i];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index,
      newValue: newValue,
      oldValue: oldValue
    } : null;
    // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't
    // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled
    if (false) {}
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
    if (false) {}
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index,
      removed: removed,
      added: added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if (false) {}
    this.atom_.reportChanged();
    // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
    if (notify) {
      notifyListeners(this, change);
    }
    if (false) {}
  };
  _proto.get_ = function get_(index) {
    if (this.legacyMode_ && index >= this.values_.length) {
      console.warn( false ? 0 : "[mobx] Out of bounds read: " + index);
      return undefined;
    }
    this.atom_.reportObserved();
    return this.dehanceValue_(this.values_[index]);
  };
  _proto.set_ = function set_(index, newValue) {
    var values = this.values_;
    if (this.legacyMode_ && index > values.length) {
      // out of bounds
      die(17, index, values.length);
    }
    if (index < values.length) {
      // update at index in range
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index];
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index: index,
          newValue: newValue
        });
        if (!change) {
          return;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values[index] = newValue;
        this.notifyArrayChildUpdate_(index, newValue, oldValue);
      }
    } else {
      // For out of bound index, we don't create an actual sparse array,
      // but rather fill the holes with undefined (same as setArrayLength_).
      // This could be considered a bug.
      var newItems = new Array(index + 1 - values.length);
      for (var i = 0; i < newItems.length - 1; i++) {
        newItems[i] = undefined;
      } // No Array.fill everywhere...
      newItems[newItems.length - 1] = newValue;
      this.spliceWithArray_(values.length, 0, newItems);
    }
  };
  return ObservableArrayAdministration;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name =  false ? 0 : "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  return initObservable(function () {
    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      adm.spliceWithArray_(0, 0, initialValues);
    }
    return proxy;
  });
}
// eslint-disable-next-line
var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index);
      case 2:
        return adm.spliceWithArray_(index, deleteCount);
    }
    return adm.spliceWithArray_(index, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];
    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    // reverse by default mutates in place before returning the result
    // which makes it both a 'derivation' and a 'mutation'.
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    // sort by default mutates in place before returning the result
    // which goes against all good practices. Let's not change the array in place!
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }
    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
/**
 * Wrap function from prototype
 * Without this, everything works as well, but this works
 * faster as everything works on unproxied values
 */
addArrayExtension("at", simpleFunc);
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("toSorted", simpleFunc);
addArrayExtension("toSpliced", simpleFunc);
addArrayExtension("with", simpleFunc);
// map
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("findLast", mapLikeFunc);
addArrayExtension("findLastIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("toReversed", mapLikeFunc);
// reduce
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
// Report and delegate to dehanced array
function simpleFunc(funcName) {
  return function () {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
// Make sure callbacks receive correct array arg #2326
function mapLikeFunc(funcName) {
  return function (callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function (element, index) {
      return callback.call(thisArg, element, index, _this2);
    });
  };
}
// Make sure callbacks receive correct array arg #2326
function reduceLikeFunc(funcName) {
  return function () {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    // #2432 - reduce behavior depends on arguments.length
    var callback = arguments[0];
    arguments[0] = function (accumulator, currentValue, index) {
      return callback(accumulator, currentValue, index, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}

var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete";
// just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54
// But: https://github.com/mobxjs/mobx/issues/1556
var ObservableMap = /*#__PURE__*/function () {
  function ObservableMap(initialData, enhancer_, name_) {
    var _this = this;
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ =  false ? 0 : "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    // hasMap, not hashMap >-).
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction(Map)) {
      die(18);
    }
    initObservable(function () {
      _this.keysAtom_ = createAtom( false ? 0 : "ObservableMap.keys()");
      _this.data_ = new Map();
      _this.hasMap_ = new Map();
      if (initialData) {
        _this.merge(initialData);
      }
    });
  }
  var _proto = ObservableMap.prototype;
  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };
  _proto.has = function has(key) {
    var _this2 = this;
    if (!globalState.trackingDerivation) {
      return this.has_(key);
    }
    var entry = this.hasMap_.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer,  false ? 0 : "ObservableMap.key?", false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function () {
        return _this2.hasMap_["delete"](key);
      });
    }
    return entry.get();
  };
  _proto.set = function set(key, value) {
    var hasKey = this.has_(key);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) {
        return this;
      }
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) {
        return false;
      }
    }
    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;
      if (false) {} // TODO fix type
      transaction(function () {
        var _this3$hasMap_$get;
        _this3.keysAtom_.reportChanged();
        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null || _this3$hasMap_$get.setNewValue_(false);
        var observable = _this3.data_.get(key);
        observable.setNewValue_(undefined);
        _this3.data_["delete"](key);
      });
      if (notify) {
        notifyListeners(this, _change);
      }
      if (false) {}
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable = this.data_.get(key);
    newValue = observable.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;
      if (false) {} // TODO fix type
      observable.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, change);
      }
      if (false) {}
    }
  };
  _proto.addValue_ = function addValue_(key, newValue) {
    var _this4 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function () {
      var _this4$hasMap_$get;
      var observable = new ObservableValue(newValue, _this4.enhancer_,  false ? 0 : "ObservableMap.key", false);
      _this4.data_.set(key, observable);
      newValue = observable.value_; // value might have been changed
      (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null || _this4$hasMap_$get.setNewValue_(true);
      _this4.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue: newValue
    } : null;
    if (false) {} // TODO fix type
    if (notify) {
      notifyListeners(this, change);
    }
    if (false) {}
  };
  _proto.get = function get(key) {
    if (this.has(key)) {
      return this.dehanceValue_(this.data_.get(key).get());
    }
    return this.dehanceValue_(undefined);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values() {
    var self = this;
    var keys = this.keys();
    return makeIterableForMap({
      next: function next() {
        var _keys$next = keys.next(),
          done = _keys$next.done,
          value = _keys$next.value;
        return {
          done: done,
          value: done ? undefined : self.get(value)
        };
      }
    });
  };
  _proto.entries = function entries() {
    var self = this;
    var keys = this.keys();
    return makeIterableForMap({
      next: function next() {
        var _keys$next2 = keys.next(),
          done = _keys$next2.done,
          value = _keys$next2.value;
        return {
          done: done,
          value: done ? undefined : [value, self.get(value)]
        };
      }
    });
  };
  _proto[Symbol.iterator] = function () {
    return this.entries();
  };
  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
        key = _step$value[0],
        value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  }
  /** Merge another object into this object, returns this. */;
  _proto.merge = function merge(other) {
    var _this5 = this;
    if (isObservableMap(other)) {
      other = new Map(other);
    }
    transaction(function () {
      if (isPlainObject(other)) {
        getPlainObjectKeys(other).forEach(function (key) {
          return _this5.set(key, other[key]);
        });
      } else if (Array.isArray(other)) {
        other.forEach(function (_ref) {
          var key = _ref[0],
            value = _ref[1];
          return _this5.set(key, value);
        });
      } else if (isES6Map(other)) {
        if (!isPlainES6Map(other)) {
          die(19, other);
        }
        other.forEach(function (value, key) {
          return _this5.set(key, value);
        });
      } else if (other !== null && other !== undefined) {
        die(20, other);
      }
    });
    return this;
  };
  _proto.clear = function clear() {
    var _this6 = this;
    transaction(function () {
      untracked(function () {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done;) {
          var key = _step2.value;
          _this6["delete"](key);
        }
      });
    });
  };
  _proto.replace = function replace(values) {
    var _this7 = this;
    // Implementation requirements:
    // - respect ordering of replacement map
    // - allow interceptors to run and potentially prevent individual operations
    // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)
    // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)
    // - note that result map may differ from replacement map due to the interceptors
    transaction(function () {
      // Convert to map so we can do quick key lookups
      var replacementMap = convertToMap(values);
      var orderedData = new Map();
      // Used for optimization
      var keysReportChangedCalled = false;
      // Delete keys that don't exist in replacement map
      // if the key deletion is prevented by interceptor
      // add entry at the beginning of the result map
      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done;) {
        var key = _step3.value;
        // Concurrently iterating/deleting keys
        // iterator should handle this correctly
        if (!replacementMap.has(key)) {
          var deleted = _this7["delete"](key);
          // Was the key removed?
          if (deleted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          } else {
            // Delete prevented by interceptor
            var value = _this7.data_.get(key);
            orderedData.set(key, value);
          }
        }
      }
      // Merge entries
      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;) {
        var _step4$value = _step4.value,
          _key = _step4$value[0],
          _value = _step4$value[1];
        // We will want to know whether a new key is added
        var keyExisted = _this7.data_.has(_key);
        // Add or update value
        _this7.set(_key, _value);
        // The addition could have been prevent by interceptor
        if (_this7.data_.has(_key)) {
          // The update could have been prevented by interceptor
          // and also we want to preserve existing values
          // so use value from _data map (instead of replacement map)
          var _value2 = _this7.data_.get(_key);
          orderedData.set(_key, _value2);
          // Was a new key added?
          if (!keyExisted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          }
        }
      }
      // Check for possible key order change
      if (!keysReportChangedCalled) {
        if (_this7.data_.size !== orderedData.size) {
          // If size differs, keys are definitely modified
          _this7.keysAtom_.reportChanged();
        } else {
          var iter1 = _this7.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this7.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      // Use correctly ordered map
      _this7.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };
  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (false) {}
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  return _createClass(ObservableMap, [{
    key: "size",
    get: function get() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return "Map";
    }
  }]);
}();
// eslint-disable-next-line
var isObservableMap = /*#__PURE__*/createInstanceofPredicate("ObservableMap", ObservableMap);
function makeIterableForMap(iterator) {
  iterator[Symbol.toStringTag] = "MapIterator";
  return makeIterable(iterator);
}
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map = new Map();
    for (var key in dataStructure) {
      map.set(key, dataStructure[key]);
    }
    return map;
  } else {
    return die(21, dataStructure);
  }
}

var ObservableSetMarker = {};
var ObservableSet = /*#__PURE__*/function () {
  function ObservableSet(initialData, enhancer, name_) {
    var _this = this;
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ =  false ? 0 : "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction(Set)) {
      die(22);
    }
    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    initObservable(function () {
      _this.atom_ = createAtom(_this.name_);
      if (initialData) {
        _this.replace(initialData);
      }
    });
  }
  var _proto = ObservableSet.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear() {
    var _this2 = this;
    transaction(function () {
      untracked(function () {
        for (var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done;) {
          var value = _step.value;
          _this2["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add(value) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) {
        return this;
      }
      // ideally, value = change.value would be done here, so that values can be
      // changed by interceptor. Same applies for other Set and Map api's.
    }
    if (!this.has(value)) {
      transaction(function () {
        _this3.data_.add(_this3.enhancer_(value, undefined));
        _this3.atom_.reportChanged();
      });
      var notifySpy =  false && 0;
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;
      if (notifySpy && "production" !== "production") {}
      if (notify) {
        notifyListeners(this, _change);
      }
      if (notifySpy && "production" !== "production") {}
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this4 = this;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) {
        return false;
      }
    }
    if (this.has(value)) {
      var notifySpy =  false && 0;
      var notify = hasListeners(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;
      if (notifySpy && "production" !== "production") {}
      transaction(function () {
        _this4.atom_.reportChanged();
        _this4.data_["delete"](value);
      });
      if (notify) {
        notifyListeners(this, _change2);
      }
      if (notifySpy && "production" !== "production") {}
      return true;
    }
    return false;
  };
  _proto.has = function has(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterableForSet({
      next: function next() {
        var index = nextIndex;
        nextIndex += 1;
        return index < values.length ? {
          value: [keys[index], values[index]],
          done: false
        } : {
          value: undefined,
          done: true
        };
      }
    });
  };
  _proto.keys = function keys() {
    return this.values();
  };
  _proto.values = function values() {
    this.atom_.reportObserved();
    var self = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterableForSet({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          value: undefined,
          done: true
        };
      }
    });
  };
  _proto.intersection = function intersection(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.intersection(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.intersection(otherSet);
    }
  };
  _proto.union = function union(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.union(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.union(otherSet);
    }
  };
  _proto.difference = function difference(otherSet) {
    return new Set(this).difference(otherSet);
  };
  _proto.symmetricDifference = function symmetricDifference(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.symmetricDifference(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.symmetricDifference(otherSet);
    }
  };
  _proto.isSubsetOf = function isSubsetOf(otherSet) {
    return new Set(this).isSubsetOf(otherSet);
  };
  _proto.isSupersetOf = function isSupersetOf(otherSet) {
    return new Set(this).isSupersetOf(otherSet);
  };
  _proto.isDisjointFrom = function isDisjointFrom(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.isDisjointFrom(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.isDisjointFrom(otherSet);
    }
  };
  _proto.replace = function replace(other) {
    var _this5 = this;
    if (isObservableSet(other)) {
      other = new Set(other);
    }
    transaction(function () {
      if (Array.isArray(other)) {
        _this5.clear();
        other.forEach(function (value) {
          return _this5.add(value);
        });
      } else if (isES6Set(other)) {
        _this5.clear();
        other.forEach(function (value) {
          return _this5.add(value);
        });
      } else if (other !== null && other !== undefined) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    // ... 'fireImmediately' could also be true?
    if (false) {}
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };
  _proto.toString = function toString() {
    return "[object ObservableSet]";
  };
  _proto[Symbol.iterator] = function () {
    return this.values();
  };
  return _createClass(ObservableSet, [{
    key: "size",
    get: function get() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return "Set";
    }
  }]);
}();
// eslint-disable-next-line
var isObservableSet = /*#__PURE__*/createInstanceofPredicate("ObservableSet", ObservableSet);
function makeIterableForSet(iterator) {
  iterator[Symbol.toStringTag] = "SetIterator";
  return makeIterable(iterator);
}

var descriptorCache = /*#__PURE__*/Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /*#__PURE__*/function () {
  function ObservableObjectAdministration(target_, values_, name_,
  // Used anytime annotation is not explicitely provided
  defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom( false ? 0 : "ObservableObject.keys");
    // Optimization: we use this frequently
    this.isPlainObject_ = isPlainObject(this.target_);
    if (false) {}
    if (false) {}
  }
  var _proto = ObservableObjectAdministration.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable = this.values_.get(key);
    if (observable instanceof ComputedValue) {
      observable.set(newValue);
      return true;
    }
    // intercept
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: newValue
      });
      if (!change) {
        return null;
      }
      newValue = change.newValue;
    }
    newValue = observable.prepareNewValue_(newValue);
    // notify spy & observers
    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy =  false && 0;
      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;
      if (false) {}
      observable.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, _change);
      }
      if (false) {}
    }
    return true;
  };
  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      // Key doesn't exist yet, subscribe for it in case it's added later
      this.has_(key);
    }
    return this.target_[key];
  }
  /**
   * @param {PropertyKey} key
   * @param {any} value
   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */;
  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    // Don't use .has(key) - we care about own
    if (hasProp(this.target_, key)) {
      // Existing prop
      if (this.values_.has(key)) {
        // Observable (can be intercepted)
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        // Non-observable - proxy
        return Reflect.set(this.target_, key, value);
      } else {
        // Non-observable
        this.target_[key] = value;
        return true;
      }
    } else {
      // New prop
      return this.extend_(key, {
        value: value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  }
  // Trap for "in"
  ;
  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      // Skip key subscription outside derivation
      return key in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = new Map());
    var entry = this.pendingKeys_.get(key);
    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer,  false ? 0 : "ObservableObject.key?", false);
      this.pendingKeys_.set(key, entry);
    }
    return entry.get();
  }
  /**
   * @param {PropertyKey} key
   * @param {Annotation|boolean} annotation true - use default annotation, false - ignore prop
   */;
  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    assertAnnotable(this, annotation, key);
    if (!(key in this.target_)) {
      var _this$target_$storedA;
      // Throw on missing key, except for decorators:
      // Decorator annotations are collected from whole prototype chain.
      // When called from super() some props may not exist yet.
      // However we don't have to worry about missing prop,
      // because the decorator must have been applied to something.
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
        return; // will be annotated by subclass constructor
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);
      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0 /* MakeResult.Cancel */) {
          return;
        }
        if (outcome === 1 /* MakeResult.Break */) {
          break;
        }
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied(this, annotation, key);
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */;
  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }
    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }
    return outcome;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */;
  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      // Delete
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      }
      // ADD interceptor
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) {
          return null;
        }
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      }
      // Define
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      // Notify
      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }
    return true;
  }
  // If original descriptor becomes relevant, move this to annotation directly
  ;
  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      // Delete
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      }
      // ADD interceptor
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) {
          return null;
        }
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      // Define
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      var observable = new ObservableValue(value, enhancer,  false ? 0 : "ObservableObject.key", false);
      this.values_.set(key, observable);
      // Notify (value possibly changed by ObservableValue)
      this.notifyPropertyAddition_(key, observable.value_);
    } finally {
      endBatch();
    }
    return true;
  }
  // If original descriptor becomes relevant, move this to annotation directly
  ;
  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      // Delete
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      }
      // ADD interceptor
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: undefined
        });
        if (!change) {
          return null;
        }
      }
      options.name || (options.name =  false ? 0 : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      // Define
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.values_.set(key, new ComputedValue(options));
      // Notify
      this.notifyPropertyAddition_(key, undefined);
    } finally {
      endBatch();
    }
    return true;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */;
  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    // No such prop
    if (!hasProp(this.target_, key)) {
      return true;
    }
    // Intercept
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      });
      // Cancelled
      if (!change) {
        return null;
      }
    }
    // Delete
    try {
      var _this$pendingKeys_;
      startBatch();
      var notify = hasListeners(this);
      var notifySpy =  false && 0;
      var observable = this.values_.get(key);
      // Value needed for spies/listeners
      var value = undefined;
      // Optimization: don't pull the value unless we will need it
      if (!observable && (notify || notifySpy)) {
        var _getDescriptor;
        value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;
      }
      // delete prop (do first, may fail)
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      }
      // Allow re-annotating this field
      if (false) {}
      // Clear observable
      if (observable) {
        this.values_["delete"](key);
        // for computed, value is undefined
        if (observable instanceof ObservableValue) {
          value = observable.value_;
        }
        // Notify: autorun(() => obj[key]), see #1796
        propagateChanged(observable);
      }
      // Notify "keys/entries/values" observers
      this.keysAtom_.reportChanged();
      // Notify "has" observers
      // "in" as it may still exist in proto
      (_this$pendingKeys_ = this.pendingKeys_) == null || (_this$pendingKeys_ = _this$pendingKeys_.get(key)) == null || _this$pendingKeys_.set(key in this.target_);
      // Notify spies/listeners
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if (false) {}
        if (notify) {
          notifyListeners(this, _change2);
        }
        if (false) {}
      }
    } finally {
      endBatch();
    }
    return true;
  }
  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */;
  _proto.observe_ = function observe_(callback, fireImmediately) {
    if (false) {}
    return registerListener(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2;
    var notify = hasListeners(this);
    var notifySpy =  false && 0;
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if (false) {}
      if (notify) {
        notifyListeners(this, change);
      }
      if (false) {}
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null || (_this$pendingKeys_2 = _this$pendingKeys_2.get(key)) == null || _this$pendingKeys_2.set(true);
    // Notify "keys/entries/values" observers
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };
  _proto.keys_ = function keys_() {
    // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.
    // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.
    // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)
    // We choose to over-report in Object.keys(object), because:
    // - typically it's used with simple data objects
    // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration;
}();
function asObservableObject(target, options) {
  var _options$name;
  if (false) {}
  if (hasProp(target, $mobx)) {
    if (false) {}
    return target;
  }
  if (false) {}
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name :  false ? 0 : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;
  if (false) {}
  // Remove applied decorator annotation so we don't try to apply it again in subclass constructor
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null || delete _adm$target_$storedAn[key];
}
function assertAnnotable(adm, annotation, key) {
  // Valid annotation
  if (false) {}
  /*
  // Configurable, not sealed, not frozen
  // Possibly not needed, just a little better error then the one thrown by engine.
  // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.
  if (__DEV__) {
      const configurable = getDescriptor(adm.target_, key)?.configurable
      const frozen = Object.isFrozen(adm.target_)
      const sealed = Object.isSealed(adm.target_)
      if (!configurable || frozen || sealed) {
          const fieldName = `${adm.name_}.${key.toString()}`
          const requestedAnnotationType = annotation.annotationType_
          let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`
          if (frozen) {
              error += `\nObject is frozen.`
          }
          if (sealed) {
              error += `\nObject is sealed.`
          }
          if (!configurable) {
              error += `\nproperty is not configurable.`
              // Mention only if caused by us to avoid confusion
              if (hasProp(adm.appliedAnnotations!, key)) {
                  error += `\nTo prevent accidental re-definition of a field by a subclass, `
                  error += `all annotated fields of non-plain objects (classes) are not configurable.`
              }
          }
          die(error)
      }
  }
  */
  // Not annotated
  if (false) { var requestedAnnotationType, currentAnnotationType, fieldName; }
}

// Bug in safari 9.* (or iOS 9 safari mobile). See #364
var ENTRY_0 = /*#__PURE__*/createArrayEntryDescriptor(0);
var safariPrototypeSetterInheritanceBug = /*#__PURE__*/function () {
  var v = false;
  var p = {};
  Object.defineProperty(p, "0", {
    set: function set() {
      v = true;
    }
  });
  /*#__PURE__*/Object.create(p)["0"] = 1;
  return v === false;
}();
/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
// Typescript workaround to make sure ObservableArray extends Array
var StubArray = function StubArray() {};
function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== undefined) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
inherit(StubArray, Array.prototype);
// Weex proto freeze protection was here,
// but it is unclear why the hack is need as MobX never changed the prototype
// anyway, so removed it in V6
var LegacyObservableArray = /*#__PURE__*/function (_StubArray) {
  function LegacyObservableArray(initialValues, enhancer, name, owned) {
    var _this;
    if (name === void 0) {
      name =  false ? 0 : "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    initObservable(function () {
      var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
      adm.proxy_ = _this;
      addHiddenFinalProp(_this, $mobx, adm);
      if (initialValues && initialValues.length) {
        // @ts-ignore
        _this.spliceWithArray(0, 0, initialValues);
      }
      if (safariPrototypeSetterInheritanceBug) {
        // Seems that Safari won't use numeric prototype setter until any * numeric property is
        // defined on the instance. After that it works fine, even if this property is deleted.
        Object.defineProperty(_this, "0", ENTRY_0);
      }
    });
    return _this;
  }
  _inheritsLoose(LegacyObservableArray, _StubArray);
  var _proto = LegacyObservableArray.prototype;
  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(this.slice(),
    //@ts-ignore
    arrays.map(function (a) {
      return isObservableArray(a) ? a.slice() : a;
    }));
  };
  _proto[Symbol.iterator] = function () {
    var self = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        return nextIndex < self.length ? {
          value: self[nextIndex++],
          done: false
        } : {
          done: true,
          value: undefined
        };
      }
    });
  };
  return _createClass(LegacyObservableArray, [{
    key: "length",
    get: function get() {
      return this[$mobx].getArrayLength_();
    },
    set: function set(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return "Array";
    }
  }]);
}(StubArray);
Object.entries(arrayExtensions).forEach(function (_ref) {
  var prop = _ref[0],
    fn = _ref[1];
  if (prop !== "concat") {
    addHiddenProp(LegacyObservableArray.prototype, prop, fn);
  }
});
function createArrayEntryDescriptor(index) {
  return {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this[$mobx].get_(index);
    },
    set: function set(value) {
      this[$mobx].set_(index, value);
    }
  };
}
function createArrayBufferItem(index) {
  defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}
function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
      createArrayBufferItem(index);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}
reserveArrayBuffer(1000);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}

function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== undefined) {
        die(23);
      }
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing.atom_;
    }
    if (isObservableMap(thing)) {
      if (property === undefined) {
        return thing.keysAtom_;
      }
      var observable = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable) {
        die(25, property, getDebugName(thing));
      }
      return observable;
    }
    if (isObservableObject(thing)) {
      if (!property) {
        return die(26);
      }
      var _observable = thing[$mobx].values_.get(property);
      if (!_observable) {
        die(27, property, getDebugName(thing));
      }
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      // disposer function
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property) {
  if (!thing) {
    die(29);
  }
  if (property !== undefined) {
    return getAdministration(getAtom(thing, property));
  }
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
    return thing;
  }
  if (isObservableMap(thing) || isObservableSet(thing)) {
    return thing;
  }
  if (thing[$mobx]) {
    return thing[$mobx];
  }
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;
  if (property !== undefined) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    // valid for arrays as well
    named = getAtom(thing);
  }
  return named.name_;
}
/**
 * Helper function for initializing observable structures, it applies:
 * 1. allowStateChanges so we don't violate enforceActions.
 * 2. untracked so we don't accidentaly subscribe to anything observable accessed during init in case the observable is created inside derivation.
 * 3. batch to avoid state version updates
 */
function initObservable(cb) {
  var derivation = untrackedStart();
  var allowStateChanges = allowStateChangesStart(true);
  startBatch();
  try {
    return cb();
  } finally {
    endBatch();
    allowStateChangesEnd(allowStateChanges);
    untrackedEnd(derivation);
  }
}

var mobx_esm_toString = objectPrototype.toString;
function deepEqual(a, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a, b, depth);
}
// Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Internal recursive comparison function for `isEqual`.
function eq(a, b, depth, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  }
  // `null` or `undefined` only equal to itself (strict comparison).
  if (a == null || b == null) {
    return false;
  }
  // `NaN`s are equivalent, but non-reflexive.
  if (a !== a) {
    return b !== b;
  }
  // Exhaust primitive checks
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object") {
    return false;
  }
  // Compare `[[Class]]` names.
  var className = mobx_esm_toString.call(a);
  if (className !== mobx_esm_toString.call(b)) {
    return false;
  }
  switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return "" + a === "" + b;
    case "[object Number]":
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) {
        return +b !== +b;
      }
      // An `egal` comparison is performed for other numeric values.
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);
    case "[object Map]":
    case "[object Set]":
      // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.
      // Hide this extra level by increasing the depth.
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  // Unwrap any wrapped objects.
  a = unwrap(a);
  b = unwrap(b);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") {
      return false;
    }
    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.
    var aCtor = a.constructor,
      bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) {
      return bStack[length] === b;
    }
  }
  // Add the first object to the stack of traversed objects.
  aStack.push(a);
  bStack.push(b);
  // Recursively compare objects and arrays.
  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) {
      return false;
    }
    // Deep compare the contents, ignoring non-numeric properties.
    while (length--) {
      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {
        return false;
      }
    }
  } else {
    // Deep compare objects.
    var keys = Object.keys(a);
    var key;
    length = keys.length;
    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (Object.keys(b).length !== length) {
      return false;
    }
    while (length--) {
      // Deep compare each member
      key = keys[length];
      if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {
        return false;
      }
    }
  }
  // Remove the first object from the stack of traversed objects.
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a) {
  if (isObservableArray(a)) {
    return a.slice();
  }
  if (isES6Map(a) || isObservableMap(a)) {
    return Array.from(a.entries());
  }
  if (isES6Set(a) || isObservableSet(a)) {
    return Array.from(a.entries());
  }
  return a;
}

var _getGlobal$Iterator;
// safely get iterator prototype if available
var maybeIteratorPrototype = ((_getGlobal$Iterator = /*#__PURE__*/getGlobal().Iterator) == null ? void 0 : _getGlobal$Iterator.prototype) || {};
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return Object.assign(Object.create(maybeIteratorPrototype), iterator);
}
function getSelf() {
  return this;
}

function isAnnotation(thing) {
  return (
    // Can be function
    thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_)
  );
}

/**
 * (c) Michel Weststrate 2015 - 2020
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get a global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */
["Symbol", "Map", "Set"].forEach(function (m) {
  var g = getGlobal();
  if (typeof g[m] === "undefined") {
    die("MobX requires global '" + m + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  // See: https://github.com/andykog/mobx-devtools/
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy: spy,
    extras: {
      getDebugName: getDebugName
    },
    $mobx: $mobx
  });
}


//# sourceMappingURL=mobx.esm.js.map

;// ./node_modules/mobx-react-lite/es/utils/assertEnvironment.js


if (!react.useState) {
    throw new Error("mobx-react-lite requires React with Hooks support");
}
if (!makeObservable) {
    throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
}
//# sourceMappingURL=assertEnvironment.js.map
;// ./node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js

//# sourceMappingURL=reactBatchedUpdates.js.map
;// ./node_modules/mobx-react-lite/es/utils/observerBatching.js

function defaultNoopBatch(callback) {
    callback();
}
function observerBatching(reactionScheduler) {
    if (!reactionScheduler) {
        reactionScheduler = defaultNoopBatch;
        if (false) {}
    }
    configure({ reactionScheduler: reactionScheduler });
}
var isObserverBatched = function () {
    if (false) {}
    return true;
};
//# sourceMappingURL=observerBatching.js.map
;// ./node_modules/mobx-react-lite/es/utils/printDebugValue.js

function printDebugValue(v) {
    return getDependencyTree(v);
}
//# sourceMappingURL=printDebugValue.js.map
;// ./node_modules/mobx-react-lite/es/staticRendering.js
var globalIsUsingStaticRendering = false;
function staticRendering_enableStaticRendering(enable) {
    globalIsUsingStaticRendering = enable;
}
function isUsingStaticRendering() {
    return globalIsUsingStaticRendering;
}
//# sourceMappingURL=staticRendering.js.map
;// ./node_modules/mobx-react-lite/es/utils/UniversalFinalizationRegistry.js
var REGISTRY_FINALIZE_AFTER = 10000;
var REGISTRY_SWEEP_INTERVAL = 10000;
var TimerBasedFinalizationRegistry = /** @class */ (function () {
    function TimerBasedFinalizationRegistry(finalize) {
        var _this = this;
        Object.defineProperty(this, "finalize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: finalize
        });
        Object.defineProperty(this, "registrations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "sweepTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Bound so it can be used directly as setTimeout callback.
        Object.defineProperty(this, "sweep", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: function (maxAge) {
                if (maxAge === void 0) { maxAge = REGISTRY_FINALIZE_AFTER; }
                // cancel timeout so we can force sweep anytime
                clearTimeout(_this.sweepTimeout);
                _this.sweepTimeout = undefined;
                var now = Date.now();
                _this.registrations.forEach(function (registration, token) {
                    if (now - registration.registeredAt >= maxAge) {
                        _this.finalize(registration.value);
                        _this.registrations.delete(token);
                    }
                });
                if (_this.registrations.size > 0) {
                    _this.scheduleSweep();
                }
            }
        });
        // Bound so it can be exported directly as clearTimers test utility.
        Object.defineProperty(this, "finalizeAllImmediately", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: function () {
                _this.sweep(0);
            }
        });
    }
    // Token is actually required with this impl
    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, "register", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target, value, token) {
            this.registrations.set(token, {
                value: value,
                registeredAt: Date.now()
            });
            this.scheduleSweep();
        }
    });
    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, "unregister", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (token) {
            this.registrations.delete(token);
        }
    });
    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, "scheduleSweep", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this.sweepTimeout === undefined) {
                this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);
            }
        }
    });
    return TimerBasedFinalizationRegistry;
}());

var UniversalFinalizationRegistry = typeof FinalizationRegistry !== "undefined"
    ? FinalizationRegistry
    : TimerBasedFinalizationRegistry;
//# sourceMappingURL=UniversalFinalizationRegistry.js.map
;// ./node_modules/mobx-react-lite/es/utils/observerFinalizationRegistry.js

var observerFinalizationRegistry = new UniversalFinalizationRegistry(function (adm) {
    var _a;
    (_a = adm.reaction) === null || _a === void 0 ? void 0 : _a.dispose();
    adm.reaction = null;
});
//# sourceMappingURL=observerFinalizationRegistry.js.map
// EXTERNAL MODULE: ./node_modules/use-sync-external-store/shim/index.js
var shim = __webpack_require__(888);
;// ./node_modules/mobx-react-lite/es/useObserver.js






function createReaction(adm) {
    adm.reaction = new Reaction("observer".concat(adm.name), function () {
        var _a;
        adm.stateVersion = Symbol();
        // onStoreChange won't be available until the component "mounts".
        // If state changes in between initial render and mount,
        // `useSyncExternalStore` should handle that by checking the state version and issuing update.
        (_a = adm.onStoreChange) === null || _a === void 0 ? void 0 : _a.call(adm);
    });
}
function useObserver(render, baseComponentName) {
    if (baseComponentName === void 0) { baseComponentName = "observed"; }
    if (isUsingStaticRendering()) {
        return render();
    }
    var admRef = react.useRef(null);
    if (!admRef.current) {
        // First render
        var adm_1 = {
            reaction: null,
            onStoreChange: null,
            stateVersion: Symbol(),
            name: baseComponentName,
            subscribe: function (onStoreChange) {
                // Do NOT access admRef here!
                observerFinalizationRegistry.unregister(adm_1);
                adm_1.onStoreChange = onStoreChange;
                if (!adm_1.reaction) {
                    // We've lost our reaction and therefore all subscriptions, occurs when:
                    // 1. Timer based finalization registry disposed reaction before component mounted.
                    // 2. React "re-mounts" same component without calling render in between (typically <StrictMode>).
                    // We have to recreate reaction and schedule re-render to recreate subscriptions,
                    // even if state did not change.
                    createReaction(adm_1);
                    // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.
                    // So we make sure that is not the case
                    adm_1.stateVersion = Symbol();
                }
                return function () {
                    var _a;
                    // Do NOT access admRef here!
                    adm_1.onStoreChange = null;
                    (_a = adm_1.reaction) === null || _a === void 0 ? void 0 : _a.dispose();
                    adm_1.reaction = null;
                };
            },
            getSnapshot: function () {
                // Do NOT access admRef here!
                return adm_1.stateVersion;
            }
        };
        admRef.current = adm_1;
    }
    var adm = admRef.current;
    if (!adm.reaction) {
        // First render or reaction was disposed by registry before subscribe
        createReaction(adm);
        // StrictMode/ConcurrentMode/Suspense may mean that our component is
        // rendered and abandoned multiple times, so we need to track leaked
        // Reactions.
        observerFinalizationRegistry.register(admRef, adm, adm);
    }
    react.useDebugValue(adm.reaction, printDebugValue);
    (0,shim.useSyncExternalStore)(
    // Both of these must be stable, otherwise it would keep resubscribing every render.
    adm.subscribe, adm.getSnapshot, adm.getSnapshot);
    // render the original component, but have the
    // reaction track the observables, so that rendering
    // can be invalidated (see above) once a dependency changes
    var renderResult;
    var exception;
    adm.reaction.track(function () {
        try {
            renderResult = render();
        }
        catch (e) {
            exception = e;
        }
    });
    if (exception) {
        throw exception; // re-throw any exceptions caught during rendering
    }
    return renderResult;
}
//# sourceMappingURL=useObserver.js.map
;// ./node_modules/mobx-react-lite/es/observer.js
var _a, _b;



var warnObserverOptionsDeprecated = true;
var warnLegacyContextTypes = true;
var hasSymbol = typeof Symbol === "function" && Symbol.for;
var observer_isFunctionNameConfigurable = (_b = (_a = Object.getOwnPropertyDescriptor(function () { }, "name")) === null || _a === void 0 ? void 0 : _a.configurable) !== null && _b !== void 0 ? _b : false;
// Using react-is had some issues (and operates on elements, not on types), see #608 / #609
var ReactForwardRefSymbol = hasSymbol
    ? Symbol.for("react.forward_ref")
    : typeof react.forwardRef === "function" && (0,react.forwardRef)(function (props) { return null; })["$$typeof"];
var ReactMemoSymbol = hasSymbol
    ? Symbol.for("react.memo")
    : typeof react.memo === "function" && (0,react.memo)(function (props) { return null; })["$$typeof"];
// n.b. base case is not used for actual typings or exported in the typing files
function observer(baseComponent, 
// TODO remove in next major
options) {
    var _a;
    if (false) {}
    if (ReactMemoSymbol && baseComponent["$$typeof"] === ReactMemoSymbol) {
        throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
    }
    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307
    if (isUsingStaticRendering()) {
        return baseComponent;
    }
    var useForwardRef = (_a = options === null || options === void 0 ? void 0 : options.forwardRef) !== null && _a !== void 0 ? _a : false;
    var render = baseComponent;
    var baseComponentName = baseComponent.displayName || baseComponent.name;
    // If already wrapped with forwardRef, unwrap,
    // so we can patch render and apply memo
    if (ReactForwardRefSymbol && baseComponent["$$typeof"] === ReactForwardRefSymbol) {
        useForwardRef = true;
        render = baseComponent["render"];
        if (typeof render !== "function") {
            throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
        }
    }
    var observerComponent = function (props, ref) {
        return useObserver(function () { return render(props, ref); }, baseComponentName);
    };
    observerComponent.displayName = baseComponent.displayName;
    if (observer_isFunctionNameConfigurable) {
        Object.defineProperty(observerComponent, "name", {
            value: baseComponent.name,
            writable: true,
            configurable: true
        });
    }
    // Support legacy context: `contextTypes` must be applied before `memo`
    if (baseComponent.contextTypes) {
        ;
        observerComponent.contextTypes = baseComponent.contextTypes;
        if (false) {}
    }
    if (useForwardRef) {
        // `forwardRef` must be applied prior `memo`
        // `forwardRef(observer(cmp))` throws:
        // "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))"
        observerComponent = (0,react.forwardRef)(observerComponent);
    }
    // memo; we are not interested in deep updates
    // in props; we assume that if deep objects are changed,
    // this is in observables, which would have been tracked anyway
    observerComponent = (0,react.memo)(observerComponent);
    copyStaticProperties(baseComponent, observerComponent);
    if (false) {}
    return observerComponent;
}
// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js
var hoistBlackList = {
    $$typeof: true,
    render: true,
    compare: true,
    type: true,
    // Don't redefine `displayName`,
    // it's defined as getter-setter pair on `memo` (see #3192).
    displayName: true
};
function copyStaticProperties(base, target) {
    Object.keys(base).forEach(function (key) {
        if (!hoistBlackList[key]) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));
        }
    });
}
//# sourceMappingURL=observer.js.map
;// ./node_modules/mobx-react-lite/es/ObserverComponent.js

function ObserverComponent(_a) {
    var children = _a.children, render = _a.render;
    if (children && render) {
        console.error("MobX Observer: Do not use children and render in the same time in `Observer`");
    }
    var component = children || render;
    if (typeof component !== "function") {
        return null;
    }
    return useObserver(component);
}
if (false) {}
ObserverComponent.displayName = "Observer";

function ObserverPropsCheck(props, key, componentName, location, propFullName) {
    var extraKey = key === "children" ? "render" : "children";
    var hasProp = typeof props[key] === "function";
    var hasExtraProp = typeof props[extraKey] === "function";
    if (hasProp && hasExtraProp) {
        return new Error("MobX Observer: Do not use children and render in the same time in`" + componentName);
    }
    if (hasProp || hasExtraProp) {
        return null;
    }
    return new Error("Invalid prop `" +
        propFullName +
        "` of type `" +
        typeof props[key] +
        "` supplied to" +
        " `" +
        componentName +
        "`, expected `function`.");
}
//# sourceMappingURL=ObserverComponent.js.map
;// ./node_modules/mobx-react-lite/es/useLocalObservable.js


function useLocalObservable(initializer, annotations) {
    return useState(function () { return observable(initializer(), annotations, { autoBind: true }); })[0];
}
//# sourceMappingURL=useLocalObservable.js.map
;// ./node_modules/mobx-react-lite/es/useAsObservableSource.js



function useAsObservableSource_useAsObservableSource(current) {
    if (false)
        {}
    // We're deliberately not using idiomatic destructuring for the hook here.
    // Accessing the state value as an array element prevents TypeScript from generating unnecessary helpers in the resulting code.
    // For further details, please refer to mobxjs/mobx#3842.
    var res = useState(function () { return observable(current, {}, { deep: false }); })[0];
    runInAction(function () {
        Object.assign(res, current);
    });
    return res;
}
//# sourceMappingURL=useAsObservableSource.js.map
;// ./node_modules/mobx-react-lite/es/useLocalStore.js




function useLocalStore(initializer, current) {
    if (false) {}
    var source = current && useAsObservableSource(current);
    return useState(function () { return observable(initializer(source), undefined, { autoBind: true }); })[0];
}
//# sourceMappingURL=useLocalStore.js.map
;// ./node_modules/mobx-react-lite/es/index.js
var es_a;







observerBatching(react_dom.unstable_batchedUpdates);







var clearTimers = (es_a = observerFinalizationRegistry["finalizeAllImmediately"]) !== null && es_a !== void 0 ? es_a : (function () { });
function es_useObserver(fn, baseComponentName) {
    if (baseComponentName === void 0) { baseComponentName = "observed"; }
    if (false) {}
    return useObserverOriginal(fn, baseComponentName);
}

function useStaticRendering(enable) {
    if (false) {}
    enableStaticRendering(enable);
}
//# sourceMappingURL=index.js.map
;// ./node_modules/mobx-react/dist/mobxreact.esm.js





function shallowEqual(objA, objB) {
  //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
  if (is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (var i = 0; i < keysA.length; i++) {
    if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
function is(x, y) {
  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js
var mobxreact_esm_hoistBlackList = {
  $$typeof: 1,
  render: 1,
  compare: 1,
  type: 1,
  childContextTypes: 1,
  contextType: 1,
  contextTypes: 1,
  defaultProps: 1,
  getDefaultProps: 1,
  getDerivedStateFromError: 1,
  getDerivedStateFromProps: 1,
  mixins: 1,
  displayName: 1,
  propTypes: 1
};
function mobxreact_esm_copyStaticProperties(base, target) {
  var protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base));
  Object.getOwnPropertyNames(base).forEach(function (key) {
    if (!mobxreact_esm_hoistBlackList[key] && protoProps.indexOf(key) === -1) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));
    }
  });
}
/**
 * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks
 * and the handler provided by mobx-react
 */
var mobxMixins = /*#__PURE__*/Symbol("patchMixins");
var mobxPatchedDefinition = /*#__PURE__*/Symbol("patchedDefinition");
function getMixins(target, methodName) {
  var mixins = target[mobxMixins] = target[mobxMixins] || {};
  var methodMixins = mixins[methodName] = mixins[methodName] || {};
  methodMixins.locks = methodMixins.locks || 0;
  methodMixins.methods = methodMixins.methods || [];
  return methodMixins;
}
function wrapper(realMethod, mixins) {
  var _this = this;
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls
  mixins.locks++;
  try {
    var retVal;
    if (realMethod !== undefined && realMethod !== null) {
      retVal = realMethod.apply(this, args);
    }
    return retVal;
  } finally {
    mixins.locks--;
    if (mixins.locks === 0) {
      mixins.methods.forEach(function (mx) {
        mx.apply(_this, args);
      });
    }
  }
}
function wrapFunction(realMethod, mixins) {
  var fn = function fn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));
  };
  return fn;
}
function patch(target, methodName, mixinMethod) {
  var mixins = getMixins(target, methodName);
  if (mixins.methods.indexOf(mixinMethod) < 0) {
    mixins.methods.push(mixinMethod);
  }
  var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);
  if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {
    // already patched definition, do not repatch
    return;
  }
  var originalMethod = target[methodName];
  var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : undefined, mixins, originalMethod);
  Object.defineProperty(target, methodName, newDefinition);
}
function createDefinition(target, methodName, enumerable, mixins, originalMethod) {
  var _ref;
  var wrappedFunc = wrapFunction(originalMethod, mixins);
  return _ref = {}, _ref[mobxPatchedDefinition] = true, _ref.get = function get() {
    return wrappedFunc;
  }, _ref.set = function set(value) {
    if (this === target) {
      wrappedFunc = wrapFunction(value, mixins);
    } else {
      // when it is an instance of the prototype/a child prototype patch that particular case again separately
      // since we need to store separate values depending on wether it is the actual instance, the prototype, etc
      // e.g. the method for super might not be the same as the method for the prototype which might be not the same
      // as the method for the instance
      var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);
      Object.defineProperty(this, methodName, newDefinition);
    }
  }, _ref.configurable = true, _ref.enumerable = enumerable, _ref;
}

var administrationSymbol = /*#__PURE__*/Symbol("ObserverAdministration");
var isMobXReactObserverSymbol = /*#__PURE__*/Symbol("isMobXReactObserver");
var observablePropDescriptors;
if (false) {}
function mobxreact_esm_getAdministration(component) {
  var _component$administra;
  // We create administration lazily, because we can't patch constructor
  // and the exact moment of initialization partially depends on React internals.
  // At the time of writing this, the first thing invoked is one of the observable getter/setter (state/props/context).
  return (_component$administra = component[administrationSymbol]) != null ? _component$administra : component[administrationSymbol] = {
    reaction: null,
    mounted: false,
    reactionInvalidatedBeforeMount: false,
    forceUpdate: null,
    name: getDisplayName(component.constructor),
    state: undefined,
    props: undefined,
    context: undefined
  };
}
function makeClassComponentObserver(componentClass) {
  var prototype = componentClass.prototype;
  if (componentClass[isMobXReactObserverSymbol]) {
    var displayName = getDisplayName(componentClass);
    throw new Error("The provided component class (" + displayName + ") has already been declared as an observer component.");
  } else {
    componentClass[isMobXReactObserverSymbol] = true;
  }
  if (prototype.componentWillReact) {
    throw new Error("The componentWillReact life-cycle event is no longer supported");
  }
  if (componentClass["__proto__"] !== react.PureComponent) {
    if (!prototype.shouldComponentUpdate) {
      prototype.shouldComponentUpdate = observerSCU;
    } else if (prototype.shouldComponentUpdate !== observerSCU) {
      // n.b. unequal check, instead of existence check, as @observer might be on superclass as well
      throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.");
    }
  }
  if (false) {}
  var originalRender = prototype.render;
  if (typeof originalRender !== "function") {
    var _displayName = getDisplayName(componentClass);
    throw new Error("[mobx-react] class component (" + _displayName + ") is missing `render` method." + "\n`observer` requires `render` being a function defined on prototype." + "\n`render = () => {}` or `render = function() {}` is not supported.");
  }
  prototype.render = function () {
    Object.defineProperty(this, "render", {
      // There is no safe way to replace render, therefore it's forbidden.
      configurable: false,
      writable: false,
      value: isUsingStaticRendering() ? originalRender : createReactiveRender.call(this, originalRender)
    });
    return this.render();
  };
  var originalComponentDidMount = prototype.componentDidMount;
  prototype.componentDidMount = function () {
    var _this = this;
    if (false) { var _displayName2; }
    // `componentDidMount` may not be called at all. React can abandon the instance after `render`.
    // That's why we use finalization registry to dispose reaction created during render.
    // Happens with `<Suspend>` see #3492
    //
    // `componentDidMount` can be called immediately after `componentWillUnmount` without calling `render` in between.
    // Happens with `<StrictMode>`see #3395.
    //
    // If `componentDidMount` is called, it's guaranteed to run synchronously with render (similary to `useLayoutEffect`).
    // Therefore we don't have to worry about external (observable) state being updated before mount (no state version checking).
    //
    // Things may change: "In the future, React will provide a feature that lets components preserve state between unmounts"
    var admin = mobxreact_esm_getAdministration(this);
    admin.mounted = true;
    // Component instance committed, prevent reaction disposal.
    observerFinalizationRegistry.unregister(this);
    // We don't set forceUpdate before mount because it requires a reference to `this`,
    // therefore `this` could NOT be garbage collected before mount,
    // preventing reaction disposal by FinalizationRegistry and leading to memory leak.
    // As an alternative we could have `admin.instanceRef = new WeakRef(this)`, but lets avoid it if possible.
    admin.forceUpdate = function () {
      return _this.forceUpdate();
    };
    if (!admin.reaction || admin.reactionInvalidatedBeforeMount) {
      // Missing reaction:
      // 1. Instance was unmounted (reaction disposed) and immediately remounted without running render #3395.
      // 2. Reaction was disposed by finalization registry before mount. Shouldn't ever happen for class components:
      // `componentDidMount` runs synchronously after render, but our registry are deferred (can't run in between).
      // In any case we lost subscriptions to observables, so we have to create new reaction and re-render to resubscribe.
      // The reaction will be created lazily by following render.
      // Reaction invalidated before mount:
      // 1. A descendant's `componenDidMount` invalidated it's parent #3730
      admin.forceUpdate();
    }
    return originalComponentDidMount == null ? void 0 : originalComponentDidMount.apply(this, arguments);
  };
  // TODO@major Overly complicated "patch" is only needed to support the deprecated @disposeOnUnmount
  patch(prototype, "componentWillUnmount", function () {
    var _admin$reaction;
    if (isUsingStaticRendering()) {
      return;
    }
    var admin = mobxreact_esm_getAdministration(this);
    (_admin$reaction = admin.reaction) == null || _admin$reaction.dispose();
    admin.reaction = null;
    admin.forceUpdate = null;
    admin.mounted = false;
    admin.reactionInvalidatedBeforeMount = false;
  });
  return componentClass;
}
// Generates a friendly name for debugging
function getDisplayName(componentClass) {
  return componentClass.displayName || componentClass.name || "<component>";
}
function createReactiveRender(originalRender) {
  var boundOriginalRender = originalRender.bind(this);
  var admin = mobxreact_esm_getAdministration(this);
  function reactiveRender() {
    if (!admin.reaction) {
      // Create reaction lazily to support re-mounting #3395
      admin.reaction = mobxreact_esm_createReaction(admin);
      if (!admin.mounted) {
        // React can abandon this instance and never call `componentDidMount`/`componentWillUnmount`,
        // we have to make sure reaction will be disposed.
        observerFinalizationRegistry.register(this, admin, this);
      }
    }
    var error = undefined;
    var renderResult = undefined;
    admin.reaction.track(function () {
      try {
        // TODO@major
        // Optimization: replace with _allowStateChangesStart/End (not available in mobx@6.0.0)
        renderResult = allowStateChanges(false, boundOriginalRender);
      } catch (e) {
        error = e;
      }
    });
    if (error) {
      throw error;
    }
    return renderResult;
  }
  return reactiveRender;
}
function mobxreact_esm_createReaction(admin) {
  return new Reaction(admin.name + ".render()", function () {
    if (!admin.mounted) {
      // This is neccessary to avoid react warning about calling forceUpdate on component that isn't mounted yet.
      // This happens when component is abandoned after render - our reaction is already created and reacts to changes.
      // `componenDidMount` runs synchronously after `render`, so unlike functional component, there is no delay during which the reaction could be invalidated.
      // However `componentDidMount` runs AFTER it's descendants' `componentDidMount`, which CAN invalidate the reaction, see #3730. Therefore remember and forceUpdate on mount.
      admin.reactionInvalidatedBeforeMount = true;
      return;
    }
    try {
      admin.forceUpdate == null || admin.forceUpdate();
    } catch (error) {
      var _admin$reaction2;
      (_admin$reaction2 = admin.reaction) == null || _admin$reaction2.dispose();
      admin.reaction = null;
    }
  });
}
function observerSCU(nextProps, nextState) {
  if (isUsingStaticRendering()) {
    console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.");
  }
  // update on any state changes (as is the default)
  if (this.state !== nextState) {
    return true;
  }
  // update if props are shallowly not equal, inspired by PureRenderMixin
  // we could return just 'false' here, and avoid the `skipRender` checks etc
  // however, it is nicer if lifecycle events are triggered like usually,
  // so we return true here if props are shallowly modified.
  return !shallowEqual(this.props, nextProps);
}
function createObservablePropDescriptor(key) {
  return {
    configurable: true,
    enumerable: true,
    get: function get() {
      var admin = mobxreact_esm_getAdministration(this);
      var derivation = _getGlobalState().trackingDerivation;
      if (derivation && derivation !== admin.reaction) {
        throw new Error("[mobx-react] Cannot read \"" + admin.name + "." + key + "\" in a reactive context, as it isn't observable.\n                    Please use component lifecycle method to copy the value into a local observable first.\n                    See https://github.com/mobxjs/mobx/blob/main/packages/mobx-react/README.md#note-on-using-props-and-state-in-derivations");
      }
      return admin[key];
    },
    set: function set(value) {
      mobxreact_esm_getAdministration(this)[key] = value;
    }
  };
}

function mobxreact_esm_observer(component, context) {
  if (context && context.kind !== "class") {
    throw new Error("The @observer decorator can be used on classes only");
  }
  if (component["isMobxInjector"] === true) {
    console.warn("Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`");
  }
  if (Object.prototype.isPrototypeOf.call(react.Component, component) || Object.prototype.isPrototypeOf.call(react.PureComponent, component)) {
    // Class component
    return makeClassComponentObserver(component);
  } else {
    // Function component
    return observer(component);
  }
}

function mobxreact_esm_extends() {
  return mobxreact_esm_extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, mobxreact_esm_extends.apply(null, arguments);
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) >= 0) continue;
    t[n] = r[n];
  }
  return t;
}

var _excluded = ["children"];
var MobXProviderContext = /*#__PURE__*/react.createContext({});
function Provider(props) {
  var children = props.children,
    stores = _objectWithoutPropertiesLoose(props, _excluded);
  var parentValue = react.useContext(MobXProviderContext);
  var mutableProviderRef = react.useRef(mobxreact_esm_extends({}, parentValue, stores));
  var value = mutableProviderRef.current;
  if (false) { var newValue; }
  return react.createElement(MobXProviderContext.Provider, {
    value: value
  }, children);
}
Provider.displayName = "MobXProvider";

/**
 * Store Injection
 */
function createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {
  // Support forward refs
  var Injector = React__default.forwardRef(function (props, ref) {
    var newProps = mobxreact_esm_extends({}, props);
    var context = React__default.useContext(MobXProviderContext);
    Object.assign(newProps, grabStoresFn(context || {}, newProps) || {});
    if (ref) {
      newProps.ref = ref;
    }
    return React__default.createElement(component, newProps);
  });
  if (makeReactive) Injector = mobxreact_esm_observer(Injector);
  Injector["isMobxInjector"] = true; // assigned late to suppress observer warning
  // Static fields from component should be visible on the generated Injector
  mobxreact_esm_copyStaticProperties(component, Injector);
  Injector["wrappedComponent"] = component;
  Injector.displayName = getInjectName(component, injectNames);
  return Injector;
}
function getInjectName(component, injectNames) {
  var displayName;
  var componentName = component.displayName || component.name || component.constructor && component.constructor.name || "Component";
  if (injectNames) displayName = "inject-with-" + injectNames + "(" + componentName + ")";else displayName = "inject(" + componentName + ")";
  return displayName;
}
function grabStoresByName(storeNames) {
  return function (baseStores, nextProps) {
    storeNames.forEach(function (storeName) {
      if (storeName in nextProps // prefer props over stores
      ) return;
      if (!(storeName in baseStores)) throw new Error("MobX injector: Store '" + storeName + "' is not available! Make sure it is provided by some Provider");
      nextProps[storeName] = baseStores[storeName];
    });
    return nextProps;
  };
}
/**
 * higher order component that injects stores to a child.
 * takes either a varargs list of strings, which are stores read from the context,
 * or a function that manually maps the available stores from the context to props:
 * storesToProps(mobxStores, props, context) => newProps
 */
function inject() {
  for (var _len = arguments.length, storeNames = new Array(_len), _key = 0; _key < _len; _key++) {
    storeNames[_key] = arguments[_key];
  }
  if (typeof arguments[0] === "function") {
    var grabStoresFn = arguments[0];
    return function (componentClass) {
      return createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true);
    };
  } else {
    return function (componentClass) {
      return createStoreInjector(grabStoresByName(storeNames), componentClass, storeNames.join("-"), false);
    };
  }
}

var reactMajorVersion = /*#__PURE__*/Number.parseInt( /*#__PURE__*/react.version.split(".")[0]);
var warnedAboutDisposeOnUnmountDeprecated = false;
var protoStoreKey = /*#__PURE__*/(/* unused pure expression or super */ null && (Symbol("disposeOnUnmountProto")));
var instStoreKey = /*#__PURE__*/(/* unused pure expression or super */ null && (Symbol("disposeOnUnmountInst")));
function runDisposersOnWillUnmount() {
  var _this = this;
  [].concat(this[protoStoreKey] || [], this[instStoreKey] || []).forEach(function (propKeyOrFunction) {
    var prop = typeof propKeyOrFunction === "string" ? _this[propKeyOrFunction] : propKeyOrFunction;
    if (prop !== undefined && prop !== null) {
      if (Array.isArray(prop)) prop.map(function (f) {
        return f();
      });else prop();
    }
  });
}
/**
 * @deprecated `disposeOnUnmount` is not compatible with React 18 and higher.
 */
function disposeOnUnmount(target, propertyKeyOrFunction) {
  if (Array.isArray(propertyKeyOrFunction)) {
    return propertyKeyOrFunction.map(function (fn) {
      return disposeOnUnmount(target, fn);
    });
  }
  if (!warnedAboutDisposeOnUnmountDeprecated) {
    if (reactMajorVersion >= 18) {
      console.error("[mobx-react] disposeOnUnmount is not compatible with React 18 and higher. Don't use it.");
    } else {
      console.warn("[mobx-react] disposeOnUnmount is deprecated. It won't work correctly with React 18 and higher.");
    }
    warnedAboutDisposeOnUnmountDeprecated = true;
  }
  var c = Object.getPrototypeOf(target).constructor;
  var c2 = Object.getPrototypeOf(target.constructor);
  // Special case for react-hot-loader
  var c3 = Object.getPrototypeOf(Object.getPrototypeOf(target));
  if (!(c === React__default.Component || c === React__default.PureComponent || c2 === React__default.Component || c2 === React__default.PureComponent || c3 === React__default.Component || c3 === React__default.PureComponent)) {
    throw new Error("[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.");
  }
  if (typeof propertyKeyOrFunction !== "string" && typeof propertyKeyOrFunction !== "function" && !Array.isArray(propertyKeyOrFunction)) {
    throw new Error("[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.");
  }
  // decorator's target is the prototype, so it doesn't have any instance properties like props
  var isDecorator = typeof propertyKeyOrFunction === "string";
  // add property key / function we want run (disposed) to the store
  var componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey];
  var store = isDecorator ?
  // decorators are added to the prototype store
  target[protoStoreKey] || (target[protoStoreKey] = []) :
  // functions are added to the instance store
  target[instStoreKey] || (target[instStoreKey] = []);
  store.push(propertyKeyOrFunction);
  // tweak the component class componentWillUnmount if not done already
  if (!componentWasAlreadyModified) {
    patch(target, "componentWillUnmount", runDisposersOnWillUnmount);
  }
  // return the disposer as is if invoked as a non decorator
  if (typeof propertyKeyOrFunction !== "string") {
    return propertyKeyOrFunction;
  }
}

// Copied from React.PropTypes
function createChainableTypeChecker(validator) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    for (var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
      rest[_key - 6] = arguments[_key];
    }
    return untracked(function () {
      componentName = componentName || "<<anonymous>>";
      propFullName = propFullName || propName;
      if (props[propName] == null) {
        if (isRequired) {
          var actual = props[propName] === null ? "null" : "undefined";
          return new Error("The " + location + " `" + propFullName + "` is marked as required " + "in `" + componentName + "`, but its value is `" + actual + "`.");
        }
        return null;
      } else {
        // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise
        return validator.apply(void 0, [props, propName, componentName, location, propFullName].concat(rest));
      }
    });
  }
  var chainedCheckType = checkType.bind(null, false);
  // Add isRequired to satisfy Requirable
  chainedCheckType.isRequired = checkType.bind(null, true);
  return chainedCheckType;
}
// Copied from React.PropTypes
function isSymbol(propType, propValue) {
  // Native Symbol.
  if (propType === "symbol") {
    return true;
  }
  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
  if (propValue["@@toStringTag"] === "Symbol") {
    return true;
  }
  // Fallback for non-spec compliant Symbols which are polyfilled.
  if (typeof Symbol === "function" && propValue instanceof Symbol) {
    return true;
  }
  return false;
}
// Copied from React.PropTypes
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return "array";
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return "object";
  }
  if (isSymbol(propType, propValue)) {
    return "symbol";
  }
  return propType;
}
// This handles more types than `getPropType`. Only used for error messages.
// Copied from React.PropTypes
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === "object") {
    if (propValue instanceof Date) {
      return "date";
    } else if (propValue instanceof RegExp) {
      return "regexp";
    }
  }
  return propType;
}
function createObservableTypeCheckerCreator(allowNativeType, mobxType) {
  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {
    return untracked(function () {
      if (allowNativeType) {
        if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;
      }
      var mobxChecker;
      switch (mobxType) {
        case "Array":
          mobxChecker = isObservableArray;
          break;
        case "Object":
          mobxChecker = isObservableObject;
          break;
        case "Map":
          mobxChecker = isObservableMap;
          break;
        default:
          throw new Error("Unexpected mobxType: " + mobxType);
      }
      var propValue = props[propName];
      if (!mobxChecker(propValue)) {
        var preciseType = getPreciseType(propValue);
        var nativeTypeExpectationMessage = allowNativeType ? " or javascript `" + mobxType.toLowerCase() + "`" : "";
        return new Error("Invalid prop `" + propFullName + "` of type `" + preciseType + "` supplied to" + " `" + componentName + "`, expected `mobx.Observable" + mobxType + "`" + nativeTypeExpectationMessage + ".");
      }
      return null;
    });
  });
}
function createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {
  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      rest[_key2 - 5] = arguments[_key2];
    }
    return untracked(function () {
      if (typeof typeChecker !== "function") {
        return new Error("Property `" + propFullName + "` of component `" + componentName + "` has " + "invalid PropType notation.");
      } else {
        var error = createObservableTypeCheckerCreator(allowNativeType, "Array")(props, propName, componentName, location, propFullName);
        if (error instanceof Error) return error;
        var propValue = props[propName];
        for (var i = 0; i < propValue.length; i++) {
          error = typeChecker.apply(void 0, [propValue, i, componentName, location, propFullName + "[" + i + "]"].concat(rest));
          if (error instanceof Error) return error;
        }
        return null;
      }
    });
  });
}
var observableArray = /*#__PURE__*/createObservableTypeCheckerCreator(false, "Array");
var observableArrayOf = /*#__PURE__*/createObservableArrayOfTypeChecker.bind(null, false);
var observableMap = /*#__PURE__*/createObservableTypeCheckerCreator(false, "Map");
var observableObject = /*#__PURE__*/createObservableTypeCheckerCreator(false, "Object");
var arrayOrObservableArray = /*#__PURE__*/createObservableTypeCheckerCreator(true, "Array");
var arrayOrObservableArrayOf = /*#__PURE__*/createObservableArrayOfTypeChecker.bind(null, true);
var objectOrObservableObject = /*#__PURE__*/createObservableTypeCheckerCreator(true, "Object");
var PropTypes = {
  observableArray: observableArray,
  observableArrayOf: observableArrayOf,
  observableMap: observableMap,
  observableObject: observableObject,
  arrayOrObservableArray: arrayOrObservableArray,
  arrayOrObservableArrayOf: arrayOrObservableArrayOf,
  objectOrObservableObject: objectOrObservableObject
};

if (!react.Component) {
  throw new Error("mobx-react requires React to be available");
}
if (!mobx_esm_observable) {
  throw new Error("mobx-react requires mobx to be available");
}


//# sourceMappingURL=mobxreact.esm.js.map

;// ./src/entities/task/config/config.ts
const TASK_TABLE_NAME = 'task';

;// ./src/shared/api/indexed-db/indexedDB.ts
const getConnection = (tableName) => new Promise((res, rej) => {
    const IDB = indexedDB.open(tableName, 1);
    IDB.onupgradeneeded = () => {
        if (IDB.result.objectStoreNames.contains(tableName)) {
            return;
        }
        IDB.result.createObjectStore(tableName, {
            keyPath: 'id',
            autoIncrement: true
        });
    };
    IDB.onsuccess = () => {
        res(IDB.result);
    };
    IDB.onerror = () => {
        rej(IDB.error);
    };
});

;// ./src/entities/task/api/getAllTasks.ts


const getAllTasks = async () => {
    const connection = await getConnection(TASK_TABLE_NAME);
    const transaction = connection.transaction(TASK_TABLE_NAME, 'readonly');
    const request = transaction.objectStore(TASK_TABLE_NAME).getAll();
    const tasks = new Promise((res, rej) => {
        request.onsuccess = () => res(request.result);
        request.onerror = () => rej(request.error);
    });
    connection.close();
    return await tasks;
};

;// ./src/entities/task/api/createTask.ts


const createTask = async (data) => {
    const connection = await getConnection(TASK_TABLE_NAME);
    const transaction = connection.transaction(TASK_TABLE_NAME, 'readwrite');
    const request = transaction.objectStore(TASK_TABLE_NAME).add({
        createdAt: new Date(),
        ...data
    });
    const result = new Promise((res, rej) => {
        request.onsuccess = () => res(request.result);
        request.onerror = () => rej(request.error);
    });
    connection.close();
    return await result;
};

;// ./src/entities/task/api/deleteTask.ts


const deleteTask = async (id) => {
    const connection = await getConnection(TASK_TABLE_NAME);
    const transaction = connection.transaction(TASK_TABLE_NAME, 'readwrite');
    const request = transaction.objectStore(TASK_TABLE_NAME).delete(id);
    const response = await new Promise((res, rej) => {
        request.onsuccess = () => res(request.result);
        request.onerror = () => rej(request.error);
    });
    connection.close();
    return await response;
};

;// ./src/entities/task/model/task.store.ts




class TaskStore {
    tasks = {};
    constructor() {
        makeAutoObservable(this);
    }
    async fetch() {
        const tasks = await getAllTasks();
        const fetchedTasks = {};
        tasks.forEach((task) => {
            fetchedTasks[task.id.toString()] = task;
        });
        mobx_esm_runInAction(() => {
            this.tasks = fetchedTasks;
        });
    }
    async add(data) {
        return await createTask(data);
    }
    async delete(id) {
        await deleteTask(id);
    }
}

;// ./src/entities/notify/model/notify.store.ts

class NotifyStore {
    notifies = [];
    constructor() {
        makeAutoObservable(this);
    }
    push(notify) {
        this.notifies = [...this.notifies, notify];
    }
    delete(id) {
        this.notifies = this.notifies.filter(i => i.id !== id);
    }
}

;// ./src/app/stores/rootStore.ts


class RootStore {
    task = new TaskStore();
    notify = new NotifyStore();
}

;// ./src/app/providers/rootProvider.tsx



const defaultValue = new RootStore();
const RootContext = (0,react.createContext)(defaultValue);
const useRootContext = () => (0,react.useContext)(RootContext);
const RootProvider = (p) => {
    return ((0,jsx_runtime.jsx)(RootContext.Provider, { value: defaultValue, children: p.children }));
};

;// ./src/pages/gantt/ui/plus-icon/PlusIcon.tsx

const PlusIcon = () => {
    return ((0,jsx_runtime.jsxs)("svg", { width: "24.000000", height: "24.000000", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0,jsx_runtime.jsx)("path", { id: "path", d: "M2.02 13.98L2 14C0.88 14 0 13.12 0 12C0 10.88 0.88 10 2 10L2.02 10.02L2.02 13.98ZM21.98 10.02L22 10C23.12 10 24 10.88 24 12C24 13.12 23.12 14 22 14L21.98 13.98L21.98 10.02ZM10.02 2.01L10 2C10 0.88 10.88 0 12 0C13.12 0 14 0.88 14 2L13.98 2.01L10.02 2.01ZM13.98 21.98L14 22C14 23.12 13.12 24 12 24C10.88 24 10 23.12 10 22L10.02 21.98L13.98 21.98Z", fill: "#26354C", fillOpacity: "0", fillRule: "nonzero" }), (0,jsx_runtime.jsx)("path", { id: "path", d: "M2 12L22 12M12 2L12 22", stroke: "#26354C", strokeOpacity: "1.000000", strokeWidth: "4.000000", strokeLinejoin: "round", strokeLinecap: "round" })] }));
};

;// ./src/shared/ui/modal/Modal.css
// extracted by mini-css-extract-plugin
var Modal_1 = "tYTlgoKYRTtpGptGuAJS";
var Modal_2 = "T6ti5vHBOcoiml1IkNPg";
var Modal_3 = "klKLzI5jevmhRLsrPqie";
var Modal_4 = "DMoiGxvXLTaJvtSo2hRf";
var Modal_5 = "Itpg0IwyfSVyrHBs5gnw";
var Modal_6 = "HuKkGHRTHc05J_y2Ws76";
var _7 = "m0PLWMHqMaf7tXIVk9YD";
var _8 = "zCdJdz0ooXBSo_xDSXmr";


;// ./src/shared/ui/assets/images/cross.svg
const cross_namespaceObject = __webpack_require__.p + "cbb53d72901466c6fcc8.svg";
;// ./src/shared/ui/modal/Modal.tsx





const Modal = (p) => {
    const containerRef = (0,react.useRef)(null);
    const backdropRef = (0,react.useRef)(null);
    const handleClick = () => {
        containerRef.current?.classList.add(Modal_5);
        backdropRef.current?.classList.add(Modal_5);
        const timeCall = performance.now();
        const timeWait = () => {
            if (performance.now() - timeCall >= 300) {
                p.close();
            }
            else {
                requestAnimationFrame(timeWait);
            }
        };
        requestAnimationFrame(timeWait);
    };
    return p.open && (0,react_dom.createPortal)(((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)("div", { className: Modal_1, onClick: handleClick, ref: backdropRef }), (0,jsx_runtime.jsxs)("div", { className: Modal_3, ref: containerRef, children: [(0,jsx_runtime.jsx)("div", { className: _7, children: (0,jsx_runtime.jsx)("button", { className: Modal_2, onClick: handleClick, children: (0,jsx_runtime.jsx)("img", { src: cross_namespaceObject, alt: "" }) }) }), (0,jsx_runtime.jsx)("div", { children: p.children })] })] })), document.getElementById('modal-portal'));
};

;// ./src/shared/ui/modal/index.ts


;// ./src/shared/ui/text-input/TextInput.css
// extracted by mini-css-extract-plugin
var TextInput_1 = "iIvjM4MZkyxgUVtIjMKX";
var TextInput_2 = "i5siaC0COQBezdfQtHVq";


;// ./src/shared/lib/classes/classes.ts
const classes = (...args) => args.filter(Boolean).join(' ');

;// ./src/shared/ui/text-input/TextInput.tsx




const TextInput = (0,react.forwardRef)((p, ref) => {
    const { value, setValue, invalid, ...other } = p;
    return ((0,jsx_runtime.jsx)("div", { className: TextInput_1, children: (0,jsx_runtime.jsx)("input", { ...other, "data-invalid": invalid, type: "text", className: classes(TextInput_2, p.className), value: value, placeholder: p.placeholder, onChange: (e) => setValue(e.currentTarget.value), ref: ref }) }));
});

;// ./src/widgets/date-picker/ui/date-input/DateInput.css
// extracted by mini-css-extract-plugin
var DateInput_1 = "HW0IdKu6Fnpk7aKkPXaS";
var DateInput_2 = "BRPw6vc5PFBvnu5yF_gp";
var DateInput_3 = "O_wOqq21BoXDclwRo53H";
var DateInput_4 = "diLwDmzZvBfCGMuh9lEm";


;// ./src/shared/ui/assets/images/calendar.svg
const calendar_namespaceObject = __webpack_require__.p + "99e70c241d5d46ada4d3.svg";
;// ./src/widgets/date-picker/ui/date-picker/DatePicker.css
// extracted by mini-css-extract-plugin
var DatePicker_1 = "IuZ0DmrH4bN_ZVz0EU5g";
var DatePicker_2 = "lbrfD4XgfdSpeDaaCvRI";
var DatePicker_3 = "e9gczb46z3Oe2cvMcLJG";
var DatePicker_4 = "fyruPf95hubIsl43SZWW";
var DatePicker_5 = "AWpcv9jKpCGno0WlA7fP";
var DatePicker_6 = "AfSNJVbrrG1uccT2CuVg";
var DatePicker_7 = "zyZGlLQpKNNqlck6ZNMK";


;// ./src/widgets/date-picker/ui/next-icon/NextIcon.tsx

const NextIcon = () => {
    return ((0,jsx_runtime.jsxs)("svg", { width: "8.064754", height: "14.008184", viewBox: "0 0 8.06475 14.0082", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0,jsx_runtime.jsx)("path", { id: "\u0424\u043E\u0440\u043C\u0430 4", d: "M0.32 1.71L0.29 1.71C-0.1 1.31 -0.1 0.69 0.29 0.29C0.69 -0.1 1.31 -0.1 1.71 0.29L1.71 0.32L0.32 1.71ZM1.71 13.68L1.71 13.71C1.31 14.1 0.69 14.1 0.29 13.71C-0.1 13.31 -0.1 12.69 0.29 12.29L0.32 12.29L1.71 13.68Z", fill: "#000000", fillOpacity: "0", fillRule: "nonzero" }), (0,jsx_runtime.jsx)("path", { id: "\u0424\u043E\u0440\u043C\u0430 4", d: "M1 1L7 7L1 13", stroke: "#26354C", strokeOpacity: "1.000000", strokeWidth: "2.000000", strokeLinejoin: "round", strokeLinecap: "round" })] }));
};

;// ./src/widgets/date-picker/ui/next-icon/index.ts


;// ./src/widgets/date-picker/ui/calendar-date/CalendarDate.css
// extracted by mini-css-extract-plugin
var CalendarDate_1 = "vy2iT9f3MFWe2_8lu306";
var CalendarDate_2 = "Inur1bBoX_zLPamGYppP";
var CalendarDate_3 = "wG5qFkeyGA_qYjPtAKH3";


;// ./src/widgets/date-picker/ui/calendar-date/CalendarDate.tsx




const CalendarDate = (p) => {
    const currentClass = p.currentMonth ? CalendarDate_2 : CalendarDate_3;
    const { setValue } = useDateInputContext();
    const onClickHandler = () => {
        setValue(p.dateString);
    };
    return ((0,jsx_runtime.jsx)("button", { className: CalendarDate_1, "data-current-day": p.currentDay, onClick: onClickHandler, type: "button", children: (0,jsx_runtime.jsx)(Typography.Text, { className: currentClass, children: p.date }) }));
};

;// ./src/widgets/date-picker/ui/calendar-date/index.ts


;// ./src/widgets/date-picker/lib/get-month-start-date/getMonthStartDate.ts
/**
 * Метод для получения начальной даты для календаря
 * @param date
 */
const getMonthStartDate = (date) => {
    const now = new Date(date);
    now.setDate(1);
    const weekDay = now.getDay();
    now.setDate(now.getDate() - (weekDay - 1));
    return now;
};

;// ./src/widgets/date-picker/lib/get-month-end-date/getMonthEndDate.ts
/**
 * Метод для получения конечной даты для календаря
 * @param date
 */
const getMonthEndDate = (date) => {
    const now = new Date(date);
    now.setFullYear(now.getFullYear(), now.getMonth() + 1, 1);
    const weekDay = now.getDay();
    if (weekDay === 1) {
        now.setDate(now.getDate() - 1);
    }
    else if (weekDay !== 0) {
        now.setDate(now.getDate() + 7 - weekDay);
    }
    return now;
};

;// ./src/widgets/date-picker/lib/get-month-dates/getMonthDates.ts


const getMonthDates = (currentMonth) => {
    const now = new Date();
    const currentDate = now.toDateString();
    now.setMonth(currentMonth, 1);
    const start = getMonthStartDate(now);
    const end = getMonthEndDate(now);
    const dates = [];
    const endDateString = end.toLocaleDateString();
    let startDateString = '';
    while (startDateString !== endDateString) {
        dates.push({
            date: start.getDate(),
            currentMonth: start.getMonth() === currentMonth,
            currentDate: start.toDateString() === currentDate,
            dateString: start.toLocaleDateString()
        });
        start.setDate(start.getDate() + 1);
        startDateString = start.toLocaleDateString();
    }
    dates.push({
        date: start.getDate(),
        currentMonth: start.getMonth() === currentMonth,
        currentDate: start.toDateString() === currentDate,
        dateString: start.toLocaleDateString()
    });
    return dates;
};

;// ./src/widgets/date-picker/lib/get-date-title/getDateTitle.ts
const getDateTitle = (date) => {
    return date.toLocaleDateString('ru-RU', {
        year: 'numeric',
        month: 'long',
    });
};

;// ./src/widgets/date-picker/ui/date-picker/DatePicker.tsx









const DatePicker = (p) => {
    const [currentMonth, setCurrentMonth] = (0,react.useState)(new Date().getMonth());
    const dates = getMonthDates(currentMonth);
    const now = new Date();
    now.setMonth(currentMonth, 1);
    return ((0,jsx_runtime.jsxs)("div", { className: DatePicker_2, children: [(0,jsx_runtime.jsxs)("div", { className: DatePicker_4, children: [(0,jsx_runtime.jsx)(Typography.Heading, { className: DatePicker_6, children: getDateTitle(now) }), (0,jsx_runtime.jsx)("button", { className: classes(DatePicker_5, DatePicker_3), onClick: () => setCurrentMonth(prev => prev - 1), type: "button", children: (0,jsx_runtime.jsx)(NextIcon, {}) }), (0,jsx_runtime.jsx)("button", { className: DatePicker_5, onClick: () => setCurrentMonth(prev => prev + 1), type: "button", children: (0,jsx_runtime.jsx)(NextIcon, {}) })] }), (0,jsx_runtime.jsxs)("div", { className: DatePicker_7, children: [(0,jsx_runtime.jsx)(Typography.Text, { children: "\u041F\u043D" }), (0,jsx_runtime.jsx)(Typography.Text, { children: "\u0412\u0442" }), (0,jsx_runtime.jsx)(Typography.Text, { children: "\u0421\u0440" }), (0,jsx_runtime.jsx)(Typography.Text, { children: "\u0427\u0442" }), (0,jsx_runtime.jsx)(Typography.Text, { children: "\u041F\u0442" }), (0,jsx_runtime.jsx)(Typography.Text, { children: "\u0421\u0431" }), (0,jsx_runtime.jsx)(Typography.Text, { children: "\u0412\u0441" })] }), (0,jsx_runtime.jsx)("div", { className: DatePicker_1, children: dates.map(i => ((0,jsx_runtime.jsx)(CalendarDate, { date: i.date, currentMonth: i.currentMonth, currentDay: i.currentDate, dateString: i.dateString }, i.dateString))) })] }));
};

;// ./src/widgets/date-picker/ui/date-picker/index.ts


;// ./src/widgets/date-picker/ui/date-input/DateInput.tsx





const DateInputContext = (0,react.createContext)({
    value: '',
    setValue: () => { },
});
const useDateInputContext = () => (0,react.useContext)(DateInputContext);
const DateInput = ({ value, setValue, invalid }) => {
    const inputRef = (0,react.useRef)(null);
    return ((0,jsx_runtime.jsx)(DateInputContext.Provider, { value: { value, setValue }, children: (0,jsx_runtime.jsxs)("div", { className: DateInput_1, "data-invalid": invalid, children: [(0,jsx_runtime.jsx)("div", { className: DateInput_2, children: (0,jsx_runtime.jsx)(DatePicker, {}) }), (0,jsx_runtime.jsx)("input", { ref: inputRef, className: DateInput_4, type: "text", value: value, placeholder: "00.00.0000", readOnly: true }), (0,jsx_runtime.jsx)("img", { className: DateInput_3, src: calendar_namespaceObject, alt: "" })] }) }));
};

;// ./src/widgets/date-picker/ui/date-input/index.ts


;// ./src/widgets/date-picker/index.ts


;// ./src/widgets/create-task-modal/ui/CreateTaskModal.css
// extracted by mini-css-extract-plugin
var CreateTaskModal_1 = "Hb_YvyuujnNiqE9uc8L5";
var CreateTaskModal_2 = "WYduAcZWzGxjp3tHqvpK";
var CreateTaskModal_3 = "NQrqKAo4EpMQF1wQK7tQ";
var CreateTaskModal_4 = "rw1Ec5dcy7MTdMwP_1HW";
var CreateTaskModal_5 = "fNVtyaSpYiVLE3ixN3TV";


;// ./src/shared/ui/textarea/Textarea.css
// extracted by mini-css-extract-plugin
var Textarea_1 = "og6OWvMLCcEdPTE8pzaX";
var Textarea_2 = "d6fP1NhApkSKP8MS3onl";


;// ./src/shared/ui/textarea/Textarea.tsx



const Textarea = (p) => {
    const { value, setValue, ...other } = p;
    return ((0,jsx_runtime.jsx)("div", { className: Textarea_1, children: (0,jsx_runtime.jsx)("textarea", { ...other, value: value, onChange: e => setValue(e.currentTarget.value), className: classes(Textarea_2, p.className) }) }));
};

;// ./src/shared/config/colors.ts
const colors = {
    red: '#E75A62',
    blue: '#3d7fed',
    green: '#32975d',
    purple: '#9b52e1',
    yellow: '#f2c957',
    orange: '#f29955',
};

;// ./src/shared/config/index.ts


;// ./src/shared/ui/button/Button.css
// extracted by mini-css-extract-plugin
var Button_1 = "L9u_UgFIY5SL_Dsbr97U";


;// ./src/shared/ui/button/Button.tsx



const Button = (p) => {
    return ((0,jsx_runtime.jsx)("button", { ...p, className: classes(Button_1, p.className), children: p.children }));
};

;// ./src/shared/ui/button/index.ts


;// ./src/widgets/create-task-modal/ui/color-pick/ColorPick.css
// extracted by mini-css-extract-plugin
var ColorPick_1 = "x0Mu02_3rXFKfRHOFllw";
var ColorPick_2 = "PiE9GrlAVtkxoGHF0kLd";


;// ./src/widgets/create-task-modal/ui/color-pick/ColorPick.tsx



const ColorPick = (p) => {
    const id = (0,react.useId)();
    return ((0,jsx_runtime.jsxs)("label", { htmlFor: id, className: ColorPick_2, style: { color: p.value }, children: [(0,jsx_runtime.jsx)("input", { type: "radio", name: "color", value: p.value, id: id, checked: p.checked, onChange: p.onChange }), (0,jsx_runtime.jsx)("div", { className: ColorPick_1, style: { backgroundColor: p.value } })] }));
};

;// ./node_modules/react-hook-form/dist/index.esm.mjs


var isCheckBoxInput = (element) => element.type === 'checkbox';

var isDateObject = (value) => value instanceof Date;

var isNullOrUndefined = (value) => value == null;

const isObjectType = (value) => typeof value === 'object';
var index_esm_isObject = (value) => !isNullOrUndefined(value) &&
    !Array.isArray(value) &&
    isObjectType(value) &&
    !isDateObject(value);

var getEventValue = (event) => index_esm_isObject(event) && event.target
    ? isCheckBoxInput(event.target)
        ? event.target.checked
        : event.target.value
    : event;

var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;

var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));

var index_esm_isPlainObject = (tempObject) => {
    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
    return (index_esm_isObject(prototypeCopy) && prototypeCopy.hasOwnProperty('isPrototypeOf'));
};

var isWeb = typeof window !== 'undefined' &&
    typeof window.HTMLElement !== 'undefined' &&
    typeof document !== 'undefined';

function cloneObject(data) {
    let copy;
    const isArray = Array.isArray(data);
    const isFileListInstance = typeof FileList !== 'undefined' ? data instanceof FileList : false;
    if (data instanceof Date) {
        copy = new Date(data);
    }
    else if (data instanceof Set) {
        copy = new Set(data);
    }
    else if (!(isWeb && (data instanceof Blob || isFileListInstance)) &&
        (isArray || index_esm_isObject(data))) {
        copy = isArray ? [] : {};
        if (!isArray && !index_esm_isPlainObject(data)) {
            copy = data;
        }
        else {
            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    copy[key] = cloneObject(data[key]);
                }
            }
        }
    }
    else {
        return data;
    }
    return copy;
}

var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];

var isUndefined = (val) => val === undefined;

var index_esm_get = (object, path, defaultValue) => {
    if (!path || !index_esm_isObject(object)) {
        return defaultValue;
    }
    const result = compact(path.split(/[,[\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], object);
    return isUndefined(result) || result === object
        ? isUndefined(object[path])
            ? defaultValue
            : object[path]
        : result;
};

var isBoolean = (value) => typeof value === 'boolean';

var isKey = (value) => /^\w*$/.test(value);

var stringToPath = (input) => compact(input.replace(/["|']|\]/g, '').split(/\.|\[/));

var index_esm_set = (object, path, value) => {
    let index = -1;
    const tempPath = isKey(path) ? [path] : stringToPath(path);
    const length = tempPath.length;
    const lastIndex = length - 1;
    while (++index < length) {
        const key = tempPath[index];
        let newValue = value;
        if (index !== lastIndex) {
            const objValue = object[key];
            newValue =
                index_esm_isObject(objValue) || Array.isArray(objValue)
                    ? objValue
                    : !isNaN(+tempPath[index + 1])
                        ? []
                        : {};
        }
        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
            return;
        }
        object[key] = newValue;
        object = object[key];
    }
    return object;
};

const EVENTS = {
    BLUR: 'blur',
    FOCUS_OUT: 'focusout',
    CHANGE: 'change',
};
const VALIDATION_MODE = {
    onBlur: 'onBlur',
    onChange: 'onChange',
    onSubmit: 'onSubmit',
    onTouched: 'onTouched',
    all: 'all',
};
const INPUT_VALIDATION_RULES = {
    max: 'max',
    min: 'min',
    maxLength: 'maxLength',
    minLength: 'minLength',
    pattern: 'pattern',
    required: 'required',
    validate: 'validate',
};

const HookFormContext = react.createContext(null);
/**
 * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
 *
 * @returns return all useForm methods
 *
 * @example
 * ```tsx
 * function App() {
 *   const methods = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   return (
 *     <FormProvider {...methods} >
 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
 *         <NestedInput />
 *         <input type="submit" />
 *       </form>
 *     </FormProvider>
 *   );
 * }
 *
 *  function NestedInput() {
 *   const { register } = useFormContext(); // retrieve all hook methods
 *   return <input {...register("test")} />;
 * }
 * ```
 */
const useFormContext = () => react.useContext(HookFormContext);
/**
 * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
 *
 * @param props - all useForm methods
 *
 * @example
 * ```tsx
 * function App() {
 *   const methods = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   return (
 *     <FormProvider {...methods} >
 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
 *         <NestedInput />
 *         <input type="submit" />
 *       </form>
 *     </FormProvider>
 *   );
 * }
 *
 *  function NestedInput() {
 *   const { register } = useFormContext(); // retrieve all hook methods
 *   return <input {...register("test")} />;
 * }
 * ```
 */
const FormProvider = (props) => {
    const { children, ...data } = props;
    return (React.createElement(HookFormContext.Provider, { value: data }, children));
};

var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
    const result = {
        defaultValues: control._defaultValues,
    };
    for (const key in formState) {
        Object.defineProperty(result, key, {
            get: () => {
                const _key = key;
                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
                }
                localProxyFormState && (localProxyFormState[_key] = true);
                return formState[_key];
            },
        });
    }
    return result;
};

var isEmptyObject = (value) => index_esm_isObject(value) && !Object.keys(value).length;

var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
    updateFormState(formStateData);
    const { name, ...formState } = formStateData;
    return (isEmptyObject(formState) ||
        Object.keys(formState).length >= Object.keys(_proxyFormState).length ||
        Object.keys(formState).find((key) => _proxyFormState[key] ===
            (!isRoot || VALIDATION_MODE.all)));
};

var convertToArrayPayload = (value) => (Array.isArray(value) ? value : [value]);

var shouldSubscribeByName = (name, signalName, exact) => !name ||
    !signalName ||
    name === signalName ||
    convertToArrayPayload(name).some((currentName) => currentName &&
        (exact
            ? currentName === signalName
            : currentName.startsWith(signalName) ||
                signalName.startsWith(currentName)));

function useSubscribe(props) {
    const _props = react.useRef(props);
    _props.current = props;
    react.useEffect(() => {
        const subscription = !props.disabled &&
            _props.current.subject &&
            _props.current.subject.subscribe({
                next: _props.current.next,
            });
        return () => {
            subscription && subscription.unsubscribe();
        };
    }, [props.disabled]);
}

/**
 * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)
 *
 * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, handleSubmit, control } = useForm({
 *     defaultValues: {
 *     firstName: "firstName"
 *   }});
 *   const { dirtyFields } = useFormState({
 *     control
 *   });
 *   const onSubmit = (data) => console.log(data);
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <input {...register("firstName")} placeholder="First Name" />
 *       {dirtyFields.firstName && <p>Field is dirty.</p>}
 *       <input type="submit" />
 *     </form>
 *   );
 * }
 * ```
 */
function useFormState(props) {
    const methods = useFormContext();
    const { control = methods.control, disabled, name, exact } = props || {};
    const [formState, updateFormState] = react.useState(control._formState);
    const _mounted = react.useRef(true);
    const _localProxyFormState = react.useRef({
        isDirty: false,
        isLoading: false,
        dirtyFields: false,
        touchedFields: false,
        validatingFields: false,
        isValidating: false,
        isValid: false,
        errors: false,
    });
    const _name = react.useRef(name);
    _name.current = name;
    useSubscribe({
        disabled,
        next: (value) => _mounted.current &&
            shouldSubscribeByName(_name.current, value.name, exact) &&
            shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) &&
            updateFormState({
                ...control._formState,
                ...value,
            }),
        subject: control._subjects.state,
    });
    react.useEffect(() => {
        _mounted.current = true;
        _localProxyFormState.current.isValid && control._updateValid(true);
        return () => {
            _mounted.current = false;
        };
    }, [control]);
    return react.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}

var isString = (value) => typeof value === 'string';

var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
    if (isString(names)) {
        isGlobal && _names.watch.add(names);
        return index_esm_get(formValues, names, defaultValue);
    }
    if (Array.isArray(names)) {
        return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), index_esm_get(formValues, fieldName)));
    }
    isGlobal && (_names.watchAll = true);
    return formValues;
};

/**
 * Custom hook to subscribe to field change and isolate re-rendering at the component level.
 *
 * @remarks
 *
 * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
 *
 * @example
 * ```tsx
 * const { control } = useForm();
 * const values = useWatch({
 *   name: "fieldName"
 *   control,
 * })
 * ```
 */
function useWatch(props) {
    const methods = useFormContext();
    const { control = methods.control, name, defaultValue, disabled, exact, } = props || {};
    const _name = react.useRef(name);
    _name.current = name;
    useSubscribe({
        disabled,
        subject: control._subjects.values,
        next: (formState) => {
            if (shouldSubscribeByName(_name.current, formState.name, exact)) {
                updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));
            }
        },
    });
    const [value, updateValue] = react.useState(control._getWatch(name, defaultValue));
    react.useEffect(() => control._removeUnmounted());
    return value;
}

/**
 * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)
 *
 * @param props - the path name to the form field value, and validation rules.
 *
 * @returns field properties, field and form state. {@link UseControllerReturn}
 *
 * @example
 * ```tsx
 * function Input(props) {
 *   const { field, fieldState, formState } = useController(props);
 *   return (
 *     <div>
 *       <input {...field} placeholder={props.name} />
 *       <p>{fieldState.isTouched && "Touched"}</p>
 *       <p>{formState.isSubmitted ? "submitted" : ""}</p>
 *     </div>
 *   );
 * }
 * ```
 */
function useController(props) {
    const methods = useFormContext();
    const { name, disabled, control = methods.control, shouldUnregister } = props;
    const isArrayField = isNameInFieldArray(control._names.array, name);
    const value = useWatch({
        control,
        name,
        defaultValue: index_esm_get(control._formValues, name, index_esm_get(control._defaultValues, name, props.defaultValue)),
        exact: true,
    });
    const formState = useFormState({
        control,
        name,
        exact: true,
    });
    const _registerProps = react.useRef(control.register(name, {
        ...props.rules,
        value,
        ...(isBoolean(props.disabled) ? { disabled: props.disabled } : {}),
    }));
    const fieldState = react.useMemo(() => Object.defineProperties({}, {
        invalid: {
            enumerable: true,
            get: () => !!index_esm_get(formState.errors, name),
        },
        isDirty: {
            enumerable: true,
            get: () => !!index_esm_get(formState.dirtyFields, name),
        },
        isTouched: {
            enumerable: true,
            get: () => !!index_esm_get(formState.touchedFields, name),
        },
        isValidating: {
            enumerable: true,
            get: () => !!index_esm_get(formState.validatingFields, name),
        },
        error: {
            enumerable: true,
            get: () => index_esm_get(formState.errors, name),
        },
    }), [formState, name]);
    const field = react.useMemo(() => ({
        name,
        value,
        ...(isBoolean(disabled) || formState.disabled
            ? { disabled: formState.disabled || disabled }
            : {}),
        onChange: (event) => _registerProps.current.onChange({
            target: {
                value: getEventValue(event),
                name: name,
            },
            type: EVENTS.CHANGE,
        }),
        onBlur: () => _registerProps.current.onBlur({
            target: {
                value: index_esm_get(control._formValues, name),
                name: name,
            },
            type: EVENTS.BLUR,
        }),
        ref: (elm) => {
            const field = index_esm_get(control._fields, name);
            if (field && elm) {
                field._f.ref = {
                    focus: () => elm.focus(),
                    select: () => elm.select(),
                    setCustomValidity: (message) => elm.setCustomValidity(message),
                    reportValidity: () => elm.reportValidity(),
                };
            }
        },
    }), [
        name,
        control._formValues,
        disabled,
        formState.disabled,
        value,
        control._fields,
    ]);
    react.useEffect(() => {
        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
        const updateMounted = (name, value) => {
            const field = index_esm_get(control._fields, name);
            if (field && field._f) {
                field._f.mount = value;
            }
        };
        updateMounted(name, true);
        if (_shouldUnregisterField) {
            const value = cloneObject(index_esm_get(control._options.defaultValues, name));
            index_esm_set(control._defaultValues, name, value);
            if (isUndefined(index_esm_get(control._formValues, name))) {
                index_esm_set(control._formValues, name, value);
            }
        }
        !isArrayField && control.register(name);
        return () => {
            (isArrayField
                ? _shouldUnregisterField && !control._state.action
                : _shouldUnregisterField)
                ? control.unregister(name)
                : updateMounted(name, false);
        };
    }, [name, control, isArrayField, shouldUnregister]);
    react.useEffect(() => {
        control._updateDisabledField({
            disabled,
            fields: control._fields,
            name,
        });
    }, [disabled, name, control]);
    return react.useMemo(() => ({
        field,
        formState,
        fieldState,
    }), [field, formState, fieldState]);
}

/**
 * Component based on `useController` hook to work with controlled component.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)
 *
 * @param props - the path name to the form field value, and validation rules.
 *
 * @returns provide field handler functions, field and form state.
 *
 * @example
 * ```tsx
 * function App() {
 *   const { control } = useForm<FormValues>({
 *     defaultValues: {
 *       test: ""
 *     }
 *   });
 *
 *   return (
 *     <form>
 *       <Controller
 *         control={control}
 *         name="test"
 *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (
 *           <>
 *             <input
 *               onChange={onChange} // send value to hook form
 *               onBlur={onBlur} // notify when input is touched
 *               value={value} // return updated value
 *               ref={ref} // set ref for focus management
 *             />
 *             <p>{formState.isSubmitted ? "submitted" : ""}</p>
 *             <p>{fieldState.isTouched ? "touched" : ""}</p>
 *           </>
 *         )}
 *       />
 *     </form>
 *   );
 * }
 * ```
 */
const Controller = (props) => props.render(useController(props));

const flatten = (obj) => {
    const output = {};
    for (const key of Object.keys(obj)) {
        if (isObjectType(obj[key]) && obj[key] !== null) {
            const nested = flatten(obj[key]);
            for (const nestedKey of Object.keys(nested)) {
                output[`${key}.${nestedKey}`] = nested[nestedKey];
            }
        }
        else {
            output[key] = obj[key];
        }
    }
    return output;
};

const POST_REQUEST = 'post';
/**
 * Form component to manage submission.
 *
 * @param props - to setup submission detail. {@link FormProps}
 *
 * @returns form component or headless render prop.
 *
 * @example
 * ```tsx
 * function App() {
 *   const { control, formState: { errors } } = useForm();
 *
 *   return (
 *     <Form action="/api" control={control}>
 *       <input {...register("name")} />
 *       <p>{errors?.root?.server && 'Server error'}</p>
 *       <button>Submit</button>
 *     </Form>
 *   );
 * }
 * ```
 */
function Form(props) {
    const methods = useFormContext();
    const [mounted, setMounted] = React.useState(false);
    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;
    const submit = async (event) => {
        let hasError = false;
        let type = '';
        await control.handleSubmit(async (data) => {
            const formData = new FormData();
            let formDataJson = '';
            try {
                formDataJson = JSON.stringify(data);
            }
            catch (_a) { }
            const flattenFormValues = flatten(control._formValues);
            for (const key in flattenFormValues) {
                formData.append(key, flattenFormValues[key]);
            }
            if (onSubmit) {
                await onSubmit({
                    data,
                    event,
                    method,
                    formData,
                    formDataJson,
                });
            }
            if (action) {
                try {
                    const shouldStringifySubmissionData = [
                        headers && headers['Content-Type'],
                        encType,
                    ].some((value) => value && value.includes('json'));
                    const response = await fetch(String(action), {
                        method,
                        headers: {
                            ...headers,
                            ...(encType ? { 'Content-Type': encType } : {}),
                        },
                        body: shouldStringifySubmissionData ? formDataJson : formData,
                    });
                    if (response &&
                        (validateStatus
                            ? !validateStatus(response.status)
                            : response.status < 200 || response.status >= 300)) {
                        hasError = true;
                        onError && onError({ response });
                        type = String(response.status);
                    }
                    else {
                        onSuccess && onSuccess({ response });
                    }
                }
                catch (error) {
                    hasError = true;
                    onError && onError({ error });
                }
            }
        })(event);
        if (hasError && props.control) {
            props.control._subjects.state.next({
                isSubmitSuccessful: false,
            });
            props.control.setError('root.server', {
                type,
            });
        }
    };
    React.useEffect(() => {
        setMounted(true);
    }, []);
    return render ? (React.createElement(React.Fragment, null, render({
        submit,
    }))) : (React.createElement("form", { noValidate: mounted, action: action, method: method, encType: encType, onSubmit: submit, ...rest }, children));
}

var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria
    ? {
        ...errors[name],
        types: {
            ...(errors[name] && errors[name].types ? errors[name].types : {}),
            [type]: message || true,
        },
    }
    : {};

var generateId = () => {
    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16 + d) % 16 | 0;
        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
};

var getFocusFieldName = (name, index, options = {}) => options.shouldFocus || isUndefined(options.shouldFocus)
    ? options.focusName ||
        `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.`
    : '';

var getValidationModes = (mode) => ({
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
    isOnAll: mode === VALIDATION_MODE.all,
    isOnTouch: mode === VALIDATION_MODE.onTouched,
});

var isWatched = (name, _names, isBlurEvent) => !isBlurEvent &&
    (_names.watchAll ||
        _names.watch.has(name) ||
        [..._names.watch].some((watchName) => name.startsWith(watchName) &&
            /^\.\w+/.test(name.slice(watchName.length))));

const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
    for (const key of fieldsNames || Object.keys(fields)) {
        const field = index_esm_get(fields, key);
        if (field) {
            const { _f, ...currentField } = field;
            if (_f) {
                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
                    return true;
                }
                else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
                    return true;
                }
                else {
                    if (iterateFieldsByAction(currentField, action)) {
                        break;
                    }
                }
            }
            else if (index_esm_isObject(currentField)) {
                if (iterateFieldsByAction(currentField, action)) {
                    break;
                }
            }
        }
    }
    return;
};

var updateFieldArrayRootError = (errors, error, name) => {
    const fieldArrayErrors = convertToArrayPayload(index_esm_get(errors, name));
    index_esm_set(fieldArrayErrors, 'root', error[name]);
    index_esm_set(errors, name, fieldArrayErrors);
    return errors;
};

var isFileInput = (element) => element.type === 'file';

var index_esm_isFunction = (value) => typeof value === 'function';

var isHTMLElement = (value) => {
    if (!isWeb) {
        return false;
    }
    const owner = value ? value.ownerDocument : 0;
    return (value instanceof
        (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement));
};

var isMessage = (value) => isString(value);

var isRadioInput = (element) => element.type === 'radio';

var isRegex = (value) => value instanceof RegExp;

const defaultResult = {
    value: false,
    isValid: false,
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
    if (Array.isArray(options)) {
        if (options.length > 1) {
            const values = options
                .filter((option) => option && option.checked && !option.disabled)
                .map((option) => option.value);
            return { value: values, isValid: !!values.length };
        }
        return options[0].checked && !options[0].disabled
            ? // @ts-expect-error expected to work in the browser
                options[0].attributes && !isUndefined(options[0].attributes.value)
                    ? isUndefined(options[0].value) || options[0].value === ''
                        ? validResult
                        : { value: options[0].value, isValid: true }
                    : validResult
            : defaultResult;
    }
    return defaultResult;
};

const defaultReturn = {
    isValid: false,
    value: null,
};
var getRadioValue = (options) => Array.isArray(options)
    ? options.reduce((previous, option) => option && option.checked && !option.disabled
        ? {
            isValid: true,
            value: option.value,
        }
        : previous, defaultReturn)
    : defaultReturn;

function getValidateError(result, ref, type = 'validate') {
    if (isMessage(result) ||
        (Array.isArray(result) && result.every(isMessage)) ||
        (isBoolean(result) && !result)) {
        return {
            type,
            message: isMessage(result) ? result : '',
            ref,
        };
    }
}

var getValueAndMessage = (validationData) => index_esm_isObject(validationData) && !isRegex(validationData)
    ? validationData
    : {
        value: validationData,
        message: '',
    };

var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, } = field._f;
    const inputValue = index_esm_get(formValues, name);
    if (!mount || disabledFieldNames.has(name)) {
        return {};
    }
    const inputRef = refs ? refs[0] : ref;
    const setCustomValidity = (message) => {
        if (shouldUseNativeValidation && inputRef.reportValidity) {
            inputRef.setCustomValidity(isBoolean(message) ? '' : message || '');
            inputRef.reportValidity();
        }
    };
    const error = {};
    const isRadio = isRadioInput(ref);
    const isCheckBox = isCheckBoxInput(ref);
    const isRadioOrCheckbox = isRadio || isCheckBox;
    const isEmpty = ((valueAsNumber || isFileInput(ref)) &&
        isUndefined(ref.value) &&
        isUndefined(inputValue)) ||
        (isHTMLElement(ref) && ref.value === '') ||
        inputValue === '' ||
        (Array.isArray(inputValue) && !inputValue.length);
    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
        const message = exceedMax ? maxLengthMessage : minLengthMessage;
        error[name] = {
            type: exceedMax ? maxType : minType,
            message,
            ref,
            ...appendErrorsCurry(exceedMax ? maxType : minType, message),
        };
    };
    if (isFieldArray
        ? !Array.isArray(inputValue) || !inputValue.length
        : required &&
            ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||
                (isBoolean(inputValue) && !inputValue) ||
                (isCheckBox && !getCheckboxValue(refs).isValid) ||
                (isRadio && !getRadioValue(refs).isValid))) {
        const { value, message } = isMessage(required)
            ? { value: !!required, message: required }
            : getValueAndMessage(required);
        if (value) {
            error[name] = {
                type: INPUT_VALIDATION_RULES.required,
                message,
                ref: inputRef,
                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),
            };
            if (!validateAllFieldCriteria) {
                setCustomValidity(message);
                return error;
            }
        }
    }
    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {
        let exceedMax;
        let exceedMin;
        const maxOutput = getValueAndMessage(max);
        const minOutput = getValueAndMessage(min);
        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
            const valueNumber = ref.valueAsNumber ||
                (inputValue ? +inputValue : inputValue);
            if (!isNullOrUndefined(maxOutput.value)) {
                exceedMax = valueNumber > maxOutput.value;
            }
            if (!isNullOrUndefined(minOutput.value)) {
                exceedMin = valueNumber < minOutput.value;
            }
        }
        else {
            const valueDate = ref.valueAsDate || new Date(inputValue);
            const convertTimeToDate = (time) => new Date(new Date().toDateString() + ' ' + time);
            const isTime = ref.type == 'time';
            const isWeek = ref.type == 'week';
            if (isString(maxOutput.value) && inputValue) {
                exceedMax = isTime
                    ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value)
                    : isWeek
                        ? inputValue > maxOutput.value
                        : valueDate > new Date(maxOutput.value);
            }
            if (isString(minOutput.value) && inputValue) {
                exceedMin = isTime
                    ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value)
                    : isWeek
                        ? inputValue < minOutput.value
                        : valueDate < new Date(minOutput.value);
            }
        }
        if (exceedMax || exceedMin) {
            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
            if (!validateAllFieldCriteria) {
                setCustomValidity(error[name].message);
                return error;
            }
        }
    }
    if ((maxLength || minLength) &&
        !isEmpty &&
        (isString(inputValue) || (isFieldArray && Array.isArray(inputValue)))) {
        const maxLengthOutput = getValueAndMessage(maxLength);
        const minLengthOutput = getValueAndMessage(minLength);
        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&
            inputValue.length > +maxLengthOutput.value;
        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&
            inputValue.length < +minLengthOutput.value;
        if (exceedMax || exceedMin) {
            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
            if (!validateAllFieldCriteria) {
                setCustomValidity(error[name].message);
                return error;
            }
        }
    }
    if (pattern && !isEmpty && isString(inputValue)) {
        const { value: patternValue, message } = getValueAndMessage(pattern);
        if (isRegex(patternValue) && !inputValue.match(patternValue)) {
            error[name] = {
                type: INPUT_VALIDATION_RULES.pattern,
                message,
                ref,
                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),
            };
            if (!validateAllFieldCriteria) {
                setCustomValidity(message);
                return error;
            }
        }
    }
    if (validate) {
        if (index_esm_isFunction(validate)) {
            const result = await validate(inputValue, formValues);
            const validateError = getValidateError(result, inputRef);
            if (validateError) {
                error[name] = {
                    ...validateError,
                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message),
                };
                if (!validateAllFieldCriteria) {
                    setCustomValidity(validateError.message);
                    return error;
                }
            }
        }
        else if (index_esm_isObject(validate)) {
            let validationResult = {};
            for (const key in validate) {
                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
                    break;
                }
                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
                if (validateError) {
                    validationResult = {
                        ...validateError,
                        ...appendErrorsCurry(key, validateError.message),
                    };
                    setCustomValidity(validateError.message);
                    if (validateAllFieldCriteria) {
                        error[name] = validationResult;
                    }
                }
            }
            if (!isEmptyObject(validationResult)) {
                error[name] = {
                    ref: inputRef,
                    ...validationResult,
                };
                if (!validateAllFieldCriteria) {
                    return error;
                }
            }
        }
    }
    setCustomValidity(true);
    return error;
};

var appendAt = (data, value) => [
    ...data,
    ...convertToArrayPayload(value),
];

var fillEmptyArray = (value) => Array.isArray(value) ? value.map(() => undefined) : undefined;

function insert(data, index, value) {
    return [
        ...data.slice(0, index),
        ...convertToArrayPayload(value),
        ...data.slice(index),
    ];
}

var moveArrayAt = (data, from, to) => {
    if (!Array.isArray(data)) {
        return [];
    }
    if (isUndefined(data[to])) {
        data[to] = undefined;
    }
    data.splice(to, 0, data.splice(from, 1)[0]);
    return data;
};

var prependAt = (data, value) => [
    ...convertToArrayPayload(value),
    ...convertToArrayPayload(data),
];

function removeAtIndexes(data, indexes) {
    let i = 0;
    const temp = [...data];
    for (const index of indexes) {
        temp.splice(index - i, 1);
        i++;
    }
    return compact(temp).length ? temp : [];
}
var removeArrayAt = (data, index) => isUndefined(index)
    ? []
    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));

var swapArrayAt = (data, indexA, indexB) => {
    [data[indexA], data[indexB]] = [data[indexB], data[indexA]];
};

function baseGet(object, updatePath) {
    const length = updatePath.slice(0, -1).length;
    let index = 0;
    while (index < length) {
        object = isUndefined(object) ? index++ : object[updatePath[index++]];
    }
    return object;
}
function isEmptyArray(obj) {
    for (const key in obj) {
        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
            return false;
        }
    }
    return true;
}
function unset(object, path) {
    const paths = Array.isArray(path)
        ? path
        : isKey(path)
            ? [path]
            : stringToPath(path);
    const childObject = paths.length === 1 ? object : baseGet(object, paths);
    const index = paths.length - 1;
    const key = paths[index];
    if (childObject) {
        delete childObject[key];
    }
    if (index !== 0 &&
        ((index_esm_isObject(childObject) && isEmptyObject(childObject)) ||
            (Array.isArray(childObject) && isEmptyArray(childObject)))) {
        unset(object, paths.slice(0, -1));
    }
    return object;
}

var updateAt = (fieldValues, index, value) => {
    fieldValues[index] = value;
    return fieldValues;
};

/**
 * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)
 *
 * @param props - useFieldArray props
 *
 * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({
 *     defaultValues: {
 *       test: []
 *     }
 *   });
 *   const { fields, append } = useFieldArray({
 *     control,
 *     name: "test"
 *   });
 *
 *   return (
 *     <form onSubmit={handleSubmit(data => console.log(data))}>
 *       {fields.map((item, index) => (
 *          <input key={item.id} {...register(`test.${index}.firstName`)}  />
 *       ))}
 *       <button type="button" onClick={() => append({ firstName: "bill" })}>
 *         append
 *       </button>
 *       <input type="submit" />
 *     </form>
 *   );
 * }
 * ```
 */
function useFieldArray(props) {
    const methods = useFormContext();
    const { control = methods.control, name, keyName = 'id', shouldUnregister, rules, } = props;
    const [fields, setFields] = React.useState(control._getFieldArray(name));
    const ids = React.useRef(control._getFieldArray(name).map(generateId));
    const _fieldIds = React.useRef(fields);
    const _name = React.useRef(name);
    const _actioned = React.useRef(false);
    _name.current = name;
    _fieldIds.current = fields;
    control._names.array.add(name);
    rules &&
        control.register(name, rules);
    useSubscribe({
        next: ({ values, name: fieldArrayName, }) => {
            if (fieldArrayName === _name.current || !fieldArrayName) {
                const fieldValues = index_esm_get(values, _name.current);
                if (Array.isArray(fieldValues)) {
                    setFields(fieldValues);
                    ids.current = fieldValues.map(generateId);
                }
            }
        },
        subject: control._subjects.array,
    });
    const updateValues = React.useCallback((updatedFieldArrayValues) => {
        _actioned.current = true;
        control._updateFieldArray(name, updatedFieldArrayValues);
    }, [control, name]);
    const append = (value, options) => {
        const appendValue = convertToArrayPayload(cloneObject(value));
        const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);
        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);
        ids.current = appendAt(ids.current, appendValue.map(generateId));
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        control._updateFieldArray(name, updatedFieldArrayValues, appendAt, {
            argA: fillEmptyArray(value),
        });
    };
    const prepend = (value, options) => {
        const prependValue = convertToArrayPayload(cloneObject(value));
        const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);
        control._names.focus = getFocusFieldName(name, 0, options);
        ids.current = prependAt(ids.current, prependValue.map(generateId));
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        control._updateFieldArray(name, updatedFieldArrayValues, prependAt, {
            argA: fillEmptyArray(value),
        });
    };
    const remove = (index) => {
        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);
        ids.current = removeArrayAt(ids.current, index);
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        !Array.isArray(index_esm_get(control._fields, name)) &&
            index_esm_set(control._fields, name, undefined);
        control._updateFieldArray(name, updatedFieldArrayValues, removeArrayAt, {
            argA: index,
        });
    };
    const insert$1 = (index, value, options) => {
        const insertValue = convertToArrayPayload(cloneObject(value));
        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);
        control._names.focus = getFocusFieldName(name, index, options);
        ids.current = insert(ids.current, index, insertValue.map(generateId));
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        control._updateFieldArray(name, updatedFieldArrayValues, insert, {
            argA: index,
            argB: fillEmptyArray(value),
        });
    };
    const swap = (indexA, indexB) => {
        const updatedFieldArrayValues = control._getFieldArray(name);
        swapArrayAt(updatedFieldArrayValues, indexA, indexB);
        swapArrayAt(ids.current, indexA, indexB);
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        control._updateFieldArray(name, updatedFieldArrayValues, swapArrayAt, {
            argA: indexA,
            argB: indexB,
        }, false);
    };
    const move = (from, to) => {
        const updatedFieldArrayValues = control._getFieldArray(name);
        moveArrayAt(updatedFieldArrayValues, from, to);
        moveArrayAt(ids.current, from, to);
        updateValues(updatedFieldArrayValues);
        setFields(updatedFieldArrayValues);
        control._updateFieldArray(name, updatedFieldArrayValues, moveArrayAt, {
            argA: from,
            argB: to,
        }, false);
    };
    const update = (index, value) => {
        const updateValue = cloneObject(value);
        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);
        ids.current = [...updatedFieldArrayValues].map((item, i) => !item || i === index ? generateId() : ids.current[i]);
        updateValues(updatedFieldArrayValues);
        setFields([...updatedFieldArrayValues]);
        control._updateFieldArray(name, updatedFieldArrayValues, updateAt, {
            argA: index,
            argB: updateValue,
        }, true, false);
    };
    const replace = (value) => {
        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value));
        ids.current = updatedFieldArrayValues.map(generateId);
        updateValues([...updatedFieldArrayValues]);
        setFields([...updatedFieldArrayValues]);
        control._updateFieldArray(name, [...updatedFieldArrayValues], (data) => data, {}, true, false);
    };
    React.useEffect(() => {
        control._state.action = false;
        isWatched(name, control._names) &&
            control._subjects.state.next({
                ...control._formState,
            });
        if (_actioned.current &&
            (!getValidationModes(control._options.mode).isOnSubmit ||
                control._formState.isSubmitted)) {
            if (control._options.resolver) {
                control._executeSchema([name]).then((result) => {
                    const error = index_esm_get(result.errors, name);
                    const existingError = index_esm_get(control._formState.errors, name);
                    if (existingError
                        ? (!error && existingError.type) ||
                            (error &&
                                (existingError.type !== error.type ||
                                    existingError.message !== error.message))
                        : error && error.type) {
                        error
                            ? index_esm_set(control._formState.errors, name, error)
                            : unset(control._formState.errors, name);
                        control._subjects.state.next({
                            errors: control._formState.errors,
                        });
                    }
                });
            }
            else {
                const field = index_esm_get(control._fields, name);
                if (field &&
                    field._f &&
                    !(getValidationModes(control._options.reValidateMode).isOnSubmit &&
                        getValidationModes(control._options.mode).isOnSubmit)) {
                    validateField(field, control._names.disabled, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error) => !isEmptyObject(error) &&
                        control._subjects.state.next({
                            errors: updateFieldArrayRootError(control._formState.errors, error, name),
                        }));
                }
            }
        }
        control._subjects.values.next({
            name,
            values: { ...control._formValues },
        });
        control._names.focus &&
            iterateFieldsByAction(control._fields, (ref, key) => {
                if (control._names.focus &&
                    key.startsWith(control._names.focus) &&
                    ref.focus) {
                    ref.focus();
                    return 1;
                }
                return;
            });
        control._names.focus = '';
        control._updateValid();
        _actioned.current = false;
    }, [fields, name, control]);
    React.useEffect(() => {
        !index_esm_get(control._formValues, name) && control._updateFieldArray(name);
        return () => {
            (control._options.shouldUnregister || shouldUnregister) &&
                control.unregister(name);
        };
    }, [name, control, keyName, shouldUnregister]);
    return {
        swap: React.useCallback(swap, [updateValues, name, control]),
        move: React.useCallback(move, [updateValues, name, control]),
        prepend: React.useCallback(prepend, [updateValues, name, control]),
        append: React.useCallback(append, [updateValues, name, control]),
        remove: React.useCallback(remove, [updateValues, name, control]),
        insert: React.useCallback(insert$1, [updateValues, name, control]),
        update: React.useCallback(update, [updateValues, name, control]),
        replace: React.useCallback(replace, [updateValues, name, control]),
        fields: React.useMemo(() => fields.map((field, index) => ({
            ...field,
            [keyName]: ids.current[index] || generateId(),
        })), [fields, keyName]),
    };
}

var createSubject = () => {
    let _observers = [];
    const next = (value) => {
        for (const observer of _observers) {
            observer.next && observer.next(value);
        }
    };
    const subscribe = (observer) => {
        _observers.push(observer);
        return {
            unsubscribe: () => {
                _observers = _observers.filter((o) => o !== observer);
            },
        };
    };
    const unsubscribe = () => {
        _observers = [];
    };
    return {
        get observers() {
            return _observers;
        },
        next,
        subscribe,
        unsubscribe,
    };
};

var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);

function index_esm_deepEqual(object1, object2) {
    if (isPrimitive(object1) || isPrimitive(object2)) {
        return object1 === object2;
    }
    if (isDateObject(object1) && isDateObject(object2)) {
        return object1.getTime() === object2.getTime();
    }
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);
    if (keys1.length !== keys2.length) {
        return false;
    }
    for (const key of keys1) {
        const val1 = object1[key];
        if (!keys2.includes(key)) {
            return false;
        }
        if (key !== 'ref') {
            const val2 = object2[key];
            if ((isDateObject(val1) && isDateObject(val2)) ||
                (index_esm_isObject(val1) && index_esm_isObject(val2)) ||
                (Array.isArray(val1) && Array.isArray(val2))
                ? !index_esm_deepEqual(val1, val2)
                : val1 !== val2) {
                return false;
            }
        }
    }
    return true;
}

var isMultipleSelect = (element) => element.type === `select-multiple`;

var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);

var live = (ref) => isHTMLElement(ref) && ref.isConnected;

var objectHasFunction = (data) => {
    for (const key in data) {
        if (index_esm_isFunction(data[key])) {
            return true;
        }
    }
    return false;
};

function markFieldsDirty(data, fields = {}) {
    const isParentNodeArray = Array.isArray(data);
    if (index_esm_isObject(data) || isParentNodeArray) {
        for (const key in data) {
            if (Array.isArray(data[key]) ||
                (index_esm_isObject(data[key]) && !objectHasFunction(data[key]))) {
                fields[key] = Array.isArray(data[key]) ? [] : {};
                markFieldsDirty(data[key], fields[key]);
            }
            else if (!isNullOrUndefined(data[key])) {
                fields[key] = true;
            }
        }
    }
    return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
    const isParentNodeArray = Array.isArray(data);
    if (index_esm_isObject(data) || isParentNodeArray) {
        for (const key in data) {
            if (Array.isArray(data[key]) ||
                (index_esm_isObject(data[key]) && !objectHasFunction(data[key]))) {
                if (isUndefined(formValues) ||
                    isPrimitive(dirtyFieldsFromValues[key])) {
                    dirtyFieldsFromValues[key] = Array.isArray(data[key])
                        ? markFieldsDirty(data[key], [])
                        : { ...markFieldsDirty(data[key]) };
                }
                else {
                    getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
                }
            }
            else {
                dirtyFieldsFromValues[key] = !index_esm_deepEqual(data[key], formValues[key]);
            }
        }
    }
    return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));

var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)
    ? value
    : valueAsNumber
        ? value === ''
            ? NaN
            : value
                ? +value
                : value
        : valueAsDate && isString(value)
            ? new Date(value)
            : setValueAs
                ? setValueAs(value)
                : value;

function getFieldValue(_f) {
    const ref = _f.ref;
    if (isFileInput(ref)) {
        return ref.files;
    }
    if (isRadioInput(ref)) {
        return getRadioValue(_f.refs).value;
    }
    if (isMultipleSelect(ref)) {
        return [...ref.selectedOptions].map(({ value }) => value);
    }
    if (isCheckBoxInput(ref)) {
        return getCheckboxValue(_f.refs).value;
    }
    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}

var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
    const fields = {};
    for (const name of fieldsNames) {
        const field = index_esm_get(_fields, name);
        field && index_esm_set(fields, name, field._f);
    }
    return {
        criteriaMode,
        names: [...fieldsNames],
        fields,
        shouldUseNativeValidation,
    };
};

var getRuleValue = (rule) => isUndefined(rule)
    ? rule
    : isRegex(rule)
        ? rule.source
        : index_esm_isObject(rule)
            ? isRegex(rule.value)
                ? rule.value.source
                : rule.value
            : rule;

const ASYNC_FUNCTION = 'AsyncFunction';
var hasPromiseValidation = (fieldReference) => !!fieldReference &&
    !!fieldReference.validate &&
    !!((index_esm_isFunction(fieldReference.validate) &&
        fieldReference.validate.constructor.name === ASYNC_FUNCTION) ||
        (index_esm_isObject(fieldReference.validate) &&
            Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION)));

var hasValidation = (options) => options.mount &&
    (options.required ||
        options.min ||
        options.max ||
        options.maxLength ||
        options.minLength ||
        options.pattern ||
        options.validate);

function schemaErrorLookup(errors, _fields, name) {
    const error = index_esm_get(errors, name);
    if (error || isKey(name)) {
        return {
            error,
            name,
        };
    }
    const names = name.split('.');
    while (names.length) {
        const fieldName = names.join('.');
        const field = index_esm_get(_fields, fieldName);
        const foundError = index_esm_get(errors, fieldName);
        if (field && !Array.isArray(field) && name !== fieldName) {
            return { name };
        }
        if (foundError && foundError.type) {
            return {
                name: fieldName,
                error: foundError,
            };
        }
        names.pop();
    }
    return {
        name,
    };
}

var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
    if (mode.isOnAll) {
        return false;
    }
    else if (!isSubmitted && mode.isOnTouch) {
        return !(isTouched || isBlurEvent);
    }
    else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
        return !isBlurEvent;
    }
    else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
        return isBlurEvent;
    }
    return true;
};

var unsetEmptyArray = (ref, name) => !compact(index_esm_get(ref, name)).length && unset(ref, name);

const defaultOptions = {
    mode: VALIDATION_MODE.onSubmit,
    reValidateMode: VALIDATION_MODE.onChange,
    shouldFocusError: true,
};
function createFormControl(props = {}) {
    let _options = {
        ...defaultOptions,
        ...props,
    };
    let _formState = {
        submitCount: 0,
        isDirty: false,
        isLoading: index_esm_isFunction(_options.defaultValues),
        isValidating: false,
        isSubmitted: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
        touchedFields: {},
        dirtyFields: {},
        validatingFields: {},
        errors: _options.errors || {},
        disabled: _options.disabled || false,
    };
    let _fields = {};
    let _defaultValues = index_esm_isObject(_options.defaultValues) || index_esm_isObject(_options.values)
        ? cloneObject(_options.defaultValues || _options.values) || {}
        : {};
    let _formValues = _options.shouldUnregister
        ? {}
        : cloneObject(_defaultValues);
    let _state = {
        action: false,
        mount: false,
        watch: false,
    };
    let _names = {
        mount: new Set(),
        disabled: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(),
    };
    let delayErrorCallback;
    let timer = 0;
    const _proxyFormState = {
        isDirty: false,
        dirtyFields: false,
        validatingFields: false,
        touchedFields: false,
        isValidating: false,
        isValid: false,
        errors: false,
    };
    const _subjects = {
        values: createSubject(),
        array: createSubject(),
        state: createSubject(),
    };
    const validationModeBeforeSubmit = getValidationModes(_options.mode);
    const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
    const debounce = (callback) => (wait) => {
        clearTimeout(timer);
        timer = setTimeout(callback, wait);
    };
    const _updateValid = async (shouldUpdateValid) => {
        if (!_options.disabled && (_proxyFormState.isValid || shouldUpdateValid)) {
            const isValid = _options.resolver
                ? isEmptyObject((await _executeSchema()).errors)
                : await executeBuiltInValidation(_fields, true);
            if (isValid !== _formState.isValid) {
                _subjects.state.next({
                    isValid,
                });
            }
        }
    };
    const _updateIsValidating = (names, isValidating) => {
        if (!_options.disabled &&
            (_proxyFormState.isValidating || _proxyFormState.validatingFields)) {
            (names || Array.from(_names.mount)).forEach((name) => {
                if (name) {
                    isValidating
                        ? index_esm_set(_formState.validatingFields, name, isValidating)
                        : unset(_formState.validatingFields, name);
                }
            });
            _subjects.state.next({
                validatingFields: _formState.validatingFields,
                isValidating: !isEmptyObject(_formState.validatingFields),
            });
        }
    };
    const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
        if (args && method && !_options.disabled) {
            _state.action = true;
            if (shouldUpdateFieldsAndState && Array.isArray(index_esm_get(_fields, name))) {
                const fieldValues = method(index_esm_get(_fields, name), args.argA, args.argB);
                shouldSetValues && index_esm_set(_fields, name, fieldValues);
            }
            if (shouldUpdateFieldsAndState &&
                Array.isArray(index_esm_get(_formState.errors, name))) {
                const errors = method(index_esm_get(_formState.errors, name), args.argA, args.argB);
                shouldSetValues && index_esm_set(_formState.errors, name, errors);
                unsetEmptyArray(_formState.errors, name);
            }
            if (_proxyFormState.touchedFields &&
                shouldUpdateFieldsAndState &&
                Array.isArray(index_esm_get(_formState.touchedFields, name))) {
                const touchedFields = method(index_esm_get(_formState.touchedFields, name), args.argA, args.argB);
                shouldSetValues && index_esm_set(_formState.touchedFields, name, touchedFields);
            }
            if (_proxyFormState.dirtyFields) {
                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
            }
            _subjects.state.next({
                name,
                isDirty: _getDirty(name, values),
                dirtyFields: _formState.dirtyFields,
                errors: _formState.errors,
                isValid: _formState.isValid,
            });
        }
        else {
            index_esm_set(_formValues, name, values);
        }
    };
    const updateErrors = (name, error) => {
        index_esm_set(_formState.errors, name, error);
        _subjects.state.next({
            errors: _formState.errors,
        });
    };
    const _setErrors = (errors) => {
        _formState.errors = errors;
        _subjects.state.next({
            errors: _formState.errors,
            isValid: false,
        });
    };
    const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
        const field = index_esm_get(_fields, name);
        if (field) {
            const defaultValue = index_esm_get(_formValues, name, isUndefined(value) ? index_esm_get(_defaultValues, name) : value);
            isUndefined(defaultValue) ||
                (ref && ref.defaultChecked) ||
                shouldSkipSetValueAs
                ? index_esm_set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f))
                : setFieldValue(name, defaultValue);
            _state.mount && _updateValid();
        }
    };
    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
        let shouldUpdateField = false;
        let isPreviousDirty = false;
        const output = {
            name,
        };
        if (!_options.disabled) {
            const disabledField = !!(index_esm_get(_fields, name) &&
                index_esm_get(_fields, name)._f &&
                index_esm_get(_fields, name)._f.disabled);
            if (!isBlurEvent || shouldDirty) {
                if (_proxyFormState.isDirty) {
                    isPreviousDirty = _formState.isDirty;
                    _formState.isDirty = output.isDirty = _getDirty();
                    shouldUpdateField = isPreviousDirty !== output.isDirty;
                }
                const isCurrentFieldPristine = disabledField || index_esm_deepEqual(index_esm_get(_defaultValues, name), fieldValue);
                isPreviousDirty = !!(!disabledField && index_esm_get(_formState.dirtyFields, name));
                isCurrentFieldPristine || disabledField
                    ? unset(_formState.dirtyFields, name)
                    : index_esm_set(_formState.dirtyFields, name, true);
                output.dirtyFields = _formState.dirtyFields;
                shouldUpdateField =
                    shouldUpdateField ||
                        (_proxyFormState.dirtyFields &&
                            isPreviousDirty !== !isCurrentFieldPristine);
            }
            if (isBlurEvent) {
                const isPreviousFieldTouched = index_esm_get(_formState.touchedFields, name);
                if (!isPreviousFieldTouched) {
                    index_esm_set(_formState.touchedFields, name, isBlurEvent);
                    output.touchedFields = _formState.touchedFields;
                    shouldUpdateField =
                        shouldUpdateField ||
                            (_proxyFormState.touchedFields &&
                                isPreviousFieldTouched !== isBlurEvent);
                }
            }
            shouldUpdateField && shouldRender && _subjects.state.next(output);
        }
        return shouldUpdateField ? output : {};
    };
    const shouldRenderByError = (name, isValid, error, fieldState) => {
        const previousFieldError = index_esm_get(_formState.errors, name);
        const shouldUpdateValid = _proxyFormState.isValid &&
            isBoolean(isValid) &&
            _formState.isValid !== isValid;
        if (_options.delayError && error) {
            delayErrorCallback = debounce(() => updateErrors(name, error));
            delayErrorCallback(_options.delayError);
        }
        else {
            clearTimeout(timer);
            delayErrorCallback = null;
            error
                ? index_esm_set(_formState.errors, name, error)
                : unset(_formState.errors, name);
        }
        if ((error ? !index_esm_deepEqual(previousFieldError, error) : previousFieldError) ||
            !isEmptyObject(fieldState) ||
            shouldUpdateValid) {
            const updatedFormState = {
                ...fieldState,
                ...(shouldUpdateValid && isBoolean(isValid) ? { isValid } : {}),
                errors: _formState.errors,
                name,
            };
            _formState = {
                ..._formState,
                ...updatedFormState,
            };
            _subjects.state.next(updatedFormState);
        }
    };
    const _executeSchema = async (name) => {
        _updateIsValidating(name, true);
        const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
        _updateIsValidating(name);
        return result;
    };
    const executeSchemaAndUpdateState = async (names) => {
        const { errors } = await _executeSchema(names);
        if (names) {
            for (const name of names) {
                const error = index_esm_get(errors, name);
                error
                    ? index_esm_set(_formState.errors, name, error)
                    : unset(_formState.errors, name);
            }
        }
        else {
            _formState.errors = errors;
        }
        return errors;
    };
    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
        valid: true,
    }) => {
        for (const name in fields) {
            const field = fields[name];
            if (field) {
                const { _f, ...fieldValue } = field;
                if (_f) {
                    const isFieldArrayRoot = _names.array.has(_f.name);
                    const isPromiseFunction = field._f && hasPromiseValidation(field._f);
                    if (isPromiseFunction && _proxyFormState.validatingFields) {
                        _updateIsValidating([name], true);
                    }
                    const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
                    if (isPromiseFunction && _proxyFormState.validatingFields) {
                        _updateIsValidating([name]);
                    }
                    if (fieldError[_f.name]) {
                        context.valid = false;
                        if (shouldOnlyCheckValid) {
                            break;
                        }
                    }
                    !shouldOnlyCheckValid &&
                        (index_esm_get(fieldError, _f.name)
                            ? isFieldArrayRoot
                                ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name)
                                : index_esm_set(_formState.errors, _f.name, fieldError[_f.name])
                            : unset(_formState.errors, _f.name));
                }
                !isEmptyObject(fieldValue) &&
                    (await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context));
            }
        }
        return context.valid;
    };
    const _removeUnmounted = () => {
        for (const name of _names.unMount) {
            const field = index_esm_get(_fields, name);
            field &&
                (field._f.refs
                    ? field._f.refs.every((ref) => !live(ref))
                    : !live(field._f.ref)) &&
                unregister(name);
        }
        _names.unMount = new Set();
    };
    const _getDirty = (name, data) => !_options.disabled &&
        (name && data && index_esm_set(_formValues, name, data),
            !index_esm_deepEqual(getValues(), _defaultValues));
    const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
        ...(_state.mount
            ? _formValues
            : isUndefined(defaultValue)
                ? _defaultValues
                : isString(names)
                    ? { [names]: defaultValue }
                    : defaultValue),
    }, isGlobal, defaultValue);
    const _getFieldArray = (name) => compact(index_esm_get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? index_esm_get(_defaultValues, name, []) : []));
    const setFieldValue = (name, value, options = {}) => {
        const field = index_esm_get(_fields, name);
        let fieldValue = value;
        if (field) {
            const fieldReference = field._f;
            if (fieldReference) {
                !fieldReference.disabled &&
                    index_esm_set(_formValues, name, getFieldValueAs(value, fieldReference));
                fieldValue =
                    isHTMLElement(fieldReference.ref) && isNullOrUndefined(value)
                        ? ''
                        : value;
                if (isMultipleSelect(fieldReference.ref)) {
                    [...fieldReference.ref.options].forEach((optionRef) => (optionRef.selected = fieldValue.includes(optionRef.value)));
                }
                else if (fieldReference.refs) {
                    if (isCheckBoxInput(fieldReference.ref)) {
                        fieldReference.refs.length > 1
                            ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) &&
                                (checkboxRef.checked = Array.isArray(fieldValue)
                                    ? !!fieldValue.find((data) => data === checkboxRef.value)
                                    : fieldValue === checkboxRef.value))
                            : fieldReference.refs[0] &&
                                (fieldReference.refs[0].checked = !!fieldValue);
                    }
                    else {
                        fieldReference.refs.forEach((radioRef) => (radioRef.checked = radioRef.value === fieldValue));
                    }
                }
                else if (isFileInput(fieldReference.ref)) {
                    fieldReference.ref.value = '';
                }
                else {
                    fieldReference.ref.value = fieldValue;
                    if (!fieldReference.ref.type) {
                        _subjects.values.next({
                            name,
                            values: { ..._formValues },
                        });
                    }
                }
            }
        }
        (options.shouldDirty || options.shouldTouch) &&
            updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
        options.shouldValidate && trigger(name);
    };
    const setValues = (name, value, options) => {
        for (const fieldKey in value) {
            const fieldValue = value[fieldKey];
            const fieldName = `${name}.${fieldKey}`;
            const field = index_esm_get(_fields, fieldName);
            (_names.array.has(name) ||
                index_esm_isObject(fieldValue) ||
                (field && !field._f)) &&
                !isDateObject(fieldValue)
                ? setValues(fieldName, fieldValue, options)
                : setFieldValue(fieldName, fieldValue, options);
        }
    };
    const setValue = (name, value, options = {}) => {
        const field = index_esm_get(_fields, name);
        const isFieldArray = _names.array.has(name);
        const cloneValue = cloneObject(value);
        index_esm_set(_formValues, name, cloneValue);
        if (isFieldArray) {
            _subjects.array.next({
                name,
                values: { ..._formValues },
            });
            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) &&
                options.shouldDirty) {
                _subjects.state.next({
                    name,
                    dirtyFields: getDirtyFields(_defaultValues, _formValues),
                    isDirty: _getDirty(name, cloneValue),
                });
            }
        }
        else {
            field && !field._f && !isNullOrUndefined(cloneValue)
                ? setValues(name, cloneValue, options)
                : setFieldValue(name, cloneValue, options);
        }
        isWatched(name, _names) && _subjects.state.next({ ..._formState });
        _subjects.values.next({
            name: _state.mount ? name : undefined,
            values: { ..._formValues },
        });
    };
    const onChange = async (event) => {
        _state.mount = true;
        const target = event.target;
        let name = target.name;
        let isFieldValueUpdated = true;
        const field = index_esm_get(_fields, name);
        const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
        const _updateIsFieldValueUpdated = (fieldValue) => {
            isFieldValueUpdated =
                Number.isNaN(fieldValue) ||
                    (isDateObject(fieldValue) && isNaN(fieldValue.getTime())) ||
                    index_esm_deepEqual(fieldValue, index_esm_get(_formValues, name, fieldValue));
        };
        if (field) {
            let error;
            let isValid;
            const fieldValue = getCurrentFieldValue();
            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
            const shouldSkipValidation = (!hasValidation(field._f) &&
                !_options.resolver &&
                !index_esm_get(_formState.errors, name) &&
                !field._f.deps) ||
                skipValidation(isBlurEvent, index_esm_get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
            const watched = isWatched(name, _names, isBlurEvent);
            index_esm_set(_formValues, name, fieldValue);
            if (isBlurEvent) {
                field._f.onBlur && field._f.onBlur(event);
                delayErrorCallback && delayErrorCallback(0);
            }
            else if (field._f.onChange) {
                field._f.onChange(event);
            }
            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
            const shouldRender = !isEmptyObject(fieldState) || watched;
            !isBlurEvent &&
                _subjects.values.next({
                    name,
                    type: event.type,
                    values: { ..._formValues },
                });
            if (shouldSkipValidation) {
                if (_proxyFormState.isValid) {
                    if (_options.mode === 'onBlur' && isBlurEvent) {
                        _updateValid();
                    }
                    else if (!isBlurEvent) {
                        _updateValid();
                    }
                }
                return (shouldRender &&
                    _subjects.state.next({ name, ...(watched ? {} : fieldState) }));
            }
            !isBlurEvent && watched && _subjects.state.next({ ..._formState });
            if (_options.resolver) {
                const { errors } = await _executeSchema([name]);
                _updateIsFieldValueUpdated(fieldValue);
                if (isFieldValueUpdated) {
                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
                    error = errorLookupResult.error;
                    name = errorLookupResult.name;
                    isValid = isEmptyObject(errors);
                }
            }
            else {
                _updateIsValidating([name], true);
                error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
                _updateIsValidating([name]);
                _updateIsFieldValueUpdated(fieldValue);
                if (isFieldValueUpdated) {
                    if (error) {
                        isValid = false;
                    }
                    else if (_proxyFormState.isValid) {
                        isValid = await executeBuiltInValidation(_fields, true);
                    }
                }
            }
            if (isFieldValueUpdated) {
                field._f.deps &&
                    trigger(field._f.deps);
                shouldRenderByError(name, isValid, error, fieldState);
            }
        }
    };
    const _focusInput = (ref, key) => {
        if (index_esm_get(_formState.errors, key) && ref.focus) {
            ref.focus();
            return 1;
        }
        return;
    };
    const trigger = async (name, options = {}) => {
        let isValid;
        let validationResult;
        const fieldNames = convertToArrayPayload(name);
        if (_options.resolver) {
            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
            isValid = isEmptyObject(errors);
            validationResult = name
                ? !fieldNames.some((name) => index_esm_get(errors, name))
                : isValid;
        }
        else if (name) {
            validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
                const field = index_esm_get(_fields, fieldName);
                return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
            }))).every(Boolean);
            !(!validationResult && !_formState.isValid) && _updateValid();
        }
        else {
            validationResult = isValid = await executeBuiltInValidation(_fields);
        }
        _subjects.state.next({
            ...(!isString(name) ||
                (_proxyFormState.isValid && isValid !== _formState.isValid)
                ? {}
                : { name }),
            ...(_options.resolver || !name ? { isValid } : {}),
            errors: _formState.errors,
        });
        options.shouldFocus &&
            !validationResult &&
            iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
        return validationResult;
    };
    const getValues = (fieldNames) => {
        const values = {
            ...(_state.mount ? _formValues : _defaultValues),
        };
        return isUndefined(fieldNames)
            ? values
            : isString(fieldNames)
                ? index_esm_get(values, fieldNames)
                : fieldNames.map((name) => index_esm_get(values, name));
    };
    const getFieldState = (name, formState) => ({
        invalid: !!index_esm_get((formState || _formState).errors, name),
        isDirty: !!index_esm_get((formState || _formState).dirtyFields, name),
        error: index_esm_get((formState || _formState).errors, name),
        isValidating: !!index_esm_get(_formState.validatingFields, name),
        isTouched: !!index_esm_get((formState || _formState).touchedFields, name),
    });
    const clearErrors = (name) => {
        name &&
            convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
        _subjects.state.next({
            errors: name ? _formState.errors : {},
        });
    };
    const setError = (name, error, options) => {
        const ref = (index_esm_get(_fields, name, { _f: {} })._f || {}).ref;
        const currentError = index_esm_get(_formState.errors, name) || {};
        // Don't override existing error messages elsewhere in the object tree.
        const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;
        index_esm_set(_formState.errors, name, {
            ...restOfErrorTree,
            ...error,
            ref,
        });
        _subjects.state.next({
            name,
            errors: _formState.errors,
            isValid: false,
        });
        options && options.shouldFocus && ref && ref.focus && ref.focus();
    };
    const watch = (name, defaultValue) => index_esm_isFunction(name)
        ? _subjects.values.subscribe({
            next: (payload) => name(_getWatch(undefined, defaultValue), payload),
        })
        : _getWatch(name, defaultValue, true);
    const unregister = (name, options = {}) => {
        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
            _names.mount.delete(fieldName);
            _names.array.delete(fieldName);
            if (!options.keepValue) {
                unset(_fields, fieldName);
                unset(_formValues, fieldName);
            }
            !options.keepError && unset(_formState.errors, fieldName);
            !options.keepDirty && unset(_formState.dirtyFields, fieldName);
            !options.keepTouched && unset(_formState.touchedFields, fieldName);
            !options.keepIsValidating &&
                unset(_formState.validatingFields, fieldName);
            !_options.shouldUnregister &&
                !options.keepDefaultValue &&
                unset(_defaultValues, fieldName);
        }
        _subjects.values.next({
            values: { ..._formValues },
        });
        _subjects.state.next({
            ..._formState,
            ...(!options.keepDirty ? {} : { isDirty: _getDirty() }),
        });
        !options.keepIsValid && _updateValid();
    };
    const _updateDisabledField = ({ disabled, name, field, fields, }) => {
        if ((isBoolean(disabled) && _state.mount) ||
            !!disabled ||
            _names.disabled.has(name)) {
            disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
            updateTouchAndDirty(name, getFieldValue(field ? field._f : index_esm_get(fields, name)._f), false, false, true);
        }
    };
    const register = (name, options = {}) => {
        let field = index_esm_get(_fields, name);
        const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);
        index_esm_set(_fields, name, {
            ...(field || {}),
            _f: {
                ...(field && field._f ? field._f : { ref: { name } }),
                name,
                mount: true,
                ...options,
            },
        });
        _names.mount.add(name);
        if (field) {
            _updateDisabledField({
                field,
                disabled: isBoolean(options.disabled)
                    ? options.disabled
                    : _options.disabled,
                name,
            });
        }
        else {
            updateValidAndValue(name, true, options.value);
        }
        return {
            ...(disabledIsDefined
                ? { disabled: options.disabled || _options.disabled }
                : {}),
            ...(_options.progressive
                ? {
                    required: !!options.required,
                    min: getRuleValue(options.min),
                    max: getRuleValue(options.max),
                    minLength: getRuleValue(options.minLength),
                    maxLength: getRuleValue(options.maxLength),
                    pattern: getRuleValue(options.pattern),
                }
                : {}),
            name,
            onChange,
            onBlur: onChange,
            ref: (ref) => {
                if (ref) {
                    register(name, options);
                    field = index_esm_get(_fields, name);
                    const fieldRef = isUndefined(ref.value)
                        ? ref.querySelectorAll
                            ? ref.querySelectorAll('input,select,textarea')[0] || ref
                            : ref
                        : ref;
                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
                    const refs = field._f.refs || [];
                    if (radioOrCheckbox
                        ? refs.find((option) => option === fieldRef)
                        : fieldRef === field._f.ref) {
                        return;
                    }
                    index_esm_set(_fields, name, {
                        _f: {
                            ...field._f,
                            ...(radioOrCheckbox
                                ? {
                                    refs: [
                                        ...refs.filter(live),
                                        fieldRef,
                                        ...(Array.isArray(index_esm_get(_defaultValues, name)) ? [{}] : []),
                                    ],
                                    ref: { type: fieldRef.type, name },
                                }
                                : { ref: fieldRef }),
                        },
                    });
                    updateValidAndValue(name, false, undefined, fieldRef);
                }
                else {
                    field = index_esm_get(_fields, name, {});
                    if (field._f) {
                        field._f.mount = false;
                    }
                    (_options.shouldUnregister || options.shouldUnregister) &&
                        !(isNameInFieldArray(_names.array, name) && _state.action) &&
                        _names.unMount.add(name);
                }
            },
        };
    };
    const _focusError = () => _options.shouldFocusError &&
        iterateFieldsByAction(_fields, _focusInput, _names.mount);
    const _disableForm = (disabled) => {
        if (isBoolean(disabled)) {
            _subjects.state.next({ disabled });
            iterateFieldsByAction(_fields, (ref, name) => {
                const currentField = index_esm_get(_fields, name);
                if (currentField) {
                    ref.disabled = currentField._f.disabled || disabled;
                    if (Array.isArray(currentField._f.refs)) {
                        currentField._f.refs.forEach((inputRef) => {
                            inputRef.disabled = currentField._f.disabled || disabled;
                        });
                    }
                }
            }, 0, false);
        }
    };
    const handleSubmit = (onValid, onInvalid) => async (e) => {
        let onValidError = undefined;
        if (e) {
            e.preventDefault && e.preventDefault();
            e.persist && e.persist();
        }
        let fieldValues = cloneObject(_formValues);
        if (_names.disabled.size) {
            for (const name of _names.disabled) {
                index_esm_set(fieldValues, name, undefined);
            }
        }
        _subjects.state.next({
            isSubmitting: true,
        });
        if (_options.resolver) {
            const { errors, values } = await _executeSchema();
            _formState.errors = errors;
            fieldValues = values;
        }
        else {
            await executeBuiltInValidation(_fields);
        }
        unset(_formState.errors, 'root');
        if (isEmptyObject(_formState.errors)) {
            _subjects.state.next({
                errors: {},
            });
            try {
                await onValid(fieldValues, e);
            }
            catch (error) {
                onValidError = error;
            }
        }
        else {
            if (onInvalid) {
                await onInvalid({ ..._formState.errors }, e);
            }
            _focusError();
            setTimeout(_focusError);
        }
        _subjects.state.next({
            isSubmitted: true,
            isSubmitting: false,
            isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
            submitCount: _formState.submitCount + 1,
            errors: _formState.errors,
        });
        if (onValidError) {
            throw onValidError;
        }
    };
    const resetField = (name, options = {}) => {
        if (index_esm_get(_fields, name)) {
            if (isUndefined(options.defaultValue)) {
                setValue(name, cloneObject(index_esm_get(_defaultValues, name)));
            }
            else {
                setValue(name, options.defaultValue);
                index_esm_set(_defaultValues, name, cloneObject(options.defaultValue));
            }
            if (!options.keepTouched) {
                unset(_formState.touchedFields, name);
            }
            if (!options.keepDirty) {
                unset(_formState.dirtyFields, name);
                _formState.isDirty = options.defaultValue
                    ? _getDirty(name, cloneObject(index_esm_get(_defaultValues, name)))
                    : _getDirty();
            }
            if (!options.keepError) {
                unset(_formState.errors, name);
                _proxyFormState.isValid && _updateValid();
            }
            _subjects.state.next({ ..._formState });
        }
    };
    const _reset = (formValues, keepStateOptions = {}) => {
        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
        const cloneUpdatedValues = cloneObject(updatedValues);
        const isEmptyResetValues = isEmptyObject(formValues);
        const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
        if (!keepStateOptions.keepDefaultValues) {
            _defaultValues = updatedValues;
        }
        if (!keepStateOptions.keepValues) {
            if (keepStateOptions.keepDirtyValues) {
                const fieldsToCheck = new Set([
                    ..._names.mount,
                    ...Object.keys(getDirtyFields(_defaultValues, _formValues)),
                ]);
                for (const fieldName of Array.from(fieldsToCheck)) {
                    index_esm_get(_formState.dirtyFields, fieldName)
                        ? index_esm_set(values, fieldName, index_esm_get(_formValues, fieldName))
                        : setValue(fieldName, index_esm_get(values, fieldName));
                }
            }
            else {
                if (isWeb && isUndefined(formValues)) {
                    for (const name of _names.mount) {
                        const field = index_esm_get(_fields, name);
                        if (field && field._f) {
                            const fieldReference = Array.isArray(field._f.refs)
                                ? field._f.refs[0]
                                : field._f.ref;
                            if (isHTMLElement(fieldReference)) {
                                const form = fieldReference.closest('form');
                                if (form) {
                                    form.reset();
                                    break;
                                }
                            }
                        }
                    }
                }
                _fields = {};
            }
            _formValues = _options.shouldUnregister
                ? keepStateOptions.keepDefaultValues
                    ? cloneObject(_defaultValues)
                    : {}
                : cloneObject(values);
            _subjects.array.next({
                values: { ...values },
            });
            _subjects.values.next({
                values: { ...values },
            });
        }
        _names = {
            mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),
            unMount: new Set(),
            array: new Set(),
            disabled: new Set(),
            watch: new Set(),
            watchAll: false,
            focus: '',
        };
        _state.mount =
            !_proxyFormState.isValid ||
                !!keepStateOptions.keepIsValid ||
                !!keepStateOptions.keepDirtyValues;
        _state.watch = !!_options.shouldUnregister;
        _subjects.state.next({
            submitCount: keepStateOptions.keepSubmitCount
                ? _formState.submitCount
                : 0,
            isDirty: isEmptyResetValues
                ? false
                : keepStateOptions.keepDirty
                    ? _formState.isDirty
                    : !!(keepStateOptions.keepDefaultValues &&
                        !index_esm_deepEqual(formValues, _defaultValues)),
            isSubmitted: keepStateOptions.keepIsSubmitted
                ? _formState.isSubmitted
                : false,
            dirtyFields: isEmptyResetValues
                ? {}
                : keepStateOptions.keepDirtyValues
                    ? keepStateOptions.keepDefaultValues && _formValues
                        ? getDirtyFields(_defaultValues, _formValues)
                        : _formState.dirtyFields
                    : keepStateOptions.keepDefaultValues && formValues
                        ? getDirtyFields(_defaultValues, formValues)
                        : keepStateOptions.keepDirty
                            ? _formState.dirtyFields
                            : {},
            touchedFields: keepStateOptions.keepTouched
                ? _formState.touchedFields
                : {},
            errors: keepStateOptions.keepErrors ? _formState.errors : {},
            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful
                ? _formState.isSubmitSuccessful
                : false,
            isSubmitting: false,
        });
    };
    const reset = (formValues, keepStateOptions) => _reset(index_esm_isFunction(formValues)
        ? formValues(_formValues)
        : formValues, keepStateOptions);
    const setFocus = (name, options = {}) => {
        const field = index_esm_get(_fields, name);
        const fieldReference = field && field._f;
        if (fieldReference) {
            const fieldRef = fieldReference.refs
                ? fieldReference.refs[0]
                : fieldReference.ref;
            if (fieldRef.focus) {
                fieldRef.focus();
                options.shouldSelect &&
                    index_esm_isFunction(fieldRef.select) &&
                    fieldRef.select();
            }
        }
    };
    const _updateFormState = (updatedFormState) => {
        _formState = {
            ..._formState,
            ...updatedFormState,
        };
    };
    const _resetDefaultValues = () => index_esm_isFunction(_options.defaultValues) &&
        _options.defaultValues().then((values) => {
            reset(values, _options.resetOptions);
            _subjects.state.next({
                isLoading: false,
            });
        });
    return {
        control: {
            register,
            unregister,
            getFieldState,
            handleSubmit,
            setError,
            _executeSchema,
            _getWatch,
            _getDirty,
            _updateValid,
            _removeUnmounted,
            _updateFieldArray,
            _updateDisabledField,
            _getFieldArray,
            _reset,
            _resetDefaultValues,
            _updateFormState,
            _disableForm,
            _subjects,
            _proxyFormState,
            _setErrors,
            get _fields() {
                return _fields;
            },
            get _formValues() {
                return _formValues;
            },
            get _state() {
                return _state;
            },
            set _state(value) {
                _state = value;
            },
            get _defaultValues() {
                return _defaultValues;
            },
            get _names() {
                return _names;
            },
            set _names(value) {
                _names = value;
            },
            get _formState() {
                return _formState;
            },
            set _formState(value) {
                _formState = value;
            },
            get _options() {
                return _options;
            },
            set _options(value) {
                _options = {
                    ..._options,
                    ...value,
                };
            },
        },
        trigger,
        register,
        handleSubmit,
        watch,
        setValue,
        getValues,
        reset,
        resetField,
        clearErrors,
        unregister,
        setError,
        setFocus,
        getFieldState,
    };
}

/**
 * Custom hook to manage the entire form.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)
 *
 * @param props - form configuration and validation parameters.
 *
 * @returns methods - individual functions to manage the form state. {@link UseFormReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, handleSubmit, watch, formState: { errors } } = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   console.log(watch("example"));
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <input defaultValue="test" {...register("example")} />
 *       <input {...register("exampleRequired", { required: true })} />
 *       {errors.exampleRequired && <span>This field is required</span>}
 *       <button>Submit</button>
 *     </form>
 *   );
 * }
 * ```
 */
function useForm(props = {}) {
    const _formControl = react.useRef(undefined);
    const _values = react.useRef(undefined);
    const [formState, updateFormState] = react.useState({
        isDirty: false,
        isValidating: false,
        isLoading: index_esm_isFunction(props.defaultValues),
        isSubmitted: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        validatingFields: {},
        errors: props.errors || {},
        disabled: props.disabled || false,
        defaultValues: index_esm_isFunction(props.defaultValues)
            ? undefined
            : props.defaultValues,
    });
    if (!_formControl.current) {
        _formControl.current = {
            ...createFormControl(props),
            formState,
        };
    }
    const control = _formControl.current.control;
    control._options = props;
    useSubscribe({
        subject: control._subjects.state,
        next: (value) => {
            if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {
                updateFormState({ ...control._formState });
            }
        },
    });
    react.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
    react.useEffect(() => {
        if (control._proxyFormState.isDirty) {
            const isDirty = control._getDirty();
            if (isDirty !== formState.isDirty) {
                control._subjects.state.next({
                    isDirty,
                });
            }
        }
    }, [control, formState.isDirty]);
    react.useEffect(() => {
        if (props.values && !index_esm_deepEqual(props.values, _values.current)) {
            control._reset(props.values, control._options.resetOptions);
            _values.current = props.values;
            updateFormState((state) => ({ ...state }));
        }
        else {
            control._resetDefaultValues();
        }
    }, [props.values, control]);
    react.useEffect(() => {
        if (props.errors) {
            control._setErrors(props.errors);
        }
    }, [props.errors, control]);
    react.useEffect(() => {
        if (!control._state.mount) {
            control._updateValid();
            control._state.mount = true;
        }
        if (control._state.watch) {
            control._state.watch = false;
            control._subjects.state.next({ ...control._formState });
        }
        control._removeUnmounted();
    });
    react.useEffect(() => {
        props.shouldUnregister &&
            control._subjects.values.next({
                values: control._getWatch(),
            });
    }, [props.shouldUnregister, control]);
    _formControl.current.formState = getProxyFormState(formState, control);
    return _formControl.current;
}


//# sourceMappingURL=index.esm.mjs.map

;// ./src/widgets/create-task-modal/ui/CreateTaskModal.tsx













const CreateTaskModal = mobxreact_esm_observer((p) => {
    const { task, notify } = useRootContext();
    const { handleSubmit, control, reset, formState } = useForm({
        defaultValues: {
            color: colors.red
        }
    });
    const onSubmit = async (data, e) => {
        e?.preventDefault();
        const addingData = {
            ...data,
            progress: 0,
            completed: false
        };
        await task.add(addingData);
        await task.fetch();
        notify.push({
            id: performance.now(),
            type: 'success',
            title: 'Задача создана!'
        });
        reset();
        p.close();
    };
    const onError = (errors, e) => {
        e?.preventDefault();
        notify.push({
            id: performance.now(),
            type: 'error',
            title: 'Ошибки заполнения формы',
        });
    };
    return ((0,jsx_runtime.jsx)(Modal, { close: p.close, open: p.open, children: (0,jsx_runtime.jsxs)("form", { action: "#", onSubmit: handleSubmit(onSubmit, onError), children: [(0,jsx_runtime.jsxs)("label", { htmlFor: "task-name-input", children: [(0,jsx_runtime.jsx)(Typography.Text, { className: CreateTaskModal_3, children: "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0437\u0430\u0434\u0430\u0447\u0438" }), (0,jsx_runtime.jsx)(Controller, { name: 'name', control: control, rules: {
                                required: {
                                    message: 'Это поле обязательно к заполнению',
                                    value: true
                                }
                            }, render: ({ field, fieldState }) => ((0,jsx_runtime.jsx)(TextInput, { id: "task-name-input", placeholder: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435...", value: field.value, setValue: field.onChange, className: CreateTaskModal_4, invalid: fieldState.invalid, ref: (node) => {
                                    node && p.open && node.focus();
                                } })) })] }), (0,jsx_runtime.jsxs)("div", { className: CreateTaskModal_2, children: [(0,jsx_runtime.jsxs)("div", { children: [(0,jsx_runtime.jsx)(Typography.Text, { className: CreateTaskModal_3, children: "\u041D\u0430\u0447\u0430\u043B\u043E" }), (0,jsx_runtime.jsx)(Controller, { name: 'start', control: control, rules: {
                                        required: {
                                            message: 'Это поле обязательно к заполнению',
                                            value: true
                                        }
                                    }, render: ({ field, fieldState }) => ((0,jsx_runtime.jsx)(DateInput, { value: field.value, setValue: field.onChange, invalid: fieldState.invalid })) })] }), (0,jsx_runtime.jsxs)("div", { children: [(0,jsx_runtime.jsx)(Typography.Text, { className: CreateTaskModal_3, children: "\u041A\u043E\u043D\u0435\u0446" }), (0,jsx_runtime.jsx)(Controller, { name: 'end', control: control, rules: {
                                        required: {
                                            message: 'Это поле обязательно к заполнению',
                                            value: true
                                        }
                                    }, render: ({ field, fieldState }) => ((0,jsx_runtime.jsx)(DateInput, { value: field.value, setValue: field.onChange, invalid: fieldState.invalid })) })] })] }), (0,jsx_runtime.jsxs)("label", { htmlFor: "task-description-input", children: [(0,jsx_runtime.jsx)(Typography.Text, { className: CreateTaskModal_3, children: "\u041E\u043F\u0438\u0441\u0430\u043D\u0438\u0435" }), (0,jsx_runtime.jsx)(Controller, { name: 'description', control: control, render: ({ field }) => ((0,jsx_runtime.jsx)(Textarea, { id: "task-description-input", value: field.value, setValue: field.onChange, className: CreateTaskModal_5 })) })] }), (0,jsx_runtime.jsxs)("div", { children: [(0,jsx_runtime.jsx)(Typography.Text, { className: CreateTaskModal_3, children: "\u0426\u0432\u0435\u0442" }), (0,jsx_runtime.jsx)("div", { className: CreateTaskModal_1, children: (0,jsx_runtime.jsx)(Controller, { name: 'color', control: control, render: ({ field }) => ((0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: Object.values(colors).map(i => ((0,jsx_runtime.jsx)(ColorPick, { value: i, checked: i === field.value, onChange: field.onChange }, i))) })) }) })] }), (0,jsx_runtime.jsx)(Button, { children: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C" })] }) }));
});

;// ./src/widgets/create-task-modal/ui/index.ts


;// ./src/widgets/sidebar-tasks/ui/SidebarTasks.tsx









const SidebarTasks = mobxreact_esm_observer(() => {
    const { task } = useRootContext();
    const [modalOpen, setModalOpen] = (0,react.useState)(false);
    (0,react.useEffect)(() => {
        task.fetch();
    }, []);
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsxs)("div", { className: SidebarTasks_2, children: [(0,jsx_runtime.jsxs)("div", { className: _6, children: [(0,jsx_runtime.jsx)(Typography.Heading, { className: SidebarTasks_4, children: "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u043F\u0440\u043E\u0435\u043A\u0442\u0430" }), (0,jsx_runtime.jsxs)("div", { className: _5, children: [(0,jsx_runtime.jsx)(Typography.Text, { children: "\u0417\u0430\u0434\u0430\u0447\u0430" }), (0,jsx_runtime.jsx)(Typography.Text, { children: "\u041F\u0440\u043E\u0433\u0440\u0435\u0441\u0441" })] }), (0,jsx_runtime.jsx)("div", { className: SidebarTasks_3, children: Object.values(task.tasks).map(i => ((0,jsx_runtime.jsx)(SidebarTask, { taskName: i.name, percent: i.progress }, i.id.toString()))) })] }), (0,jsx_runtime.jsxs)("button", { className: SidebarTasks_1, onClick: () => setModalOpen(true), children: [(0,jsx_runtime.jsx)(PlusIcon, {}), (0,jsx_runtime.jsx)(Typography.Text, { children: "\u041D\u043E\u0432\u0430\u044F \u0437\u0430\u0434\u0430\u0447\u0430" })] })] }), (0,jsx_runtime.jsx)(CreateTaskModal, { open: modalOpen, close: () => setModalOpen(false) })] }));
});

;// ./src/widgets/sidebar-tasks/ui/index.ts


;// ./src/pages/gantt/ui/GanttPage.css
// extracted by mini-css-extract-plugin
var GanttPage_1 = "WQwdJzAAZI6rRpaeq9cx";


;// ./src/pages/gantt/ui/chart-view/ChartView.css
// extracted by mini-css-extract-plugin
var ChartView_1 = "E3Mn_SbRLSNC9g9EAKBE";
var ChartView_2 = "CZXvZBAJwhZKm4qEpLtI";
var ChartView_3 = "Fh4rMe91viF84PpF12CC";
var ChartView_4 = "ko50_XsoBoseKXGeKatM";
var ChartView_5 = "fFP9xYRqGp_4ZFgrqPDV";


;// ./src/shared/ui/table-head-element/TableHeadElement.css
// extracted by mini-css-extract-plugin
var TableHeadElement_1 = "KW0no9sUJUfBKYL1h3xu";
var TableHeadElement_2 = "bfbBRAAW5dJry6TzKlQA";
var TableHeadElement_3 = "_UAzBndqrc3NKoXXUHQx";


;// ./src/shared/ui/table-head-element/TableHeadElement.tsx


const TableHeadElement = (p) => {
    return ((0,jsx_runtime.jsxs)("div", { className: TableHeadElement_1, "data-current": p.current, children: [(0,jsx_runtime.jsx)("div", { className: TableHeadElement_3, children: p.day }), (0,jsx_runtime.jsx)("div", { className: TableHeadElement_2, children: p.date })] }));
};

;// ./src/pages/gantt/config/index.ts
const columnWidth = 96;
const outerColumnsCount = 6;

;// ./src/pages/gantt/lib/get-default-date/getDefaultDate.ts
const getDefaultDate = (leftOffset) => {
    const now = new Date();
    now.setDate(now.getDate() - leftOffset);
    return now;
};

;// ./src/shared/lib/get-weekday/getWeekday.ts
const getWeekday = (date) => date.toLocaleDateString('ru-RU', { weekday: 'short' }).toUpperCase();

;// ./src/pages/gantt/lib/get-chart-date/getChartDate.ts

const getChartDate = (nowDateString, date) => ({
    date: date.getDate(),
    dateString: date.toLocaleDateString(),
    weekday: getWeekday(date),
    currentDate: nowDateString === date.toLocaleDateString(),
});

;// ./src/pages/gantt/lib/set-chart-elements-offset/setChartElementsOffset.ts
const setChartElementsOffset = (head, chart, offsetX) => {
    head.style.transform = `translate(${offsetX}px, 0px)`;
    chart.style.transform = `translate(${offsetX}px, 0px)`;
};

;// ./src/widgets/create-task-modal/lib/split-date/splitDate.ts
const splitDate = (dateString) => {
    const splitResult = dateString.split('.').map(Number);
    return new Date(splitResult[2], splitResult[1] - 1, splitResult[0]);
};

;// ./src/pages/gantt/lib/get-chart-right-dates/getChartRightDates.ts


const getChartRightDates = (dates, count, nowString) => {
    const lastDate = splitDate(dates[dates.length - 1].dateString);
    for (let i = 0; i < count; i++) {
        lastDate.setDate(lastDate.getDate() + 1);
        dates.push(getChartDate(nowString, lastDate));
        dates.shift();
    }
    return dates;
};

;// ./src/pages/gantt/lib/get-chart-left-dates/getChartLeftDates.ts


const getChartLeftDates = (dates, count, nowString) => {
    const firstDate = splitDate(dates[0].dateString);
    for (let i = 0; i < count; i++) {
        firstDate.setDate(firstDate.getDate() - 1);
        dates.unshift(getChartDate(nowString, firstDate));
        dates.pop();
    }
    return dates;
};

;// ./src/shared/lib/use-throttle/useThrottle.ts
const useThrottle = (cb, ms) => {
    let timer = null;
    return (...args) => {
        if (timer === null) {
            cb(...args);
            timer = setTimeout(() => timer = null, ms);
        }
    };
};

;// ./src/pages/gantt/ui/chart-column/ChartColumn.css
// extracted by mini-css-extract-plugin
var ChartColumn_1 = "vBfoZKNytwwzVIc29Qy1";


;// ./src/pages/gantt/ui/chart-column/ChartColumn.tsx


const ChartColumn = (p) => {
    return ((0,jsx_runtime.jsx)("div", { className: ChartColumn_1, "data-date-string": p.dateString, draggable: "false" }));
};

;// ./src/pages/gantt/ui/chart-column/index.ts


;// ./src/pages/gantt/ui/chart-tasks/ChartTasks.css
// extracted by mini-css-extract-plugin
var ChartTasks_1 = "dQN_lX2Xis9S13FC92eT";


;// ./src/widgets/table-task/ui/TableTask.css
// extracted by mini-css-extract-plugin
var TableTask_1 = "Dm0L_3st0iE74G0DekfQ";
var TableTask_2 = "u7hl39wJbdLS9tQ33DMA";
var TableTask_3 = "A3xDNYDVrTmW936iKpw9";
var TableTask_4 = "aDk6TxOAGykDSVmUOx9r";
var TableTask_5 = "Ot4LXi9ySWmdoU7cU1bL";


;// ./src/shared/ui/assets/images/table-task-button.svg
const table_task_button_namespaceObject = __webpack_require__.p + "3205118c99a2bab351f8.svg";
;// ./src/entities/task/api/updateTask.ts


const updateTask = async (data) => {
    const connection = await getConnection(TASK_TABLE_NAME);
    const transaction = connection.transaction(TASK_TABLE_NAME, 'readwrite');
    const request = transaction.objectStore(TASK_TABLE_NAME).put(data);
    const response = new Promise((res, rej) => {
        request.onsuccess = () => res(request.result);
        request.onerror = () => rej(request.error);
    });
    connection.close();
    return await response;
};

;// ./src/widgets/context-menu/ui/ContextMenu.css
// extracted by mini-css-extract-plugin
var ContextMenu_1 = "PqarvPYmusPdbcHE_BYW";
var ContextMenu_2 = "QikK9_Bk2o5aIHAt3I2B";
var ContextMenu_3 = "xr5Vi25fEg1whk7op_1r";
var ContextMenu_4 = "qZO2DX1LpqirLCrImV6i";
var ContextMenu_5 = "xJ1_DO04d3692fEhSlQS";
var ContextMenu_6 = "X9OzVYO_vTnnXGvquaKq";
var ContextMenu_7 = "KofHDVPaYFNTwHlZfE_n";
var ContextMenu_8 = "q0giHEHKAeJiZtlBc_Y_";
var _9 = "lamO8Bp3IIeO95lkqjU6";
var ContextMenu_a = "iJ58jkT4z4KMWzjwhnRV";
var ContextMenu_b = "k_Dfr7XtyO57ysPTRVRR";


;// ./src/shared/ui/checkbox/Checkbox.css
// extracted by mini-css-extract-plugin
var Checkbox_1 = "kIma2ueDKBe7t5f3yI7g";
var Checkbox_2 = "ginVzmUIlfsYXhYnvDxW";
var Checkbox_3 = "pydgKgtJrqNX5fnHpZ94";


;// ./src/shared/ui/assets/images/mark.svg
const mark_namespaceObject = __webpack_require__.p + "c449605fc3101da02b97.svg";
;// ./src/shared/ui/checkbox/Checkbox.tsx




const Checkbox = (p) => {
    const id = (0,react.useId)();
    return ((0,jsx_runtime.jsxs)("label", { className: Checkbox_2, id: id, children: [(0,jsx_runtime.jsx)("input", { type: "checkbox", id: id, checked: p.checked, onChange: (e) => p.setChecked(e.currentTarget.checked) }), (0,jsx_runtime.jsx)("div", { className: Checkbox_1, children: (0,jsx_runtime.jsx)("img", { className: Checkbox_3, src: mark_namespaceObject, alt: " " }) })] }));
};

;// ./src/shared/ui/checkbox/index.ts


;// ./src/shared/ui/assets/images/edit.svg
const edit_namespaceObject = __webpack_require__.p + "8be18e4793ec8ca1a0ee.svg";
;// ./src/shared/ui/assets/images/color.svg
const color_namespaceObject = __webpack_require__.p + "992a75b0b9afebcb817f.svg";
;// ./src/shared/ui/assets/images/progress.svg
const progress_namespaceObject = __webpack_require__.p + "d83fed50b5dfd7e550c3.svg";
;// ./src/shared/ui/assets/images/delete.svg
const delete_namespaceObject = __webpack_require__.p + "00ea0e9a9322e6b7aa41.svg";
;// ./src/shared/ui/assets/images/next.svg
const next_namespaceObject = __webpack_require__.p + "b96c0713889e0295e1b6.svg";
;// ./src/widgets/context-menu/ui/ContextMenu.tsx
















const ContextMenu = mobxreact_esm_observer((p) => {
    const { task } = useRootContext();
    const currentTask = task.tasks[p.id.toString()] ?? {};
    const progressButtons = [];
    for (let i = 10; i <= 100; i += 10) {
        progressButtons.push((0,jsx_runtime.jsxs)(Typography.Text, { onClick: () => updateTaskProp('progress', i), className: ContextMenu_7, children: [i, "%"] }, i));
    }
    const updateTaskProp = async (key, value) => {
        await updateTask({ ...currentTask, [key]: value });
        await task.fetch();
    };
    (0,react.useEffect)(() => {
        const handleClose = () => p.close();
        document.addEventListener('click', handleClose);
        return () => document.removeEventListener('click', handleClose);
    }, []);
    return p.open && (0,react_dom.createPortal)(((0,jsx_runtime.jsx)("div", { style: {
            position: 'absolute',
            top: p.y,
            left: p.x
        }, onClick: (e) => e.stopPropagation(), children: (0,jsx_runtime.jsxs)("div", { className: ContextMenu_4, children: [(0,jsx_runtime.jsxs)("div", { className: ContextMenu_b, children: [(0,jsx_runtime.jsx)(Checkbox, { checked: currentTask.completed, setChecked: async () => {
                                await updateTaskProp('completed', !currentTask.completed);
                                await task.fetch();
                            } }), (0,jsx_runtime.jsx)(Typography.Text, { className: ContextMenu_5, children: "\u0412\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u043E" })] }), (0,jsx_runtime.jsxs)("div", { className: ContextMenu_1, children: [(0,jsx_runtime.jsx)("img", { src: edit_namespaceObject, alt: "" }), (0,jsx_runtime.jsx)(Typography.Text, { className: ContextMenu_5, children: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C" })] }), (0,jsx_runtime.jsxs)("div", { className: classes(ContextMenu_1, ContextMenu_a), children: [(0,jsx_runtime.jsx)("img", { src: color_namespaceObject, alt: "" }), (0,jsx_runtime.jsx)(Typography.Text, { className: ContextMenu_5, children: "\u0426\u0432\u0435\u0442" }), (0,jsx_runtime.jsx)("img", { className: ContextMenu_6, src: next_namespaceObject, alt: "" }), (0,jsx_runtime.jsx)("div", { className: _9, children: (0,jsx_runtime.jsx)("div", { className: ContextMenu_3, children: Object.values(colors).map(i => ((0,jsx_runtime.jsx)("div", { onClick: () => updateTaskProp('color', i), className: ContextMenu_2, style: { backgroundColor: i } }, i))) }) })] }), (0,jsx_runtime.jsxs)("div", { className: classes(ContextMenu_1, ContextMenu_a), children: [(0,jsx_runtime.jsx)("img", { src: progress_namespaceObject, alt: "" }), (0,jsx_runtime.jsx)(Typography.Text, { className: ContextMenu_5, children: "\u041F\u0440\u043E\u0433\u0440\u0435\u0441\u0441" }), (0,jsx_runtime.jsx)("img", { className: ContextMenu_6, src: next_namespaceObject, alt: "" }), (0,jsx_runtime.jsx)("div", { className: _9, children: (0,jsx_runtime.jsx)("div", { className: ContextMenu_8, children: progressButtons }) })] }), (0,jsx_runtime.jsxs)("div", { className: ContextMenu_1, onClick: async () => {
                        await task.delete(+p.id);
                        await task.fetch();
                    }, children: [(0,jsx_runtime.jsx)("img", { src: delete_namespaceObject, alt: "" }), (0,jsx_runtime.jsx)(Typography.Text, { className: ContextMenu_5, children: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C" })] })] }) })), document.getElementById('context-menu-portal'));
});

;// ./src/widgets/context-menu/ui/index.ts


;// ./src/widgets/table-task/ui/TableTask.tsx










const TableTask = mobxreact_esm_observer((p) => {
    const [contextMenuOpen, setContextMenuOpen] = (0,react.useState)(false);
    const contextMenuPosition = (0,react.useRef)({ x: 0, y: 0 });
    const { task, notify } = useRootContext();
    const currentTask = task.tasks[p.id.toString()] ?? {};
    const containerRef = (0,react.useRef)(null);
    const parentRef = (0,react.useRef)(null);
    let startMoveX = 0;
    let initWidth = 0;
    let initLeft = 0;
    const mutationObserver = new MutationObserver((mutations) => {
        const targetElem = mutations[0].target;
        initLeft = +targetElem.style.left.replaceAll('px', '');
    });
    const updateDate = async (x, y, key) => {
        const targetElem = document.elementsFromPoint(x, y).find(i => {
            return Boolean(i.attributes.getNamedItem('data-date-string'));
        });
        if (targetElem && currentTask) {
            //обновить
            const targetDate = targetElem.attributes.getNamedItem('data-date-string');
            const newEndDate = targetDate.value;
            await updateTask({ ...currentTask, [key]: newEndDate });
            await task.fetch();
            notify.push({
                id: performance.now(),
                type: 'success',
                title: 'Сроки задачи изменены'
            });
        }
    };
    const handleMouseUpLeft = (e) => {
        startMoveX = 0;
        initWidth = 0;
        initLeft = 0;
        updateDate(e.clientX, e.clientY, 'start');
        document.removeEventListener('mouseup', handleMouseUpLeft);
        document.removeEventListener('mousemove', handleMoveLeft);
    };
    const handleMouseUpRight = (e) => {
        startMoveX = 0;
        initWidth = 0;
        initLeft = 0;
        updateDate(e.clientX, e.clientY, 'end');
        document.removeEventListener('mouseup', handleMouseUpRight);
        document.removeEventListener('mousemove', handleMoveRight);
    };
    const handleMoveLeft = useThrottle((e) => {
        if (parentRef.current) {
            const diff = e.clientX - startMoveX;
            parentRef.current.style.left = initLeft + diff + 'px';
            parentRef.current.style.width = initWidth - diff + 'px';
        }
    }, 100);
    const handleMoveRight = useThrottle((e) => {
        if (parentRef.current) {
            parentRef.current.style.width = initWidth + e.clientX - startMoveX + 'px';
        }
    }, 100);
    const handleMouseDownLeft = (e) => {
        e.stopPropagation();
        if (e.button === 0) {
            mutationObserver.disconnect();
            startMoveX = e.clientX;
            document.addEventListener('mouseup', handleMouseUpLeft);
            document.addEventListener('mousemove', handleMoveLeft);
        }
    };
    const handleMouseDownRight = (e) => {
        e.stopPropagation();
        if (e.button === 0) {
            startMoveX = e.clientX;
            document.addEventListener('mouseup', handleMouseUpRight);
            document.addEventListener('mousemove', handleMoveRight);
        }
    };
    const callbackRef = (node) => {
        if (node) {
            initWidth = node.clientWidth;
            containerRef.current = node;
            const parent = node.parentNode;
            initLeft = parent.offsetLeft;
            parentRef.current = parent;
            mutationObserver.observe(parent, { attributes: true });
        }
        else {
            document.removeEventListener('mouseup', handleMouseUpRight);
            document.removeEventListener('mousemove', handleMoveRight);
            document.removeEventListener('mouseup', handleMouseUpLeft);
            document.removeEventListener('mousemove', handleMoveLeft);
            mutationObserver.disconnect();
        }
    };
    return ((0,jsx_runtime.jsxs)("div", { className: TableTask_2, ref: callbackRef, onContextMenu: (e) => {
            e.preventDefault();
            contextMenuPosition.current.x = e.clientX;
            contextMenuPosition.current.y = e.clientY;
            setContextMenuOpen(true);
        }, children: [(0,jsx_runtime.jsx)("div", { className: TableTask_1, style: { backgroundColor: `color-mix(in oklab, ${currentTask.color}, transparent 60%)` } }), (0,jsx_runtime.jsx)("div", { className: TableTask_4, style: {
                    width: `${currentTask.progress}%`,
                    backgroundColor: currentTask.color
                } }), (0,jsx_runtime.jsxs)("div", { className: TableTask_3, children: [(0,jsx_runtime.jsx)("img", { src: table_task_button_namespaceObject, alt: "", onMouseDown: handleMouseDownLeft, draggable: "false" }), (0,jsx_runtime.jsx)(Typography.Text, { className: TableTask_5, children: currentTask.name }), (0,jsx_runtime.jsxs)(Typography.Text, { className: TableTask_5, children: [currentTask.progress, "%"] }), (0,jsx_runtime.jsx)("img", { src: table_task_button_namespaceObject, alt: "", onMouseDown: handleMouseDownRight, draggable: "false" })] }), (0,jsx_runtime.jsx)(ContextMenu, { open: contextMenuOpen, x: contextMenuPosition.current.x, y: contextMenuPosition.current.y, close: () => setContextMenuOpen(false), id: p.id })] }));
});

;// ./src/widgets/table-task/ui/index.ts


;// ./src/pages/gantt/lib/get-tasks-to-render/getTasksToRender.ts


const getTasksToRender = (tasks, dates) => {
    const tasksToRender = [];
    tasks.forEach(i => {
        const elemStart = document.querySelector(`[data-date-string="${i.start}"]`);
        const elemEnd = document.querySelector(`[data-date-string="${i.end}"]`);
        //если обе даты отображены в таблице
        if (elemStart && elemEnd) {
            //если дата начала и конца совпадают
            if (elemStart === elemEnd) {
                tasksToRender.push({
                    id: i.id,
                    progress: i.progress,
                    taskName: i.name,
                    left: elemStart.offsetLeft,
                    width: columnWidth,
                });
                return;
            }
            tasksToRender.push({
                id: i.id,
                progress: i.progress,
                taskName: i.name,
                left: elemStart.offsetLeft,
                width: elemEnd.offsetLeft - elemStart.offsetLeft + columnWidth,
            });
            return;
        }
        const leftDate = splitDate(dates[0].dateString); //краняя левая дата
        const dayMillis = 1000 * 60 * 60 * 24;
        const startDate = splitDate(i.start);
        const endDate = splitDate(i.end);
        const totalDiff = Math.floor((+endDate - +startDate) / dayMillis);
        const leftDiff = Math.floor((+startDate - +leftDate) / dayMillis);
        tasksToRender.push({
            id: i.id,
            progress: i.progress,
            taskName: i.name,
            left: (leftDiff) * columnWidth,
            width: (totalDiff + 1) * columnWidth,
        });
    });
    return tasksToRender;
};

;// ./src/pages/gantt/ui/chart-tasks/ChartTasks.tsx








const ChartTasks = mobxreact_esm_observer((p) => {
    const { task } = useRootContext();
    const [tasksToRender, setTasksToRender] = (0,react.useState)([]);
    (0,react.useEffect)(() => {
        if (p.dates.length > 0) {
            setTasksToRender(getTasksToRender(Object.values(task.tasks), p.dates));
        }
    }, [p.dates, task.tasks]);
    return ((0,jsx_runtime.jsxs)("div", { className: ChartTasks_1, children: [p.dates.map((i) => (0,jsx_runtime.jsx)(ChartColumn, { dateString: i.dateString }, i.dateString)), tasksToRender.map((i, index) => ((0,jsx_runtime.jsx)("div", { style: {
                    left: i.left,
                    width: i.width,
                    top: index * 65 + 5,
                    height: 59,
                    position: 'absolute'
                }, children: (0,jsx_runtime.jsx)(TableTask, { id: i.id }) }, i.id.toString())))] }));
});

;// ./src/pages/gantt/ui/chart-tasks/index.ts


;// ./src/pages/gantt/ui/chart-view/ChartView.tsx














const defaultOffsetX = columnWidth * -outerColumnsCount;
const todayTitle = new Date().toLocaleString('ru-RU', { month: 'long', year: 'numeric' });
const ChartView = () => {
    const viewRef = (0,react.useRef)(null);
    const headRef = (0,react.useRef)(null);
    const chartRef = (0,react.useRef)(null);
    const coordinatesRef = (0,react.useRef)(null);
    const headTextRef = (0,react.useRef)(null);
    const mutationObserver = new MutationObserver(() => {
        if (coordinatesRef.current && headTextRef.current) {
            const targetElem = document.elementFromPoint(coordinatesRef.current.x, coordinatesRef.current.y);
            const dateString = targetElem.getAttribute('data-date-string');
            if (dateString) {
                const date = splitDate(dateString);
                headTextRef.current.innerText = date.toLocaleString('ru-RU', {
                    month: 'long',
                    year: 'numeric',
                });
            }
        }
    });
    const nowString = new Date().toLocaleDateString();
    const offsetX = defaultOffsetX;
    let isMouseDown = false;
    let moveX = 0;
    const [dates, setDates] = (0,react.useState)([]);
    const handleMove = (e) => {
        if (isMouseDown && headRef.current && chartRef.current) {
            const newOffsetX = offsetX - moveX + e.clientX;
            setChartElementsOffset(headRef.current, chartRef.current, newOffsetX);
            //движение вправо
            if (newOffsetX <= (outerColumnsCount * -2) * columnWidth) {
                setDates([...getChartRightDates(dates, outerColumnsCount, nowString)]);
            }
            //движение влево
            if (newOffsetX >= 0) {
                setDates([...getChartLeftDates(dates, outerColumnsCount, nowString)]);
            }
        }
    };
    const throttledMove = useThrottle(handleMove, 15);
    const handleMouseDown = (e) => {
        //отлавливаем только левую кнопку мыши
        if (e.button === 0) {
            isMouseDown = true;
            moveX = e.clientX;
        }
    };
    const handleMouseUp = () => {
        isMouseDown = false;
        moveX = 0;
    };
    (0,react.useEffect)(() => {
        if (viewRef.current && headRef.current && chartRef.current) {
            headTextRef.current = viewRef.current.querySelector('[data-head-text="true"]');
            const { width } = viewRef.current.getBoundingClientRect();
            const colsCount = Math.ceil(width / columnWidth) + (outerColumnsCount * 2);
            const newDates = [];
            const leftDate = getDefaultDate(outerColumnsCount);
            for (let i = 0; i <= colsCount; i++) {
                newDates.push(getChartDate(nowString, leftDate));
                leftDate.setDate(leftDate.getDate() + 1);
            }
            mutationObserver.observe(headRef.current, { attributes: true });
            setChartElementsOffset(headRef.current, chartRef.current, offsetX);
            setDates(newDates);
        }
        return () => {
            mutationObserver.disconnect();
        };
    }, []);
    (0,react.useEffect)(() => {
        if (headRef.current && chartRef.current) {
            setChartElementsOffset(headRef.current, chartRef.current, defaultOffsetX);
        }
    }, [dates]);
    return ((0,jsx_runtime.jsxs)("div", { className: ChartView_5, ref: viewRef, children: [(0,jsx_runtime.jsxs)("div", { className: ChartView_2, ref: (node) => {
                    if (node) {
                        const bounds = node.getBoundingClientRect();
                        coordinatesRef.current = { x: bounds.x, y: bounds.y + 200 };
                    }
                }, children: [(0,jsx_runtime.jsx)(Typography.Text, { className: ChartView_4, "data-head-text": "true", children: todayTitle }), (0,jsx_runtime.jsx)("div", { className: ChartView_3, ref: headRef, children: dates.map((i) => ((0,jsx_runtime.jsx)(TableHeadElement, { current: i.currentDate, day: i.weekday, date: i.date }, i.dateString))) })] }), (0,jsx_runtime.jsx)("div", { className: ChartView_1, ref: chartRef, onMouseDown: handleMouseDown, onMouseUp: handleMouseUp, onMouseMove: throttledMove, children: (0,jsx_runtime.jsx)(ChartTasks, { dates: dates }) })] }));
};

;// ./src/pages/gantt/ui/chart-view/index.ts


;// ./src/pages/gantt/ui/GanttPage.tsx





const GanttPage = () => {
    return ((0,jsx_runtime.jsxs)("div", { className: GanttPage_1, children: [(0,jsx_runtime.jsx)(SidebarNavigation, {}), (0,jsx_runtime.jsx)(SidebarTasks, {}), (0,jsx_runtime.jsx)(ChartView, {})] }));
};

;// ./src/entities/notify/ui/notify/Notify.css
// extracted by mini-css-extract-plugin
var Notify_1 = "GyupuXv1WvCS3jDPMBmJ";
var Notify_2 = "etzOBqbx_oTADHr1GNVC";
var Notify_3 = "mgqLzM_1iNcP4PhQcvI_";
var Notify_4 = "zflVqVQLZcfCXDKieJ1F";
var Notify_5 = "lHmrI295MuJAKvnCs85K";
var Notify_6 = "SAPX8Zy5sapew9hcjrjr";
var Notify_7 = "kpHmRtHwmXuKA0QVeurh";
var Notify_8 = "iDZqEeW0XwapW1E5bcsX";


;// ./src/shared/ui/assets/images/notify/success.svg
const success_namespaceObject = __webpack_require__.p + "745c2e0c9c3b6a2f4c87.svg";
;// ./src/shared/ui/assets/images/notify/warning.svg
const warning_namespaceObject = __webpack_require__.p + "5789591736ccb4b6bcc6.svg";
;// ./src/shared/ui/assets/images/notify/error.svg
const error_namespaceObject = __webpack_require__.p + "7b7358d8891bfc7e3271.svg";
;// ./src/shared/ui/assets/images/notify/info.svg
const info_namespaceObject = __webpack_require__.p + "a462e0e88cc2bf205ccf.svg";
;// ./src/entities/notify/ui/notify/Notify.tsx









const icons = {
    success: success_namespaceObject,
    warning: warning_namespaceObject,
    info: info_namespaceObject,
    error: error_namespaceObject
};
const Notify = (p) => {
    const { notify } = useRootContext();
    const [close, setClose] = (0,react.useState)(false);
    const handleClick = () => {
        const timeCall = performance.now();
        setClose(true);
        const animate = () => {
            if (performance.now() - timeCall >= 300) {
                notify.delete(p.id);
            }
            else {
                requestAnimationFrame(animate);
            }
        };
        requestAnimationFrame(animate);
    };
    return ((0,jsx_runtime.jsxs)("div", { className: Notify_2, "data-close": close, children: [(0,jsx_runtime.jsx)("img", { className: Notify_5, src: icons[p.type], alt: "" }), (0,jsx_runtime.jsxs)("div", { className: Notify_7, children: [(0,jsx_runtime.jsx)(Typography.Text, { className: Notify_8, children: p.title }), (0,jsx_runtime.jsx)(Typography.Text, { className: Notify_3, children: p.description })] }), (0,jsx_runtime.jsx)("button", { className: Notify_1, onClick: handleClick, children: (0,jsx_runtime.jsx)("svg", { width: "16", height: "16", viewBox: "0 0 352.817 352.817", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0,jsx_runtime.jsx)("path", { id: "path", d: "M9.76 9.76C-3.26 22.78 -3.26 43.88 9.76 56.9L129.26 176.4L9.76 295.91C-3.26 308.93 -3.26 330.03 9.76 343.05C22.78 356.07 43.88 356.07 56.9 343.05L176.4 223.54L295.91 343.05C308.93 356.07 330.03 356.07 343.05 343.05C356.07 330.03 356.07 308.93 343.05 295.91L223.54 176.4L343.05 56.9C356.07 43.88 356.07 22.78 343.05 9.76C330.03 -3.26 308.93 -3.26 295.91 9.76L176.4 129.26L56.9 9.76C43.88 -3.26 22.78 -3.26 9.76 9.76Z", fill: "var(--light-gray)", fillOpacity: "1.000000", fillRule: "nonzero" }) }) })] }));
};

;// ./src/entities/notify/ui/notify/index.ts


;// ./src/entities/notify/ui/notify-block/NotifyBlock.css
// extracted by mini-css-extract-plugin
var NotifyBlock_1 = "EFiLW3EVkesRfzkBmE8Z";


;// ./src/entities/notify/ui/notify-block/NotifyBlock.tsx





const NotifyBlock = mobxreact_esm_observer(() => {
    const { notify } = useRootContext();
    return ((0,jsx_runtime.jsx)("div", { className: NotifyBlock_1, children: notify.notifies.map(i => ((0,jsx_runtime.jsx)(Notify, { id: i.id, type: i.type, title: i.title, description: i.description }, i.id))) }));
});

;// ./src/entities/notify/ui/notify-block/index.ts


;// ./src/app/App.tsx





const App = () => {
    return ((0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: (0,jsx_runtime.jsx)(react.StrictMode, { children: (0,jsx_runtime.jsxs)(RootProvider, { children: [(0,jsx_runtime.jsx)(GanttPage, {}), (0,jsx_runtime.jsx)(NotifyBlock, {})] }) }) }));
};

;// ./src/index.tsx




const rootContainer = document.querySelector('#root');
const root = (0,client.createRoot)(rootContainer);
root.render((0,jsx_runtime.jsx)(App, {}));

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLTIyM2M5NzRiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsZ0JBQWdCLG1CQUFPLENBQUMsR0FBVztBQUNuQyxVQUFVLG1CQUFPLENBQUMsR0FBTztBQUN6QixhQUFhLG1CQUFPLENBQUMsR0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUF5RDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQjtBQUMzQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4QkFBOEIsb0JBQW9CLG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDLHlCQUF5QixpQkFBaUI7QUFDMUU7QUFDQSxpQ0FBaUMsc0JBQXNCLGtCQUFrQjtBQUN6RTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVDQUF1QyxvQkFBb0IsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0RBQWtEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9DQUFvQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0NBQXdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5Q0FBeUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDRCQUE0QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDRCQUE0QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBNEM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQSxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUJBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlDQUFpQztBQUN4RSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUE2QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNENBQTRDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQkFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsVUFBVTtBQUNWO0FBQ0EsMkNBQTJDO0FBQzNDLElBQUk7QUFDSiwyQkFBMkI7QUFDM0I7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0JBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBOEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyQ0FBMkM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQW1CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4Q0FBOEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9DQUFvQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQWdEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUE4RDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQ0FBc0M7QUFDdEMsdUNBQXVDO0FBQ3ZDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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TSxLQUFrRSxFQUFFLEVBRXZFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxNQUFNLEtBQW9ILEVBQUUsa0JBR3pIO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBb0gsRUFBRSxrRUFLekg7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXNFLEVBQUUsRUFFM0U7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFxQyxHQUFHLENBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFVO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG1CQUFVO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG1CQUFVO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG1CQUFVO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBVTtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG1CQUFVO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsbUJBQVU7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxtQkFBVTtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsTUFBTSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUF3RCxFQUFFLEVBRTdEO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBMkQsRUFBRSxFQUVoRTtBQUNIO0FBQ0EsTUFBTSxLQUErRSxFQUFFLEVBRXBGO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQUUxQztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUEyRCxFQUFFLEVBRWhFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQUUxQztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUEyRCxFQUFFLEVBRWhFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQUUxQztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQ0FBb0MsTUFBcUMsR0FBRyxDQUFnQztBQUM1RztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBNkMsRUFBRSxFQUVsRDtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBdUQsRUFBRSxFQVM1RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFVBQVUsS0FBMkUsRUFBRSxFQUVoRjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSxJQUF3QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLE1BQU0sSUFBd0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUErRyxFQUFFLEVBRXBIO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVRQUF1TjtBQUM1TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQXdFLEVBQUUsRUFFN0U7QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUF3RSxFQUFFLEVBRTdFO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FB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Q0g7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUErRCxFQUFFLEVBRXBFO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUE2RixFQUFFLEVBRWxHO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUErRCxFQUFFLEVBRXBFO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUErRCxFQUFFLEVBRXBFO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FB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LEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0RUFBNEUsZUFBZTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFxQyxHQUFHLENBQThCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBcUMsR0FBRyxDQUF1QjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbUJBQW1CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFRO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQVE7QUFDMUIsb0JBQW9CLGlCQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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LEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFDZCxXQUFXLEVBQUUsQ0FBQyxDQUFDLFdBQVcsSUFDckIsQ0FBQyxDQUFDLEVBQUUsQ0FDWCxDQUNMLENBQUMsR0FFSixDQUNULENBQUM7QUFDTixDQUFDLENBQUM7OztBQ3RCdUM7Ozs7QUNBZTtBQUN2QjtBQUM0QjtBQUNJO0FBRTFELE1BQU0sR0FBRyxHQUFHLEdBQUcsRUFBRTtJQUNwQixPQUFPLENBQ0gsc0RBQ0ksb0JBQUMsZ0JBQVUsY0FDUCxxQkFBQyxZQUFZLGVBQ1Qsb0JBQUMsU0FBUyxLQUFFLEVBQ1osb0JBQUMsV0FBVyxLQUFFLElBQ0gsR0FDTixHQUNkLENBQ04sQ0FBQztBQUNOLENBQUMsQ0FBQzs7OztBQ2hCeUM7QUFDVjtBQUNiO0FBRXBCLE1BQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDO0FBQ3JELE1BQU0sSUFBSSxHQUFHLHFCQUFVLENBQUMsYUFBYyxDQUFDO0FBQ3ZDLElBQUksQ0FBQyxNQUFNLENBQUMsb0JBQUMsR0FBRyxLQUFFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLWNsaWVudC5wcm9kdWN0aW9uLmpzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5qcyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5qcyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLmpzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtcnVudGltZS5qcyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24uanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5wcm9kdWN0aW9uLmpzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9nYW50dC1mbG93L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2dhbnR0LWZsb3cvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9nYW50dC1mbG93L3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9zaWRlYmFyLW5hdmlnYXRpb24vdWkvU2lkZWJhck5hdmlnYXRpb24uY3NzP2NiZjYiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9zaGFyZWQvdWkvdG9vbHRpcC9Ub29sdGlwLmNzcz84YzY5Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL3Rvb2x0aXAvVG9vbHRpcC50c3giLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9zaGFyZWQvdWkvdG9vbHRpcC9pbmRleC50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvc2lkZWJhci1uYXZpZ2F0aW9uL3VpL1NpZGViYXJOYXZpZ2F0aW9uLnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvc2lkZWJhci1uYXZpZ2F0aW9uL3VpL2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9zaWRlYmFyLXRhc2tzL3VpL1NpZGViYXJUYXNrcy5jc3M/NTQwMCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC91aS90eXBvZ3JhcGh5L1R5cG9ncmFwaHkuY3NzP2Q3ZDkiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9zaGFyZWQvdWkvdHlwb2dyYXBoeS9UeXBvZ3JhcGh5LnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC91aS90eXBvZ3JhcGh5L2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL3NpZGViYXItdGFzay9TaWRlYmFyVGFzay5jc3M/YWVlOSIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC91aS9kaWFncmFtL0RpYWdyYW0uY3NzPzlmYWEiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9zaGFyZWQvdWkvZGlhZ3JhbS9EaWFncmFtLnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC91aS9kaWFncmFtL2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL3NpZGViYXItdGFzay9TaWRlYmFyVGFzay50c3giLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9zaGFyZWQvdWkvc2lkZWJhci10YXNrL2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvbW9ieC9kaXN0L21vYnguZXNtLmpzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL2Fzc2VydEVudmlyb25tZW50LmpzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL3JlYWN0QmF0Y2hlZFVwZGF0ZXMuanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXRpbHMvb2JzZXJ2ZXJCYXRjaGluZy5qcyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91dGlscy9wcmludERlYnVnVmFsdWUuanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvc3RhdGljUmVuZGVyaW5nLmpzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL1VuaXZlcnNhbEZpbmFsaXphdGlvblJlZ2lzdHJ5LmpzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL29ic2VydmVyRmluYWxpemF0aW9uUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXNlT2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvT2JzZXJ2ZXJDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXNlTG9jYWxPYnNlcnZhYmxlLmpzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3VzZUFzT2JzZXJ2YWJsZVNvdXJjZS5qcyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91c2VMb2NhbFN0b3JlLmpzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL2luZGV4LmpzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC9kaXN0L21vYnhyZWFjdC5lc20uanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9lbnRpdGllcy90YXNrL2NvbmZpZy9jb25maWcudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9zaGFyZWQvYXBpL2luZGV4ZWQtZGIvaW5kZXhlZERCLnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvZW50aXRpZXMvdGFzay9hcGkvZ2V0QWxsVGFza3MudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9lbnRpdGllcy90YXNrL2FwaS9jcmVhdGVUYXNrLnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvZW50aXRpZXMvdGFzay9hcGkvZGVsZXRlVGFzay50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL2VudGl0aWVzL3Rhc2svbW9kZWwvdGFzay5zdG9yZS50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL2VudGl0aWVzL25vdGlmeS9tb2RlbC9ub3RpZnkuc3RvcmUudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9hcHAvc3RvcmVzL3Jvb3RTdG9yZS50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL2FwcC9wcm92aWRlcnMvcm9vdFByb3ZpZGVyLnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3BhZ2VzL2dhbnR0L3VpL3BsdXMtaWNvbi9QbHVzSWNvbi50c3giLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9zaGFyZWQvdWkvbW9kYWwvTW9kYWwuY3NzPzQ2NzMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9zaGFyZWQvdWkvbW9kYWwvTW9kYWwudHN4Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL21vZGFsL2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL3RleHQtaW5wdXQvVGV4dElucHV0LmNzcz9kNjE1Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL2xpYi9jbGFzc2VzL2NsYXNzZXMudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9zaGFyZWQvdWkvdGV4dC1pbnB1dC9UZXh0SW5wdXQudHN4Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9kYXRlLXBpY2tlci91aS9kYXRlLWlucHV0L0RhdGVJbnB1dC5jc3M/YTY2ZCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvZGF0ZS1waWNrZXIvdWkvZGF0ZS1waWNrZXIvRGF0ZVBpY2tlci5jc3M/YTc3YSIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvZGF0ZS1waWNrZXIvdWkvbmV4dC1pY29uL05leHRJY29uLnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvZGF0ZS1waWNrZXIvdWkvbmV4dC1pY29uL2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9kYXRlLXBpY2tlci91aS9jYWxlbmRhci1kYXRlL0NhbGVuZGFyRGF0ZS5jc3M/Y2M2OSIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvZGF0ZS1waWNrZXIvdWkvY2FsZW5kYXItZGF0ZS9DYWxlbmRhckRhdGUudHN4Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9kYXRlLXBpY2tlci91aS9jYWxlbmRhci1kYXRlL2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9kYXRlLXBpY2tlci9saWIvZ2V0LW1vbnRoLXN0YXJ0LWRhdGUvZ2V0TW9udGhTdGFydERhdGUudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy93aWRnZXRzL2RhdGUtcGlja2VyL2xpYi9nZXQtbW9udGgtZW5kLWRhdGUvZ2V0TW9udGhFbmREYXRlLnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9kYXRlLXBpY2tlci9saWIvZ2V0LW1vbnRoLWRhdGVzL2dldE1vbnRoRGF0ZXMudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy93aWRnZXRzL2RhdGUtcGlja2VyL2xpYi9nZXQtZGF0ZS10aXRsZS9nZXREYXRlVGl0bGUudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy93aWRnZXRzL2RhdGUtcGlja2VyL3VpL2RhdGUtcGlja2VyL0RhdGVQaWNrZXIudHN4Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9kYXRlLXBpY2tlci91aS9kYXRlLXBpY2tlci9pbmRleC50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvZGF0ZS1waWNrZXIvdWkvZGF0ZS1pbnB1dC9EYXRlSW5wdXQudHN4Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9kYXRlLXBpY2tlci91aS9kYXRlLWlucHV0L2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9kYXRlLXBpY2tlci9pbmRleC50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvY3JlYXRlLXRhc2stbW9kYWwvdWkvQ3JlYXRlVGFza01vZGFsLmNzcz82YzZkIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL3RleHRhcmVhL1RleHRhcmVhLmNzcz9lNmVmIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL3RleHRhcmVhL1RleHRhcmVhLnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC9jb25maWcvY29sb3JzLnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL2NvbmZpZy9pbmRleC50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC91aS9idXR0b24vQnV0dG9uLmNzcz9kMGVkIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL2J1dHRvbi9CdXR0b24udHN4Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL2J1dHRvbi9pbmRleC50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvY3JlYXRlLXRhc2stbW9kYWwvdWkvY29sb3ItcGljay9Db2xvclBpY2suY3NzPzAxYjkiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy93aWRnZXRzL2NyZWF0ZS10YXNrLW1vZGFsL3VpL2NvbG9yLXBpY2svQ29sb3JQaWNrLnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWhvb2stZm9ybS9kaXN0L2luZGV4LmVzbS5tanMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy93aWRnZXRzL2NyZWF0ZS10YXNrLW1vZGFsL3VpL0NyZWF0ZVRhc2tNb2RhbC50c3giLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy93aWRnZXRzL2NyZWF0ZS10YXNrLW1vZGFsL3VpL2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9zaWRlYmFyLXRhc2tzL3VpL1NpZGViYXJUYXNrcy50c3giLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy93aWRnZXRzL3NpZGViYXItdGFza3MvdWkvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9wYWdlcy9nYW50dC91aS9HYW50dFBhZ2UuY3NzP2Y3MjQiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9wYWdlcy9nYW50dC91aS9jaGFydC12aWV3L0NoYXJ0Vmlldy5jc3M/YjlhMyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC91aS90YWJsZS1oZWFkLWVsZW1lbnQvVGFibGVIZWFkRWxlbWVudC5jc3M/M2UzZSIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC91aS90YWJsZS1oZWFkLWVsZW1lbnQvVGFibGVIZWFkRWxlbWVudC50c3giLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9wYWdlcy9nYW50dC9jb25maWcvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9wYWdlcy9nYW50dC9saWIvZ2V0LWRlZmF1bHQtZGF0ZS9nZXREZWZhdWx0RGF0ZS50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC9saWIvZ2V0LXdlZWtkYXkvZ2V0V2Vla2RheS50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3BhZ2VzL2dhbnR0L2xpYi9nZXQtY2hhcnQtZGF0ZS9nZXRDaGFydERhdGUudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9wYWdlcy9nYW50dC9saWIvc2V0LWNoYXJ0LWVsZW1lbnRzLW9mZnNldC9zZXRDaGFydEVsZW1lbnRzT2Zmc2V0LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy9jcmVhdGUtdGFzay1tb2RhbC9saWIvc3BsaXQtZGF0ZS9zcGxpdERhdGUudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9wYWdlcy9nYW50dC9saWIvZ2V0LWNoYXJ0LXJpZ2h0LWRhdGVzL2dldENoYXJ0UmlnaHREYXRlcy50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3BhZ2VzL2dhbnR0L2xpYi9nZXQtY2hhcnQtbGVmdC1kYXRlcy9nZXRDaGFydExlZnREYXRlcy50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC9saWIvdXNlLXRocm90dGxlL3VzZVRocm90dGxlLnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvcGFnZXMvZ2FudHQvdWkvY2hhcnQtY29sdW1uL0NoYXJ0Q29sdW1uLmNzcz9iZTliIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvcGFnZXMvZ2FudHQvdWkvY2hhcnQtY29sdW1uL0NoYXJ0Q29sdW1uLnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3BhZ2VzL2dhbnR0L3VpL2NoYXJ0LWNvbHVtbi9pbmRleC50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3BhZ2VzL2dhbnR0L3VpL2NoYXJ0LXRhc2tzL0NoYXJ0VGFza3MuY3NzPzVkYTIiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy93aWRnZXRzL3RhYmxlLXRhc2svdWkvVGFibGVUYXNrLmNzcz9mYmExIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvZW50aXRpZXMvdGFzay9hcGkvdXBkYXRlVGFzay50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvY29udGV4dC1tZW51L3VpL0NvbnRleHRNZW51LmNzcz85MmFlIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL2NoZWNrYm94L0NoZWNrYm94LmNzcz85OTkwIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvc2hhcmVkL3VpL2NoZWNrYm94L0NoZWNrYm94LnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3NoYXJlZC91aS9jaGVja2JveC9pbmRleC50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvY29udGV4dC1tZW51L3VpL0NvbnRleHRNZW51LnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3dpZGdldHMvY29udGV4dC1tZW51L3VpL2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvd2lkZ2V0cy90YWJsZS10YXNrL3VpL1RhYmxlVGFzay50c3giLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy93aWRnZXRzL3RhYmxlLXRhc2svdWkvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9wYWdlcy9nYW50dC9saWIvZ2V0LXRhc2tzLXRvLXJlbmRlci9nZXRUYXNrc1RvUmVuZGVyLnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvcGFnZXMvZ2FudHQvdWkvY2hhcnQtdGFza3MvQ2hhcnRUYXNrcy50c3giLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9wYWdlcy9nYW50dC91aS9jaGFydC10YXNrcy9pbmRleC50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3BhZ2VzL2dhbnR0L3VpL2NoYXJ0LXZpZXcvQ2hhcnRWaWV3LnRzeCIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL3BhZ2VzL2dhbnR0L3VpL2NoYXJ0LXZpZXcvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9wYWdlcy9nYW50dC91aS9HYW50dFBhZ2UudHN4Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvZW50aXRpZXMvbm90aWZ5L3VpL25vdGlmeS9Ob3RpZnkuY3NzP2Y1NmEiLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9lbnRpdGllcy9ub3RpZnkvdWkvbm90aWZ5L05vdGlmeS50c3giLCJ3ZWJwYWNrOi8vZ2FudHQtZmxvdy8uL3NyYy9lbnRpdGllcy9ub3RpZnkvdWkvbm90aWZ5L2luZGV4LnRzIiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvZW50aXRpZXMvbm90aWZ5L3VpL25vdGlmeS1ibG9jay9Ob3RpZnlCbG9jay5jc3M/MzAzNyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL2VudGl0aWVzL25vdGlmeS91aS9ub3RpZnktYmxvY2svTm90aWZ5QmxvY2sudHN4Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvZW50aXRpZXMvbm90aWZ5L3VpL25vdGlmeS1ibG9jay9pbmRleC50cyIsIndlYnBhY2s6Ly9nYW50dC1mbG93Ly4vc3JjL2FwcC9BcHAudHN4Iiwid2VicGFjazovL2dhbnR0LWZsb3cvLi9zcmMvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS1jbGllbnQucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBTY2hlZHVsZXIgPSByZXF1aXJlKFwic2NoZWR1bGVyXCIpLFxuICBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgUmVhY3RET00gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHZhciB1cmwgPSBcImh0dHBzOi8vcmVhY3QuZGV2L2Vycm9ycy9cIiArIGNvZGU7XG4gIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHVybCArPSBcIj9hcmdzW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzWzFdKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIHVybCArPSBcIiZhcmdzW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2ldKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIFwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiICtcbiAgICBjb2RlICtcbiAgICBcIjsgdmlzaXQgXCIgK1xuICAgIHVybCArXG4gICAgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiXG4gICk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEoXG4gICAgIW5vZGUgfHxcbiAgICAoMSAhPT0gbm9kZS5ub2RlVHlwZSAmJiA5ICE9PSBub2RlLm5vZGVUeXBlICYmIDExICE9PSBub2RlLm5vZGVUeXBlKVxuICApO1xufVxudmFyIFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksXG4gIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1xuU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpO1xuU3ltYm9sLmZvcihcInJlYWN0LmRlYnVnX3RyYWNlX21vZGVcIik7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xuU3ltYm9sLmZvcihcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIik7XG5TeW1ib2wuZm9yKFwicmVhY3QudHJhY2luZ19tYXJrZXJcIik7XG52YXIgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpLFxuICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG51bGwgPT09IG1heWJlSXRlcmFibGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG1heWJlSXRlcmFibGUpIHJldHVybiBudWxsO1xuICBtYXliZUl0ZXJhYmxlID1cbiAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICBtYXliZUl0ZXJhYmxlW1wiQEBpdGVyYXRvclwiXTtcbiAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlSXRlcmFibGUgPyBtYXliZUl0ZXJhYmxlIDogbnVsbDtcbn1cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIik7XG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgID8gbnVsbFxuICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gIH1cbiAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgfVxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICBwcmVmaXgsXG4gIHN1ZmZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICBzdWZmaXggPVxuICAgICAgICAtMSA8IHguc3RhY2suaW5kZXhPZihcIlxcbiAgICBhdFwiKVxuICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgID8gXCJAdW5rbm93bjowOjBcIlxuICAgICAgICAgICAgOiBcIlwiO1xuICAgIH1cbiAgcmV0dXJuIFwiXFxuXCIgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xufVxudmFyIHJlZW50cnkgPSAhMTtcbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICBpZiAoIWZuIHx8IHJlZW50cnkpIHJldHVybiBcIlwiO1xuICByZWVudHJ5ID0gITA7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICB0cnkge1xuICAgIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoICh4JDApIHtcbiAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoRmFrZSA9IGZuKCkpICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEZha2UuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgfVxuICAgIH07XG4gICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICBcIm5hbWVcIlxuICAgICk7XG4gICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgIHsgdmFsdWU6IFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCIgfVxuICAgICAgKTtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgZm9yIChcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID0gUnVuSW5Sb290RnJhbWUgPSAwO1xuICAgICAgICBSdW5JblJvb3RGcmFtZSA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAhc2FtcGxlTGluZXNbUnVuSW5Sb290RnJhbWVdLmluY2x1ZGVzKFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCIpO1xuXG4gICAgICApXG4gICAgICAgIFJ1bkluUm9vdEZyYW1lKys7XG4gICAgICBmb3IgKFxuICAgICAgICA7XG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgIWNvbnRyb2xMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLmluY2x1ZGVzKFxuICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgKTtcblxuICAgICAgKVxuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgIGlmIChcbiAgICAgICAgUnVuSW5Sb290RnJhbWUgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fFxuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGhcbiAgICAgIClcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZSA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAxIDw9IFJ1bkluUm9vdEZyYW1lICYmXG4gICAgICAgICAgMCA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICBzYW1wbGVMaW5lc1tSdW5JblJvb3RGcmFtZV0gIT09IGNvbnRyb2xMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdO1xuXG4gICAgICAgIClcbiAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLTtcbiAgICAgIGZvciAoXG4gICAgICAgIDtcbiAgICAgICAgMSA8PSBSdW5JblJvb3RGcmFtZSAmJiAwIDw9IG5hbWVQcm9wRGVzY3JpcHRvcjtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUtLSwgbmFtZVByb3BEZXNjcmlwdG9yLS1cbiAgICAgIClcbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW1J1bkluUm9vdEZyYW1lXSAhPT0gY29udHJvbExpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0pIHtcbiAgICAgICAgICBpZiAoMSAhPT0gUnVuSW5Sb290RnJhbWUgfHwgMSAhPT0gbmFtZVByb3BEZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBkb1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKFJ1bkluUm9vdEZyYW1lLS0sXG4gICAgICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sXG4gICAgICAgICAgICAgICAgMCA+IG5hbWVQcm9wRGVzY3JpcHRvciB8fFxuICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbUnVuSW5Sb290RnJhbWVdICE9PVxuICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID1cbiAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbUnVuSW5Sb290RnJhbWVdLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgZm4uZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgIGZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgIChmcmFtZSA9IGZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKDEgPD0gUnVuSW5Sb290RnJhbWUgJiYgMCA8PSBuYW1lUHJvcERlc2NyaXB0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAocmVlbnRyeSA9ICExKSwgKEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSk7XG4gIH1cbiAgcmV0dXJuIChwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UpXG4gICAgOiBcIlwiO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgMjY6XG4gICAgY2FzZSAyNzpcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG4gICAgY2FzZSAxNjpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIkxhenlcIik7XG4gICAgY2FzZSAxMzpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgIGNhc2UgMTk6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTU6XG4gICAgICByZXR1cm4gKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLCAhMSkpLCBmaWJlcjtcbiAgICBjYXNlIDExOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlciwgITEpKSwgZmliZXJcbiAgICAgICk7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIChmaWJlciA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSwgITApKSwgZmliZXI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgZG9cbiAgICAgIChpbmZvICs9IGRlc2NyaWJlRmliZXIod29ya0luUHJvZ3Jlc3MpKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuKTtcbiAgICB3aGlsZSAod29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuIFwiXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogXCIgKyB4Lm1lc3NhZ2UgKyBcIlxcblwiICsgeC5zdGFjaztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikge1xuICB2YXIgbm9kZSA9IGZpYmVyLFxuICAgIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG4gIGlmIChmaWJlci5hbHRlcm5hdGUpIGZvciAoOyBub2RlLnJldHVybjsgKSBub2RlID0gbm9kZS5yZXR1cm47XG4gIGVsc2Uge1xuICAgIGZpYmVyID0gbm9kZTtcbiAgICBkb1xuICAgICAgKG5vZGUgPSBmaWJlciksXG4gICAgICAgIDAgIT09IChub2RlLmZsYWdzICYgNDA5OCkgJiYgKG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm4pLFxuICAgICAgICAoZmliZXIgPSBub2RlLnJldHVybik7XG4gICAgd2hpbGUgKGZpYmVyKTtcbiAgfVxuICByZXR1cm4gMyA9PT0gbm9kZS50YWcgPyBuZWFyZXN0TW91bnRlZCA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKGZpYmVyKSB7XG4gIGlmICgxMyA9PT0gZmliZXIudGFnKSB7XG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICAgIG51bGwgPT09IHN1c3BlbnNlU3RhdGUgJiZcbiAgICAgICgoZmliZXIgPSBmaWJlci5hbHRlcm5hdGUpLFxuICAgICAgbnVsbCAhPT0gZmliZXIgJiYgKHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlKSk7XG4gICAgaWYgKG51bGwgIT09IHN1c3BlbnNlU3RhdGUpIHJldHVybiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcilcbiAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE4OCkpO1xufVxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICBhbHRlcm5hdGUgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcbiAgICBpZiAobnVsbCA9PT0gYWx0ZXJuYXRlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE4OCkpO1xuICAgIHJldHVybiBhbHRlcm5hdGUgIT09IGZpYmVyID8gbnVsbCA6IGZpYmVyO1xuICB9XG4gIGZvciAodmFyIGEgPSBmaWJlciwgYiA9IGFsdGVybmF0ZTsgOyApIHtcbiAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuICAgIGlmIChudWxsID09PSBwYXJlbnRBKSBicmVhaztcbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEuYWx0ZXJuYXRlO1xuICAgIGlmIChudWxsID09PSBwYXJlbnRCKSB7XG4gICAgICBiID0gcGFyZW50QS5yZXR1cm47XG4gICAgICBpZiAobnVsbCAhPT0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIGZvciAocGFyZW50QiA9IHBhcmVudEEuY2hpbGQ7IHBhcmVudEI7ICkge1xuICAgICAgICBpZiAocGFyZW50QiA9PT0gYSkgcmV0dXJuIGFzc2VydElzTW91bnRlZChwYXJlbnRBKSwgZmliZXI7XG4gICAgICAgIGlmIChwYXJlbnRCID09PSBiKSByZXR1cm4gYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpLCBhbHRlcm5hdGU7XG4gICAgICAgIHBhcmVudEIgPSBwYXJlbnRCLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE4OCkpO1xuICAgIH1cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSAoYSA9IHBhcmVudEEpLCAoYiA9IHBhcmVudEIpO1xuICAgIGVsc2Uge1xuICAgICAgZm9yICh2YXIgZGlkRmluZENoaWxkID0gITEsIGNoaWxkJDIgPSBwYXJlbnRBLmNoaWxkOyBjaGlsZCQyOyApIHtcbiAgICAgICAgaWYgKGNoaWxkJDIgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQkMiA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkJDIgPSBjaGlsZCQyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICBmb3IgKGNoaWxkJDIgPSBwYXJlbnRCLmNoaWxkOyBjaGlsZCQyOyApIHtcbiAgICAgICAgICBpZiAoY2hpbGQkMiA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGlsZCQyID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGQkMiA9IGNoaWxkJDIuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpZEZpbmRDaGlsZCkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxODkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGEuYWx0ZXJuYXRlICE9PSBiKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5MCkpO1xuICB9XG4gIGlmICgzICE9PSBhLnRhZykgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxODgpKTtcbiAgcmV0dXJuIGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEgPyBmaWJlciA6IGFsdGVybmF0ZTtcbn1cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcgfHwgNiA9PT0gdGFnKSByZXR1cm4gbm9kZTtcbiAgZm9yIChub2RlID0gbm9kZS5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgdGFnID0gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpO1xuICAgIGlmIChudWxsICE9PSB0YWcpIHJldHVybiB0YWc7XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzID1cbiAgICBSZWFjdERPTS5fX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gIHNoYXJlZE5vdFBlbmRpbmdPYmplY3QgPSB7XG4gICAgcGVuZGluZzogITEsXG4gICAgZGF0YTogbnVsbCxcbiAgICBtZXRob2Q6IG51bGwsXG4gICAgYWN0aW9uOiBudWxsXG4gIH0sXG4gIHZhbHVlU3RhY2sgPSBbXSxcbiAgaW5kZXggPSAtMTtcbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHsgY3VycmVudDogZGVmYXVsdFZhbHVlIH07XG59XG5mdW5jdGlvbiBwb3AoY3Vyc29yKSB7XG4gIDAgPiBpbmRleCB8fFxuICAgICgoY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XSksICh2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGwpLCBpbmRleC0tKTtcbn1cbmZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSkge1xuICBpbmRleCsrO1xuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxudmFyIGNvbnRleHRTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSk7XG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG51bGwpO1xuICBmaWJlciA9IG5leHRSb290SW5zdGFuY2Uubm9kZVR5cGU7XG4gIHN3aXRjaCAoZmliZXIpIHtcbiAgICBjYXNlIDk6XG4gICAgY2FzZSAxMTpcbiAgICAgIG5leHRSb290SW5zdGFuY2UgPSAobmV4dFJvb3RJbnN0YW5jZSA9IG5leHRSb290SW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50KVxuICAgICAgICA/IChuZXh0Um9vdEluc3RhbmNlID0gbmV4dFJvb3RJbnN0YW5jZS5uYW1lc3BhY2VVUkkpXG4gICAgICAgICAgPyBnZXRPd25Ib3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKVxuICAgICAgICAgIDogMFxuICAgICAgICA6IDA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKFxuICAgICAgICAoKGZpYmVyID0gOCA9PT0gZmliZXIgPyBuZXh0Um9vdEluc3RhbmNlLnBhcmVudE5vZGUgOiBuZXh0Um9vdEluc3RhbmNlKSxcbiAgICAgICAgKG5leHRSb290SW5zdGFuY2UgPSBmaWJlci50YWdOYW1lKSxcbiAgICAgICAgKGZpYmVyID0gZmliZXIubmFtZXNwYWNlVVJJKSlcbiAgICAgIClcbiAgICAgICAgKGZpYmVyID0gZ2V0T3duSG9zdENvbnRleHQoZmliZXIpKSxcbiAgICAgICAgICAobmV4dFJvb3RJbnN0YW5jZSA9IGdldENoaWxkSG9zdENvbnRleHRQcm9kKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSk7XG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCAobmV4dFJvb3RJbnN0YW5jZSkge1xuICAgICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgICAgIG5leHRSb290SW5zdGFuY2UgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgICAgICAgIG5leHRSb290SW5zdGFuY2UgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG5leHRSb290SW5zdGFuY2UgPSAwO1xuICAgICAgICB9XG4gIH1cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoKSB7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IpO1xuICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IpO1xufVxuZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIG51bGwgIT09IGZpYmVyLm1lbW9pemVkU3RhdGUgJiYgcHVzaChob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLCBmaWJlcik7XG4gIHZhciBjb250ZXh0ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0UHJvZChjb250ZXh0LCBmaWJlci50eXBlKTtcbiAgY29udGV4dCAhPT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYmXG4gICAgKHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKSxcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSk7XG59XG5mdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICBjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ID09PSBmaWJlciAmJlxuICAgIChwb3AoY29udGV4dFN0YWNrQ3Vyc29yKSwgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yKSk7XG4gIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IuY3VycmVudCA9PT0gZmliZXIgJiZcbiAgICAocG9wKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IpLFxuICAgIChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHNoYXJlZE5vdFBlbmRpbmdPYmplY3QpKTtcbn1cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gIHNjaGVkdWxlQ2FsbGJhY2skMyA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICBjYW5jZWxDYWxsYmFjayQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrLFxuICBzaG91bGRZaWVsZCA9IFNjaGVkdWxlci51bnN0YWJsZV9zaG91bGRZaWVsZCxcbiAgcmVxdWVzdFBhaW50ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3JlcXVlc3RQYWludCxcbiAgbm93ID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwgPSBTY2hlZHVsZXIudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwsXG4gIEltbWVkaWF0ZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFxuICBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxcbiAgTm9ybWFsUHJpb3JpdHkkMSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxcbiAgTG93UHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfTG93UHJpb3JpdHksXG4gIElkbGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JZGxlUHJpb3JpdHksXG4gIGxvZyQxID0gU2NoZWR1bGVyLmxvZyxcbiAgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUgPSBTY2hlZHVsZXIudW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUsXG4gIHJlbmRlcmVySUQgPSBudWxsLFxuICBpbmplY3RlZEhvb2sgPSBudWxsO1xuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QpXG4gICAgdHJ5IHtcbiAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChcbiAgICAgICAgcmVuZGVyZXJJRCxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICAxMjggPT09IChyb290LmN1cnJlbnQuZmxhZ3MgJiAxMjgpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge31cbn1cbmZ1bmN0aW9uIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKG5ld0lzU3RyaWN0TW9kZSkge1xuICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsb2ckMSAmJiB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZShuZXdJc1N0cmljdE1vZGUpO1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKVxuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2suc2V0U3RyaWN0TW9kZShyZW5kZXJlcklELCBuZXdJc1N0cmljdE1vZGUpO1xuICAgIH0gY2F0Y2ggKGVycikge31cbn1cbnZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjayxcbiAgbG9nID0gTWF0aC5sb2csXG4gIExOMiA9IE1hdGguTE4yO1xuZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG4gIHggPj4+PSAwO1xuICByZXR1cm4gMCA9PT0geCA/IDMyIDogKDMxIC0gKChsb2coeCkgLyBMTjIpIHwgMCkpIHwgMDtcbn1cbnZhciBuZXh0VHJhbnNpdGlvbkxhbmUgPSAxMjgsXG4gIG5leHRSZXRyeUxhbmUgPSA0MTk0MzA0O1xuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobGFuZXMpIHtcbiAgdmFyIHBlbmRpbmdTeW5jTGFuZXMgPSBsYW5lcyAmIDQyO1xuICBpZiAoMCAhPT0gcGVuZGluZ1N5bmNMYW5lcykgcmV0dXJuIHBlbmRpbmdTeW5jTGFuZXM7XG4gIHN3aXRjaCAobGFuZXMgJiAtbGFuZXMpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gODtcbiAgICBjYXNlIDE2OlxuICAgICAgcmV0dXJuIDE2O1xuICAgIGNhc2UgMzI6XG4gICAgICByZXR1cm4gMzI7XG4gICAgY2FzZSA2NDpcbiAgICAgIHJldHVybiA2NDtcbiAgICBjYXNlIDEyODpcbiAgICBjYXNlIDI1NjpcbiAgICBjYXNlIDUxMjpcbiAgICBjYXNlIDEwMjQ6XG4gICAgY2FzZSAyMDQ4OlxuICAgIGNhc2UgNDA5NjpcbiAgICBjYXNlIDgxOTI6XG4gICAgY2FzZSAxNjM4NDpcbiAgICBjYXNlIDMyNzY4OlxuICAgIGNhc2UgNjU1MzY6XG4gICAgY2FzZSAxMzEwNzI6XG4gICAgY2FzZSAyNjIxNDQ6XG4gICAgY2FzZSA1MjQyODg6XG4gICAgY2FzZSAxMDQ4NTc2OlxuICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgIHJldHVybiBsYW5lcyAmIDQxOTQxNzY7XG4gICAgY2FzZSA0MTk0MzA0OlxuICAgIGNhc2UgODM4ODYwODpcbiAgICBjYXNlIDE2Nzc3MjE2OlxuICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICByZXR1cm4gbGFuZXMgJiA2MjkxNDU2MDtcbiAgICBjYXNlIDY3MTA4ODY0OlxuICAgICAgcmV0dXJuIDY3MTA4ODY0O1xuICAgIGNhc2UgMTM0MjE3NzI4OlxuICAgICAgcmV0dXJuIDEzNDIxNzcyODtcbiAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgIHJldHVybiAyNjg0MzU0NTY7XG4gICAgY2FzZSA1MzY4NzA5MTI6XG4gICAgICByZXR1cm4gNTM2ODcwOTEyO1xuICAgIGNhc2UgMTA3Mzc0MTgyNDpcbiAgICAgIHJldHVybiAwO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbGFuZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5leHRMYW5lcyhyb290LCB3aXBMYW5lcykge1xuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gIGlmICgwID09PSBwZW5kaW5nTGFuZXMpIHJldHVybiAwO1xuICB2YXIgbmV4dExhbmVzID0gMCxcbiAgICBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzLFxuICAgIHdhcm1MYW5lcyA9IHJvb3Qud2FybUxhbmVzO1xuICByb290ID0gMCAhPT0gcm9vdC5maW5pc2hlZExhbmVzO1xuICB2YXIgbm9uSWRsZVBlbmRpbmdMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIDEzNDIxNzcyNztcbiAgMCAhPT0gbm9uSWRsZVBlbmRpbmdMYW5lc1xuICAgID8gKChwZW5kaW5nTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzKSxcbiAgICAgIDAgIT09IHBlbmRpbmdMYW5lc1xuICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwZW5kaW5nTGFuZXMpKVxuICAgICAgICA6ICgocGluZ2VkTGFuZXMgJj0gbm9uSWRsZVBlbmRpbmdMYW5lcyksXG4gICAgICAgICAgMCAhPT0gcGluZ2VkTGFuZXNcbiAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKSlcbiAgICAgICAgICAgIDogcm9vdCB8fFxuICAgICAgICAgICAgICAoKHdhcm1MYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+d2FybUxhbmVzKSxcbiAgICAgICAgICAgICAgMCAhPT0gd2FybUxhbmVzICYmXG4gICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHdhcm1MYW5lcykpKSkpXG4gICAgOiAoKG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXMpLFxuICAgICAgMCAhPT0gbm9uSWRsZVBlbmRpbmdMYW5lc1xuICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlUGVuZGluZ0xhbmVzKSlcbiAgICAgICAgOiAwICE9PSBwaW5nZWRMYW5lc1xuICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKSlcbiAgICAgICAgICA6IHJvb3QgfHxcbiAgICAgICAgICAgICgod2FybUxhbmVzID0gcGVuZGluZ0xhbmVzICYgfndhcm1MYW5lcyksXG4gICAgICAgICAgICAwICE9PSB3YXJtTGFuZXMgJiZcbiAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHdhcm1MYW5lcykpKSk7XG4gIHJldHVybiAwID09PSBuZXh0TGFuZXNcbiAgICA/IDBcbiAgICA6IDAgIT09IHdpcExhbmVzICYmXG4gICAgICAgIHdpcExhbmVzICE9PSBuZXh0TGFuZXMgJiZcbiAgICAgICAgMCA9PT0gKHdpcExhbmVzICYgc3VzcGVuZGVkTGFuZXMpICYmXG4gICAgICAgICgoc3VzcGVuZGVkTGFuZXMgPSBuZXh0TGFuZXMgJiAtbmV4dExhbmVzKSxcbiAgICAgICAgKHdhcm1MYW5lcyA9IHdpcExhbmVzICYgLXdpcExhbmVzKSxcbiAgICAgICAgc3VzcGVuZGVkTGFuZXMgPj0gd2FybUxhbmVzIHx8XG4gICAgICAgICAgKDMyID09PSBzdXNwZW5kZWRMYW5lcyAmJiAwICE9PSAod2FybUxhbmVzICYgNDE5NDE3NikpKVxuICAgICAgPyB3aXBMYW5lc1xuICAgICAgOiBuZXh0TGFuZXM7XG59XG5mdW5jdGlvbiBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiAoXG4gICAgMCA9PT1cbiAgICAocm9vdC5wZW5kaW5nTGFuZXMgJlxuICAgICAgfihyb290LnN1c3BlbmRlZExhbmVzICYgfnJvb3QucGluZ2VkTGFuZXMpICZcbiAgICAgIHJlbmRlckxhbmVzKVxuICApO1xufVxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gIHN3aXRjaCAobGFuZSkge1xuICAgIGNhc2UgMTpcbiAgICBjYXNlIDI6XG4gICAgY2FzZSA0OlxuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBjdXJyZW50VGltZSArIDI1MDtcbiAgICBjYXNlIDE2OlxuICAgIGNhc2UgMzI6XG4gICAgY2FzZSA2NDpcbiAgICBjYXNlIDEyODpcbiAgICBjYXNlIDI1NjpcbiAgICBjYXNlIDUxMjpcbiAgICBjYXNlIDEwMjQ6XG4gICAgY2FzZSAyMDQ4OlxuICAgIGNhc2UgNDA5NjpcbiAgICBjYXNlIDgxOTI6XG4gICAgY2FzZSAxNjM4NDpcbiAgICBjYXNlIDMyNzY4OlxuICAgIGNhc2UgNjU1MzY6XG4gICAgY2FzZSAxMzEwNzI6XG4gICAgY2FzZSAyNjIxNDQ6XG4gICAgY2FzZSA1MjQyODg6XG4gICAgY2FzZSAxMDQ4NTc2OlxuICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgIHJldHVybiBjdXJyZW50VGltZSArIDVlMztcbiAgICBjYXNlIDQxOTQzMDQ6XG4gICAgY2FzZSA4Mzg4NjA4OlxuICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgIHJldHVybiAtMTtcbiAgICBjYXNlIDY3MTA4ODY0OlxuICAgIGNhc2UgMTM0MjE3NzI4OlxuICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgIGNhc2UgNTM2ODcwOTEyOlxuICAgIGNhc2UgMTA3Mzc0MTgyNDpcbiAgICAgIHJldHVybiAtMTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIC0xO1xuICB9XG59XG5mdW5jdGlvbiBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpIHtcbiAgdmFyIGxhbmUgPSBuZXh0VHJhbnNpdGlvbkxhbmU7XG4gIG5leHRUcmFuc2l0aW9uTGFuZSA8PD0gMTtcbiAgMCA9PT0gKG5leHRUcmFuc2l0aW9uTGFuZSAmIDQxOTQxNzYpICYmIChuZXh0VHJhbnNpdGlvbkxhbmUgPSAxMjgpO1xuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGNsYWltTmV4dFJldHJ5TGFuZSgpIHtcbiAgdmFyIGxhbmUgPSBuZXh0UmV0cnlMYW5lO1xuICBuZXh0UmV0cnlMYW5lIDw8PSAxO1xuICAwID09PSAobmV4dFJldHJ5TGFuZSAmIDYyOTE0NTYwKSAmJiAobmV4dFJldHJ5TGFuZSA9IDQxOTQzMDQpO1xuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxhbmVNYXAoaW5pdGlhbCkge1xuICBmb3IgKHZhciBsYW5lTWFwID0gW10sIGkgPSAwOyAzMSA+IGk7IGkrKykgbGFuZU1hcC5wdXNoKGluaXRpYWwpO1xuICByZXR1cm4gbGFuZU1hcDtcbn1cbmZ1bmN0aW9uIG1hcmtSb290VXBkYXRlZCQxKHJvb3QsIHVwZGF0ZUxhbmUpIHtcbiAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTtcbiAgMjY4NDM1NDU2ICE9PSB1cGRhdGVMYW5lICYmXG4gICAgKChyb290LnN1c3BlbmRlZExhbmVzID0gMCksIChyb290LnBpbmdlZExhbmVzID0gMCksIChyb290Lndhcm1MYW5lcyA9IDApKTtcbn1cbmZ1bmN0aW9uIG1hcmtSb290RmluaXNoZWQoXG4gIHJvb3QsXG4gIGZpbmlzaGVkTGFuZXMsXG4gIHJlbWFpbmluZ0xhbmVzLFxuICBzcGF3bmVkTGFuZSxcbiAgdXBkYXRlZExhbmVzLFxuICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4pIHtcbiAgdmFyIHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgcm9vdC5wZW5kaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IDA7XG4gIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICByb290Lndhcm1MYW5lcyA9IDA7XG4gIHJvb3QuZXhwaXJlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LnNoZWxsU3VzcGVuZENvdW50ZXIgPSAwO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cyxcbiAgICBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lcyxcbiAgICBoaWRkZW5VcGRhdGVzID0gcm9vdC5oaWRkZW5VcGRhdGVzO1xuICBmb3IgKFxuICAgIHJlbWFpbmluZ0xhbmVzID0gcHJldmlvdXNseVBlbmRpbmdMYW5lcyAmIH5yZW1haW5pbmdMYW5lcztcbiAgICAwIDwgcmVtYWluaW5nTGFuZXM7XG5cbiAgKSB7XG4gICAgdmFyIGluZGV4JDcgPSAzMSAtIGNsejMyKHJlbWFpbmluZ0xhbmVzKSxcbiAgICAgIGxhbmUgPSAxIDw8IGluZGV4JDc7XG4gICAgZW50YW5nbGVtZW50c1tpbmRleCQ3XSA9IDA7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4JDddID0gLTE7XG4gICAgdmFyIGhpZGRlblVwZGF0ZXNGb3JMYW5lID0gaGlkZGVuVXBkYXRlc1tpbmRleCQ3XTtcbiAgICBpZiAobnVsbCAhPT0gaGlkZGVuVXBkYXRlc0ZvckxhbmUpXG4gICAgICBmb3IgKFxuICAgICAgICBoaWRkZW5VcGRhdGVzW2luZGV4JDddID0gbnVsbCwgaW5kZXgkNyA9IDA7XG4gICAgICAgIGluZGV4JDcgPCBoaWRkZW5VcGRhdGVzRm9yTGFuZS5sZW5ndGg7XG4gICAgICAgIGluZGV4JDcrK1xuICAgICAgKSB7XG4gICAgICAgIHZhciB1cGRhdGUgPSBoaWRkZW5VcGRhdGVzRm9yTGFuZVtpbmRleCQ3XTtcbiAgICAgICAgbnVsbCAhPT0gdXBkYXRlICYmICh1cGRhdGUubGFuZSAmPSAtNTM2ODcwOTEzKTtcbiAgICAgIH1cbiAgICByZW1haW5pbmdMYW5lcyAmPSB+bGFuZTtcbiAgfVxuICAwICE9PSBzcGF3bmVkTGFuZSAmJiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgMCk7XG4gIDAgIT09IHN1c3BlbmRlZFJldHJ5TGFuZXMgJiZcbiAgICAwID09PSB1cGRhdGVkTGFuZXMgJiZcbiAgICAwICE9PSByb290LnRhZyAmJlxuICAgIChyb290LnN1c3BlbmRlZExhbmVzIHw9XG4gICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzICYgfihwcmV2aW91c2x5UGVuZGluZ0xhbmVzICYgfmZpbmlzaGVkTGFuZXMpKTtcbn1cbmZ1bmN0aW9uIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCBlbnRhbmdsZWRMYW5lcykge1xuICByb290LnBlbmRpbmdMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyAmPSB+c3Bhd25lZExhbmU7XG4gIHZhciBzcGF3bmVkTGFuZUluZGV4ID0gMzEgLSBjbHozMihzcGF3bmVkTGFuZSk7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gc3Bhd25lZExhbmU7XG4gIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSA9XG4gICAgcm9vdC5lbnRhbmdsZW1lbnRzW3NwYXduZWRMYW5lSW5kZXhdIHxcbiAgICAxMDczNzQxODI0IHxcbiAgICAoZW50YW5nbGVkTGFuZXMgJiA0MTk0MjE4KTtcbn1cbmZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGVudGFuZ2xlZExhbmVzKSB7XG4gIHZhciByb290RW50YW5nbGVkTGFuZXMgPSAocm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcyk7XG4gIGZvciAocm9vdCA9IHJvb3QuZW50YW5nbGVtZW50czsgcm9vdEVudGFuZ2xlZExhbmVzOyApIHtcbiAgICB2YXIgaW5kZXgkOCA9IDMxIC0gY2x6MzIocm9vdEVudGFuZ2xlZExhbmVzKSxcbiAgICAgIGxhbmUgPSAxIDw8IGluZGV4JDg7XG4gICAgKGxhbmUgJiBlbnRhbmdsZWRMYW5lcykgfCAocm9vdFtpbmRleCQ4XSAmIGVudGFuZ2xlZExhbmVzKSAmJlxuICAgICAgKHJvb3RbaW5kZXgkOF0gfD0gZW50YW5nbGVkTGFuZXMpO1xuICAgIHJvb3RFbnRhbmdsZWRMYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbGFuZXNUb0V2ZW50UHJpb3JpdHkobGFuZXMpIHtcbiAgbGFuZXMgJj0gLWxhbmVzO1xuICByZXR1cm4gMiA8IGxhbmVzXG4gICAgPyA4IDwgbGFuZXNcbiAgICAgID8gMCAhPT0gKGxhbmVzICYgMTM0MjE3NzI3KVxuICAgICAgICA/IDMyXG4gICAgICAgIDogMjY4NDM1NDU2XG4gICAgICA6IDhcbiAgICA6IDI7XG59XG5mdW5jdGlvbiByZXNvbHZlVXBkYXRlUHJpb3JpdHkoKSB7XG4gIHZhciB1cGRhdGVQcmlvcml0eSA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnA7XG4gIGlmICgwICE9PSB1cGRhdGVQcmlvcml0eSkgcmV0dXJuIHVwZGF0ZVByaW9yaXR5O1xuICB1cGRhdGVQcmlvcml0eSA9IHdpbmRvdy5ldmVudDtcbiAgcmV0dXJuIHZvaWQgMCA9PT0gdXBkYXRlUHJpb3JpdHkgPyAzMiA6IGdldEV2ZW50UHJpb3JpdHkodXBkYXRlUHJpb3JpdHkudHlwZSk7XG59XG5mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkocHJpb3JpdHksIGZuKSB7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmlvcml0eSksIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByZXZpb3VzUHJpb3JpdHk7XG4gIH1cbn1cbnZhciByYW5kb21LZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcbiAgaW50ZXJuYWxJbnN0YW5jZUtleSA9IFwiX19yZWFjdEZpYmVyJFwiICsgcmFuZG9tS2V5LFxuICBpbnRlcm5hbFByb3BzS2V5ID0gXCJfX3JlYWN0UHJvcHMkXCIgKyByYW5kb21LZXksXG4gIGludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXkgPSBcIl9fcmVhY3RDb250YWluZXIkXCIgKyByYW5kb21LZXksXG4gIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9IFwiX19yZWFjdEV2ZW50cyRcIiArIHJhbmRvbUtleSxcbiAgaW50ZXJuYWxFdmVudEhhbmRsZXJMaXN0ZW5lcnNLZXkgPSBcIl9fcmVhY3RMaXN0ZW5lcnMkXCIgKyByYW5kb21LZXksXG4gIGludGVybmFsRXZlbnRIYW5kbGVzU2V0S2V5ID0gXCJfX3JlYWN0SGFuZGxlcyRcIiArIHJhbmRvbUtleSxcbiAgaW50ZXJuYWxSb290Tm9kZVJlc291cmNlc0tleSA9IFwiX19yZWFjdFJlc291cmNlcyRcIiArIHJhbmRvbUtleSxcbiAgaW50ZXJuYWxIb2lzdGFibGVNYXJrZXIgPSBcIl9fcmVhY3RNYXJrZXIkXCIgKyByYW5kb21LZXk7XG5mdW5jdGlvbiBkZXRhY2hEZWxldGVkSW5zdGFuY2Uobm9kZSkge1xuICBkZWxldGUgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgZGVsZXRlIG5vZGVbaW50ZXJuYWxQcm9wc0tleV07XG4gIGRlbGV0ZSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07XG4gIGRlbGV0ZSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyTGlzdGVuZXJzS2V5XTtcbiAgZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXNTZXRLZXldO1xufVxuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0Tm9kZSkge1xuICB2YXIgdGFyZ2V0SW5zdCA9IHRhcmdldE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmICh0YXJnZXRJbnN0KSByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgZm9yICh2YXIgcGFyZW50Tm9kZSA9IHRhcmdldE5vZGUucGFyZW50Tm9kZTsgcGFyZW50Tm9kZTsgKSB7XG4gICAgaWYgKFxuICAgICAgKHRhcmdldEluc3QgPVxuICAgICAgICBwYXJlbnROb2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldIHx8XG4gICAgICAgIHBhcmVudE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pXG4gICAgKSB7XG4gICAgICBwYXJlbnROb2RlID0gdGFyZ2V0SW5zdC5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHRhcmdldEluc3QuY2hpbGQgfHxcbiAgICAgICAgKG51bGwgIT09IHBhcmVudE5vZGUgJiYgbnVsbCAhPT0gcGFyZW50Tm9kZS5jaGlsZClcbiAgICAgIClcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB0YXJnZXROb2RlID0gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXROb2RlKTtcbiAgICAgICAgICBudWxsICE9PSB0YXJnZXROb2RlO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICgocGFyZW50Tm9kZSA9IHRhcmdldE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pKSByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICAgICAgICB0YXJnZXROb2RlID0gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXROb2RlKTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gICAgfVxuICAgIHRhcmdldE5vZGUgPSBwYXJlbnROb2RlO1xuICAgIHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKFxuICAgIChub2RlID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSB8fCBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldKVxuICApIHtcbiAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgaWYgKFxuICAgICAgNSA9PT0gdGFnIHx8XG4gICAgICA2ID09PSB0YWcgfHxcbiAgICAgIDEzID09PSB0YWcgfHxcbiAgICAgIDI2ID09PSB0YWcgfHxcbiAgICAgIDI3ID09PSB0YWcgfHxcbiAgICAgIDMgPT09IHRhZ1xuICAgIClcbiAgICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XG4gIHZhciB0YWcgPSBpbnN0LnRhZztcbiAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcgfHwgNiA9PT0gdGFnKSByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzMpKTtcbn1cbmZ1bmN0aW9uIGdldFJlc291cmNlc0Zyb21Sb290KHJvb3QpIHtcbiAgdmFyIHJlc291cmNlcyA9IHJvb3RbaW50ZXJuYWxSb290Tm9kZVJlc291cmNlc0tleV07XG4gIHJlc291cmNlcyB8fFxuICAgIChyZXNvdXJjZXMgPSByb290W2ludGVybmFsUm9vdE5vZGVSZXNvdXJjZXNLZXldID1cbiAgICAgIHsgaG9pc3RhYmxlU3R5bGVzOiBuZXcgTWFwKCksIGhvaXN0YWJsZVNjcmlwdHM6IG5ldyBNYXAoKSB9KTtcbiAgcmV0dXJuIHJlc291cmNlcztcbn1cbmZ1bmN0aW9uIG1hcmtOb2RlQXNIb2lzdGFibGUobm9kZSkge1xuICBub2RlW2ludGVybmFsSG9pc3RhYmxlTWFya2VyXSA9ICEwO1xufVxudmFyIGFsbE5hdGl2ZUV2ZW50cyA9IG5ldyBTZXQoKSxcbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJUd29QaGFzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcykge1xuICByZWdpc3RlckRpcmVjdEV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcyk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSArIFwiQ2FwdHVyZVwiLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lLCBkZXBlbmRlbmNpZXMpIHtcbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IGRlcGVuZGVuY2llcztcbiAgZm9yIChcbiAgICByZWdpc3RyYXRpb25OYW1lID0gMDtcbiAgICByZWdpc3RyYXRpb25OYW1lIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDtcbiAgICByZWdpc3RyYXRpb25OYW1lKytcbiAgKVxuICAgIGFsbE5hdGl2ZUV2ZW50cy5hZGQoZGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdKTtcbn1cbnZhciBjYW5Vc2VET00gPSAhKFxuICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3aW5kb3cgfHxcbiAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93LmRvY3VtZW50IHx8XG4gICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG4gICksXG4gIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gUmVnRXhwKFxuICAgIFwiXls6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICApLFxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge30sXG4gIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpXG4gICAgcmV0dXJuICEwO1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkgcmV0dXJuICExO1xuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSlcbiAgICByZXR1cm4gKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9ICEwKTtcbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9ICEwO1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSlcbiAgICBpZiAobnVsbCA9PT0gdmFsdWUpIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGVsc2Uge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICB2YXIgcHJlZml4JDEwID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgIGlmIChcImRhdGEtXCIgIT09IHByZWZpeCQxMCAmJiBcImFyaWEtXCIgIT09IHByZWZpeCQxMCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIiArIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChudWxsID09PSB2YWx1ZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIFwiXCIgKyB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZhbHVlRm9yTmFtZXNwYWNlZEF0dHJpYnV0ZShub2RlLCBuYW1lc3BhY2UsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChudWxsID09PSB2YWx1ZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCBcIlwiICsgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgcmV0dXJuIChcbiAgICAoZWxlbSA9IGVsZW0ubm9kZU5hbWUpICYmXG4gICAgXCJpbnB1dFwiID09PSBlbGVtLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAoXCJjaGVja2JveFwiID09PSB0eXBlIHx8IFwicmFkaW9cIiA9PT0gdHlwZSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSkge1xuICB2YXIgdmFsdWVGaWVsZCA9IGlzQ2hlY2thYmxlKG5vZGUpID8gXCJjaGVja2VkXCIgOiBcInZhbHVlXCIsXG4gICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICBub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxcbiAgICAgIHZhbHVlRmllbGRcbiAgICApLFxuICAgIGN1cnJlbnRWYWx1ZSA9IFwiXCIgKyBub2RlW3ZhbHVlRmllbGRdO1xuICBpZiAoXG4gICAgIW5vZGUuaGFzT3duUHJvcGVydHkodmFsdWVGaWVsZCkgJiZcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZGVzY3JpcHRvciAmJlxuICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICYmXG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGVzY3JpcHRvci5zZXRcbiAgKSB7XG4gICAgdmFyIGdldCA9IGRlc2NyaXB0b3IuZ2V0LFxuICAgICAgc2V0ID0gZGVzY3JpcHRvci5zZXQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGVcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBub2RlLl92YWx1ZVRyYWNrZXIgfHwgKG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSkpO1xufVxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiAhMTtcbiAgdmFyIHRyYWNrZXIgPSBub2RlLl92YWx1ZVRyYWNrZXI7XG4gIGlmICghdHJhY2tlcikgcmV0dXJuICEwO1xuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgdmFsdWUgPSBcIlwiO1xuICBub2RlICYmXG4gICAgKHZhbHVlID0gaXNDaGVja2FibGUobm9kZSlcbiAgICAgID8gbm9kZS5jaGVja2VkXG4gICAgICAgID8gXCJ0cnVlXCJcbiAgICAgICAgOiBcImZhbHNlXCJcbiAgICAgIDogbm9kZS52YWx1ZSk7XG4gIG5vZGUgPSB2YWx1ZTtcbiAgcmV0dXJuIG5vZGUgIT09IGxhc3RWYWx1ZSA/ICh0cmFja2VyLnNldFZhbHVlKG5vZGUpLCAhMCkgOiAhMTtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gIGRvYyA9IGRvYyB8fCAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGRvY3VtZW50ID8gZG9jdW1lbnQgOiB2b2lkIDApO1xuICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGRvYykgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50IHx8IGRvYy5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvYy5ib2R5O1xuICB9XG59XG52YXIgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3Rlc1JlZ2V4ID0gL1tcXG5cIlxcXFxdL2c7XG5mdW5jdGlvbiBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKFxuICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXNSZWdleCxcbiAgICBmdW5jdGlvbiAoY2gpIHtcbiAgICAgIHJldHVybiBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpICsgXCIgXCI7XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gdXBkYXRlSW5wdXQoXG4gIGVsZW1lbnQsXG4gIHZhbHVlLFxuICBkZWZhdWx0VmFsdWUsXG4gIGxhc3REZWZhdWx0VmFsdWUsXG4gIGNoZWNrZWQsXG4gIGRlZmF1bHRDaGVja2VkLFxuICB0eXBlLFxuICBuYW1lXG4pIHtcbiAgZWxlbWVudC5uYW1lID0gXCJcIjtcbiAgbnVsbCAhPSB0eXBlICYmXG4gIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgXCJib29sZWFuXCIgIT09IHR5cGVvZiB0eXBlXG4gICAgPyAoZWxlbWVudC50eXBlID0gdHlwZSlcbiAgICA6IGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcbiAgaWYgKG51bGwgIT0gdmFsdWUpXG4gICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGUpIHtcbiAgICAgIGlmICgoMCA9PT0gdmFsdWUgJiYgXCJcIiA9PT0gZWxlbWVudC52YWx1ZSkgfHwgZWxlbWVudC52YWx1ZSAhPSB2YWx1ZSlcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKTtcbiAgICB9IGVsc2VcbiAgICAgIGVsZW1lbnQudmFsdWUgIT09IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSAmJlxuICAgICAgICAoZWxlbWVudC52YWx1ZSA9IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSk7XG4gIGVsc2VcbiAgICAoXCJzdWJtaXRcIiAhPT0gdHlwZSAmJiBcInJlc2V0XCIgIT09IHR5cGUpIHx8IGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7XG4gIG51bGwgIT0gdmFsdWVcbiAgICA/IHNldERlZmF1bHRWYWx1ZShlbGVtZW50LCB0eXBlLCBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSlcbiAgICA6IG51bGwgIT0gZGVmYXVsdFZhbHVlXG4gICAgICA/IHNldERlZmF1bHRWYWx1ZShlbGVtZW50LCB0eXBlLCBnZXRUb1N0cmluZ1ZhbHVlKGRlZmF1bHRWYWx1ZSkpXG4gICAgICA6IG51bGwgIT0gbGFzdERlZmF1bHRWYWx1ZSAmJiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBudWxsID09IGNoZWNrZWQgJiZcbiAgICBudWxsICE9IGRlZmF1bHRDaGVja2VkICYmXG4gICAgKGVsZW1lbnQuZGVmYXVsdENoZWNrZWQgPSAhIWRlZmF1bHRDaGVja2VkKTtcbiAgbnVsbCAhPSBjaGVja2VkICYmXG4gICAgKGVsZW1lbnQuY2hlY2tlZCA9XG4gICAgICBjaGVja2VkICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoZWNrZWQgJiYgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGNoZWNrZWQpO1xuICBudWxsICE9IG5hbWUgJiZcbiAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgbmFtZSAmJlxuICBcInN5bWJvbFwiICE9PSB0eXBlb2YgbmFtZSAmJlxuICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIG5hbWVcbiAgICA/IChlbGVtZW50Lm5hbWUgPSBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZShuYW1lKSlcbiAgICA6IGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwibmFtZVwiKTtcbn1cbmZ1bmN0aW9uIGluaXRJbnB1dChcbiAgZWxlbWVudCxcbiAgdmFsdWUsXG4gIGRlZmF1bHRWYWx1ZSxcbiAgY2hlY2tlZCxcbiAgZGVmYXVsdENoZWNrZWQsXG4gIHR5cGUsXG4gIG5hbWUsXG4gIGlzSHlkcmF0aW5nXG4pIHtcbiAgbnVsbCAhPSB0eXBlICYmXG4gICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdHlwZSAmJlxuICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgKGVsZW1lbnQudHlwZSA9IHR5cGUpO1xuICBpZiAobnVsbCAhPSB2YWx1ZSB8fCBudWxsICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIChcInN1Ym1pdFwiICE9PSB0eXBlICYmIFwicmVzZXRcIiAhPT0gdHlwZSkgfHxcbiAgICAgICAgKHZvaWQgMCAhPT0gdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWUpXG4gICAgICApXG4gICAgKVxuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHRWYWx1ZSA9XG4gICAgICBudWxsICE9IGRlZmF1bHRWYWx1ZSA/IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKGRlZmF1bHRWYWx1ZSkgOiBcIlwiO1xuICAgIHZhbHVlID0gbnVsbCAhPSB2YWx1ZSA/IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcbiAgICBpc0h5ZHJhdGluZyB8fCB2YWx1ZSA9PT0gZWxlbWVudC52YWx1ZSB8fCAoZWxlbWVudC52YWx1ZSA9IHZhbHVlKTtcbiAgICBlbGVtZW50LmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGNoZWNrZWQgPSBudWxsICE9IGNoZWNrZWQgPyBjaGVja2VkIDogZGVmYXVsdENoZWNrZWQ7XG4gIGNoZWNrZWQgPVxuICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoZWNrZWQgJiYgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGNoZWNrZWQgJiYgISFjaGVja2VkO1xuICBlbGVtZW50LmNoZWNrZWQgPSBpc0h5ZHJhdGluZyA/IGVsZW1lbnQuY2hlY2tlZCA6ICEhY2hlY2tlZDtcbiAgZWxlbWVudC5kZWZhdWx0Q2hlY2tlZCA9ICEhY2hlY2tlZDtcbiAgbnVsbCAhPSBuYW1lICYmXG4gICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgbmFtZSAmJlxuICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBuYW1lICYmXG4gICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiBuYW1lICYmXG4gICAgKGVsZW1lbnQubmFtZSA9IG5hbWUpO1xufVxuZnVuY3Rpb24gc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHR5cGUsIHZhbHVlKSB7XG4gIChcIm51bWJlclwiID09PSB0eXBlICYmIGdldEFjdGl2ZUVsZW1lbnQobm9kZS5vd25lckRvY3VtZW50KSA9PT0gbm9kZSkgfHxcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9PT0gXCJcIiArIHZhbHVlIHx8XG4gICAgKG5vZGUuZGVmYXVsdFZhbHVlID0gXCJcIiArIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gIG5vZGUgPSBub2RlLm9wdGlvbnM7XG4gIGlmIChtdWx0aXBsZSkge1xuICAgIG11bHRpcGxlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICBtdWx0aXBsZVtcIiRcIiArIHByb3BWYWx1ZVtpXV0gPSAhMDtcbiAgICBmb3IgKHByb3BWYWx1ZSA9IDA7IHByb3BWYWx1ZSA8IG5vZGUubGVuZ3RoOyBwcm9wVmFsdWUrKylcbiAgICAgIChpID0gbXVsdGlwbGUuaGFzT3duUHJvcGVydHkoXCIkXCIgKyBub2RlW3Byb3BWYWx1ZV0udmFsdWUpKSxcbiAgICAgICAgbm9kZVtwcm9wVmFsdWVdLnNlbGVjdGVkICE9PSBpICYmIChub2RlW3Byb3BWYWx1ZV0uc2VsZWN0ZWQgPSBpKSxcbiAgICAgICAgaSAmJiBzZXREZWZhdWx0U2VsZWN0ZWQgJiYgKG5vZGVbcHJvcFZhbHVlXS5kZWZhdWx0U2VsZWN0ZWQgPSAhMCk7XG4gIH0gZWxzZSB7XG4gICAgcHJvcFZhbHVlID0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKTtcbiAgICBtdWx0aXBsZSA9IG51bGw7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChub2RlW2ldLnZhbHVlID09PSBwcm9wVmFsdWUpIHtcbiAgICAgICAgbm9kZVtpXS5zZWxlY3RlZCA9ICEwO1xuICAgICAgICBzZXREZWZhdWx0U2VsZWN0ZWQgJiYgKG5vZGVbaV0uZGVmYXVsdFNlbGVjdGVkID0gITApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBudWxsICE9PSBtdWx0aXBsZSB8fCBub2RlW2ldLmRpc2FibGVkIHx8IChtdWx0aXBsZSA9IG5vZGVbaV0pO1xuICAgIH1cbiAgICBudWxsICE9PSBtdWx0aXBsZSAmJiAobXVsdGlwbGUuc2VsZWN0ZWQgPSAhMCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVRleHRhcmVhKGVsZW1lbnQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKFxuICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAoKHZhbHVlID0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpKSxcbiAgICB2YWx1ZSAhPT0gZWxlbWVudC52YWx1ZSAmJiAoZWxlbWVudC52YWx1ZSA9IHZhbHVlKSxcbiAgICBudWxsID09IGRlZmF1bHRWYWx1ZSlcbiAgKSB7XG4gICAgZWxlbWVudC5kZWZhdWx0VmFsdWUgIT09IHZhbHVlICYmIChlbGVtZW50LmRlZmF1bHRWYWx1ZSA9IHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5kZWZhdWx0VmFsdWUgPVxuICAgIG51bGwgIT0gZGVmYXVsdFZhbHVlID8gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUoZGVmYXVsdFZhbHVlKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBpbml0VGV4dGFyZWEoZWxlbWVudCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSwgY2hpbGRyZW4pIHtcbiAgaWYgKG51bGwgPT0gdmFsdWUpIHtcbiAgICBpZiAobnVsbCAhPSBjaGlsZHJlbikge1xuICAgICAgaWYgKG51bGwgIT0gZGVmYXVsdFZhbHVlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkyKSk7XG4gICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgIGlmICgxIDwgY2hpbGRyZW4ubGVuZ3RoKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkzKSk7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICB9XG4gICAgICBkZWZhdWx0VmFsdWUgPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgbnVsbCA9PSBkZWZhdWx0VmFsdWUgJiYgKGRlZmF1bHRWYWx1ZSA9IFwiXCIpO1xuICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG4gIGRlZmF1bHRWYWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUodmFsdWUpO1xuICBlbGVtZW50LmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgY2hpbGRyZW4gPSBlbGVtZW50LnRleHRDb250ZW50O1xuICBjaGlsZHJlbiA9PT0gZGVmYXVsdFZhbHVlICYmXG4gICAgXCJcIiAhPT0gY2hpbGRyZW4gJiZcbiAgICBudWxsICE9PSBjaGlsZHJlbiAmJlxuICAgIChlbGVtZW50LnZhbHVlID0gY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgIGlmIChcbiAgICAgIGZpcnN0Q2hpbGQgJiZcbiAgICAgIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmXG4gICAgICAzID09PSBmaXJzdENoaWxkLm5vZGVUeXBlXG4gICAgKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxudmFyIHVuaXRsZXNzTnVtYmVycyA9IG5ldyBTZXQoXG4gIFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgYXNwZWN0UmF0aW8gYm9yZGVySW1hZ2VPdXRzZXQgYm9yZGVySW1hZ2VTbGljZSBib3JkZXJJbWFnZVdpZHRoIGJveEZsZXggYm94RmxleEdyb3VwIGJveE9yZGluYWxHcm91cCBjb2x1bW5Db3VudCBjb2x1bW5zIGZsZXggZmxleEdyb3cgZmxleFBvc2l0aXZlIGZsZXhTaHJpbmsgZmxleE5lZ2F0aXZlIGZsZXhPcmRlciBncmlkQXJlYSBncmlkUm93IGdyaWRSb3dFbmQgZ3JpZFJvd1NwYW4gZ3JpZFJvd1N0YXJ0IGdyaWRDb2x1bW4gZ3JpZENvbHVtbkVuZCBncmlkQ29sdW1uU3BhbiBncmlkQ29sdW1uU3RhcnQgZm9udFdlaWdodCBsaW5lQ2xhbXAgbGluZUhlaWdodCBvcGFjaXR5IG9yZGVyIG9ycGhhbnMgc2NhbGUgdGFiU2l6ZSB3aWRvd3MgekluZGV4IHpvb20gZmlsbE9wYWNpdHkgZmxvb2RPcGFjaXR5IHN0b3BPcGFjaXR5IHN0cm9rZURhc2hhcnJheSBzdHJva2VEYXNob2Zmc2V0IHN0cm9rZU1pdGVybGltaXQgc3Ryb2tlT3BhY2l0eSBzdHJva2VXaWR0aCBNb3pBbmltYXRpb25JdGVyYXRpb25Db3VudCBNb3pCb3hGbGV4IE1vekJveEZsZXhHcm91cCBNb3pMaW5lQ2xhbXAgbXNBbmltYXRpb25JdGVyYXRpb25Db3VudCBtc0ZsZXggbXNab29tIG1zRmxleEdyb3cgbXNGbGV4TmVnYXRpdmUgbXNGbGV4T3JkZXIgbXNGbGV4UG9zaXRpdmUgbXNGbGV4U2hyaW5rIG1zR3JpZENvbHVtbiBtc0dyaWRDb2x1bW5TcGFuIG1zR3JpZFJvdyBtc0dyaWRSb3dTcGFuIFdlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IFdlYmtpdEJveEZsZXggV2ViS2l0Qm94RmxleEdyb3VwIFdlYmtpdEJveE9yZGluYWxHcm91cCBXZWJraXRDb2x1bW5Db3VudCBXZWJraXRDb2x1bW5zIFdlYmtpdEZsZXggV2Via2l0RmxleEdyb3cgV2Via2l0RmxleFBvc2l0aXZlIFdlYmtpdEZsZXhTaHJpbmsgV2Via2l0TGluZUNsYW1wXCIuc3BsaXQoXG4gICAgXCIgXCJcbiAgKVxuKTtcbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGUoc3R5bGUsIHN0eWxlTmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSAwID09PSBzdHlsZU5hbWUuaW5kZXhPZihcIi0tXCIpO1xuICBudWxsID09IHZhbHVlIHx8IFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWUgfHwgXCJcIiA9PT0gdmFsdWVcbiAgICA/IGlzQ3VzdG9tUHJvcGVydHlcbiAgICAgID8gc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCBcIlwiKVxuICAgICAgOiBcImZsb2F0XCIgPT09IHN0eWxlTmFtZVxuICAgICAgICA/IChzdHlsZS5jc3NGbG9hdCA9IFwiXCIpXG4gICAgICAgIDogKHN0eWxlW3N0eWxlTmFtZV0gPSBcIlwiKVxuICAgIDogaXNDdXN0b21Qcm9wZXJ0eVxuICAgICAgPyBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHZhbHVlKVxuICAgICAgOiBcIm51bWJlclwiICE9PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAwID09PSB2YWx1ZSB8fFxuICAgICAgICAgIHVuaXRsZXNzTnVtYmVycy5oYXMoc3R5bGVOYW1lKVxuICAgICAgICA/IFwiZmxvYXRcIiA9PT0gc3R5bGVOYW1lXG4gICAgICAgICAgPyAoc3R5bGUuY3NzRmxvYXQgPSB2YWx1ZSlcbiAgICAgICAgICA6IChzdHlsZVtzdHlsZU5hbWVdID0gKFwiXCIgKyB2YWx1ZSkudHJpbSgpKVxuICAgICAgICA6IChzdHlsZVtzdHlsZU5hbWVdID0gdmFsdWUgKyBcInB4XCIpO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzLCBwcmV2U3R5bGVzKSB7XG4gIGlmIChudWxsICE9IHN0eWxlcyAmJiBcIm9iamVjdFwiICE9PSB0eXBlb2Ygc3R5bGVzKVxuICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNjIpKTtcbiAgbm9kZSA9IG5vZGUuc3R5bGU7XG4gIGlmIChudWxsICE9IHByZXZTdHlsZXMpIHtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gcHJldlN0eWxlcylcbiAgICAgICFwcmV2U3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgfHxcbiAgICAgICAgKG51bGwgIT0gc3R5bGVzICYmIHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB8fFxuICAgICAgICAoMCA9PT0gc3R5bGVOYW1lLmluZGV4T2YoXCItLVwiKVxuICAgICAgICAgID8gbm9kZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIFwiXCIpXG4gICAgICAgICAgOiBcImZsb2F0XCIgPT09IHN0eWxlTmFtZVxuICAgICAgICAgICAgPyAobm9kZS5jc3NGbG9hdCA9IFwiXCIpXG4gICAgICAgICAgICA6IChub2RlW3N0eWxlTmFtZV0gPSBcIlwiKSk7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lJDE2IGluIHN0eWxlcylcbiAgICAgIChzdHlsZU5hbWUgPSBzdHlsZXNbc3R5bGVOYW1lJDE2XSksXG4gICAgICAgIHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUkMTYpICYmXG4gICAgICAgICAgcHJldlN0eWxlc1tzdHlsZU5hbWUkMTZdICE9PSBzdHlsZU5hbWUgJiZcbiAgICAgICAgICBzZXRWYWx1ZUZvclN0eWxlKG5vZGUsIHN0eWxlTmFtZSQxNiwgc3R5bGVOYW1lKTtcbiAgfSBlbHNlXG4gICAgZm9yICh2YXIgc3R5bGVOYW1lJDE3IGluIHN0eWxlcylcbiAgICAgIHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUkMTcpICYmXG4gICAgICAgIHNldFZhbHVlRm9yU3R5bGUobm9kZSwgc3R5bGVOYW1lJDE3LCBzdHlsZXNbc3R5bGVOYW1lJDE3XSk7XG59XG5mdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodGFnTmFtZSkge1xuICBpZiAoLTEgPT09IHRhZ05hbWUuaW5kZXhPZihcIi1cIikpIHJldHVybiAhMTtcbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImFubm90YXRpb24teG1sXCI6XG4gICAgY2FzZSBcImNvbG9yLXByb2ZpbGVcIjpcbiAgICBjYXNlIFwiZm9udC1mYWNlXCI6XG4gICAgY2FzZSBcImZvbnQtZmFjZS1zcmNcIjpcbiAgICBjYXNlIFwiZm9udC1mYWNlLXVyaVwiOlxuICAgIGNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6XG4gICAgY2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6XG4gICAgY2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpcbiAgICAgIHJldHVybiAhMTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICEwO1xuICB9XG59XG52YXIgYWxpYXNlcyA9IG5ldyBNYXAoW1xuICAgIFtcImFjY2VwdENoYXJzZXRcIiwgXCJhY2NlcHQtY2hhcnNldFwiXSxcbiAgICBbXCJodG1sRm9yXCIsIFwiZm9yXCJdLFxuICAgIFtcImh0dHBFcXVpdlwiLCBcImh0dHAtZXF1aXZcIl0sXG4gICAgW1wiY3Jvc3NPcmlnaW5cIiwgXCJjcm9zc29yaWdpblwiXSxcbiAgICBbXCJhY2NlbnRIZWlnaHRcIiwgXCJhY2NlbnQtaGVpZ2h0XCJdLFxuICAgIFtcImFsaWdubWVudEJhc2VsaW5lXCIsIFwiYWxpZ25tZW50LWJhc2VsaW5lXCJdLFxuICAgIFtcImFyYWJpY0Zvcm1cIiwgXCJhcmFiaWMtZm9ybVwiXSxcbiAgICBbXCJiYXNlbGluZVNoaWZ0XCIsIFwiYmFzZWxpbmUtc2hpZnRcIl0sXG4gICAgW1wiY2FwSGVpZ2h0XCIsIFwiY2FwLWhlaWdodFwiXSxcbiAgICBbXCJjbGlwUGF0aFwiLCBcImNsaXAtcGF0aFwiXSxcbiAgICBbXCJjbGlwUnVsZVwiLCBcImNsaXAtcnVsZVwiXSxcbiAgICBbXCJjb2xvckludGVycG9sYXRpb25cIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCJdLFxuICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIl0sXG4gICAgW1wiY29sb3JQcm9maWxlXCIsIFwiY29sb3ItcHJvZmlsZVwiXSxcbiAgICBbXCJjb2xvclJlbmRlcmluZ1wiLCBcImNvbG9yLXJlbmRlcmluZ1wiXSxcbiAgICBbXCJkb21pbmFudEJhc2VsaW5lXCIsIFwiZG9taW5hbnQtYmFzZWxpbmVcIl0sXG4gICAgW1wiZW5hYmxlQmFja2dyb3VuZFwiLCBcImVuYWJsZS1iYWNrZ3JvdW5kXCJdLFxuICAgIFtcImZpbGxPcGFjaXR5XCIsIFwiZmlsbC1vcGFjaXR5XCJdLFxuICAgIFtcImZpbGxSdWxlXCIsIFwiZmlsbC1ydWxlXCJdLFxuICAgIFtcImZsb29kQ29sb3JcIiwgXCJmbG9vZC1jb2xvclwiXSxcbiAgICBbXCJmbG9vZE9wYWNpdHlcIiwgXCJmbG9vZC1vcGFjaXR5XCJdLFxuICAgIFtcImZvbnRGYW1pbHlcIiwgXCJmb250LWZhbWlseVwiXSxcbiAgICBbXCJmb250U2l6ZVwiLCBcImZvbnQtc2l6ZVwiXSxcbiAgICBbXCJmb250U2l6ZUFkanVzdFwiLCBcImZvbnQtc2l6ZS1hZGp1c3RcIl0sXG4gICAgW1wiZm9udFN0cmV0Y2hcIiwgXCJmb250LXN0cmV0Y2hcIl0sXG4gICAgW1wiZm9udFN0eWxlXCIsIFwiZm9udC1zdHlsZVwiXSxcbiAgICBbXCJmb250VmFyaWFudFwiLCBcImZvbnQtdmFyaWFudFwiXSxcbiAgICBbXCJmb250V2VpZ2h0XCIsIFwiZm9udC13ZWlnaHRcIl0sXG4gICAgW1wiZ2x5cGhOYW1lXCIsIFwiZ2x5cGgtbmFtZVwiXSxcbiAgICBbXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIl0sXG4gICAgW1wiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIl0sXG4gICAgW1wiaG9yaXpBZHZYXCIsIFwiaG9yaXotYWR2LXhcIl0sXG4gICAgW1wiaG9yaXpPcmlnaW5YXCIsIFwiaG9yaXotb3JpZ2luLXhcIl0sXG4gICAgW1wiaW1hZ2VSZW5kZXJpbmdcIiwgXCJpbWFnZS1yZW5kZXJpbmdcIl0sXG4gICAgW1wibGV0dGVyU3BhY2luZ1wiLCBcImxldHRlci1zcGFjaW5nXCJdLFxuICAgIFtcImxpZ2h0aW5nQ29sb3JcIiwgXCJsaWdodGluZy1jb2xvclwiXSxcbiAgICBbXCJtYXJrZXJFbmRcIiwgXCJtYXJrZXItZW5kXCJdLFxuICAgIFtcIm1hcmtlck1pZFwiLCBcIm1hcmtlci1taWRcIl0sXG4gICAgW1wibWFya2VyU3RhcnRcIiwgXCJtYXJrZXItc3RhcnRcIl0sXG4gICAgW1wib3ZlcmxpbmVQb3NpdGlvblwiLCBcIm92ZXJsaW5lLXBvc2l0aW9uXCJdLFxuICAgIFtcIm92ZXJsaW5lVGhpY2tuZXNzXCIsIFwib3ZlcmxpbmUtdGhpY2tuZXNzXCJdLFxuICAgIFtcInBhaW50T3JkZXJcIiwgXCJwYWludC1vcmRlclwiXSxcbiAgICBbXCJwYW5vc2UtMVwiLCBcInBhbm9zZS0xXCJdLFxuICAgIFtcInBvaW50ZXJFdmVudHNcIiwgXCJwb2ludGVyLWV2ZW50c1wiXSxcbiAgICBbXCJyZW5kZXJpbmdJbnRlbnRcIiwgXCJyZW5kZXJpbmctaW50ZW50XCJdLFxuICAgIFtcInNoYXBlUmVuZGVyaW5nXCIsIFwic2hhcGUtcmVuZGVyaW5nXCJdLFxuICAgIFtcInN0b3BDb2xvclwiLCBcInN0b3AtY29sb3JcIl0sXG4gICAgW1wic3RvcE9wYWNpdHlcIiwgXCJzdG9wLW9wYWNpdHlcIl0sXG4gICAgW1wic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsIFwic3RyaWtldGhyb3VnaC1wb3NpdGlvblwiXSxcbiAgICBbXCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzXCIsIFwic3RyaWtldGhyb3VnaC10aGlja25lc3NcIl0sXG4gICAgW1wic3Ryb2tlRGFzaGFycmF5XCIsIFwic3Ryb2tlLWRhc2hhcnJheVwiXSxcbiAgICBbXCJzdHJva2VEYXNob2Zmc2V0XCIsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIl0sXG4gICAgW1wic3Ryb2tlTGluZWNhcFwiLCBcInN0cm9rZS1saW5lY2FwXCJdLFxuICAgIFtcInN0cm9rZUxpbmVqb2luXCIsIFwic3Ryb2tlLWxpbmVqb2luXCJdLFxuICAgIFtcInN0cm9rZU1pdGVybGltaXRcIiwgXCJzdHJva2UtbWl0ZXJsaW1pdFwiXSxcbiAgICBbXCJzdHJva2VPcGFjaXR5XCIsIFwic3Ryb2tlLW9wYWNpdHlcIl0sXG4gICAgW1wic3Ryb2tlV2lkdGhcIiwgXCJzdHJva2Utd2lkdGhcIl0sXG4gICAgW1widGV4dEFuY2hvclwiLCBcInRleHQtYW5jaG9yXCJdLFxuICAgIFtcInRleHREZWNvcmF0aW9uXCIsIFwidGV4dC1kZWNvcmF0aW9uXCJdLFxuICAgIFtcInRleHRSZW5kZXJpbmdcIiwgXCJ0ZXh0LXJlbmRlcmluZ1wiXSxcbiAgICBbXCJ0cmFuc2Zvcm1PcmlnaW5cIiwgXCJ0cmFuc2Zvcm0tb3JpZ2luXCJdLFxuICAgIFtcInVuZGVybGluZVBvc2l0aW9uXCIsIFwidW5kZXJsaW5lLXBvc2l0aW9uXCJdLFxuICAgIFtcInVuZGVybGluZVRoaWNrbmVzc1wiLCBcInVuZGVybGluZS10aGlja25lc3NcIl0sXG4gICAgW1widW5pY29kZUJpZGlcIiwgXCJ1bmljb2RlLWJpZGlcIl0sXG4gICAgW1widW5pY29kZVJhbmdlXCIsIFwidW5pY29kZS1yYW5nZVwiXSxcbiAgICBbXCJ1bml0c1BlckVtXCIsIFwidW5pdHMtcGVyLWVtXCJdLFxuICAgIFtcInZBbHBoYWJldGljXCIsIFwidi1hbHBoYWJldGljXCJdLFxuICAgIFtcInZIYW5naW5nXCIsIFwidi1oYW5naW5nXCJdLFxuICAgIFtcInZJZGVvZ3JhcGhpY1wiLCBcInYtaWRlb2dyYXBoaWNcIl0sXG4gICAgW1widk1hdGhlbWF0aWNhbFwiLCBcInYtbWF0aGVtYXRpY2FsXCJdLFxuICAgIFtcInZlY3RvckVmZmVjdFwiLCBcInZlY3Rvci1lZmZlY3RcIl0sXG4gICAgW1widmVydEFkdllcIiwgXCJ2ZXJ0LWFkdi15XCJdLFxuICAgIFtcInZlcnRPcmlnaW5YXCIsIFwidmVydC1vcmlnaW4teFwiXSxcbiAgICBbXCJ2ZXJ0T3JpZ2luWVwiLCBcInZlcnQtb3JpZ2luLXlcIl0sXG4gICAgW1wid29yZFNwYWNpbmdcIiwgXCJ3b3JkLXNwYWNpbmdcIl0sXG4gICAgW1wid3JpdGluZ01vZGVcIiwgXCJ3cml0aW5nLW1vZGVcIl0sXG4gICAgW1wieG1sbnNYbGlua1wiLCBcInhtbG5zOnhsaW5rXCJdLFxuICAgIFtcInhIZWlnaHRcIiwgXCJ4LWhlaWdodFwiXVxuICBdKSxcbiAgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPVxuICAgIC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSo6L2k7XG5mdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAgcmV0dXJuIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QoXCJcIiArIHVybClcbiAgICA/IFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGhhcyBibG9ja2VkIGEgamF2YXNjcmlwdDogVVJMIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4nKVwiXG4gICAgOiB1cmw7XG59XG52YXIgY3VycmVudFJlcGxheWluZ0V2ZW50ID0gbnVsbDtcbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIG5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuICBuYXRpdmVFdmVudC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCAmJlxuICAgIChuYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtcbiAgcmV0dXJuIDMgPT09IG5hdGl2ZUV2ZW50Lm5vZGVUeXBlID8gbmF0aXZlRXZlbnQucGFyZW50Tm9kZSA6IG5hdGl2ZUV2ZW50O1xufVxudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsLFxuICByZXN0b3JlUXVldWUgPSBudWxsO1xuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXQpO1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZSAmJiAodGFyZ2V0ID0gaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUpKSB7XG4gICAgdmFyIHByb3BzID0gdGFyZ2V0W2ludGVybmFsUHJvcHNLZXldIHx8IG51bGw7XG4gICAgYTogc3dpdGNoICgoKHRhcmdldCA9IGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKSwgaW50ZXJuYWxJbnN0YW5jZS50eXBlKSkge1xuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIHVwZGF0ZUlucHV0KFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBwcm9wcy52YWx1ZSxcbiAgICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIHByb3BzLmNoZWNrZWQsXG4gICAgICAgICAgcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICAgICAgcHJvcHMudHlwZSxcbiAgICAgICAgICBwcm9wcy5uYW1lXG4gICAgICAgICk7XG4gICAgICAgIGludGVybmFsSW5zdGFuY2UgPSBwcm9wcy5uYW1lO1xuICAgICAgICBpZiAoXCJyYWRpb1wiID09PSBwcm9wcy50eXBlICYmIG51bGwgIT0gaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgICAgIGZvciAocHJvcHMgPSB0YXJnZXQ7IHByb3BzLnBhcmVudE5vZGU7ICkgcHJvcHMgPSBwcm9wcy5wYXJlbnROb2RlO1xuICAgICAgICAgIHByb3BzID0gcHJvcHMucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICAgICdpbnB1dFtuYW1lPVwiJyArXG4gICAgICAgICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoXG4gICAgICAgICAgICAgICAgXCJcIiArIGludGVybmFsSW5zdGFuY2VcbiAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICdcIl1bdHlwZT1cInJhZGlvXCJdJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UgPSAwO1xuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSA8IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG90aGVyTm9kZSA9IHByb3BzW2ludGVybmFsSW5zdGFuY2VdO1xuICAgICAgICAgICAgaWYgKG90aGVyTm9kZSAhPT0gdGFyZ2V0ICYmIG90aGVyTm9kZS5mb3JtID09PSB0YXJnZXQuZm9ybSkge1xuICAgICAgICAgICAgICB2YXIgb3RoZXJQcm9wcyA9IG90aGVyTm9kZVtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsO1xuICAgICAgICAgICAgICBpZiAoIW90aGVyUHJvcHMpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOTApKTtcbiAgICAgICAgICAgICAgdXBkYXRlSW5wdXQoXG4gICAgICAgICAgICAgICAgb3RoZXJOb2RlLFxuICAgICAgICAgICAgICAgIG90aGVyUHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgICAgb3RoZXJQcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgb3RoZXJQcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgb3RoZXJQcm9wcy5jaGVja2VkLFxuICAgICAgICAgICAgICAgIG90aGVyUHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICAgICAgICAgICAgb3RoZXJQcm9wcy50eXBlLFxuICAgICAgICAgICAgICAgIG90aGVyUHJvcHMubmFtZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSA9IDA7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlIDwgcHJvcHMubGVuZ3RoO1xuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgKG90aGVyTm9kZSA9IHByb3BzW2ludGVybmFsSW5zdGFuY2VdKSxcbiAgICAgICAgICAgICAgb3RoZXJOb2RlLmZvcm0gPT09IHRhcmdldC5mb3JtICYmIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWsgYTtcbiAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICB1cGRhdGVUZXh0YXJlYSh0YXJnZXQsIHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgICBicmVhayBhO1xuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAoaW50ZXJuYWxJbnN0YW5jZSA9IHByb3BzLnZhbHVlKSxcbiAgICAgICAgICBudWxsICE9IGludGVybmFsSW5zdGFuY2UgJiZcbiAgICAgICAgICAgIHVwZGF0ZU9wdGlvbnModGFyZ2V0LCAhIXByb3BzLm11bHRpcGxlLCBpbnRlcm5hbEluc3RhbmNlLCAhMSk7XG4gICAgfVxuICB9XG59XG52YXIgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSAhMTtcbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzJDEoZm4sIGEsIGIpIHtcbiAgaWYgKGlzSW5zaWRlRXZlbnRIYW5kbGVyKSByZXR1cm4gZm4oYSwgYik7XG4gIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gITA7XG4gIHRyeSB7XG4gICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGZuKGEpO1xuICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKFxuICAgICAgKChpc0luc2lkZUV2ZW50SGFuZGxlciA9ICExKSxcbiAgICAgIG51bGwgIT09IHJlc3RvcmVUYXJnZXQgfHwgbnVsbCAhPT0gcmVzdG9yZVF1ZXVlKVxuICAgIClcbiAgICAgIGlmIChcbiAgICAgICAgKGZsdXNoU3luY1dvcmskMSgpLFxuICAgICAgICByZXN0b3JlVGFyZ2V0ICYmXG4gICAgICAgICAgKChhID0gcmVzdG9yZVRhcmdldCksXG4gICAgICAgICAgKGZuID0gcmVzdG9yZVF1ZXVlKSxcbiAgICAgICAgICAocmVzdG9yZVF1ZXVlID0gcmVzdG9yZVRhcmdldCA9IG51bGwpLFxuICAgICAgICAgIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KGEpLFxuICAgICAgICAgIGZuKSlcbiAgICAgIClcbiAgICAgICAgZm9yIChhID0gMDsgYSA8IGZuLmxlbmd0aDsgYSsrKSByZXN0b3JlU3RhdGVPZlRhcmdldChmblthXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuICBpZiAobnVsbCA9PT0gc3RhdGVOb2RlKSByZXR1cm4gbnVsbDtcbiAgdmFyIHByb3BzID0gc3RhdGVOb2RlW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGw7XG4gIGlmIChudWxsID09PSBwcm9wcykgcmV0dXJuIG51bGw7XG4gIHN0YXRlTm9kZSA9IHByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBhOiBzd2l0Y2ggKHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBjYXNlIFwib25DbGlja1wiOlxuICAgIGNhc2UgXCJvbkNsaWNrQ2FwdHVyZVwiOlxuICAgIGNhc2UgXCJvbkRvdWJsZUNsaWNrXCI6XG4gICAgY2FzZSBcIm9uRG91YmxlQ2xpY2tDYXB0dXJlXCI6XG4gICAgY2FzZSBcIm9uTW91c2VEb3duXCI6XG4gICAgY2FzZSBcIm9uTW91c2VEb3duQ2FwdHVyZVwiOlxuICAgIGNhc2UgXCJvbk1vdXNlTW92ZVwiOlxuICAgIGNhc2UgXCJvbk1vdXNlTW92ZUNhcHR1cmVcIjpcbiAgICBjYXNlIFwib25Nb3VzZVVwXCI6XG4gICAgY2FzZSBcIm9uTW91c2VVcENhcHR1cmVcIjpcbiAgICBjYXNlIFwib25Nb3VzZUVudGVyXCI6XG4gICAgICAocHJvcHMgPSAhcHJvcHMuZGlzYWJsZWQpIHx8XG4gICAgICAgICgoaW5zdCA9IGluc3QudHlwZSksXG4gICAgICAgIChwcm9wcyA9ICEoXG4gICAgICAgICAgXCJidXR0b25cIiA9PT0gaW5zdCB8fFxuICAgICAgICAgIFwiaW5wdXRcIiA9PT0gaW5zdCB8fFxuICAgICAgICAgIFwic2VsZWN0XCIgPT09IGluc3QgfHxcbiAgICAgICAgICBcInRleHRhcmVhXCIgPT09IGluc3RcbiAgICAgICAgKSkpO1xuICAgICAgaW5zdCA9ICFwcm9wcztcbiAgICAgIGJyZWFrIGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIGluc3QgPSAhMTtcbiAgfVxuICBpZiAoaW5zdCkgcmV0dXJuIG51bGw7XG4gIGlmIChzdGF0ZU5vZGUgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygc3RhdGVOb2RlKVxuICAgIHRocm93IEVycm9yKFxuICAgICAgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMzEsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBzdGF0ZU5vZGUpXG4gICAgKTtcbiAgcmV0dXJuIHN0YXRlTm9kZTtcbn1cbnZhciBwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCA9ICExO1xuaWYgKGNhblVzZURPTSlcbiAgdHJ5IHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRpb25zLCBcInBhc3NpdmVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gITA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gITE7XG4gIH1cbnZhciByb290ID0gbnVsbCxcbiAgc3RhcnRUZXh0ID0gbnVsbCxcbiAgZmFsbGJhY2tUZXh0ID0gbnVsbDtcbmZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGlmIChmYWxsYmFja1RleHQpIHJldHVybiBmYWxsYmFja1RleHQ7XG4gIHZhciBzdGFydCxcbiAgICBzdGFydFZhbHVlID0gc3RhcnRUZXh0LFxuICAgIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGgsXG4gICAgZW5kLFxuICAgIGVuZFZhbHVlID0gXCJ2YWx1ZVwiIGluIHJvb3QgPyByb290LnZhbHVlIDogcm9vdC50ZXh0Q29udGVudCxcbiAgICBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG4gIGZvciAoXG4gICAgc3RhcnQgPSAwO1xuICAgIHN0YXJ0IDwgc3RhcnRMZW5ndGggJiYgc3RhcnRWYWx1ZVtzdGFydF0gPT09IGVuZFZhbHVlW3N0YXJ0XTtcbiAgICBzdGFydCsrXG4gICk7XG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICBmb3IgKFxuICAgIGVuZCA9IDE7XG4gICAgZW5kIDw9IG1pbkVuZCAmJlxuICAgIHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdID09PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdO1xuICAgIGVuZCsrXG4gICk7XG4gIHJldHVybiAoZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIDEgPCBlbmQgPyAxIC0gZW5kIDogdm9pZCAwKSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcbiAgXCJjaGFyQ29kZVwiIGluIG5hdGl2ZUV2ZW50XG4gICAgPyAoKG5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQuY2hhckNvZGUpLFxuICAgICAgMCA9PT0gbmF0aXZlRXZlbnQgJiYgMTMgPT09IGtleUNvZGUgJiYgKG5hdGl2ZUV2ZW50ID0gMTMpKVxuICAgIDogKG5hdGl2ZUV2ZW50ID0ga2V5Q29kZSk7XG4gIDEwID09PSBuYXRpdmVFdmVudCAmJiAobmF0aXZlRXZlbnQgPSAxMyk7XG4gIHJldHVybiAzMiA8PSBuYXRpdmVFdmVudCB8fCAxMyA9PT0gbmF0aXZlRXZlbnQgPyBuYXRpdmVFdmVudCA6IDA7XG59XG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSgpIHtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlKCkge1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBjcmVhdGVTeW50aGV0aWNFdmVudChJbnRlcmZhY2UpIHtcbiAgZnVuY3Rpb24gU3ludGhldGljQmFzZUV2ZW50KFxuICAgIHJlYWN0TmFtZSxcbiAgICByZWFjdEV2ZW50VHlwZSxcbiAgICB0YXJnZXRJbnN0LFxuICAgIG5hdGl2ZUV2ZW50LFxuICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICkge1xuICAgIHRoaXMuX3JlYWN0TmFtZSA9IHJlYWN0TmFtZTtcbiAgICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICB0aGlzLnR5cGUgPSByZWFjdEV2ZW50VHlwZTtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSlcbiAgICAgIEludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiZcbiAgICAgICAgKChyZWFjdE5hbWUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdKSxcbiAgICAgICAgKHRoaXNbcHJvcE5hbWVdID0gcmVhY3ROYW1lXG4gICAgICAgICAgPyByZWFjdE5hbWUobmF0aXZlRXZlbnQpXG4gICAgICAgICAgOiBuYXRpdmVFdmVudFtwcm9wTmFtZV0pKTtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IChcbiAgICAgIG51bGwgIT0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICAgICAgICA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcbiAgICAgICAgOiAhMSA9PT0gbmF0aXZlRXZlbnQucmV0dXJuVmFsdWVcbiAgICApXG4gICAgICA/IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlXG4gICAgICA6IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzc2lnbihTeW50aGV0aWNCYXNlRXZlbnQucHJvdG90eXBlLCB7XG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICAgIGV2ZW50ICYmXG4gICAgICAgIChldmVudC5wcmV2ZW50RGVmYXVsdFxuICAgICAgICAgID8gZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgIDogXCJ1bmtub3duXCIgIT09IHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAmJiAoZXZlbnQucmV0dXJuVmFsdWUgPSAhMSksXG4gICAgICAgICh0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlKSk7XG4gICAgfSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgICBldmVudCAmJlxuICAgICAgICAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgICAgPyBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgIDogXCJ1bmtub3duXCIgIT09IHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgJiZcbiAgICAgICAgICAgIChldmVudC5jYW5jZWxCdWJibGUgPSAhMCksXG4gICAgICAgICh0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUpKTtcbiAgICB9LFxuICAgIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGlzUGVyc2lzdGVudDogZnVuY3Rpb25UaGF0UmV0dXJuc1RydWVcbiAgfSk7XG4gIHJldHVybiBTeW50aGV0aWNCYXNlRXZlbnQ7XG59XG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gICAgZXZlbnRQaGFzZTogMCxcbiAgICBidWJibGVzOiAwLFxuICAgIGNhbmNlbGFibGU6IDAsXG4gICAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgICB9LFxuICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IDAsXG4gICAgaXNUcnVzdGVkOiAwXG4gIH0sXG4gIFN5bnRoZXRpY0V2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoRXZlbnRJbnRlcmZhY2UpLFxuICBVSUV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwgeyB2aWV3OiAwLCBkZXRhaWw6IDAgfSksXG4gIFN5bnRoZXRpY1VJRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChVSUV2ZW50SW50ZXJmYWNlKSxcbiAgbGFzdE1vdmVtZW50WCxcbiAgbGFzdE1vdmVtZW50WSxcbiAgbGFzdE1vdXNlRXZlbnQsXG4gIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgICBzY3JlZW5YOiAwLFxuICAgIHNjcmVlblk6IDAsXG4gICAgY2xpZW50WDogMCxcbiAgICBjbGllbnRZOiAwLFxuICAgIHBhZ2VYOiAwLFxuICAgIHBhZ2VZOiAwLFxuICAgIGN0cmxLZXk6IDAsXG4gICAgc2hpZnRLZXk6IDAsXG4gICAgYWx0S2V5OiAwLFxuICAgIG1ldGFLZXk6IDAsXG4gICAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAgIGJ1dHRvbjogMCxcbiAgICBidXR0b25zOiAwLFxuICAgIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZXZlbnQucmVsYXRlZFRhcmdldFxuICAgICAgICA/IGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50XG4gICAgICAgICAgPyBldmVudC50b0VsZW1lbnRcbiAgICAgICAgICA6IGV2ZW50LmZyb21FbGVtZW50XG4gICAgICAgIDogZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICB9LFxuICAgIG1vdmVtZW50WDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoXCJtb3ZlbWVudFhcIiBpbiBldmVudCkgcmV0dXJuIGV2ZW50Lm1vdmVtZW50WDtcbiAgICAgIGV2ZW50ICE9PSBsYXN0TW91c2VFdmVudCAmJlxuICAgICAgICAobGFzdE1vdXNlRXZlbnQgJiYgXCJtb3VzZW1vdmVcIiA9PT0gZXZlbnQudHlwZVxuICAgICAgICAgID8gKChsYXN0TW92ZW1lbnRYID0gZXZlbnQuc2NyZWVuWCAtIGxhc3RNb3VzZUV2ZW50LnNjcmVlblgpLFxuICAgICAgICAgICAgKGxhc3RNb3ZlbWVudFkgPSBldmVudC5zY3JlZW5ZIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWSkpXG4gICAgICAgICAgOiAobGFzdE1vdmVtZW50WSA9IGxhc3RNb3ZlbWVudFggPSAwKSxcbiAgICAgICAgKGxhc3RNb3VzZUV2ZW50ID0gZXZlbnQpKTtcbiAgICAgIHJldHVybiBsYXN0TW92ZW1lbnRYO1xuICAgIH0sXG4gICAgbW92ZW1lbnRZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBcIm1vdmVtZW50WVwiIGluIGV2ZW50ID8gZXZlbnQubW92ZW1lbnRZIDogbGFzdE1vdmVtZW50WTtcbiAgICB9XG4gIH0pLFxuICBTeW50aGV0aWNNb3VzZUV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoTW91c2VFdmVudEludGVyZmFjZSksXG4gIERyYWdFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwgeyBkYXRhVHJhbnNmZXI6IDAgfSksXG4gIFN5bnRoZXRpY0RyYWdFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KERyYWdFdmVudEludGVyZmFjZSksXG4gIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHsgcmVsYXRlZFRhcmdldDogMCB9KSxcbiAgU3ludGhldGljRm9jdXNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEZvY3VzRXZlbnRJbnRlcmZhY2UpLFxuICBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgICBhbmltYXRpb25OYW1lOiAwLFxuICAgIGVsYXBzZWRUaW1lOiAwLFxuICAgIHBzZXVkb0VsZW1lbnQ6IDBcbiAgfSksXG4gIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpLFxuICBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBcImNsaXBib2FyZERhdGFcIiBpbiBldmVudFxuICAgICAgICA/IGV2ZW50LmNsaXBib2FyZERhdGFcbiAgICAgICAgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgICB9XG4gIH0pLFxuICBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKSxcbiAgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHsgZGF0YTogMCB9KSxcbiAgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpLFxuICBub3JtYWxpemVLZXkgPSB7XG4gICAgRXNjOiBcIkVzY2FwZVwiLFxuICAgIFNwYWNlYmFyOiBcIiBcIixcbiAgICBMZWZ0OiBcIkFycm93TGVmdFwiLFxuICAgIFVwOiBcIkFycm93VXBcIixcbiAgICBSaWdodDogXCJBcnJvd1JpZ2h0XCIsXG4gICAgRG93bjogXCJBcnJvd0Rvd25cIixcbiAgICBEZWw6IFwiRGVsZXRlXCIsXG4gICAgV2luOiBcIk9TXCIsXG4gICAgTWVudTogXCJDb250ZXh0TWVudVwiLFxuICAgIEFwcHM6IFwiQ29udGV4dE1lbnVcIixcbiAgICBTY3JvbGw6IFwiU2Nyb2xsTG9ja1wiLFxuICAgIE1velByaW50YWJsZUtleTogXCJVbmlkZW50aWZpZWRcIlxuICB9LFxuICB0cmFuc2xhdGVUb0tleSA9IHtcbiAgICA4OiBcIkJhY2tzcGFjZVwiLFxuICAgIDk6IFwiVGFiXCIsXG4gICAgMTI6IFwiQ2xlYXJcIixcbiAgICAxMzogXCJFbnRlclwiLFxuICAgIDE2OiBcIlNoaWZ0XCIsXG4gICAgMTc6IFwiQ29udHJvbFwiLFxuICAgIDE4OiBcIkFsdFwiLFxuICAgIDE5OiBcIlBhdXNlXCIsXG4gICAgMjA6IFwiQ2Fwc0xvY2tcIixcbiAgICAyNzogXCJFc2NhcGVcIixcbiAgICAzMjogXCIgXCIsXG4gICAgMzM6IFwiUGFnZVVwXCIsXG4gICAgMzQ6IFwiUGFnZURvd25cIixcbiAgICAzNTogXCJFbmRcIixcbiAgICAzNjogXCJIb21lXCIsXG4gICAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gICAgMzg6IFwiQXJyb3dVcFwiLFxuICAgIDM5OiBcIkFycm93UmlnaHRcIixcbiAgICA0MDogXCJBcnJvd0Rvd25cIixcbiAgICA0NTogXCJJbnNlcnRcIixcbiAgICA0NjogXCJEZWxldGVcIixcbiAgICAxMTI6IFwiRjFcIixcbiAgICAxMTM6IFwiRjJcIixcbiAgICAxMTQ6IFwiRjNcIixcbiAgICAxMTU6IFwiRjRcIixcbiAgICAxMTY6IFwiRjVcIixcbiAgICAxMTc6IFwiRjZcIixcbiAgICAxMTg6IFwiRjdcIixcbiAgICAxMTk6IFwiRjhcIixcbiAgICAxMjA6IFwiRjlcIixcbiAgICAxMjE6IFwiRjEwXCIsXG4gICAgMTIyOiBcIkYxMVwiLFxuICAgIDEyMzogXCJGMTJcIixcbiAgICAxNDQ6IFwiTnVtTG9ja1wiLFxuICAgIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gICAgMjI0OiBcIk1ldGFcIlxuICB9LFxuICBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgICBBbHQ6IFwiYWx0S2V5XCIsXG4gICAgQ29udHJvbDogXCJjdHJsS2V5XCIsXG4gICAgTWV0YTogXCJtZXRhS2V5XCIsXG4gICAgU2hpZnQ6IFwic2hpZnRLZXlcIlxuICB9O1xuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGVcbiAgICA/IG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKVxuICAgIDogKGtleUFyZyA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ10pXG4gICAgICA/ICEhbmF0aXZlRXZlbnRba2V5QXJnXVxuICAgICAgOiAhMTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSgpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICAgIGtleTogZnVuY3Rpb24gKG5hdGl2ZUV2ZW50KSB7XG4gICAgICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgICAgIGlmIChcIlVuaWRlbnRpZmllZFwiICE9PSBrZXkpIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJrZXlwcmVzc1wiID09PSBuYXRpdmVFdmVudC50eXBlXG4gICAgICAgID8gKChuYXRpdmVFdmVudCA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpKSxcbiAgICAgICAgICAxMyA9PT0gbmF0aXZlRXZlbnQgPyBcIkVudGVyXCIgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50KSlcbiAgICAgICAgOiBcImtleWRvd25cIiA9PT0gbmF0aXZlRXZlbnQudHlwZSB8fCBcImtleXVwXCIgPT09IG5hdGl2ZUV2ZW50LnR5cGVcbiAgICAgICAgICA/IHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8IFwiVW5pZGVudGlmaWVkXCJcbiAgICAgICAgICA6IFwiXCI7XG4gICAgfSxcbiAgICBjb2RlOiAwLFxuICAgIGxvY2F0aW9uOiAwLFxuICAgIGN0cmxLZXk6IDAsXG4gICAgc2hpZnRLZXk6IDAsXG4gICAgYWx0S2V5OiAwLFxuICAgIG1ldGFLZXk6IDAsXG4gICAgcmVwZWF0OiAwLFxuICAgIGxvY2FsZTogMCxcbiAgICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gICAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIFwia2V5cHJlc3NcIiA9PT0gZXZlbnQudHlwZSA/IGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpIDogMDtcbiAgICB9LFxuICAgIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIFwia2V5ZG93blwiID09PSBldmVudC50eXBlIHx8IFwia2V5dXBcIiA9PT0gZXZlbnQudHlwZVxuICAgICAgICA/IGV2ZW50LmtleUNvZGVcbiAgICAgICAgOiAwO1xuICAgIH0sXG4gICAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIFwia2V5cHJlc3NcIiA9PT0gZXZlbnQudHlwZVxuICAgICAgICA/IGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpXG4gICAgICAgIDogXCJrZXlkb3duXCIgPT09IGV2ZW50LnR5cGUgfHwgXCJrZXl1cFwiID09PSBldmVudC50eXBlXG4gICAgICAgICAgPyBldmVudC5rZXlDb2RlXG4gICAgICAgICAgOiAwO1xuICAgIH1cbiAgfSksXG4gIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChLZXlib2FyZEV2ZW50SW50ZXJmYWNlKSxcbiAgUG9pbnRlckV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gICAgcG9pbnRlcklkOiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBwcmVzc3VyZTogMCxcbiAgICB0YW5nZW50aWFsUHJlc3N1cmU6IDAsXG4gICAgdGlsdFg6IDAsXG4gICAgdGlsdFk6IDAsXG4gICAgdHdpc3Q6IDAsXG4gICAgcG9pbnRlclR5cGU6IDAsXG4gICAgaXNQcmltYXJ5OiAwXG4gIH0pLFxuICBTeW50aGV0aWNQb2ludGVyRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChQb2ludGVyRXZlbnRJbnRlcmZhY2UpLFxuICBUb3VjaEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gICAgdG91Y2hlczogMCxcbiAgICB0YXJnZXRUb3VjaGVzOiAwLFxuICAgIGNoYW5nZWRUb3VjaGVzOiAwLFxuICAgIGFsdEtleTogMCxcbiAgICBtZXRhS2V5OiAwLFxuICAgIGN0cmxLZXk6IDAsXG4gICAgc2hpZnRLZXk6IDAsXG4gICAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG4gIH0pLFxuICBTeW50aGV0aWNUb3VjaEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVG91Y2hFdmVudEludGVyZmFjZSksXG4gIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgICBwcm9wZXJ0eU5hbWU6IDAsXG4gICAgZWxhcHNlZFRpbWU6IDAsXG4gICAgcHNldWRvRWxlbWVudDogMFxuICB9KSxcbiAgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKSxcbiAgV2hlZWxFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICAgIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gXCJkZWx0YVhcIiBpbiBldmVudFxuICAgICAgICA/IGV2ZW50LmRlbHRhWFxuICAgICAgICA6IFwid2hlZWxEZWx0YVhcIiBpbiBldmVudFxuICAgICAgICAgID8gLWV2ZW50LndoZWVsRGVsdGFYXG4gICAgICAgICAgOiAwO1xuICAgIH0sXG4gICAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBcImRlbHRhWVwiIGluIGV2ZW50XG4gICAgICAgID8gZXZlbnQuZGVsdGFZXG4gICAgICAgIDogXCJ3aGVlbERlbHRhWVwiIGluIGV2ZW50XG4gICAgICAgICAgPyAtZXZlbnQud2hlZWxEZWx0YVlcbiAgICAgICAgICA6IFwid2hlZWxEZWx0YVwiIGluIGV2ZW50XG4gICAgICAgICAgICA/IC1ldmVudC53aGVlbERlbHRhXG4gICAgICAgICAgICA6IDA7XG4gICAgfSxcbiAgICBkZWx0YVo6IDAsXG4gICAgZGVsdGFNb2RlOiAwXG4gIH0pLFxuICBTeW50aGV0aWNXaGVlbEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoV2hlZWxFdmVudEludGVyZmFjZSksXG4gIFRvZ2dsZUV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgIG5ld1N0YXRlOiAwLFxuICAgIG9sZFN0YXRlOiAwXG4gIH0pLFxuICBTeW50aGV0aWNUb2dnbGVFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRvZ2dsZUV2ZW50SW50ZXJmYWNlKSxcbiAgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdLFxuICBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gY2FuVXNlRE9NICYmIFwiQ29tcG9zaXRpb25FdmVudFwiIGluIHdpbmRvdyxcbiAgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmNhblVzZURPTSAmJlxuICBcImRvY3VtZW50TW9kZVwiIGluIGRvY3VtZW50ICYmXG4gIChkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gY2FuVXNlRE9NICYmIFwiVGV4dEV2ZW50XCIgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUsXG4gIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID1cbiAgICBjYW5Vc2VET00gJiZcbiAgICAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHxcbiAgICAgIChkb2N1bWVudE1vZGUgJiYgOCA8IGRvY3VtZW50TW9kZSAmJiAxMSA+PSBkb2N1bWVudE1vZGUpKSxcbiAgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzIpLFxuICBoYXNTcGFjZUtleXByZXNzID0gITE7XG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgICAgcmV0dXJuIC0xICE9PSBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKTtcbiAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgICAgcmV0dXJuIDIyOSAhPT0gbmF0aXZlRXZlbnQua2V5Q29kZTtcbiAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICBjYXNlIFwibW91c2Vkb3duXCI6XG4gICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgICByZXR1cm4gITA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICBuYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgcmV0dXJuIFwib2JqZWN0XCIgPT09IHR5cGVvZiBuYXRpdmVFdmVudCAmJiBcImRhdGFcIiBpbiBuYXRpdmVFdmVudFxuICAgID8gbmF0aXZlRXZlbnQuZGF0YVxuICAgIDogbnVsbDtcbn1cbnZhciBpc0NvbXBvc2luZyA9ICExO1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSBcImtleXByZXNzXCI6XG4gICAgICBpZiAoMzIgIT09IG5hdGl2ZUV2ZW50LndoaWNoKSByZXR1cm4gbnVsbDtcbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSAhMDtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuICAgIGNhc2UgXCJ0ZXh0SW5wdXRcIjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChkb21FdmVudE5hbWUgPSBuYXRpdmVFdmVudC5kYXRhKSxcbiAgICAgICAgZG9tRXZlbnROYW1lID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MgPyBudWxsIDogZG9tRXZlbnROYW1lXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKGlzQ29tcG9zaW5nKVxuICAgIHJldHVybiBcImNvbXBvc2l0aW9uZW5kXCIgPT09IGRvbUV2ZW50TmFtZSB8fFxuICAgICAgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmXG4gICAgICAgIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSlcbiAgICAgID8gKChkb21FdmVudE5hbWUgPSBnZXREYXRhKCkpLFxuICAgICAgICAoZmFsbGJhY2tUZXh0ID0gc3RhcnRUZXh0ID0gcm9vdCA9IG51bGwpLFxuICAgICAgICAoaXNDb21wb3NpbmcgPSAhMSksXG4gICAgICAgIGRvbUV2ZW50TmFtZSlcbiAgICAgIDogbnVsbDtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlIFwicGFzdGVcIjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgXCJrZXlwcmVzc1wiOlxuICAgICAgaWYgKFxuICAgICAgICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpIHx8XG4gICAgICAgIChuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSlcbiAgICAgICkge1xuICAgICAgICBpZiAobmF0aXZlRXZlbnQuY2hhciAmJiAxIDwgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCkgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgXCJrb1wiICE9PSBuYXRpdmVFdmVudC5sb2NhbGVcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogITAsXG4gIGRhdGU6ICEwLFxuICBkYXRldGltZTogITAsXG4gIFwiZGF0ZXRpbWUtbG9jYWxcIjogITAsXG4gIGVtYWlsOiAhMCxcbiAgbW9udGg6ICEwLFxuICBudW1iZXI6ICEwLFxuICBwYXNzd29yZDogITAsXG4gIHJhbmdlOiAhMCxcbiAgc2VhcmNoOiAhMCxcbiAgdGVsOiAhMCxcbiAgdGV4dDogITAsXG4gIHRpbWU6ICEwLFxuICB1cmw6ICEwLFxuICB3ZWVrOiAhMFxufTtcbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBcImlucHV0XCIgPT09IG5vZGVOYW1lXG4gICAgPyAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXVxuICAgIDogXCJ0ZXh0YXJlYVwiID09PSBub2RlTmFtZVxuICAgICAgPyAhMFxuICAgICAgOiAhMTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChcbiAgZGlzcGF0Y2hRdWV1ZSxcbiAgaW5zdCxcbiAgbmF0aXZlRXZlbnQsXG4gIHRhcmdldFxuKSB7XG4gIHJlc3RvcmVUYXJnZXRcbiAgICA/IHJlc3RvcmVRdWV1ZVxuICAgICAgPyByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpXG4gICAgICA6IChyZXN0b3JlUXVldWUgPSBbdGFyZ2V0XSlcbiAgICA6IChyZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0KTtcbiAgaW5zdCA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhpbnN0LCBcIm9uQ2hhbmdlXCIpO1xuICAwIDwgaW5zdC5sZW5ndGggJiZcbiAgICAoKG5hdGl2ZUV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KFxuICAgICAgXCJvbkNoYW5nZVwiLFxuICAgICAgXCJjaGFuZ2VcIixcbiAgICAgIG51bGwsXG4gICAgICBuYXRpdmVFdmVudCxcbiAgICAgIHRhcmdldFxuICAgICkpLFxuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7IGV2ZW50OiBuYXRpdmVFdmVudCwgbGlzdGVuZXJzOiBpbnN0IH0pKTtcbn1cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsLFxuICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChkaXNwYXRjaFF1ZXVlKSB7XG4gIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsIDApO1xufVxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHJldHVybiB0YXJnZXRJbnN0O1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoXCJjaGFuZ2VcIiA9PT0gZG9tRXZlbnROYW1lKSByZXR1cm4gdGFyZ2V0SW5zdDtcbn1cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSAhMTtcbmlmIChjYW5Vc2VET00pIHtcbiAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMjgzO1xuICBpZiAoY2FuVXNlRE9NKSB7XG4gICAgdmFyIGlzU3VwcG9ydGVkJGpzY29tcCRpbmxpbmVfNDE4ID0gXCJvbmlucHV0XCIgaW4gZG9jdW1lbnQ7XG4gICAgaWYgKCFpc1N1cHBvcnRlZCRqc2NvbXAkaW5saW5lXzQxOCkge1xuICAgICAgdmFyIGVsZW1lbnQkanNjb21wJGlubGluZV80MTkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZWxlbWVudCRqc2NvbXAkaW5saW5lXzQxOS5zZXRBdHRyaWJ1dGUoXCJvbmlucHV0XCIsIFwicmV0dXJuO1wiKTtcbiAgICAgIGlzU3VwcG9ydGVkJGpzY29tcCRpbmxpbmVfNDE4ID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZWxlbWVudCRqc2NvbXAkaW5saW5lXzQxOS5vbmlucHV0O1xuICAgIH1cbiAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDI4MyA9IGlzU3VwcG9ydGVkJGpzY29tcCRpbmxpbmVfNDE4O1xuICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyODMgPSAhMTtcbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID1cbiAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDI4MyAmJlxuICAgICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IDkgPCBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xufVxuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGFjdGl2ZUVsZW1lbnQkMSAmJlxuICAgIChhY3RpdmVFbGVtZW50JDEuZGV0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKSxcbiAgICAoYWN0aXZlRWxlbWVudEluc3QkMSA9IGFjdGl2ZUVsZW1lbnQkMSA9IG51bGwpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChcbiAgICBcInZhbHVlXCIgPT09IG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAmJlxuICAgIGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCQxKVxuICApIHtcbiAgICB2YXIgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICAgIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChcbiAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICBhY3RpdmVFbGVtZW50SW5zdCQxLFxuICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudClcbiAgICApO1xuICAgIGJhdGNoZWRVcGRhdGVzJDEocnVuRXZlbnRJbkJhdGNoLCBkaXNwYXRjaFF1ZXVlKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIFwiZm9jdXNpblwiID09PSBkb21FdmVudE5hbWVcbiAgICA/IChzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpLFxuICAgICAgKGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldCksXG4gICAgICAoYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3QpLFxuICAgICAgYWN0aXZlRWxlbWVudCQxLmF0dGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSkpXG4gICAgOiBcImZvY3Vzb3V0XCIgPT09IGRvbUV2ZW50TmFtZSAmJiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbChkb21FdmVudE5hbWUpIHtcbiAgaWYgKFxuICAgIFwic2VsZWN0aW9uY2hhbmdlXCIgPT09IGRvbUV2ZW50TmFtZSB8fFxuICAgIFwia2V5dXBcIiA9PT0gZG9tRXZlbnROYW1lIHx8XG4gICAgXCJrZXlkb3duXCIgPT09IGRvbUV2ZW50TmFtZVxuICApXG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCQxKTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoXCJjbGlja1wiID09PSBkb21FdmVudE5hbWUpIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoXCJpbnB1dFwiID09PSBkb21FdmVudE5hbWUgfHwgXCJjaGFuZ2VcIiA9PT0gZG9tRXZlbnROYW1lKVxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG59XG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbn1cbnZhciBvYmplY3RJcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IGlzO1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iamVjdElzKG9iakEsIG9iakIpKSByZXR1cm4gITA7XG4gIGlmIChcbiAgICBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqQSB8fFxuICAgIG51bGwgPT09IG9iakEgfHxcbiAgICBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqQiB8fFxuICAgIG51bGwgPT09IG9iakJcbiAgKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSksXG4gICAga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gITE7XG4gIGZvciAoa2V5c0IgPSAwOyBrZXlzQiA8IGtleXNBLmxlbmd0aDsga2V5c0IrKykge1xuICAgIHZhciBjdXJyZW50S2V5ID0ga2V5c0Fba2V5c0JdO1xuICAgIGlmIChcbiAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGN1cnJlbnRLZXkpIHx8XG4gICAgICAhb2JqZWN0SXMob2JqQVtjdXJyZW50S2V5XSwgb2JqQltjdXJyZW50S2V5XSlcbiAgICApXG4gICAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICBmb3IgKDsgbm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQ7ICkgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICByb290ID0gMDtcbiAgZm9yICh2YXIgbm9kZUVuZDsgbm9kZTsgKSB7XG4gICAgaWYgKDMgPT09IG5vZGUubm9kZVR5cGUpIHtcbiAgICAgIG5vZGVFbmQgPSByb290ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICBpZiAocm9vdCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpXG4gICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0IC0gcm9vdCB9O1xuICAgICAgcm9vdCA9IG5vZGVFbmQ7XG4gICAgfVxuICAgIGE6IHtcbiAgICAgIGZvciAoOyBub2RlOyApIHtcbiAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICBicmVhayBhO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gdm9pZCAwO1xuICAgIH1cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUobm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICByZXR1cm4gb3V0ZXJOb2RlICYmIGlubmVyTm9kZVxuICAgID8gb3V0ZXJOb2RlID09PSBpbm5lck5vZGVcbiAgICAgID8gITBcbiAgICAgIDogb3V0ZXJOb2RlICYmIDMgPT09IG91dGVyTm9kZS5ub2RlVHlwZVxuICAgICAgICA/ICExXG4gICAgICAgIDogaW5uZXJOb2RlICYmIDMgPT09IGlubmVyTm9kZS5ub2RlVHlwZVxuICAgICAgICAgID8gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgOiBcImNvbnRhaW5zXCIgaW4gb3V0ZXJOb2RlXG4gICAgICAgICAgICA/IG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpXG4gICAgICAgICAgICA6IG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuICAgICAgICAgICAgICA/ICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpXG4gICAgICAgICAgICAgIDogITFcbiAgICA6ICExO1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudERlZXAoY29udGFpbmVySW5mbykge1xuICBjb250YWluZXJJbmZvID1cbiAgICBudWxsICE9IGNvbnRhaW5lckluZm8gJiZcbiAgICBudWxsICE9IGNvbnRhaW5lckluZm8ub3duZXJEb2N1bWVudCAmJlxuICAgIG51bGwgIT0gY29udGFpbmVySW5mby5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3XG4gICAgICA/IGNvbnRhaW5lckluZm8ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld1xuICAgICAgOiB3aW5kb3c7XG4gIGZvciAoXG4gICAgdmFyIGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KGNvbnRhaW5lckluZm8uZG9jdW1lbnQpO1xuICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBjb250YWluZXJJbmZvLkhUTUxJRnJhbWVFbGVtZW50O1xuXG4gICkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVsZW1lbnQuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgfVxuICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIGNvbnRhaW5lckluZm8gPSBlbGVtZW50LmNvbnRlbnRXaW5kb3c7XG4gICAgZWxzZSBicmVhaztcbiAgICBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudChjb250YWluZXJJbmZvLmRvY3VtZW50KTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAoXG4gICAgbm9kZU5hbWUgJiZcbiAgICAoKFwiaW5wdXRcIiA9PT0gbm9kZU5hbWUgJiZcbiAgICAgIChcInRleHRcIiA9PT0gZWxlbS50eXBlIHx8XG4gICAgICAgIFwic2VhcmNoXCIgPT09IGVsZW0udHlwZSB8fFxuICAgICAgICBcInRlbFwiID09PSBlbGVtLnR5cGUgfHxcbiAgICAgICAgXCJ1cmxcIiA9PT0gZWxlbS50eXBlIHx8XG4gICAgICAgIFwicGFzc3dvcmRcIiA9PT0gZWxlbS50eXBlKSkgfHxcbiAgICAgIFwidGV4dGFyZWFcIiA9PT0gbm9kZU5hbWUgfHxcbiAgICAgIFwidHJ1ZVwiID09PSBlbGVtLmNvbnRlbnRFZGl0YWJsZSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiwgY29udGFpbmVySW5mbykge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50RGVlcChjb250YWluZXJJbmZvKTtcbiAgY29udGFpbmVySW5mbyA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKFxuICAgIGN1ckZvY3VzZWRFbGVtICE9PSBjb250YWluZXJJbmZvICYmXG4gICAgY29udGFpbmVySW5mbyAmJlxuICAgIGNvbnRhaW5lckluZm8ub3duZXJEb2N1bWVudCAmJlxuICAgIGNvbnRhaW5zTm9kZShjb250YWluZXJJbmZvLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBjb250YWluZXJJbmZvKVxuICApIHtcbiAgICBpZiAobnVsbCAhPT0gcHJpb3JTZWxlY3Rpb25SYW5nZSAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoY29udGFpbmVySW5mbykpXG4gICAgICBpZiAoXG4gICAgICAgICgocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiA9IHByaW9yU2VsZWN0aW9uUmFuZ2Uuc3RhcnQpLFxuICAgICAgICAoY3VyRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvblJhbmdlLmVuZCksXG4gICAgICAgIHZvaWQgMCA9PT0gY3VyRm9jdXNlZEVsZW0gJiZcbiAgICAgICAgICAoY3VyRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSxcbiAgICAgICAgXCJzZWxlY3Rpb25TdGFydFwiIGluIGNvbnRhaW5lckluZm8pXG4gICAgICApXG4gICAgICAgIChjb250YWluZXJJbmZvLnNlbGVjdGlvblN0YXJ0ID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiksXG4gICAgICAgICAgKGNvbnRhaW5lckluZm8uc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgICBjdXJGb2N1c2VkRWxlbSxcbiAgICAgICAgICAgIGNvbnRhaW5lckluZm8udmFsdWUubGVuZ3RoXG4gICAgICAgICAgKSk7XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgKChjdXJGb2N1c2VkRWxlbSA9XG4gICAgICAgICAgKChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uID1cbiAgICAgICAgICAgIGNvbnRhaW5lckluZm8ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkgJiZcbiAgICAgICAgICAgIHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZGVmYXVsdFZpZXcpIHx8XG4gICAgICAgICAgd2luZG93KSxcbiAgICAgICAgY3VyRm9jdXNlZEVsZW0uZ2V0U2VsZWN0aW9uKVxuICAgICAgKSB7XG4gICAgICAgIGN1ckZvY3VzZWRFbGVtID0gY3VyRm9jdXNlZEVsZW0uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb250YWluZXJJbmZvLnRleHRDb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IE1hdGgubWluKHByaW9yU2VsZWN0aW9uUmFuZ2Uuc3RhcnQsIGxlbmd0aCk7XG4gICAgICAgIHByaW9yU2VsZWN0aW9uUmFuZ2UgPVxuICAgICAgICAgIHZvaWQgMCA9PT0gcHJpb3JTZWxlY3Rpb25SYW5nZS5lbmRcbiAgICAgICAgICAgID8gc3RhcnRcbiAgICAgICAgICAgIDogTWF0aC5taW4ocHJpb3JTZWxlY3Rpb25SYW5nZS5lbmQsIGxlbmd0aCk7XG4gICAgICAgICFjdXJGb2N1c2VkRWxlbS5leHRlbmQgJiZcbiAgICAgICAgICBzdGFydCA+IHByaW9yU2VsZWN0aW9uUmFuZ2UgJiZcbiAgICAgICAgICAoKGxlbmd0aCA9IHByaW9yU2VsZWN0aW9uUmFuZ2UpLFxuICAgICAgICAgIChwcmlvclNlbGVjdGlvblJhbmdlID0gc3RhcnQpLFxuICAgICAgICAgIChzdGFydCA9IGxlbmd0aCkpO1xuICAgICAgICBsZW5ndGggPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KGNvbnRhaW5lckluZm8sIHN0YXJ0KTtcbiAgICAgICAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQoXG4gICAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgICBwcmlvclNlbGVjdGlvblJhbmdlXG4gICAgICAgICk7XG4gICAgICAgIGxlbmd0aCAmJlxuICAgICAgICAgIGVuZE1hcmtlciAmJlxuICAgICAgICAgICgxICE9PSBjdXJGb2N1c2VkRWxlbS5yYW5nZUNvdW50IHx8XG4gICAgICAgICAgICBjdXJGb2N1c2VkRWxlbS5hbmNob3JOb2RlICE9PSBsZW5ndGgubm9kZSB8fFxuICAgICAgICAgICAgY3VyRm9jdXNlZEVsZW0uYW5jaG9yT2Zmc2V0ICE9PSBsZW5ndGgub2Zmc2V0IHx8XG4gICAgICAgICAgICBjdXJGb2N1c2VkRWxlbS5mb2N1c05vZGUgIT09IGVuZE1hcmtlci5ub2RlIHx8XG4gICAgICAgICAgICBjdXJGb2N1c2VkRWxlbS5mb2N1c09mZnNldCAhPT0gZW5kTWFya2VyLm9mZnNldCkgJiZcbiAgICAgICAgICAoKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24gPVxuICAgICAgICAgICAgcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5jcmVhdGVSYW5nZSgpKSxcbiAgICAgICAgICBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNldFN0YXJ0KGxlbmd0aC5ub2RlLCBsZW5ndGgub2Zmc2V0KSxcbiAgICAgICAgICBjdXJGb2N1c2VkRWxlbS5yZW1vdmVBbGxSYW5nZXMoKSxcbiAgICAgICAgICBzdGFydCA+IHByaW9yU2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgICAgID8gKGN1ckZvY3VzZWRFbGVtLmFkZFJhbmdlKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pLFxuICAgICAgICAgICAgICBjdXJGb2N1c2VkRWxlbS5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpKVxuICAgICAgICAgICAgOiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZXRFbmQoXG4gICAgICAgICAgICAgICAgZW5kTWFya2VyLm5vZGUsXG4gICAgICAgICAgICAgICAgZW5kTWFya2VyLm9mZnNldFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjdXJGb2N1c2VkRWxlbS5hZGRSYW5nZShwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSkpO1xuICAgICAgfVxuICAgIHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24gPSBbXTtcbiAgICBmb3IgKFxuICAgICAgY3VyRm9jdXNlZEVsZW0gPSBjb250YWluZXJJbmZvO1xuICAgICAgKGN1ckZvY3VzZWRFbGVtID0gY3VyRm9jdXNlZEVsZW0ucGFyZW50Tm9kZSk7XG5cbiAgICApXG4gICAgICAxID09PSBjdXJGb2N1c2VkRWxlbS5ub2RlVHlwZSAmJlxuICAgICAgICBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGN1ckZvY3VzZWRFbGVtLFxuICAgICAgICAgIGxlZnQ6IGN1ckZvY3VzZWRFbGVtLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBjdXJGb2N1c2VkRWxlbS5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGFpbmVySW5mby5mb2N1cyAmJiBjb250YWluZXJJbmZvLmZvY3VzKCk7XG4gICAgZm9yIChcbiAgICAgIGNvbnRhaW5lckluZm8gPSAwO1xuICAgICAgY29udGFpbmVySW5mbyA8IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24ubGVuZ3RoO1xuICAgICAgY29udGFpbmVySW5mbysrXG4gICAgKVxuICAgICAgKGN1ckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbltjb250YWluZXJJbmZvXSksXG4gICAgICAgIChjdXJGb2N1c2VkRWxlbS5lbGVtZW50LnNjcm9sbExlZnQgPSBjdXJGb2N1c2VkRWxlbS5sZWZ0KSxcbiAgICAgICAgKGN1ckZvY3VzZWRFbGVtLmVsZW1lbnQuc2Nyb2xsVG9wID0gY3VyRm9jdXNlZEVsZW0udG9wKTtcbiAgfVxufVxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9XG4gICAgY2FuVXNlRE9NICYmIFwiZG9jdW1lbnRNb2RlXCIgaW4gZG9jdW1lbnQgJiYgMTEgPj0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlLFxuICBhY3RpdmVFbGVtZW50ID0gbnVsbCxcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsLFxuICBsYXN0U2VsZWN0aW9uID0gbnVsbCxcbiAgbW91c2VEb3duID0gITE7XG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGRvYyA9XG4gICAgbmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudFxuICAgICAgOiA5ID09PSBuYXRpdmVFdmVudFRhcmdldC5ub2RlVHlwZVxuICAgICAgICA/IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgIDogbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgbW91c2VEb3duIHx8XG4gICAgbnVsbCA9PSBhY3RpdmVFbGVtZW50IHx8XG4gICAgYWN0aXZlRWxlbWVudCAhPT0gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHx8XG4gICAgKChkb2MgPSBhY3RpdmVFbGVtZW50KSxcbiAgICBcInNlbGVjdGlvblN0YXJ0XCIgaW4gZG9jICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhkb2MpXG4gICAgICA/IChkb2MgPSB7IHN0YXJ0OiBkb2Muc2VsZWN0aW9uU3RhcnQsIGVuZDogZG9jLnNlbGVjdGlvbkVuZCB9KVxuICAgICAgOiAoKGRvYyA9IChcbiAgICAgICAgICAoZG9jLm93bmVyRG9jdW1lbnQgJiYgZG9jLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8XG4gICAgICAgICAgd2luZG93XG4gICAgICAgICkuZ2V0U2VsZWN0aW9uKCkpLFxuICAgICAgICAoZG9jID0ge1xuICAgICAgICAgIGFuY2hvck5vZGU6IGRvYy5hbmNob3JOb2RlLFxuICAgICAgICAgIGFuY2hvck9mZnNldDogZG9jLmFuY2hvck9mZnNldCxcbiAgICAgICAgICBmb2N1c05vZGU6IGRvYy5mb2N1c05vZGUsXG4gICAgICAgICAgZm9jdXNPZmZzZXQ6IGRvYy5mb2N1c09mZnNldFxuICAgICAgICB9KSksXG4gICAgKGxhc3RTZWxlY3Rpb24gJiYgc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGRvYykpIHx8XG4gICAgICAoKGxhc3RTZWxlY3Rpb24gPSBkb2MpLFxuICAgICAgKGRvYyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhhY3RpdmVFbGVtZW50SW5zdCwgXCJvblNlbGVjdFwiKSksXG4gICAgICAwIDwgZG9jLmxlbmd0aCAmJlxuICAgICAgICAoKG5hdGl2ZUV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KFxuICAgICAgICAgIFwib25TZWxlY3RcIixcbiAgICAgICAgICBcInNlbGVjdFwiLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgKSksXG4gICAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7IGV2ZW50OiBuYXRpdmVFdmVudCwgbGlzdGVuZXJzOiBkb2MgfSksXG4gICAgICAgIChuYXRpdmVFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50KSkpKTtcbn1cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1tcIldlYmtpdFwiICsgc3R5bGVQcm9wXSA9IFwid2Via2l0XCIgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzW1wiTW96XCIgKyBzdHlsZVByb3BdID0gXCJtb3pcIiArIGV2ZW50TmFtZTtcbiAgcmV0dXJuIHByZWZpeGVzO1xufVxudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICAgIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcChcIkFuaW1hdGlvblwiLCBcIkFuaW1hdGlvbkVuZFwiKSxcbiAgICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoXCJBbmltYXRpb25cIiwgXCJBbmltYXRpb25JdGVyYXRpb25cIiksXG4gICAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoXCJBbmltYXRpb25cIiwgXCJBbmltYXRpb25TdGFydFwiKSxcbiAgICB0cmFuc2l0aW9ucnVuOiBtYWtlUHJlZml4TWFwKFwiVHJhbnNpdGlvblwiLCBcIlRyYW5zaXRpb25SdW5cIiksXG4gICAgdHJhbnNpdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKFwiVHJhbnNpdGlvblwiLCBcIlRyYW5zaXRpb25TdGFydFwiKSxcbiAgICB0cmFuc2l0aW9uY2FuY2VsOiBtYWtlUHJlZml4TWFwKFwiVHJhbnNpdGlvblwiLCBcIlRyYW5zaXRpb25DYW5jZWxcIiksXG4gICAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcChcIlRyYW5zaXRpb25cIiwgXCJUcmFuc2l0aW9uRW5kXCIpXG4gIH0sXG4gIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9LFxuICBzdHlsZSA9IHt9O1xuY2FuVXNlRE9NICYmXG4gICgoc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlKSxcbiAgXCJBbmltYXRpb25FdmVudFwiIGluIHdpbmRvdyB8fFxuICAgIChkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbixcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbixcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uKSxcbiAgXCJUcmFuc2l0aW9uRXZlbnRcIiBpbiB3aW5kb3cgfHxcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uKTtcbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSByZXR1cm4gZXZlbnROYW1lO1xuICB2YXIgcHJlZml4TWFwID0gdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSxcbiAgICBzdHlsZVByb3A7XG4gIGZvciAoc3R5bGVQcm9wIGluIHByZWZpeE1hcClcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKVxuICAgICAgcmV0dXJuIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdKTtcbiAgcmV0dXJuIGV2ZW50TmFtZTtcbn1cbnZhciBBTklNQVRJT05fRU5EID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoXCJhbmltYXRpb25lbmRcIiksXG4gIEFOSU1BVElPTl9JVEVSQVRJT04gPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcImFuaW1hdGlvbml0ZXJhdGlvblwiKSxcbiAgQU5JTUFUSU9OX1NUQVJUID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoXCJhbmltYXRpb25zdGFydFwiKSxcbiAgVFJBTlNJVElPTl9SVU4gPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcInRyYW5zaXRpb25ydW5cIiksXG4gIFRSQU5TSVRJT05fU1RBUlQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcInRyYW5zaXRpb25zdGFydFwiKSxcbiAgVFJBTlNJVElPTl9DQU5DRUwgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcInRyYW5zaXRpb25jYW5jZWxcIiksXG4gIFRSQU5TSVRJT05fRU5EID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoXCJ0cmFuc2l0aW9uZW5kXCIpLFxuICB0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcyA9IG5ldyBNYXAoKSxcbiAgc2ltcGxlRXZlbnRQbHVnaW5FdmVudHMgPVxuICAgIFwiYWJvcnQgYXV4Q2xpY2sgYmVmb3JlVG9nZ2xlIGNhbmNlbCBjYW5QbGF5IGNhblBsYXlUaHJvdWdoIGNsaWNrIGNsb3NlIGNvbnRleHRNZW51IGNvcHkgY3V0IGRyYWcgZHJhZ0VuZCBkcmFnRW50ZXIgZHJhZ0V4aXQgZHJhZ0xlYXZlIGRyYWdPdmVyIGRyYWdTdGFydCBkcm9wIGR1cmF0aW9uQ2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGdvdFBvaW50ZXJDYXB0dXJlIGlucHV0IGludmFsaWQga2V5RG93biBrZXlQcmVzcyBrZXlVcCBsb2FkIGxvYWRlZERhdGEgbG9hZGVkTWV0YWRhdGEgbG9hZFN0YXJ0IGxvc3RQb2ludGVyQ2FwdHVyZSBtb3VzZURvd24gbW91c2VNb3ZlIG1vdXNlT3V0IG1vdXNlT3ZlciBtb3VzZVVwIHBhc3RlIHBhdXNlIHBsYXkgcGxheWluZyBwb2ludGVyQ2FuY2VsIHBvaW50ZXJEb3duIHBvaW50ZXJNb3ZlIHBvaW50ZXJPdXQgcG9pbnRlck92ZXIgcG9pbnRlclVwIHByb2dyZXNzIHJhdGVDaGFuZ2UgcmVzZXQgcmVzaXplIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VibWl0IHN1c3BlbmQgdGltZVVwZGF0ZSB0b3VjaENhbmNlbCB0b3VjaEVuZCB0b3VjaFN0YXJ0IHZvbHVtZUNoYW5nZSBzY3JvbGwgc2Nyb2xsRW5kIHRvZ2dsZSB0b3VjaE1vdmUgd2FpdGluZyB3aGVlbFwiLnNwbGl0KFxuICAgICAgXCIgXCJcbiAgICApO1xuZnVuY3Rpb24gcmVnaXN0ZXJTaW1wbGVFdmVudChkb21FdmVudE5hbWUsIHJlYWN0TmFtZSkge1xuICB0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcy5zZXQoZG9tRXZlbnROYW1lLCByZWFjdE5hbWUpO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVhY3ROYW1lLCBbZG9tRXZlbnROYW1lXSk7XG59XG52YXIgY29uY3VycmVudFF1ZXVlcyA9IFtdLFxuICBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwLFxuICBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSAwO1xuZnVuY3Rpb24gZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpIHtcbiAgZm9yIChcbiAgICB2YXIgZW5kSW5kZXggPSBjb25jdXJyZW50UXVldWVzSW5kZXgsXG4gICAgICBpID0gKGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IGNvbmN1cnJlbnRRdWV1ZXNJbmRleCA9IDApO1xuICAgIGkgPCBlbmRJbmRleDtcblxuICApIHtcbiAgICB2YXIgZmliZXIgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgdmFyIHF1ZXVlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgdmFyIGxhbmUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgaWYgKG51bGwgIT09IHF1ZXVlICYmIG51bGwgIT09IHVwZGF0ZSkge1xuICAgICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuICAgICAgbnVsbCA9PT0gcGVuZGluZ1xuICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgOiAoKHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0KSwgKHBlbmRpbmcubmV4dCA9IHVwZGF0ZSkpO1xuICAgICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICB9XG4gICAgMCAhPT0gbGFuZSAmJiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgdXBkYXRlLCBsYW5lKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gZmliZXI7XG4gIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gcXVldWU7XG4gIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gdXBkYXRlO1xuICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IGxhbmU7XG4gIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyB8PSBsYW5lO1xuICBmaWJlci5sYW5lcyB8PSBsYW5lO1xuICBmaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgbnVsbCAhPT0gZmliZXIgJiYgKGZpYmVyLmxhbmVzIHw9IGxhbmUpO1xufVxuZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSkge1xuICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIG51bGwsIG51bGwsIGxhbmUpO1xuICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG59XG5mdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gIHNvdXJjZUZpYmVyLmxhbmVzIHw9IGxhbmU7XG4gIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG4gIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmxhbmVzIHw9IGxhbmUpO1xuICBmb3IgKHZhciBpc0hpZGRlbiA9ICExLCBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47IG51bGwgIT09IHBhcmVudDsgKVxuICAgIChwYXJlbnQuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgIChhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlKSxcbiAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gbGFuZSksXG4gICAgICAyMiA9PT0gcGFyZW50LnRhZyAmJlxuICAgICAgICAoKHNvdXJjZUZpYmVyID0gcGFyZW50LnN0YXRlTm9kZSksXG4gICAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyIHx8IHNvdXJjZUZpYmVyLl92aXNpYmlsaXR5ICYgMSB8fCAoaXNIaWRkZW4gPSAhMCkpLFxuICAgICAgKHNvdXJjZUZpYmVyID0gcGFyZW50KSxcbiAgICAgIChwYXJlbnQgPSBwYXJlbnQucmV0dXJuKTtcbiAgaXNIaWRkZW4gJiZcbiAgICBudWxsICE9PSB1cGRhdGUgJiZcbiAgICAzID09PSBzb3VyY2VGaWJlci50YWcgJiZcbiAgICAoKHBhcmVudCA9IHNvdXJjZUZpYmVyLnN0YXRlTm9kZSksXG4gICAgKGlzSGlkZGVuID0gMzEgLSBjbHozMihsYW5lKSksXG4gICAgKHBhcmVudCA9IHBhcmVudC5oaWRkZW5VcGRhdGVzKSxcbiAgICAoc291cmNlRmliZXIgPSBwYXJlbnRbaXNIaWRkZW5dKSxcbiAgICBudWxsID09PSBzb3VyY2VGaWJlclxuICAgICAgPyAocGFyZW50W2lzSGlkZGVuXSA9IFt1cGRhdGVdKVxuICAgICAgOiBzb3VyY2VGaWJlci5wdXNoKHVwZGF0ZSksXG4gICAgKHVwZGF0ZS5sYW5lID0gbGFuZSB8IDUzNjg3MDkxMikpO1xufVxuZnVuY3Rpb24gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihzb3VyY2VGaWJlcikge1xuICBpZiAoNTAgPCBuZXN0ZWRVcGRhdGVDb3VudClcbiAgICB0aHJvdyAoXG4gICAgICAoKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAocm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbCksXG4gICAgICBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE4NSkpKVxuICAgICk7XG4gIGZvciAodmFyIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgKHNvdXJjZUZpYmVyID0gcGFyZW50KSwgKHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybik7XG4gIHJldHVybiAzID09PSBzb3VyY2VGaWJlci50YWcgPyBzb3VyY2VGaWJlci5zdGF0ZU5vZGUgOiBudWxsO1xufVxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9LFxuICBDYXB0dXJlZFN0YWNrcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlKSB7XG4gIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWUpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBDYXB0dXJlZFN0YWNrcy5nZXQodmFsdWUpO1xuICAgIGlmICh2b2lkIDAgIT09IGV4aXN0aW5nKSByZXR1cm4gZXhpc3Rpbmc7XG4gICAgc291cmNlID0ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgICB9O1xuICAgIENhcHR1cmVkU3RhY2tzLnNldCh2YWx1ZSwgc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICB9O1xufVxudmFyIGZvcmtTdGFjayA9IFtdLFxuICBmb3JrU3RhY2tJbmRleCA9IDAsXG4gIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsLFxuICB0cmVlRm9ya0NvdW50ID0gMCxcbiAgaWRTdGFjayA9IFtdLFxuICBpZFN0YWNrSW5kZXggPSAwLFxuICB0cmVlQ29udGV4dFByb3ZpZGVyID0gbnVsbCxcbiAgdHJlZUNvbnRleHRJZCA9IDEsXG4gIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBcIlwiO1xuZnVuY3Rpb24gcHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuKSB7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrQ291bnQ7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrUHJvdmlkZXI7XG4gIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdHJlZUZvcmtDb3VudCA9IHRvdGFsQ2hpbGRyZW47XG59XG5mdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQ7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyO1xuICB0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBiYXNlSWRXaXRoTGVhZGluZ0JpdCA9IHRyZWVDb250ZXh0SWQ7XG4gIHdvcmtJblByb2dyZXNzID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgdmFyIGJhc2VMZW5ndGggPSAzMiAtIGNsejMyKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gIGJhc2VJZFdpdGhMZWFkaW5nQml0ICY9IH4oMSA8PCBiYXNlTGVuZ3RoKTtcbiAgaW5kZXggKz0gMTtcbiAgdmFyIGxlbmd0aCA9IDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoO1xuICBpZiAoMzAgPCBsZW5ndGgpIHtcbiAgICB2YXIgbnVtYmVyT2ZPdmVyZmxvd0JpdHMgPSBiYXNlTGVuZ3RoIC0gKGJhc2VMZW5ndGggJSA1KTtcbiAgICBsZW5ndGggPSAoXG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmXG4gICAgICAoKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMSlcbiAgICApLnRvU3RyaW5nKDMyKTtcbiAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCA+Pj0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgYmFzZUxlbmd0aCAtPSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICB0cmVlQ29udGV4dElkID1cbiAgICAgICgxIDw8ICgzMiAtIGNsejMyKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aCkpIHxcbiAgICAgIChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8XG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gbGVuZ3RoICsgd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZVxuICAgICh0cmVlQ29udGV4dElkID1cbiAgICAgICgxIDw8IGxlbmd0aCkgfCAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfCBiYXNlSWRXaXRoTGVhZGluZ0JpdCksXG4gICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IHdvcmtJblByb2dyZXNzKTtcbn1cbmZ1bmN0aW9uIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpIHtcbiAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MucmV0dXJuICYmXG4gICAgKHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgMSksIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIDEsIDApKTtcbn1cbmZ1bmN0aW9uIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIGZvciAoOyB3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUZvcmtQcm92aWRlcjsgKVxuICAgICh0cmVlRm9ya1Byb3ZpZGVyID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgIChmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAodHJlZUZvcmtDb3VudCA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XSksXG4gICAgICAoZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGwpO1xuICBmb3IgKDsgd29ya0luUHJvZ3Jlc3MgPT09IHRyZWVDb250ZXh0UHJvdmlkZXI7IClcbiAgICAodHJlZUNvbnRleHRQcm92aWRlciA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgKHRyZWVDb250ZXh0SWQgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCk7XG59XG52YXIgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsLFxuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCxcbiAgaXNIeWRyYXRpbmcgPSAhMSxcbiAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbCxcbiAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExLFxuICBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiA9IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNTE5KSk7XG5mdW5jdGlvbiB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpIHtcbiAgdmFyIGVycm9yID0gRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MTgsIFwiXCIpKTtcbiAgcXVldWVIeWRyYXRpb25FcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgZmliZXIpKTtcbiAgdGhyb3cgSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb247XG59XG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyKSB7XG4gIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZSxcbiAgICB0eXBlID0gZmliZXIudHlwZSxcbiAgICBwcm9wcyA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlW2ludGVybmFsSW5zdGFuY2VLZXldID0gZmliZXI7XG4gIGluc3RhbmNlW2ludGVybmFsUHJvcHNLZXldID0gcHJvcHM7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJkaWFsb2dcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJjYW5jZWxcIiwgaW5zdGFuY2UpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImNsb3NlXCIsIGluc3RhbmNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpZnJhbWVcIjpcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgY2FzZSBcImVtYmVkXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidmlkZW9cIjpcbiAgICBjYXNlIFwiYXVkaW9cIjpcbiAgICAgIGZvciAodHlwZSA9IDA7IHR5cGUgPCBtZWRpYUV2ZW50VHlwZXMubGVuZ3RoOyB0eXBlKyspXG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW3R5cGVdLCBpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiZXJyb3JcIiwgaW5zdGFuY2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImltZ1wiOlxuICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiZXJyb3JcIiwgaW5zdGFuY2UpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgaW5zdGFuY2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRldGFpbHNcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJ0b2dnbGVcIiwgaW5zdGFuY2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlucHV0XCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBpbnN0YW5jZSk7XG4gICAgICBpbml0SW5wdXQoXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBwcm9wcy52YWx1ZSxcbiAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICBwcm9wcy5jaGVja2VkLFxuICAgICAgICBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICAgICAgcHJvcHMudHlwZSxcbiAgICAgICAgcHJvcHMubmFtZSxcbiAgICAgICAgITBcbiAgICAgICk7XG4gICAgICB0cmFjayhpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGluc3RhbmNlKSxcbiAgICAgICAgaW5pdFRleHRhcmVhKGluc3RhbmNlLCBwcm9wcy52YWx1ZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCBwcm9wcy5jaGlsZHJlbiksXG4gICAgICAgIHRyYWNrKGluc3RhbmNlKTtcbiAgfVxuICB0eXBlID0gcHJvcHMuY2hpbGRyZW47XG4gIChcInN0cmluZ1wiICE9PSB0eXBlb2YgdHlwZSAmJlxuICAgIFwibnVtYmVyXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgXCJiaWdpbnRcIiAhPT0gdHlwZW9mIHR5cGUpIHx8XG4gIGluc3RhbmNlLnRleHRDb250ZW50ID09PSBcIlwiICsgdHlwZSB8fFxuICAhMCA9PT0gcHJvcHMuc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIHx8XG4gIGNoZWNrRm9yVW5tYXRjaGVkVGV4dChpbnN0YW5jZS50ZXh0Q29udGVudCwgdHlwZSlcbiAgICA/IChudWxsICE9IHByb3BzLnBvcG92ZXIgJiZcbiAgICAgICAgKGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJiZWZvcmV0b2dnbGVcIiwgaW5zdGFuY2UpLFxuICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwidG9nZ2xlXCIsIGluc3RhbmNlKSksXG4gICAgICBudWxsICE9IHByb3BzLm9uU2Nyb2xsICYmIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJzY3JvbGxcIiwgaW5zdGFuY2UpLFxuICAgICAgbnVsbCAhPSBwcm9wcy5vblNjcm9sbEVuZCAmJlxuICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwic2Nyb2xsZW5kXCIsIGluc3RhbmNlKSxcbiAgICAgIG51bGwgIT0gcHJvcHMub25DbGljayAmJiAoaW5zdGFuY2Uub25jbGljayA9IG5vb3AkMSksXG4gICAgICAoaW5zdGFuY2UgPSAhMCkpXG4gICAgOiAoaW5zdGFuY2UgPSAhMSk7XG4gIGluc3RhbmNlIHx8IHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG59XG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIGZvciAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47IGh5ZHJhdGlvblBhcmVudEZpYmVyOyApXG4gICAgc3dpdGNoIChoeWRyYXRpb25QYXJlbnRGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgMjc6XG4gICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyLnJldHVybjtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSByZXR1cm4gITE7XG4gIGlmICghaXNIeWRyYXRpbmcpIHJldHVybiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSwgKGlzSHlkcmF0aW5nID0gITApLCAhMTtcbiAgdmFyIHNob3VsZENsZWFyID0gITEsXG4gICAgSlNDb21waWxlcl90ZW1wO1xuICBpZiAoKEpTQ29tcGlsZXJfdGVtcCA9IDMgIT09IGZpYmVyLnRhZyAmJiAyNyAhPT0gZmliZXIudGFnKSkge1xuICAgIGlmICgoSlNDb21waWxlcl90ZW1wID0gNSA9PT0gZmliZXIudGFnKSlcbiAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSBmaWJlci50eXBlKSxcbiAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgIShcImZvcm1cIiAhPT0gSlNDb21waWxlcl90ZW1wICYmIFwiYnV0dG9uXCIgIT09IEpTQ29tcGlsZXJfdGVtcCkgfHxcbiAgICAgICAgICBzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSk7XG4gICAgSlNDb21waWxlcl90ZW1wID0gIUpTQ29tcGlsZXJfdGVtcDtcbiAgfVxuICBKU0NvbXBpbGVyX3RlbXAgJiYgKHNob3VsZENsZWFyID0gITApO1xuICBzaG91bGRDbGVhciAmJiBuZXh0SHlkcmF0YWJsZUluc3RhbmNlICYmIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICBmaWJlciA9IG51bGwgIT09IGZpYmVyID8gZmliZXIuZGVoeWRyYXRlZCA6IG51bGw7XG4gICAgaWYgKCFmaWJlcikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMTcpKTtcbiAgICBhOiB7XG4gICAgICBmaWJlciA9IGZpYmVyLm5leHRTaWJsaW5nO1xuICAgICAgZm9yIChzaG91bGRDbGVhciA9IDA7IGZpYmVyOyApIHtcbiAgICAgICAgaWYgKDggPT09IGZpYmVyLm5vZGVUeXBlKVxuICAgICAgICAgIGlmICgoKEpTQ29tcGlsZXJfdGVtcCA9IGZpYmVyLmRhdGEpLCBcIi8kXCIgPT09IEpTQ29tcGlsZXJfdGVtcCkpIHtcbiAgICAgICAgICAgIGlmICgwID09PSBzaG91bGRDbGVhcikge1xuICAgICAgICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoZmliZXIubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hvdWxkQ2xlYXItLTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChcIiRcIiAhPT0gSlNDb21waWxlcl90ZW1wICYmXG4gICAgICAgICAgICAgIFwiJCFcIiAhPT0gSlNDb21waWxlcl90ZW1wICYmXG4gICAgICAgICAgICAgIFwiJD9cIiAhPT0gSlNDb21waWxlcl90ZW1wKSB8fFxuICAgICAgICAgICAgICBzaG91bGRDbGVhcisrO1xuICAgICAgICBmaWJlciA9IGZpYmVyLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICB9IGVsc2VcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXJcbiAgICAgID8gZ2V0TmV4dEh5ZHJhdGFibGUoZmliZXIuc3RhdGVOb2RlLm5leHRTaWJsaW5nKVxuICAgICAgOiBudWxsO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBpc0h5ZHJhdGluZyA9ICExO1xufVxuZnVuY3Rpb24gcXVldWVIeWRyYXRpb25FcnJvcihlcnJvcikge1xuICBudWxsID09PSBoeWRyYXRpb25FcnJvcnNcbiAgICA/IChoeWRyYXRpb25FcnJvcnMgPSBbZXJyb3JdKVxuICAgIDogaHlkcmF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xufVxudmFyIFN1c3BlbnNlRXhjZXB0aW9uID0gRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NjApKSxcbiAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uID0gRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NzQpKSxcbiAgbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlID0geyB0aGVuOiBmdW5jdGlvbiAoKSB7fSB9O1xuZnVuY3Rpb24gaXNUaGVuYWJsZVJlc29sdmVkKHRoZW5hYmxlKSB7XG4gIHRoZW5hYmxlID0gdGhlbmFibGUuc3RhdHVzO1xuICByZXR1cm4gXCJmdWxmaWxsZWRcIiA9PT0gdGhlbmFibGUgfHwgXCJyZWplY3RlZFwiID09PSB0aGVuYWJsZTtcbn1cbmZ1bmN0aW9uIG5vb3AkMygpIHt9XG5mdW5jdGlvbiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpIHtcbiAgaW5kZXggPSB0aGVuYWJsZVN0YXRlW2luZGV4XTtcbiAgdm9pZCAwID09PSBpbmRleFxuICAgID8gdGhlbmFibGVTdGF0ZS5wdXNoKHRoZW5hYmxlKVxuICAgIDogaW5kZXggIT09IHRoZW5hYmxlICYmICh0aGVuYWJsZS50aGVuKG5vb3AkMywgbm9vcCQzKSwgKHRoZW5hYmxlID0gaW5kZXgpKTtcbiAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICB0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUucmVhc29uO1xuICAgICAgaWYgKHRoZW5hYmxlU3RhdGUgPT09IFN1c3BlbnNlRXhjZXB0aW9uKVxuICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ4MykpO1xuICAgICAgdGhyb3cgdGhlbmFibGVTdGF0ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMpIHRoZW5hYmxlLnRoZW4obm9vcCQzLCBub29wJDMpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRoZW5hYmxlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgIGlmIChudWxsICE9PSB0aGVuYWJsZVN0YXRlICYmIDEwMCA8IHRoZW5hYmxlU3RhdGUuc2hlbGxTdXNwZW5kQ291bnRlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ4MikpO1xuICAgICAgICB0aGVuYWJsZVN0YXRlID0gdGhlbmFibGU7XG4gICAgICAgIHRoZW5hYmxlU3RhdGUuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICAgIHRoZW5hYmxlU3RhdGUudGhlbihcbiAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICB0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUucmVhc29uO1xuICAgICAgICAgIGlmICh0aGVuYWJsZVN0YXRlID09PSBTdXNwZW5zZUV4Y2VwdGlvbilcbiAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDgzKSk7XG4gICAgICAgICAgdGhyb3cgdGhlbmFibGVTdGF0ZTtcbiAgICAgIH1cbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgfVxufVxudmFyIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbmZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkVGhlbmFibGUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDU5KSk7XG4gIHZhciB0aGVuYWJsZSA9IHN1c3BlbmRlZFRoZW5hYmxlO1xuICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gIHJldHVybiB0aGVuYWJsZTtcbn1cbnZhciB0aGVuYWJsZVN0YXRlJDEgPSBudWxsLFxuICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbmZ1bmN0aW9uIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyJDE7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgKz0gMTtcbiAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSQxICYmICh0aGVuYWJsZVN0YXRlJDEgPSBbXSk7XG4gIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlJDEsIHRoZW5hYmxlLCBpbmRleCk7XG59XG5mdW5jdGlvbiBjb2VyY2VSZWYod29ya0luUHJvZ3Jlc3MsIGVsZW1lbnQpIHtcbiAgZWxlbWVudCA9IGVsZW1lbnQucHJvcHMucmVmO1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSB2b2lkIDAgIT09IGVsZW1lbnQgPyBlbGVtZW50IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFKVxuICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNTI1KSk7XG4gIHJldHVybkZpYmVyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKTtcbiAgdGhyb3cgRXJyb3IoXG4gICAgZm9ybWF0UHJvZEVycm9yTWVzc2FnZShcbiAgICAgIDMxLFxuICAgICAgXCJbb2JqZWN0IE9iamVjdF1cIiA9PT0gcmV0dXJuRmliZXJcbiAgICAgICAgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgIDogcmV0dXJuRmliZXJcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiByZXNvbHZlTGF6eShsYXp5VHlwZSkge1xuICB2YXIgaW5pdCA9IGxhenlUeXBlLl9pbml0O1xuICByZXR1cm4gaW5pdChsYXp5VHlwZS5fcGF5bG9hZCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuICAgICAgbnVsbCA9PT0gZGVsZXRpb25zXG4gICAgICAgID8gKChyZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY2hpbGRUb0RlbGV0ZV0pLCAocmV0dXJuRmliZXIuZmxhZ3MgfD0gMTYpKVxuICAgICAgICA6IGRlbGV0aW9ucy5wdXNoKGNoaWxkVG9EZWxldGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHJldHVybiBudWxsO1xuICAgIGZvciAoOyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKVxuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4oY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICBmb3IgKHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpOyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKVxuICAgICAgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQua2V5XG4gICAgICAgID8gZXhpc3RpbmdDaGlsZHJlbi5zZXQoY3VycmVudEZpcnN0Q2hpbGQua2V5LCBjdXJyZW50Rmlyc3RDaGlsZClcbiAgICAgICAgOiBleGlzdGluZ0NoaWxkcmVuLnNldChjdXJyZW50Rmlyc3RDaGlsZC5pbmRleCwgY3VycmVudEZpcnN0Q2hpbGQpLFxuICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgfVxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzKSB7XG4gICAgZmliZXIgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICBmaWJlci5pbmRleCA9IDA7XG4gICAgZmliZXIuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cylcbiAgICAgIHJldHVybiAobmV3RmliZXIuZmxhZ3MgfD0gMTA0ODU3NiksIGxhc3RQbGFjZWRJbmRleDtcbiAgICBuZXdJbmRleCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcbiAgICBpZiAobnVsbCAhPT0gbmV3SW5kZXgpXG4gICAgICByZXR1cm4gKFxuICAgICAgICAobmV3SW5kZXggPSBuZXdJbmRleC5pbmRleCksXG4gICAgICAgIG5ld0luZGV4IDwgbGFzdFBsYWNlZEluZGV4XG4gICAgICAgICAgPyAoKG5ld0ZpYmVyLmZsYWdzIHw9IDMzNTU0NDM0KSwgbGFzdFBsYWNlZEluZGV4KVxuICAgICAgICAgIDogbmV3SW5kZXhcbiAgICAgICk7XG4gICAgbmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQ7XG4gICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgfVxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgbnVsbCA9PT0gbmV3RmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAobmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQpO1xuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG4gICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgNiAhPT0gY3VycmVudC50YWcpXG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKSksXG4gICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgY3VycmVudFxuICAgICAgKTtcbiAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKVxuICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgbGFuZXMsXG4gICAgICAgIGVsZW1lbnQua2V5XG4gICAgICApO1xuICAgIGlmIChcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgIChjdXJyZW50LmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fFxuICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVsZW1lbnRUeXBlICYmXG4gICAgICAgICAgbnVsbCAhPT0gZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICBlbGVtZW50VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgcmVzb2x2ZUxhenkoZWxlbWVudFR5cGUpID09PSBjdXJyZW50LnR5cGUpKVxuICAgIClcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcykpLFxuICAgICAgICBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCksXG4gICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgY3VycmVudFxuICAgICAgKTtcbiAgICBjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgZWxlbWVudC50eXBlLFxuICAgICAgZWxlbWVudC5rZXksXG4gICAgICBlbGVtZW50LnByb3BzLFxuICAgICAgbnVsbCxcbiAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICBsYW5lc1xuICAgICk7XG4gICAgY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgaWYgKFxuICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgNCAhPT0gY3VycmVudC50YWcgfHxcbiAgICAgIGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8XG4gICAgICBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gICAgKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcykpLFxuICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgIGN1cnJlbnRcbiAgICAgICk7XG4gICAgY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGxhbmVzLCBrZXkpIHtcbiAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCA3ICE9PSBjdXJyZW50LnRhZylcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgZnJhZ21lbnQsXG4gICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICBrZXlcbiAgICAgICAgKSksXG4gICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgY3VycmVudFxuICAgICAgKTtcbiAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQpO1xuICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIGlmIChcbiAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgIClcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChuZXdDaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoXG4gICAgICAgICAgXCJcIiArIG5ld0NoaWxkLFxuICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKSksXG4gICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgIG5ld0NoaWxkXG4gICAgICApO1xuICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgICAgICAgICAgbmV3Q2hpbGQudHlwZSxcbiAgICAgICAgICAgICAgbmV3Q2hpbGQua2V5LFxuICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcyxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobmV3Q2hpbGQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwoXG4gICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAobmV3Q2hpbGQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgbmV3Q2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB2YXIgaW5pdCA9IG5ld0NoaWxkLl9pbml0O1xuICAgICAgICAgIG5ld0NoaWxkID0gaW5pdChuZXdDaGlsZC5fcGF5bG9hZCk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAobmV3Q2hpbGQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICkpLFxuICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgbmV3Q2hpbGRcbiAgICAgICAgKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZC50aGVuKVxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSwgbGFuZXMpO1xuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKTtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgdmFyIGtleSA9IG51bGwgIT09IG9sZEZpYmVyID8gb2xkRmliZXIua2V5IDogbnVsbDtcbiAgICBpZiAoXG4gICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICApXG4gICAgICByZXR1cm4gbnVsbCAhPT0ga2V5XG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgXCJcIiArIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgID8gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgID8gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGtleSA9IG5ld0NoaWxkLl9pbml0KSxcbiAgICAgICAgICAgIChuZXdDaGlsZCA9IGtleShuZXdDaGlsZC5fcGF5bG9hZCkpLFxuICAgICAgICAgICAgdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSlcbiAgICAgICAgcmV0dXJuIG51bGwgIT09IGtleVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgIHJldHVybiB1cGRhdGVTbG90KFxuICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgIHJldHVybiB1cGRhdGVTbG90KFxuICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoXG4gICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICByZXR1cm5GaWJlcixcbiAgICBuZXdJZHgsXG4gICAgbmV3Q2hpbGQsXG4gICAgbGFuZXNcbiAgKSB7XG4gICAgaWYgKFxuICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgZXhpc3RpbmdDaGlsZHJlbiwgXCJcIiArIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICk7XG4gICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPVxuICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmdldChcbiAgICAgICAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgKSB8fCBudWxsKSxcbiAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGV4aXN0aW5nQ2hpbGRyZW4sIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9XG4gICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICApIHx8IG51bGwpLFxuICAgICAgICAgICAgdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICBuZXdDaGlsZCA9IGluaXQobmV3Q2hpbGQuX3BheWxvYWQpO1xuICAgICAgICAgIHJldHVybiB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsKSxcbiAgICAgICAgICB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgZXhpc3RpbmdDaGlsZHJlbiwgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKVxuICAgICAgICApO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgIHJldHVybiB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgIHJldHVybiB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoXG4gICAgcmV0dXJuRmliZXIsXG4gICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgbmV3Q2hpbGRyZW4sXG4gICAgbGFuZXNcbiAgKSB7XG4gICAgZm9yIChcbiAgICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbCxcbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgIG5ld0lkeCA9IChjdXJyZW50Rmlyc3RDaGlsZCA9IDApLFxuICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgbmV3SWR4KytcbiAgICApIHtcbiAgICAgIG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4XG4gICAgICAgID8gKChuZXh0T2xkRmliZXIgPSBvbGRGaWJlciksIChvbGRGaWJlciA9IG51bGwpKVxuICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgbGFuZXNcbiAgICAgICk7XG4gICAgICBpZiAobnVsbCA9PT0gbmV3RmliZXIpIHtcbiAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyKVxuICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKSxcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpLFxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkXG4gICAgICApO1xuICAgIGlmIChudWxsID09PSBvbGRGaWJlcikge1xuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspXG4gICAgICAgIChvbGRGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcykpLFxuICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAoKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gb2xkRmliZXIpXG4gICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gb2xkRmliZXIpKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cbiAgICBmb3IgKFxuICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7XG4gICAgICBuZXdJZHgrK1xuICAgIClcbiAgICAgIChuZXh0T2xkRmliZXIgPSB1cGRhdGVGcm9tTWFwKFxuICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG5ld0lkeCxcbiAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgbGFuZXNcbiAgICAgICkpLFxuICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIgJiZcbiAgICAgICAgICAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgb2xkRmliZXIuZGVsZXRlKFxuICAgICAgICAgICAgICBudWxsID09PSBuZXh0T2xkRmliZXIua2V5ID8gbmV3SWR4IDogbmV4dE9sZEZpYmVyLmtleVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICApKSxcbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV4dE9sZEZpYmVyKVxuICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV4dE9sZEZpYmVyKSxcbiAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG5leHRPbGRGaWJlcikpO1xuICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgIG9sZEZpYmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoXG4gICAgcmV0dXJuRmliZXIsXG4gICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgbmV3Q2hpbGRyZW4sXG4gICAgbGFuZXNcbiAgKSB7XG4gICAgaWYgKG51bGwgPT0gbmV3Q2hpbGRyZW4pIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUxKSk7XG4gICAgZm9yIChcbiAgICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbCxcbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgIG5ld0lkeCA9IChjdXJyZW50Rmlyc3RDaGlsZCA9IDApLFxuICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsLFxuICAgICAgICBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiYgIXN0ZXAuZG9uZTtcbiAgICAgIG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpXG4gICAgKSB7XG4gICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICA/ICgobmV4dE9sZEZpYmVyID0gb2xkRmliZXIpLCAob2xkRmliZXIgPSBudWxsKSlcbiAgICAgICAgOiAobmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZyk7XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuICAgICAgaWYgKG51bGwgPT09IG5ld0ZpYmVyKSB7XG4gICAgICAgIG51bGwgPT09IG9sZEZpYmVyICYmIChvbGRGaWJlciA9IG5leHRPbGRGaWJlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICBvbGRGaWJlciAmJlxuICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChuZXdGaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0lkeCk7XG4gICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcilcbiAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXIpO1xuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuICAgIGlmIChzdGVwLmRvbmUpXG4gICAgICByZXR1cm4gKFxuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCksXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGRcbiAgICAgICk7XG4gICAgaWYgKG51bGwgPT09IG9sZEZpYmVyKSB7XG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpXG4gICAgICAgIChzdGVwID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKSksXG4gICAgICAgICAgbnVsbCAhPT0gc3RlcCAmJlxuICAgICAgICAgICAgKChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoc3RlcCwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0lkeCkpLFxuICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gc3RlcClcbiAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gc3RlcCksXG4gICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IHN0ZXApKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cbiAgICBmb3IgKFxuICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAhc3RlcC5kb25lO1xuICAgICAgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KClcbiAgICApXG4gICAgICAoc3RlcCA9IHVwZGF0ZUZyb21NYXAob2xkRmliZXIsIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGxhbmVzKSksXG4gICAgICAgIG51bGwgIT09IHN0ZXAgJiZcbiAgICAgICAgICAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gc3RlcC5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIG9sZEZpYmVyLmRlbGV0ZShudWxsID09PSBzdGVwLmtleSA/IG5ld0lkeCA6IHN0ZXAua2V5KSxcbiAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKHN0ZXAsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdJZHgpKSxcbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gc3RlcClcbiAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IHN0ZXApLFxuICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gc3RlcCkpO1xuICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgIG9sZEZpYmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICByZXR1cm5GaWJlcixcbiAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICBuZXdDaGlsZCxcbiAgICBsYW5lc1xuICApIHtcbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgIG51bGwgIT09IG5ld0NoaWxkICYmXG4gICAgICBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmXG4gICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgJiZcbiAgICAgIChuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuKTtcbiAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIG51bGwgIT09IG5ld0NoaWxkKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSA9IG5ld0NoaWxkLmtleTsgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7ICkge1xuICAgICAgICAgICAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBuZXdDaGlsZC50eXBlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICg3ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBsYW5lcyA9IHVzZUZpYmVyKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5lbGVtZW50VHlwZSA9PT0ga2V5IHx8XG4gICAgICAgICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGtleSAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBrZXkgJiZcbiAgICAgICAgICAgICAgICAgICAga2V5LiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUxhenkoa2V5KSA9PT0gY3VycmVudEZpcnN0Q2hpbGQudHlwZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEVcbiAgICAgICAgICAgICAgPyAoKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbGFuZXMpKVxuICAgICAgICAgICAgICA6ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZC50eXBlLFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQua2V5LFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQucHJvcHMsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgZm9yIChrZXkgPSBuZXdDaGlsZC5rZXk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkLmtleSA9PT0ga2V5KVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIDQgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZyAmJlxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLmNvbnRhaW5lckluZm8gJiZcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT1cbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQuaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFuZXMgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmV0dXJuRmliZXIpO1xuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGtleSA9IG5ld0NoaWxkLl9pbml0KSxcbiAgICAgICAgICAgIChuZXdDaGlsZCA9IGtleShuZXdDaGlsZC5fcGF5bG9hZCkpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpKVxuICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIGtleSA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2Yga2V5KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1MCkpO1xuICAgICAgICBuZXdDaGlsZCA9IGtleS5jYWxsKG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZC50aGVuKVxuICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgPyAoKG5ld0NoaWxkID0gXCJcIiArIG5ld0NoaWxkKSxcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQgJiYgNiA9PT0gY3VycmVudEZpcnN0Q2hpbGQudGFnXG4gICAgICAgICAgPyAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpLFxuICAgICAgICAgICAgKGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkKSksXG4gICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbGFuZXMpKVxuICAgICAgICAgIDogKGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21UZXh0KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcykpLFxuICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSksXG4gICAgICAgIHBsYWNlU2luZ2xlQ2hpbGQocmV0dXJuRmliZXIpKVxuICAgICAgOiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICB0cnkge1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgICB2YXIgZmlyc3RDaGlsZEZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgIG5ld0NoaWxkLFxuICAgICAgICBsYW5lc1xuICAgICAgKTtcbiAgICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7XG4gICAgICByZXR1cm4gZmlyc3RDaGlsZEZpYmVyO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIGlmICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbikgdGhyb3cgeDtcbiAgICAgIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKDI5LCB4LCBudWxsLCByZXR1cm5GaWJlci5tb2RlKTtcbiAgICAgIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gICAgICBmaWJlci5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBmaWJlcjtcbiAgICB9IGZpbmFsbHkge1xuICAgIH1cbiAgfTtcbn1cbnZhciByZWNvbmNpbGVDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcighMCksXG4gIG1vdW50Q2hpbGRGaWJlcnMgPSBjcmVhdGVDaGlsZFJlY29uY2lsZXIoITEpLFxuICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCk7XG5mdW5jdGlvbiBwdXNoSGlkZGVuQ29udGV4dChmaWJlciwgY29udGV4dCkge1xuICBmaWJlciA9IGVudGFuZ2xlZFJlbmRlckxhbmVzO1xuICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xuICBwdXNoKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGNvbnRleHQpO1xuICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGZpYmVyIHwgY29udGV4dC5iYXNlTGFuZXM7XG59XG5mdW5jdGlvbiByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKCkge1xuICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZW50YW5nbGVkUmVuZGVyTGFuZXMpO1xuICBwdXNoKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudCk7XG59XG5mdW5jdGlvbiBwb3BIaWRkZW5Db250ZXh0KCkge1xuICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvci5jdXJyZW50O1xuICBwb3AoY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvcik7XG4gIHBvcChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IpO1xufVxudmFyIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICBzaGVsbEJvdW5kYXJ5ID0gbnVsbDtcbmZ1bmN0aW9uIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcihoYW5kbGVyKSB7XG4gIHZhciBjdXJyZW50ID0gaGFuZGxlci5hbHRlcm5hdGU7XG4gIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICYgMSk7XG4gIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGhhbmRsZXIpO1xuICBudWxsID09PSBzaGVsbEJvdW5kYXJ5ICYmXG4gICAgKG51bGwgPT09IGN1cnJlbnQgfHwgbnVsbCAhPT0gY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50XG4gICAgICA/IChzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcilcbiAgICAgIDogbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmIChzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcikpO1xufVxuZnVuY3Rpb24gcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcihmaWJlcikge1xuICBpZiAoMjIgPT09IGZpYmVyLnRhZykge1xuICAgIGlmIChcbiAgICAgIChwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBmaWJlciksXG4gICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5KVxuICAgICkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAoc2hlbGxCb3VuZGFyeSA9IGZpYmVyKTtcbiAgICB9XG4gIH0gZWxzZSByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2soZmliZXIpO1xufVxuZnVuY3Rpb24gcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKCkge1xuICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xufVxuZnVuY3Rpb24gcG9wU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gIHBvcChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvcik7XG4gIHNoZWxsQm91bmRhcnkgPT09IGZpYmVyICYmIChzaGVsbEJvdW5kYXJ5ID0gbnVsbCk7XG4gIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yKTtcbn1cbnZhciBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApO1xuZnVuY3Rpb24gZmluZEZpcnN0U3VzcGVuZGVkKHJvdykge1xuICBmb3IgKHZhciBub2RlID0gcm93OyBudWxsICE9PSBub2RlOyApIHtcbiAgICBpZiAoMTMgPT09IG5vZGUudGFnKSB7XG4gICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHN0YXRlICYmXG4gICAgICAgICgoc3RhdGUgPSBzdGF0ZS5kZWh5ZHJhdGVkKSxcbiAgICAgICAgbnVsbCA9PT0gc3RhdGUgfHwgXCIkP1wiID09PSBzdGF0ZS5kYXRhIHx8IFwiJCFcIiA9PT0gc3RhdGUuZGF0YSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmICgxOSA9PT0gbm9kZS50YWcgJiYgdm9pZCAwICE9PSBub2RlLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXIpIHtcbiAgICAgIGlmICgwICE9PSAobm9kZS5mbGFncyAmIDEyOCkpIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobnVsbCAhPT0gbm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IHJvdykgYnJlYWs7XG4gICAgZm9yICg7IG51bGwgPT09IG5vZGUuc2libGluZzsgKSB7XG4gICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IHJvdykgcmV0dXJuIG51bGw7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxudmFyIEFib3J0Q29udHJvbGxlckxvY2FsID1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgQWJvcnRDb250cm9sbGVyXG4gICAgICA/IEFib3J0Q29udHJvbGxlclxuICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdLFxuICAgICAgICAgICAgc2lnbmFsID0gKHRoaXMuc2lnbmFsID0ge1xuICAgICAgICAgICAgICBhYm9ydGVkOiAhMSxcbiAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2lnbmFsLmFib3J0ZWQgPSAhMDtcbiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gIHNjaGVkdWxlQ2FsbGJhY2skMiA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxcbiAgQ2FjaGVDb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgQ29uc3VtZXI6IG51bGwsXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgX2N1cnJlbnRWYWx1ZTogbnVsbCxcbiAgICBfY3VycmVudFZhbHVlMjogbnVsbCxcbiAgICBfdGhyZWFkQ291bnQ6IDBcbiAgfTtcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICByZXR1cm4ge1xuICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXJMb2NhbCgpLFxuICAgIGRhdGE6IG5ldyBNYXAoKSxcbiAgICByZWZDb3VudDogMFxuICB9O1xufVxuZnVuY3Rpb24gcmVsZWFzZUNhY2hlKGNhY2hlKSB7XG4gIGNhY2hlLnJlZkNvdW50LS07XG4gIDAgPT09IGNhY2hlLnJlZkNvdW50ICYmXG4gICAgc2NoZWR1bGVDYWxsYmFjayQyKE5vcm1hbFByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWNoZS5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSk7XG59XG52YXIgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGwsXG4gIGN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQgPSAwLFxuICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IDAsXG4gIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IG51bGw7XG5mdW5jdGlvbiBlbnRhbmdsZUFzeW5jQWN0aW9uKHRyYW5zaXRpb24sIHRoZW5hYmxlKSB7XG4gIGlmIChudWxsID09PSBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzKSB7XG4gICAgdmFyIGVudGFuZ2xlZExpc3RlbmVycyA9IChjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gW10pO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQgPSAwO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gcmVxdWVzdFRyYW5zaXRpb25MYW5lKCk7XG4gICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0ge1xuICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBlbnRhbmdsZWRMaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQrKztcbiAgdGhlbmFibGUudGhlbihwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlLCBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKTtcbiAgcmV0dXJuIHRoZW5hYmxlO1xufVxuZnVuY3Rpb24gcGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSgpIHtcbiAgaWYgKFxuICAgIDAgPT09IC0tY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCAmJlxuICAgIG51bGwgIT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnNcbiAgKSB7XG4gICAgbnVsbCAhPT0gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlICYmXG4gICAgICAoY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMDtcbiAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSAoMCwgbGlzdGVuZXJzW2ldKSgpO1xuICB9XG59XG5mdW5jdGlvbiBjaGFpblRoZW5hYmxlVmFsdWUodGhlbmFibGUsIHJlc3VsdCkge1xuICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUgPSB7XG4gICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICByZWFzb246IG51bGwsXG4gICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgIH1cbiAgICB9O1xuICB0aGVuYWJsZS50aGVuKFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS52YWx1ZSA9IHJlc3VsdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSAoMCwgbGlzdGVuZXJzW2ldKShyZXN1bHQpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgIGZvciAoZXJyb3IgPSAwOyBlcnJvciA8IGxpc3RlbmVycy5sZW5ndGg7IGVycm9yKyspXG4gICAgICAgICgwLCBsaXN0ZW5lcnNbZXJyb3JdKSh2b2lkIDApO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHRoZW5hYmxlV2l0aE92ZXJyaWRlO1xufVxudmFyIHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG5SZWFjdFNoYXJlZEludGVybmFscy5TID0gZnVuY3Rpb24gKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKSB7XG4gIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiAmJlxuICAgIGVudGFuZ2xlQXN5bmNBY3Rpb24odHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICBudWxsICE9PSBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2godHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xufTtcbnZhciByZXN1bWVkQ2FjaGUgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG5mdW5jdGlvbiBwZWVrQ2FjaGVGcm9tUG9vbCgpIHtcbiAgdmFyIGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciA9IHJlc3VtZWRDYWNoZS5jdXJyZW50O1xuICByZXR1cm4gbnVsbCAhPT0gY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyXG4gICAgPyBjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXJcbiAgICA6IHdvcmtJblByb2dyZXNzUm9vdC5wb29sZWRDYWNoZTtcbn1cbmZ1bmN0aW9uIHB1c2hUcmFuc2l0aW9uKG9mZnNjcmVlbldvcmtJblByb2dyZXNzLCBwcmV2Q2FjaGVQb29sKSB7XG4gIG51bGwgPT09IHByZXZDYWNoZVBvb2xcbiAgICA/IHB1c2gocmVzdW1lZENhY2hlLCByZXN1bWVkQ2FjaGUuY3VycmVudClcbiAgICA6IHB1c2gocmVzdW1lZENhY2hlLCBwcmV2Q2FjaGVQb29sLnBvb2wpO1xufVxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQ2FjaGUoKSB7XG4gIHZhciBjYWNoZUZyb21Qb29sID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgcmV0dXJuIG51bGwgPT09IGNhY2hlRnJvbVBvb2xcbiAgICA/IG51bGxcbiAgICA6IHsgcGFyZW50OiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSwgcG9vbDogY2FjaGVGcm9tUG9vbCB9O1xufVxudmFyIHJlbmRlckxhbmVzID0gMCxcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGwsXG4gIGN1cnJlbnRIb29rID0gbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCxcbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExLFxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSAhMSxcbiAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSAhMSxcbiAgbG9jYWxJZENvdW50ZXIgPSAwLFxuICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDAsXG4gIHRoZW5hYmxlU3RhdGUgPSBudWxsLFxuICBnbG9iYWxDbGllbnRJZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCkge1xuICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMyMSkpO1xufVxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICBpZiAobnVsbCA9PT0gcHJldkRlcHMpIHJldHVybiAhMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKVxuICAgIGlmICghb2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoXG4gIGN1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIHByb3BzLFxuICBzZWNvbmRBcmcsXG4gIG5leHRSZW5kZXJMYW5lc1xuKSB7XG4gIHJlbmRlckxhbmVzID0gbmV4dFJlbmRlckxhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gMDtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9XG4gICAgbnVsbCA9PT0gY3VycmVudCB8fCBudWxsID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgID8gSG9va3NEaXNwYXRjaGVyT25Nb3VudFxuICAgICAgOiBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZTtcbiAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSAhMTtcbiAgbmV4dFJlbmRlckxhbmVzID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExO1xuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgJiZcbiAgICAobmV4dFJlbmRlckxhbmVzID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHByb3BzLFxuICAgICAgc2Vjb25kQXJnXG4gICAgKSk7XG4gIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQpO1xuICByZXR1cm4gbmV4dFJlbmRlckxhbmVzO1xufVxuZnVuY3Rpb24gZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCkge1xuICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB2YXIgZGlkUmVuZGVyVG9vRmV3SG9va3MgPSBudWxsICE9PSBjdXJyZW50SG9vayAmJiBudWxsICE9PSBjdXJyZW50SG9vay5uZXh0O1xuICByZW5kZXJMYW5lcyA9IDA7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgaWYgKGRpZFJlbmRlclRvb0Zld0hvb2tzKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwMCkpO1xuICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgZGlkUmVjZWl2ZVVwZGF0ZSB8fFxuICAgICgoY3VycmVudCA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzKSxcbiAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCkgJiZcbiAgICAgIChkaWRSZWNlaXZlVXBkYXRlID0gITApKTtcbn1cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rc0FnYWluKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICBkbyB7XG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzICYmICh0aGVuYWJsZVN0YXRlID0gbnVsbCk7XG4gICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExO1xuICAgIGlmICgyNSA8PSBudW1iZXJPZlJlUmVuZGVycykgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMDEpKTtcbiAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICBpZiAobnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBjaGlsZHJlbi5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgIGNoaWxkcmVuLmV2ZW50cyA9IG51bGw7XG4gICAgICBjaGlsZHJlbi5zdG9yZXMgPSBudWxsO1xuICAgICAgbnVsbCAhPSBjaGlsZHJlbi5tZW1vQ2FjaGUgJiYgKGNoaWxkcmVuLm1lbW9DYWNoZS5pbmRleCA9IDApO1xuICAgIH1cbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlcjtcbiAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgfSB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCgpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5ILFxuICAgIG1heWJlVGhlbmFibGUgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKClbMF07XG4gIG1heWJlVGhlbmFibGUgPVxuICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlVGhlbmFibGUudGhlblxuICAgICAgPyB1c2VUaGVuYWJsZShtYXliZVRoZW5hYmxlKVxuICAgICAgOiBtYXliZVRoZW5hYmxlO1xuICBkaXNwYXRjaGVyID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpWzBdO1xuICAobnVsbCAhPT0gY3VycmVudEhvb2sgPyBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlIDogbnVsbCkgIT09IGRpc3BhdGNoZXIgJiZcbiAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSAxMDI0KTtcbiAgcmV0dXJuIG1heWJlVGhlbmFibGU7XG59XG5mdW5jdGlvbiBjaGVja0RpZFJlbmRlcklkSG9vaygpIHtcbiAgdmFyIGRpZFJlbmRlcklkSG9vayA9IDAgIT09IGxvY2FsSWRDb3VudGVyO1xuICBsb2NhbElkQ291bnRlciA9IDA7XG4gIHJldHVybiBkaWRSZW5kZXJJZEhvb2s7XG59XG5mdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTIwNTM7XG4gIGN1cnJlbnQubGFuZXMgJj0gfmxhbmVzO1xufVxuZnVuY3Rpb24gcmVzZXRIb29rc09uVW53aW5kKHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgZm9yIChcbiAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzO1xuXG4gICAgKSB7XG4gICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy5xdWV1ZTtcbiAgICAgIG51bGwgIT09IHF1ZXVlICYmIChxdWV1ZS5wZW5kaW5nID0gbnVsbCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLm5leHQ7XG4gICAgfVxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgfVxuICByZW5kZXJMYW5lcyA9IDA7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciA9IGxvY2FsSWRDb3VudGVyID0gMDtcbiAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG59XG5mdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgdmFyIGhvb2sgPSB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICBiYXNlU3RhdGU6IG51bGwsXG4gICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgPyAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaylcbiAgICA6ICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGhvb2spO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICBpZiAobnVsbCA9PT0gY3VycmVudEhvb2spIHtcbiAgICB2YXIgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG4gICAgbmV4dEN1cnJlbnRIb29rID1cbiAgICAgIG51bGwgIT09IG5leHRDdXJyZW50SG9vayA/IG5leHRDdXJyZW50SG9vay5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgfSBlbHNlIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gIHZhciBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgID8gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlXG4gICAgICA6IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICBpZiAobnVsbCAhPT0gbmV4dFdvcmtJblByb2dyZXNzSG9vaylcbiAgICAod29ya0luUHJvZ3Jlc3NIb29rID0gbmV4dFdvcmtJblByb2dyZXNzSG9vayksXG4gICAgICAoY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2spO1xuICBlbHNlIHtcbiAgICBpZiAobnVsbCA9PT0gbmV4dEN1cnJlbnRIb29rKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGUpXG4gICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDY3KSk7XG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMxMCkpO1xuICAgIH1cbiAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcbiAgICBuZXh0Q3VycmVudEhvb2sgPSB7XG4gICAgICBtZW1vaXplZFN0YXRlOiBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50SG9vay5iYXNlU3RhdGUsXG4gICAgICBiYXNlUXVldWU6IGN1cnJlbnRIb29rLmJhc2VRdWV1ZSxcbiAgICAgIHF1ZXVlOiBjdXJyZW50SG9vay5xdWV1ZSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgPyAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgICBuZXh0Q3VycmVudEhvb2spXG4gICAgICA6ICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IG5leHRDdXJyZW50SG9vayk7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cbnZhciBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHsgbGFzdEVmZmVjdDogbnVsbCwgZXZlbnRzOiBudWxsLCBzdG9yZXM6IG51bGwsIG1lbW9DYWNoZTogbnVsbCB9O1xufTtcbmZ1bmN0aW9uIHVzZVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciArPSAxO1xuICBudWxsID09PSB0aGVuYWJsZVN0YXRlICYmICh0aGVuYWJsZVN0YXRlID0gW10pO1xuICB0aGVuYWJsZSA9IHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCk7XG4gIGluZGV4ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgbnVsbCA9PT1cbiAgICAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICA/IGluZGV4Lm1lbW9pemVkU3RhdGVcbiAgICAgIDogd29ya0luUHJvZ3Jlc3NIb29rLm5leHQpICYmXG4gICAgKChpbmRleCA9IGluZGV4LmFsdGVybmF0ZSksXG4gICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPVxuICAgICAgbnVsbCA9PT0gaW5kZXggfHwgbnVsbCA9PT0gaW5kZXgubWVtb2l6ZWRTdGF0ZVxuICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRcbiAgICAgICAgOiBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZSkpO1xuICByZXR1cm4gdGhlbmFibGU7XG59XG5mdW5jdGlvbiB1c2UodXNhYmxlKSB7XG4gIGlmIChudWxsICE9PSB1c2FibGUgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVzYWJsZSkge1xuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1c2FibGUudGhlbikgcmV0dXJuIHVzZVRoZW5hYmxlKHVzYWJsZSk7XG4gICAgaWYgKHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSByZXR1cm4gcmVhZENvbnRleHQodXNhYmxlKTtcbiAgfVxuICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQzOCwgU3RyaW5nKHVzYWJsZSkpKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW9DYWNoZShzaXplKSB7XG4gIHZhciBtZW1vQ2FjaGUgPSBudWxsLFxuICAgIHVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcbiAgbnVsbCAhPT0gdXBkYXRlUXVldWUgJiYgKG1lbW9DYWNoZSA9IHVwZGF0ZVF1ZXVlLm1lbW9DYWNoZSk7XG4gIGlmIChudWxsID09IG1lbW9DYWNoZSkge1xuICAgIHZhciBjdXJyZW50ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG4gICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQubWVtb0NhY2hlKSxcbiAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmXG4gICAgICAgICAgKG1lbW9DYWNoZSA9IHtcbiAgICAgICAgICAgIGRhdGE6IGN1cnJlbnQuZGF0YS5tYXAoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcnJheS5zbGljZSgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgIH0pKSk7XG4gIH1cbiAgbnVsbCA9PSBtZW1vQ2FjaGUgJiYgKG1lbW9DYWNoZSA9IHsgZGF0YTogW10sIGluZGV4OiAwIH0pO1xuICBudWxsID09PSB1cGRhdGVRdWV1ZSAmJlxuICAgICgodXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUpKTtcbiAgdXBkYXRlUXVldWUubWVtb0NhY2hlID0gbWVtb0NhY2hlO1xuICB1cGRhdGVRdWV1ZSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF07XG4gIGlmICh2b2lkIDAgPT09IHVwZGF0ZVF1ZXVlKVxuICAgIGZvciAoXG4gICAgICB1cGRhdGVRdWV1ZSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF0gPSBBcnJheShzaXplKSwgY3VycmVudCA9IDA7XG4gICAgICBjdXJyZW50IDwgc2l6ZTtcbiAgICAgIGN1cnJlbnQrK1xuICAgIClcbiAgICAgIHVwZGF0ZVF1ZXVlW2N1cnJlbnRdID0gUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTDtcbiAgbWVtb0NhY2hlLmluZGV4Kys7XG4gIHJldHVybiB1cGRhdGVRdWV1ZTtcbn1cbmZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvbiA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5mdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCByZWR1Y2VyKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnQsIHJlZHVjZXIpIHtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcbiAgaWYgKG51bGwgPT09IHF1ZXVlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMxMSkpO1xuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGJhc2VRdWV1ZSA9IGhvb2suYmFzZVF1ZXVlLFxuICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnBlbmRpbmc7XG4gIGlmIChudWxsICE9PSBwZW5kaW5nUXVldWUpIHtcbiAgICBpZiAobnVsbCAhPT0gYmFzZVF1ZXVlKSB7XG4gICAgICB2YXIgYmFzZUZpcnN0ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgICBiYXNlUXVldWUubmV4dCA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgfVxuICAgIGN1cnJlbnQuYmFzZVF1ZXVlID0gYmFzZVF1ZXVlID0gcGVuZGluZ1F1ZXVlO1xuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICB9XG4gIHBlbmRpbmdRdWV1ZSA9IGhvb2suYmFzZVN0YXRlO1xuICBpZiAobnVsbCA9PT0gYmFzZVF1ZXVlKSBob29rLm1lbW9pemVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gIGVsc2Uge1xuICAgIGN1cnJlbnQgPSBiYXNlUXVldWUubmV4dDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSAoYmFzZUZpcnN0ID0gbnVsbCksXG4gICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbCxcbiAgICAgIHVwZGF0ZSA9IGN1cnJlbnQsXG4gICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uJDU0ID0gITE7XG4gICAgZG8ge1xuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSB1cGRhdGUubGFuZSAmIC01MzY4NzA5MTM7XG4gICAgICBpZiAoXG4gICAgICAgIHVwZGF0ZUxhbmUgIT09IHVwZGF0ZS5sYW5lXG4gICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgIDogKHJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICkge1xuICAgICAgICB2YXIgcmV2ZXJ0TGFuZSA9IHVwZGF0ZS5yZXZlcnRMYW5lO1xuICAgICAgICBpZiAoMCA9PT0gcmV2ZXJ0TGFuZSlcbiAgICAgICAgICBudWxsICE9PSBuZXdCYXNlUXVldWVMYXN0ICYmXG4gICAgICAgICAgICAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgICAgIHJldmVydExhbmU6IDAsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB1cGRhdGVMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiQ1NCA9ICEwKTtcbiAgICAgICAgZWxzZSBpZiAoKHJlbmRlckxhbmVzICYgcmV2ZXJ0TGFuZSkgPT09IHJldmVydExhbmUpIHtcbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgICByZXZlcnRMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24kNTQgPSAhMCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICh1cGRhdGVMYW5lID0ge1xuICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICAgICAgPyAoKG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICAgICAgIChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gcmV2ZXJ0TGFuZSk7XG4gICAgICAgIHVwZGF0ZUxhbmUgPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViAmJlxuICAgICAgICAgIHJlZHVjZXIocGVuZGluZ1F1ZXVlLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gdXBkYXRlLmhhc0VhZ2VyU3RhdGVcbiAgICAgICAgICA/IHVwZGF0ZS5lYWdlclN0YXRlXG4gICAgICAgICAgOiByZWR1Y2VyKHBlbmRpbmdRdWV1ZSwgdXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHJldmVydExhbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICByZXZlcnRMYW5lOiB1cGRhdGUucmV2ZXJ0TGFuZSxcbiAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9KSxcbiAgICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgICA/ICgobmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgICAgIChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IHJldmVydExhbmUpLFxuICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gdXBkYXRlTGFuZSk7XG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlIChudWxsICE9PSB1cGRhdGUgJiYgdXBkYXRlICE9PSBjdXJyZW50KTtcbiAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICA/IChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpXG4gICAgICA6IChuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBuZXdCYXNlUXVldWVGaXJzdCk7XG4gICAgaWYgKFxuICAgICAgIW9iamVjdElzKHBlbmRpbmdRdWV1ZSwgaG9vay5tZW1vaXplZFN0YXRlKSAmJlxuICAgICAgKChkaWRSZWNlaXZlVXBkYXRlID0gITApLFxuICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiQ1NCAmJlxuICAgICAgICAoKHJlZHVjZXIgPSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUpLCBudWxsICE9PSByZWR1Y2VyKSlcbiAgICApXG4gICAgICB0aHJvdyByZWR1Y2VyO1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICBob29rLmJhc2VTdGF0ZSA9IGJhc2VGaXJzdDtcbiAgICBob29rLmJhc2VRdWV1ZSA9IG5ld0Jhc2VRdWV1ZUxhc3Q7XG4gICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gIH1cbiAgbnVsbCA9PT0gYmFzZVF1ZXVlICYmIChxdWV1ZS5sYW5lcyA9IDApO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgcXVldWUuZGlzcGF0Y2hdO1xufVxuZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICBxdWV1ZSA9IGhvb2sucXVldWU7XG4gIGlmIChudWxsID09PSBxdWV1ZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMTEpKTtcbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoLFxuICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHF1ZXVlLnBlbmRpbmcsXG4gICAgbmV3U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIGlmIChudWxsICE9PSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0KTtcbiAgICBkbyAobmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCB1cGRhdGUuYWN0aW9uKSksICh1cGRhdGUgPSB1cGRhdGUubmV4dCk7XG4gICAgd2hpbGUgKHVwZGF0ZSAhPT0gbGFzdFJlbmRlclBoYXNlVXBkYXRlKTtcbiAgICBvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSB8fCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKTtcbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBudWxsID09PSBob29rLmJhc2VRdWV1ZSAmJiAoaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZSk7XG4gICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG59XG5mdW5jdGlvbiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICBpc0h5ZHJhdGluZyRqc2NvbXAkMCA9IGlzSHlkcmF0aW5nO1xuICBpZiAoaXNIeWRyYXRpbmckanNjb21wJDApIHtcbiAgICBpZiAodm9pZCAwID09PSBnZXRTZXJ2ZXJTbmFwc2hvdCkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MDcpKTtcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG4gIH0gZWxzZSBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gIHZhciBzbmFwc2hvdENoYW5nZWQgPSAhb2JqZWN0SXMoXG4gICAgKGN1cnJlbnRIb29rIHx8IGhvb2spLm1lbW9pemVkU3RhdGUsXG4gICAgZ2V0U2VydmVyU25hcHNob3RcbiAgKTtcbiAgc25hcHNob3RDaGFuZ2VkICYmXG4gICAgKChob29rLm1lbW9pemVkU3RhdGUgPSBnZXRTZXJ2ZXJTbmFwc2hvdCksIChkaWRSZWNlaXZlVXBkYXRlID0gITApKTtcbiAgaG9vayA9IGhvb2sucXVldWU7XG4gIHVwZGF0ZUVmZmVjdChzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGhvb2ssIHN1YnNjcmliZSksIFtcbiAgICBzdWJzY3JpYmVcbiAgXSk7XG4gIGlmIChcbiAgICBob29rLmdldFNuYXBzaG90ICE9PSBnZXRTbmFwc2hvdCB8fFxuICAgIHNuYXBzaG90Q2hhbmdlZCB8fFxuICAgIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzc0hvb2sgJiYgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUudGFnICYgMSlcbiAgKSB7XG4gICAgZmliZXIuZmxhZ3MgfD0gMjA0ODtcbiAgICBwdXNoRWZmZWN0KFxuICAgICAgOSxcbiAgICAgIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZmliZXIsXG4gICAgICAgIGhvb2ssXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgICBnZXRTbmFwc2hvdFxuICAgICAgKSxcbiAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM0OSkpO1xuICAgIGlzSHlkcmF0aW5nJGpzY29tcCQwIHx8XG4gICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiA2MCkgfHxcbiAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gIH1cbiAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90O1xufVxuZnVuY3Rpb24gcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIHJlbmRlcmVkU25hcHNob3QpIHtcbiAgZmliZXIuZmxhZ3MgfD0gMTYzODQ7XG4gIGZpYmVyID0geyBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QsIHZhbHVlOiByZW5kZXJlZFNuYXBzaG90IH07XG4gIGdldFNuYXBzaG90ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcbiAgbnVsbCA9PT0gZ2V0U25hcHNob3RcbiAgICA/ICgoZ2V0U25hcHNob3QgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBnZXRTbmFwc2hvdCksXG4gICAgICAoZ2V0U25hcHNob3Quc3RvcmVzID0gW2ZpYmVyXSkpXG4gICAgOiAoKHJlbmRlcmVkU25hcHNob3QgPSBnZXRTbmFwc2hvdC5zdG9yZXMpLFxuICAgICAgbnVsbCA9PT0gcmVuZGVyZWRTbmFwc2hvdFxuICAgICAgICA/IChnZXRTbmFwc2hvdC5zdG9yZXMgPSBbZmliZXJdKVxuICAgICAgICA6IHJlbmRlcmVkU25hcHNob3QucHVzaChmaWJlcikpO1xufVxuZnVuY3Rpb24gdXBkYXRlU3RvcmVJbnN0YW5jZShmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCkge1xuICBpbnN0LnZhbHVlID0gbmV4dFNuYXBzaG90O1xuICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7XG4gIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHN1YnNjcmliZVRvU3RvcmUoZmliZXIsIGluc3QsIHN1YnNjcmliZSkge1xuICByZXR1cm4gc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gIGluc3QgPSBpbnN0LnZhbHVlO1xuICB0cnkge1xuICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgIHJldHVybiAhb2JqZWN0SXMoaW5zdCwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcikge1xuICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKTtcbn1cbmZ1bmN0aW9uIG1vdW50U3RhdGVJbXBsKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbml0aWFsU3RhdGUpIHtcbiAgICB2YXIgaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIgPSBpbml0aWFsU3RhdGU7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcbiAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICBob29rLnF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IDAsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICByZXR1cm4gaG9vaztcbn1cbmZ1bmN0aW9uIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnQsIHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gIHJldHVybiB1cGRhdGVSZWR1Y2VySW1wbChcbiAgICBob29rLFxuICAgIGN1cnJlbnRIb29rLFxuICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZHVjZXIgPyByZWR1Y2VyIDogYmFzaWNTdGF0ZVJlZHVjZXJcbiAgKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uU3RhdGUoXG4gIGZpYmVyLFxuICBhY3Rpb25RdWV1ZSxcbiAgc2V0UGVuZGluZ1N0YXRlLFxuICBzZXRTdGF0ZSxcbiAgcGF5bG9hZFxuKSB7XG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0ODUpKTtcbiAgZmliZXIgPSBhY3Rpb25RdWV1ZS5hY3Rpb247XG4gIGlmIChudWxsICE9PSBmaWJlcikge1xuICAgIHZhciBhY3Rpb25Ob2RlID0ge1xuICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgIGFjdGlvbjogZmliZXIsXG4gICAgICBuZXh0OiBudWxsLFxuICAgICAgaXNUcmFuc2l0aW9uOiAhMCxcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICB0aGVuOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgYWN0aW9uTm9kZS5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5UXG4gICAgICA/IHNldFBlbmRpbmdTdGF0ZSghMClcbiAgICAgIDogKGFjdGlvbk5vZGUuaXNUcmFuc2l0aW9uID0gITEpO1xuICAgIHNldFN0YXRlKGFjdGlvbk5vZGUpO1xuICAgIHNldFBlbmRpbmdTdGF0ZSA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gICAgbnVsbCA9PT0gc2V0UGVuZGluZ1N0YXRlXG4gICAgICA/ICgoYWN0aW9uTm9kZS5uZXh0ID0gYWN0aW9uUXVldWUucGVuZGluZyA9IGFjdGlvbk5vZGUpLFxuICAgICAgICBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSkpXG4gICAgICA6ICgoYWN0aW9uTm9kZS5uZXh0ID0gc2V0UGVuZGluZ1N0YXRlLm5leHQpLFxuICAgICAgICAoYWN0aW9uUXVldWUucGVuZGluZyA9IHNldFBlbmRpbmdTdGF0ZS5uZXh0ID0gYWN0aW9uTm9kZSkpO1xuICB9XG59XG5mdW5jdGlvbiBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgbm9kZSkge1xuICB2YXIgYWN0aW9uID0gbm9kZS5hY3Rpb24sXG4gICAgcGF5bG9hZCA9IG5vZGUucGF5bG9hZCxcbiAgICBwcmV2U3RhdGUgPSBhY3Rpb25RdWV1ZS5zdGF0ZTtcbiAgaWYgKG5vZGUuaXNUcmFuc2l0aW9uKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSBhY3Rpb24ocHJldlN0YXRlLCBwYXlsb2FkKSxcbiAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIG5vZGUsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuICAgIH1cbiAgfSBlbHNlXG4gICAgdHJ5IHtcbiAgICAgIChwcmV2VHJhbnNpdGlvbiA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpKSxcbiAgICAgICAgaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHByZXZUcmFuc2l0aW9uKTtcbiAgICB9IGNhdGNoIChlcnJvciQ2MCkge1xuICAgICAgb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IkNjApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSkge1xuICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlblxuICAgID8gcmV0dXJuVmFsdWUudGhlbihcbiAgICAgICAgZnVuY3Rpb24gKG5leHRTdGF0ZSkge1xuICAgICAgICAgIG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgbm9kZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIG5vZGUsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIDogb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSk7XG59XG5mdW5jdGlvbiBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUsIG5leHRTdGF0ZSkge1xuICBhY3Rpb25Ob2RlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gIGFjdGlvbk5vZGUudmFsdWUgPSBuZXh0U3RhdGU7XG4gIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKTtcbiAgYWN0aW9uUXVldWUuc3RhdGUgPSBuZXh0U3RhdGU7XG4gIGFjdGlvbk5vZGUgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICBudWxsICE9PSBhY3Rpb25Ob2RlICYmXG4gICAgKChuZXh0U3RhdGUgPSBhY3Rpb25Ob2RlLm5leHQpLFxuICAgIG5leHRTdGF0ZSA9PT0gYWN0aW9uTm9kZVxuICAgICAgPyAoYWN0aW9uUXVldWUucGVuZGluZyA9IG51bGwpXG4gICAgICA6ICgobmV4dFN0YXRlID0gbmV4dFN0YXRlLm5leHQpLFxuICAgICAgICAoYWN0aW9uTm9kZS5uZXh0ID0gbmV4dFN0YXRlKSxcbiAgICAgICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIG5leHRTdGF0ZSkpKTtcbn1cbmZ1bmN0aW9uIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUsIGVycm9yKSB7XG4gIHZhciBsYXN0ID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgYWN0aW9uUXVldWUucGVuZGluZyA9IG51bGw7XG4gIGlmIChudWxsICE9PSBsYXN0KSB7XG4gICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICBkb1xuICAgICAgKGFjdGlvbk5vZGUuc3RhdHVzID0gXCJyZWplY3RlZFwiKSxcbiAgICAgICAgKGFjdGlvbk5vZGUucmVhc29uID0gZXJyb3IpLFxuICAgICAgICBub3RpZnlBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTm9kZSksXG4gICAgICAgIChhY3Rpb25Ob2RlID0gYWN0aW9uTm9kZS5uZXh0KTtcbiAgICB3aGlsZSAoYWN0aW9uTm9kZSAhPT0gbGFzdCk7XG4gIH1cbiAgYWN0aW9uUXVldWUuYWN0aW9uID0gbnVsbDtcbn1cbmZ1bmN0aW9uIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKSB7XG4gIGFjdGlvbk5vZGUgPSBhY3Rpb25Ob2RlLmxpc3RlbmVycztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3Rpb25Ob2RlLmxlbmd0aDsgaSsrKSAoMCwgYWN0aW9uTm9kZVtpXSkoKTtcbn1cbmZ1bmN0aW9uIGFjdGlvblN0YXRlUmVkdWNlcihvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuZnVuY3Rpb24gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZVByb3ApIHtcbiAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgdmFyIHNzckZvcm1TdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdC5mb3JtU3RhdGU7XG4gICAgaWYgKG51bGwgIT09IHNzckZvcm1TdGF0ZSkge1xuICAgICAgYToge1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgaWYgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGI6IHtcbiAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIGluUm9vdE9yU2luZ2xldG9uID0gcm9vdE9yU2luZ2xldG9uQ29udGV4dDtcbiAgICAgICAgICAgICAgICA4ICE9PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAubm9kZVR5cGU7XG5cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpblJvb3RPclNpbmdsZXRvbikge1xuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5Sb290T3JTaW5nbGV0b24gPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAuZGF0YTtcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICBcIkYhXCIgPT09IGluUm9vdE9yU2luZ2xldG9uIHx8IFwiRlwiID09PSBpblJvb3RPclNpbmdsZXRvblxuICAgICAgICAgICAgICAgICAgPyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMC5uZXh0U2libGluZ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICAgICAgICAgIFwiRiFcIiA9PT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwLmRhdGE7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfVxuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYmIChpbml0aWFsU3RhdGVQcm9wID0gc3NyRm9ybVN0YXRlWzBdKTtcbiAgICB9XG4gIH1cbiAgc3NyRm9ybVN0YXRlID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgc3NyRm9ybVN0YXRlLm1lbW9pemVkU3RhdGUgPSBzc3JGb3JtU3RhdGUuYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlUHJvcDtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IDAsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYWN0aW9uU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVQcm9wXG4gIH07XG4gIHNzckZvcm1TdGF0ZS5xdWV1ZSA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKFxuICAgIG51bGwsXG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgKTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmRpc3BhdGNoID0gc3NyRm9ybVN0YXRlO1xuICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBtb3VudFN0YXRlSW1wbCghMSk7XG4gIGluUm9vdE9yU2luZ2xldG9uID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChcbiAgICBudWxsLFxuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgITEsXG4gICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnF1ZXVlXG4gICk7XG4gIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IHtcbiAgICBzdGF0ZTogaW5pdGlhbFN0YXRlUHJvcCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBwZW5kaW5nOiBudWxsXG4gIH07XG4gIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5xdWV1ZSA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMDtcbiAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hBY3Rpb25TdGF0ZS5iaW5kKFxuICAgIG51bGwsXG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAsXG4gICAgaW5Sb290T3JTaW5nbGV0b24sXG4gICAgc3NyRm9ybVN0YXRlXG4gICk7XG4gIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMC5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0Lm1lbW9pemVkU3RhdGUgPSBhY3Rpb247XG4gIHJldHVybiBbaW5pdGlhbFN0YXRlUHJvcCwgc3NyRm9ybVN0YXRlLCAhMV07XG59XG5mdW5jdGlvbiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pIHtcbiAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudEhvb2ssIGFjdGlvbik7XG59XG5mdW5jdGlvbiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pIHtcbiAgY3VycmVudFN0YXRlSG9vayA9IHVwZGF0ZVJlZHVjZXJJbXBsKFxuICAgIHN0YXRlSG9vayxcbiAgICBjdXJyZW50U3RhdGVIb29rLFxuICAgIGFjdGlvblN0YXRlUmVkdWNlclxuICApWzBdO1xuICBzdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXTtcbiAgY3VycmVudFN0YXRlSG9vayA9XG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGN1cnJlbnRTdGF0ZUhvb2sgJiZcbiAgICBudWxsICE9PSBjdXJyZW50U3RhdGVIb29rICYmXG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudFN0YXRlSG9vay50aGVuXG4gICAgICA/IHVzZVRoZW5hYmxlKGN1cnJlbnRTdGF0ZUhvb2spXG4gICAgICA6IGN1cnJlbnRTdGF0ZUhvb2s7XG4gIHZhciBhY3Rpb25RdWV1ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICBhY3Rpb25RdWV1ZSA9IGFjdGlvblF1ZXVlSG9vay5xdWV1ZSxcbiAgICBkaXNwYXRjaCA9IGFjdGlvblF1ZXVlLmRpc3BhdGNoO1xuICBhY3Rpb24gIT09IGFjdGlvblF1ZXVlSG9vay5tZW1vaXplZFN0YXRlICYmXG4gICAgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IDIwNDgpLFxuICAgIHB1c2hFZmZlY3QoXG4gICAgICA5LFxuICAgICAgYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QuYmluZChudWxsLCBhY3Rpb25RdWV1ZSwgYWN0aW9uKSxcbiAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICBudWxsXG4gICAgKSk7XG4gIHJldHVybiBbY3VycmVudFN0YXRlSG9vaywgZGlzcGF0Y2gsIHN0YXRlSG9va107XG59XG5mdW5jdGlvbiBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdChhY3Rpb25RdWV1ZSwgYWN0aW9uKSB7XG4gIGFjdGlvblF1ZXVlLmFjdGlvbiA9IGFjdGlvbjtcbn1cbmZ1bmN0aW9uIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKSB7XG4gIHZhciBzdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICBjdXJyZW50U3RhdGVIb29rID0gY3VycmVudEhvb2s7XG4gIGlmIChudWxsICE9PSBjdXJyZW50U3RhdGVIb29rKVxuICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pO1xuICB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgc3RhdGVIb29rID0gc3RhdGVIb29rLm1lbW9pemVkU3RhdGU7XG4gIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGRpc3BhdGNoID0gY3VycmVudFN0YXRlSG9vay5xdWV1ZS5kaXNwYXRjaDtcbiAgY3VycmVudFN0YXRlSG9vay5tZW1vaXplZFN0YXRlID0gYWN0aW9uO1xuICByZXR1cm4gW3N0YXRlSG9vaywgZGlzcGF0Y2gsICExXTtcbn1cbmZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLCBjcmVhdGUsIGluc3QsIGRlcHMpIHtcbiAgdGFnID0geyB0YWc6IHRhZywgY3JlYXRlOiBjcmVhdGUsIGluc3Q6IGluc3QsIGRlcHM6IGRlcHMsIG5leHQ6IG51bGwgfTtcbiAgY3JlYXRlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcbiAgbnVsbCA9PT0gY3JlYXRlICYmXG4gICAgKChjcmVhdGUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY3JlYXRlKSk7XG4gIGluc3QgPSBjcmVhdGUubGFzdEVmZmVjdDtcbiAgbnVsbCA9PT0gaW5zdFxuICAgID8gKGNyZWF0ZS5sYXN0RWZmZWN0ID0gdGFnLm5leHQgPSB0YWcpXG4gICAgOiAoKGRlcHMgPSBpbnN0Lm5leHQpLFxuICAgICAgKGluc3QubmV4dCA9IHRhZyksXG4gICAgICAodGFnLm5leHQgPSBkZXBzKSxcbiAgICAgIChjcmVhdGUubGFzdEVmZmVjdCA9IHRhZykpO1xuICByZXR1cm4gdGFnO1xufVxuZnVuY3Rpb24gdXBkYXRlUmVmKCkge1xuICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbn1cbmZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChcbiAgICAxIHwgaG9va0ZsYWdzLFxuICAgIGNyZWF0ZSxcbiAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgIHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzXG4gICk7XG59XG5mdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgdmFyIGluc3QgPSBob29rLm1lbW9pemVkU3RhdGUuaW5zdDtcbiAgbnVsbCAhPT0gY3VycmVudEhvb2sgJiZcbiAgbnVsbCAhPT0gZGVwcyAmJlxuICBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZS5kZXBzKVxuICAgID8gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoaG9va0ZsYWdzLCBjcmVhdGUsIGluc3QsIGRlcHMpKVxuICAgIDogKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3MpLFxuICAgICAgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoMSB8IGhvb2tGbGFncywgY3JlYXRlLCBpbnN0LCBkZXBzKSkpO1xufVxuZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIG1vdW50RWZmZWN0SW1wbCg4MzkwNjU2LCA4LCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIDgsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIDIsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIDQsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpIHtcbiAgICBjcmVhdGUgPSBjcmVhdGUoKTtcbiAgICB2YXIgcmVmQ2xlYW51cCA9IHJlZihjcmVhdGUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWZDbGVhbnVwID8gcmVmQ2xlYW51cCgpIDogcmVmKG51bGwpO1xuICAgIH07XG4gIH1cbiAgaWYgKG51bGwgIT09IHJlZiAmJiB2b2lkIDAgIT09IHJlZilcbiAgICByZXR1cm4gKFxuICAgICAgKGNyZWF0ZSA9IGNyZWF0ZSgpKSxcbiAgICAgIChyZWYuY3VycmVudCA9IGNyZWF0ZSksXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICApO1xufVxuZnVuY3Rpb24gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICBkZXBzID0gbnVsbCAhPT0gZGVwcyAmJiB2b2lkIDAgIT09IGRlcHMgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICB1cGRhdGVFZmZlY3RJbXBsKDQsIDQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGRlcHMpO1xufVxuZnVuY3Rpb24gbW91bnREZWJ1Z1ZhbHVlKCkge31cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKG51bGwgIT09IGRlcHMgJiYgYXJlSG9va0lucHV0c0VxdWFsKGRlcHMsIHByZXZTdGF0ZVsxXSkpXG4gICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBkZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKG51bGwgIT09IGRlcHMgJiYgYXJlSG9va0lucHV0c0VxdWFsKGRlcHMsIHByZXZTdGF0ZVsxXSkpXG4gICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgcHJldlN0YXRlID0gbmV4dENyZWF0ZSgpO1xuICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgdHJ5IHtcbiAgICAgIG5leHRDcmVhdGUoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgIH1cbiAgfVxuICBob29rLm1lbW9pemVkU3RhdGUgPSBbcHJldlN0YXRlLCBkZXBzXTtcbiAgcmV0dXJuIHByZXZTdGF0ZTtcbn1cbmZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICBpZiAodm9pZCAwID09PSBpbml0aWFsVmFsdWUgfHwgMCAhPT0gKHJlbmRlckxhbmVzICYgMTA3Mzc0MTgyNCkpXG4gICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZSk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZTtcbiAgaG9vayA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSBob29rO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gaG9vaztcbiAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICBpZiAob2JqZWN0SXModmFsdWUsIHByZXZWYWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgaWYgKG51bGwgIT09IGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudClcbiAgICByZXR1cm4gKFxuICAgICAgKGhvb2sgPSBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpKSxcbiAgICAgIG9iamVjdElzKGhvb2ssIHByZXZWYWx1ZSkgfHwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksXG4gICAgICBob29rXG4gICAgKTtcbiAgaWYgKDAgPT09IChyZW5kZXJMYW5lcyAmIDQyKSlcbiAgICByZXR1cm4gKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksIChob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZSk7XG4gIGhvb2sgPSByZXF1ZXN0RGVmZXJyZWRMYW5lKCk7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gaG9vaztcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGhvb2s7XG4gIHJldHVybiBwcmV2VmFsdWU7XG59XG5mdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oZmliZXIsIHF1ZXVlLCBwZW5kaW5nU3RhdGUsIGZpbmlzaGVkU3RhdGUsIGNhbGxiYWNrKSB7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9XG4gICAgMCAhPT0gcHJldmlvdXNQcmlvcml0eSAmJiA4ID4gcHJldmlvdXNQcmlvcml0eSA/IHByZXZpb3VzUHJpb3JpdHkgOiA4O1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUoZmliZXIsICExLCBxdWV1ZSwgcGVuZGluZ1N0YXRlKTtcbiAgdHJ5IHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpLFxuICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgIGlmIChcbiAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW5cbiAgICApIHtcbiAgICAgIHZhciB0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUgPSBjaGFpblRoZW5hYmxlVmFsdWUoXG4gICAgICAgIHJldHVyblZhbHVlLFxuICAgICAgICBmaW5pc2hlZFN0YXRlXG4gICAgICApO1xuICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICBmaWJlcixcbiAgICAgICAgcXVldWUsXG4gICAgICAgIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSxcbiAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICApO1xuICAgIH0gZWxzZVxuICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICBmaWJlcixcbiAgICAgICAgcXVldWUsXG4gICAgICAgIGZpbmlzaGVkU3RhdGUsXG4gICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKVxuICAgICAgKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICBmaWJlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgeyB0aGVuOiBmdW5jdGlvbiAoKSB7fSwgc3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbjogZXJyb3IgfSxcbiAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKClcbiAgICApO1xuICB9IGZpbmFsbHkge1xuICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eSksXG4gICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9vcCQyKCkge31cbmZ1bmN0aW9uIHN0YXJ0SG9zdFRyYW5zaXRpb24oZm9ybUZpYmVyLCBwZW5kaW5nU3RhdGUsIGFjdGlvbiwgZm9ybURhdGEpIHtcbiAgaWYgKDUgIT09IGZvcm1GaWJlci50YWcpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDc2KSk7XG4gIHZhciBxdWV1ZSA9IGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikucXVldWU7XG4gIHN0YXJ0VHJhbnNpdGlvbihcbiAgICBmb3JtRmliZXIsXG4gICAgcXVldWUsXG4gICAgcGVuZGluZ1N0YXRlLFxuICAgIHNoYXJlZE5vdFBlbmRpbmdPYmplY3QsXG4gICAgbnVsbCA9PT0gYWN0aW9uXG4gICAgICA/IG5vb3AkMlxuICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVxdWVzdEZvcm1SZXNldCQxKGZvcm1GaWJlcik7XG4gICAgICAgICAgcmV0dXJuIGFjdGlvbihmb3JtRGF0YSk7XG4gICAgICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikge1xuICB2YXIgZXhpc3RpbmdTdGF0ZUhvb2sgPSBmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKG51bGwgIT09IGV4aXN0aW5nU3RhdGVIb29rKSByZXR1cm4gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gIGV4aXN0aW5nU3RhdGVIb29rID0ge1xuICAgIG1lbW9pemVkU3RhdGU6IHNoYXJlZE5vdFBlbmRpbmdPYmplY3QsXG4gICAgYmFzZVN0YXRlOiBzaGFyZWROb3RQZW5kaW5nT2JqZWN0LFxuICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICBxdWV1ZToge1xuICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgIGxhbmVzOiAwLFxuICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBzaGFyZWROb3RQZW5kaW5nT2JqZWN0XG4gICAgfSxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHZhciBpbml0aWFsUmVzZXRTdGF0ZSA9IHt9O1xuICBleGlzdGluZ1N0YXRlSG9vay5uZXh0ID0ge1xuICAgIG1lbW9pemVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgIGJhc2VTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgIHF1ZXVlOiB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgbGFuZXM6IDAsXG4gICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlXG4gICAgfSxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIGZvcm1GaWJlci5tZW1vaXplZFN0YXRlID0gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gIGZvcm1GaWJlciA9IGZvcm1GaWJlci5hbHRlcm5hdGU7XG4gIG51bGwgIT09IGZvcm1GaWJlciAmJiAoZm9ybUZpYmVyLm1lbW9pemVkU3RhdGUgPSBleGlzdGluZ1N0YXRlSG9vayk7XG4gIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbn1cbmZ1bmN0aW9uIHJlcXVlc3RGb3JtUmVzZXQkMShmb3JtRmliZXIpIHtcbiAgdmFyIHJlc2V0U3RhdGVRdWV1ZSA9IGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikubmV4dC5xdWV1ZTtcbiAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKGZvcm1GaWJlciwgcmVzZXRTdGF0ZVF1ZXVlLCB7fSwgcmVxdWVzdFVwZGF0ZUxhbmUoKSk7XG59XG5mdW5jdGlvbiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpIHtcbiAgcmV0dXJuIHJlYWRDb250ZXh0KEhvc3RUcmFuc2l0aW9uQ29udGV4dCk7XG59XG5mdW5jdGlvbiB1cGRhdGVJZCgpIHtcbiAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG59XG5mdW5jdGlvbiB1cGRhdGVSZWZyZXNoKCkge1xuICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbn1cbmZ1bmN0aW9uIHJlZnJlc2hDYWNoZShmaWJlcikge1xuICBmb3IgKHZhciBwcm92aWRlciA9IGZpYmVyLnJldHVybjsgbnVsbCAhPT0gcHJvdmlkZXI7ICkge1xuICAgIHN3aXRjaCAocHJvdmlkZXIudGFnKSB7XG4gICAgICBjYXNlIDI0OlxuICAgICAgY2FzZSAzOlxuICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKCk7XG4gICAgICAgIGZpYmVyID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICB2YXIgcm9vdCQ2MyA9IGVucXVldWVVcGRhdGUocHJvdmlkZXIsIGZpYmVyLCBsYW5lKTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCQ2MyAmJlxuICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCQ2MywgcHJvdmlkZXIsIGxhbmUpLFxuICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCQ2MywgcHJvdmlkZXIsIGxhbmUpKTtcbiAgICAgICAgcHJvdmlkZXIgPSB7IGNhY2hlOiBjcmVhdGVDYWNoZSgpIH07XG4gICAgICAgIGZpYmVyLnBheWxvYWQgPSBwcm92aWRlcjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcm92aWRlciA9IHByb3ZpZGVyLnJldHVybjtcbiAgfVxufVxuZnVuY3Rpb24gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uKGZpYmVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoKTtcbiAgYWN0aW9uID0ge1xuICAgIGxhbmU6IGxhbmUsXG4gICAgcmV2ZXJ0TGFuZTogMCxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiAhMSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcilcbiAgICA/IGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgYWN0aW9uKVxuICAgIDogKChhY3Rpb24gPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCBhY3Rpb24sIGxhbmUpKSxcbiAgICAgIG51bGwgIT09IGFjdGlvbiAmJlxuICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGFjdGlvbiwgZmliZXIsIGxhbmUpLFxuICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUoYWN0aW9uLCBxdWV1ZSwgbGFuZSkpKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGUoZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZSgpO1xuICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoZmliZXIsIHF1ZXVlLCBhY3Rpb24sIGxhbmUpO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKGZpYmVyLCBxdWV1ZSwgYWN0aW9uLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICByZXZlcnRMYW5lOiAwLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKTtcbiAgZWxzZSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICBpZiAoXG4gICAgICAwID09PSBmaWJlci5sYW5lcyAmJlxuICAgICAgKG51bGwgPT09IGFsdGVybmF0ZSB8fCAwID09PSBhbHRlcm5hdGUubGFuZXMpICYmXG4gICAgICAoKGFsdGVybmF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIpLCBudWxsICE9PSBhbHRlcm5hdGUpXG4gICAgKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlLFxuICAgICAgICAgIGVhZ2VyU3RhdGUgPSBhbHRlcm5hdGUoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgICAgICB1cGRhdGUuaGFzRWFnZXJTdGF0ZSA9ICEwO1xuICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG4gICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIDApLFxuICAgICAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgfVxuICAgIGFjdGlvbiA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgaWYgKG51bGwgIT09IGFjdGlvbilcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihhY3Rpb24sIGZpYmVyLCBsYW5lKSxcbiAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKGFjdGlvbiwgcXVldWUsIGxhbmUpLFxuICAgICAgICAhMFxuICAgICAgKTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZShmaWJlciwgdGhyb3dJZkR1cmluZ1JlbmRlciwgcXVldWUsIGFjdGlvbikge1xuICBhY3Rpb24gPSB7XG4gICAgbGFuZTogMixcbiAgICByZXZlcnRMYW5lOiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiAhMSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB7XG4gICAgaWYgKHRocm93SWZEdXJpbmdSZW5kZXIpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDc5KSk7XG4gIH0gZWxzZVxuICAgICh0aHJvd0lmRHVyaW5nUmVuZGVyID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIDJcbiAgICApKSxcbiAgICAgIG51bGwgIT09IHRocm93SWZEdXJpbmdSZW5kZXIgJiZcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHRocm93SWZEdXJpbmdSZW5kZXIsIGZpYmVyLCAyKTtcbn1cbmZ1bmN0aW9uIGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgcmV0dXJuIChcbiAgICBmaWJlciA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSB8fFxuICAgIChudWxsICE9PSBhbHRlcm5hdGUgJiYgYWx0ZXJuYXRlID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKVxuICApO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9XG4gICAgITA7XG4gIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcbiAgbnVsbCA9PT0gcGVuZGluZ1xuICAgID8gKHVwZGF0ZS5uZXh0ID0gdXBkYXRlKVxuICAgIDogKCh1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dCksIChwZW5kaW5nLm5leHQgPSB1cGRhdGUpKTtcbiAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSkge1xuICBpZiAoMCAhPT0gKGxhbmUgJiA0MTk0MTc2KSkge1xuICAgIHZhciBxdWV1ZUxhbmVzID0gcXVldWUubGFuZXM7XG4gICAgcXVldWVMYW5lcyAmPSByb290LnBlbmRpbmdMYW5lcztcbiAgICBsYW5lIHw9IHF1ZXVlTGFuZXM7XG4gICAgcXVldWUubGFuZXMgPSBsYW5lO1xuICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGxhbmUpO1xuICB9XG59XG52YXIgQ29udGV4dE9ubHlEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZTogdXNlLFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbnNlcnRpb25FZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTWVtbzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlZmVycmVkVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlVHJhbnNpdGlvbjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJZDogdGhyb3dJbnZhbGlkSG9va0Vycm9yXG59O1xuQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbkNvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VNZW1vQ2FjaGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG5Db250ZXh0T25seURpc3BhdGNoZXIudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG5Db250ZXh0T25seURpc3BhdGNoZXIudXNlRm9ybVN0YXRlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUFjdGlvblN0YXRlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZU9wdGltaXN0aWMgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudCA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2U6IHVzZSxcbiAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IFtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgICBdO1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSxcbiAgdXNlQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZUVmZmVjdDogbW91bnRFZmZlY3QsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgIGRlcHMgPSBudWxsICE9PSBkZXBzICYmIHZvaWQgMCAhPT0gZGVwcyA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gICAgbW91bnRFZmZlY3RJbXBsKFxuICAgICAgNDE5NDMwOCxcbiAgICAgIDQsXG4gICAgICBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLFxuICAgICAgZGVwc1xuICAgICk7XG4gIH0sXG4gIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgIHJldHVybiBtb3VudEVmZmVjdEltcGwoNDE5NDMwOCwgNCwgY3JlYXRlLCBkZXBzKTtcbiAgfSxcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgbW91bnRFZmZlY3RJbXBsKDQsIDIsIGNyZWF0ZSwgZGVwcyk7XG4gIH0sXG4gIHVzZU1lbW86IGZ1bmN0aW9uIChuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV4dENyZWF0ZSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgfVxuICAgIH1cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBkZXBzXTtcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICB9LFxuICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICBpZiAodm9pZCAwICE9PSBpbml0KSB7XG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcbiAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5pdChpbml0aWFsQXJnKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaW5pdGlhbFN0YXRlID0gaW5pdGlhbEFyZztcbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICByZWR1Y2VyID0ge1xuICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgIGxhbmVzOiAwLFxuICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiByZWR1Y2VyLFxuICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICAgIH07XG4gICAgaG9vay5xdWV1ZSA9IHJlZHVjZXI7XG4gICAgcmVkdWNlciA9IHJlZHVjZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaFJlZHVjZXJBY3Rpb24uYmluZChcbiAgICAgIG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgcmVkdWNlclxuICAgICk7XG4gICAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIHJlZHVjZXJdO1xuICB9LFxuICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgaW5pdGlhbFZhbHVlID0geyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfTtcbiAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZSk7XG4gIH0sXG4gIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKTtcbiAgICB2YXIgcXVldWUgPSBpbml0aWFsU3RhdGUucXVldWUsXG4gICAgICBkaXNwYXRjaCA9IGRpc3BhdGNoU2V0U3RhdGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBxdWV1ZSk7XG4gICAgcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICByZXR1cm4gW2luaXRpYWxTdGF0ZS5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gIH0sXG4gIHVzZURlYnVnVmFsdWU6IG1vdW50RGVidWdWYWx1ZSxcbiAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gIH0sXG4gIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGVIb29rID0gbW91bnRTdGF0ZUltcGwoITEpO1xuICAgIHN0YXRlSG9vayA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKFxuICAgICAgbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICBzdGF0ZUhvb2sucXVldWUsXG4gICAgICAhMCxcbiAgICAgICExXG4gICAgKTtcbiAgICBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2s7XG4gICAgcmV0dXJuIFshMSwgc3RhdGVIb29rXTtcbiAgfSxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQwNykpO1xuICAgICAgZ2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM0OSkpO1xuICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjApIHx8XG4gICAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfVxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGdldFNlcnZlclNuYXBzaG90O1xuICAgIHZhciBpbnN0ID0geyB2YWx1ZTogZ2V0U2VydmVyU25hcHNob3QsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9O1xuICAgIGhvb2sucXVldWUgPSBpbnN0O1xuICAgIG1vdW50RWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSwgW1xuICAgICAgc3Vic2NyaWJlXG4gICAgXSk7XG4gICAgZmliZXIuZmxhZ3MgfD0gMjA0ODtcbiAgICBwdXNoRWZmZWN0KFxuICAgICAgOSxcbiAgICAgIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZmliZXIsXG4gICAgICAgIGluc3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgICBnZXRTbmFwc2hvdFxuICAgICAgKSxcbiAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICBudWxsXG4gICAgKTtcbiAgICByZXR1cm4gZ2V0U2VydmVyU25hcHNob3Q7XG4gIH0sXG4gIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgaWRlbnRpZmllclByZWZpeCA9IHdvcmtJblByb2dyZXNzUm9vdC5pZGVudGlmaWVyUHJlZml4O1xuICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICB2YXIgaWRXaXRoTGVhZGluZ0JpdCA9IHRyZWVDb250ZXh0SWQ7XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICAoXG4gICAgICAgICAgaWRXaXRoTGVhZGluZ0JpdCAmIH4oMSA8PCAoMzIgLSBjbHozMihpZFdpdGhMZWFkaW5nQml0KSAtIDEpKVxuICAgICAgICApLnRvU3RyaW5nKDMyKSArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgIGlkZW50aWZpZXJQcmVmaXggPVxuICAgICAgICBcIjpcIiArIGlkZW50aWZpZXJQcmVmaXggKyBcIlJcIiArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGxvY2FsSWRDb3VudGVyKys7XG4gICAgICAwIDwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYmXG4gICAgICAgIChpZGVudGlmaWVyUHJlZml4ICs9IFwiSFwiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnRvU3RyaW5nKDMyKSk7XG4gICAgICBpZGVudGlmaWVyUHJlZml4ICs9IFwiOlwiO1xuICAgIH0gZWxzZVxuICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGdsb2JhbENsaWVudElkQ291bnRlcisrKSxcbiAgICAgICAgKGlkZW50aWZpZXJQcmVmaXggPVxuICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICBpZGVudGlmaWVyUHJlZml4ICtcbiAgICAgICAgICBcInJcIiArXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnRvU3RyaW5nKDMyKSArXG4gICAgICAgICAgXCI6XCIpO1xuICAgIHJldHVybiAoaG9vay5tZW1vaXplZFN0YXRlID0gaWRlbnRpZmllclByZWZpeCk7XG4gIH0sXG4gIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAobW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gcmVmcmVzaENhY2hlLmJpbmQoXG4gICAgICBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMVxuICAgICkpO1xuICB9XG59O1xuSG9va3NEaXNwYXRjaGVyT25Nb3VudC51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG5Ib29rc0Rpc3BhdGNoZXJPbk1vdW50LnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5Ib29rc0Rpc3BhdGNoZXJPbk1vdW50LnVzZUZvcm1TdGF0ZSA9IG1vdW50QWN0aW9uU3RhdGU7XG5Ib29rc0Rpc3BhdGNoZXJPbk1vdW50LnVzZUFjdGlvblN0YXRlID0gbW91bnRBY3Rpb25TdGF0ZTtcbkhvb2tzRGlzcGF0Y2hlck9uTW91bnQudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiAwLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IG51bGxcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICBob29rID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChcbiAgICBudWxsLFxuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgITAsXG4gICAgcXVldWVcbiAgKTtcbiAgcXVldWUuZGlzcGF0Y2ggPSBob29rO1xuICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBob29rXTtcbn07XG52YXIgSG9va3NEaXNwYXRjaGVyT25VcGRhdGUgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlOiB1c2UsXG4gIHVzZUNhbGxiYWNrOiB1cGRhdGVDYWxsYmFjayxcbiAgdXNlQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZUVmZmVjdDogdXBkYXRlRWZmZWN0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlLFxuICB1c2VJbnNlcnRpb25FZmZlY3Q6IHVwZGF0ZUluc2VydGlvbkVmZmVjdCxcbiAgdXNlTGF5b3V0RWZmZWN0OiB1cGRhdGVMYXlvdXRFZmZlY3QsXG4gIHVzZU1lbW86IHVwZGF0ZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVwZGF0ZVJlZHVjZXIsXG4gIHVzZVJlZjogdXBkYXRlUmVmLFxuICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgfSxcbiAgdXNlRGVidWdWYWx1ZTogbW91bnREZWJ1Z1ZhbHVlLFxuICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKFxuICAgICAgaG9vayxcbiAgICAgIGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGluaXRpYWxWYWx1ZVxuICAgICk7XG4gIH0sXG4gIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9vbGVhbk9yVGhlbmFibGUgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXSxcbiAgICAgIHN0YXJ0ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICByZXR1cm4gW1xuICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICA/IGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgIDogdXNlVGhlbmFibGUoYm9vbGVhbk9yVGhlbmFibGUpLFxuICAgICAgc3RhcnRcbiAgICBdO1xuICB9LFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdXBkYXRlU3luY0V4dGVybmFsU3RvcmUsXG4gIHVzZUlkOiB1cGRhdGVJZFxufTtcbkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlLnVzZUNhY2hlUmVmcmVzaCA9IHVwZGF0ZVJlZnJlc2g7XG5Ib29rc0Rpc3BhdGNoZXJPblVwZGF0ZS51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG5Ib29rc0Rpc3BhdGNoZXJPblVwZGF0ZS51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuSG9va3NEaXNwYXRjaGVyT25VcGRhdGUudXNlRm9ybVN0YXRlID0gdXBkYXRlQWN0aW9uU3RhdGU7XG5Ib29rc0Rpc3BhdGNoZXJPblVwZGF0ZS51c2VBY3Rpb25TdGF0ZSA9IHVwZGF0ZUFjdGlvblN0YXRlO1xuSG9va3NEaXNwYXRjaGVyT25VcGRhdGUudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudEhvb2ssIHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbn07XG52YXIgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2U6IHVzZSxcbiAgdXNlQ2FsbGJhY2s6IHVwZGF0ZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlRWZmZWN0OiB1cGRhdGVFZmZlY3QsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogdXBkYXRlSW5zZXJ0aW9uRWZmZWN0LFxuICB1c2VMYXlvdXRFZmZlY3Q6IHVwZGF0ZUxheW91dEVmZmVjdCxcbiAgdXNlTWVtbzogdXBkYXRlTWVtbyxcbiAgdXNlUmVkdWNlcjogcmVyZW5kZXJSZWR1Y2VyLFxuICB1c2VSZWY6IHVwZGF0ZVJlZixcbiAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgfSxcbiAgdXNlRGVidWdWYWx1ZTogbW91bnREZWJ1Z1ZhbHVlLFxuICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgcmV0dXJuIG51bGwgPT09IGN1cnJlbnRIb29rXG4gICAgICA/IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSlcbiAgICAgIDogdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoXG4gICAgICAgICAgaG9vayxcbiAgICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGluaXRpYWxWYWx1ZVxuICAgICAgICApO1xuICB9LFxuICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvb2xlYW5PclRoZW5hYmxlID0gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXSxcbiAgICAgIHN0YXJ0ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICByZXR1cm4gW1xuICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICA/IGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgIDogdXNlVGhlbmFibGUoYm9vbGVhbk9yVGhlbmFibGUpLFxuICAgICAgc3RhcnRcbiAgICBdO1xuICB9LFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdXBkYXRlU3luY0V4dGVybmFsU3RvcmUsXG4gIHVzZUlkOiB1cGRhdGVJZFxufTtcbkhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXIudXNlQ2FjaGVSZWZyZXNoID0gdXBkYXRlUmVmcmVzaDtcbkhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXIudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlci51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlci51c2VGb3JtU3RhdGUgPSByZXJlbmRlckFjdGlvblN0YXRlO1xuSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlci51c2VBY3Rpb25TdGF0ZSA9IHJlcmVuZGVyQWN0aW9uU3RhdGU7XG5Ib29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaWYgKG51bGwgIT09IGN1cnJlbnRIb29rKVxuICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBob29rLnF1ZXVlLmRpc3BhdGNoXTtcbn07XG5mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIGN0b3IsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgbmV4dFByb3BzXG4pIHtcbiAgY3RvciA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIGN0b3IpO1xuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPVxuICAgIG51bGwgPT09IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fCB2b2lkIDAgPT09IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuICAgICAgPyBjdG9yXG4gICAgICA6IGFzc2lnbih7fSwgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgMCA9PT0gd29ya0luUHJvZ3Jlc3MubGFuZXMgJiZcbiAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKTtcbn1cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHJldHVybiAoY29tcG9uZW50ID0gY29tcG9uZW50Ll9yZWFjdEludGVybmFscylcbiAgICAgID8gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihjb21wb25lbnQpID09PSBjb21wb25lbnRcbiAgICAgIDogITE7XG4gIH0sXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoKSxcbiAgICAgIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJiBudWxsICE9PSBjYWxsYmFjayAmJiAodXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2spO1xuICAgIHBheWxvYWQgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgbnVsbCAhPT0gcGF5bG9hZCAmJlxuICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXlsb2FkLCBpbnN0LCBsYW5lKSxcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocGF5bG9hZCwgaW5zdCwgbGFuZSkpO1xuICB9LFxuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZSgpLFxuICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgIHVwZGF0ZS50YWcgPSAxO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmIG51bGwgIT09IGNhbGxiYWNrICYmICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjayk7XG4gICAgcGF5bG9hZCA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICBudWxsICE9PSBwYXlsb2FkICYmXG4gICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBheWxvYWQsIGluc3QsIGxhbmUpLFxuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhwYXlsb2FkLCBpbnN0LCBsYW5lKSk7XG4gIH0sXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoKSxcbiAgICAgIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gMjtcbiAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmIG51bGwgIT09IGNhbGxiYWNrICYmICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjayk7XG4gICAgY2FsbGJhY2sgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoY2FsbGJhY2ssIGluc3QsIGxhbmUpLFxuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhjYWxsYmFjaywgaW5zdCwgbGFuZSkpO1xuICB9XG59O1xuZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gIHdvcmtJblByb2dyZXNzLFxuICBjdG9yLFxuICBvbGRQcm9wcyxcbiAgbmV3UHJvcHMsXG4gIG9sZFN0YXRlLFxuICBuZXdTdGF0ZSxcbiAgbmV4dENvbnRleHRcbikge1xuICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHdvcmtJblByb2dyZXNzLnNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAgID8gd29ya0luUHJvZ3Jlc3Muc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpXG4gICAgOiBjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudFxuICAgICAgPyAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpXG4gICAgICA6ICEwO1xufVxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gIHdvcmtJblByb2dyZXNzLFxuICBpbnN0YW5jZSxcbiAgbmV3UHJvcHMsXG4gIG5leHRDb250ZXh0XG4pIHtcbiAgd29ya0luUHJvZ3Jlc3MgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICBpbnN0YW5jZS5zdGF0ZSAhPT0gd29ya0luUHJvZ3Jlc3MgJiZcbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMpIHtcbiAgdmFyIG5ld1Byb3BzID0gYmFzZVByb3BzO1xuICBpZiAoXCJyZWZcIiBpbiBiYXNlUHJvcHMpIHtcbiAgICBuZXdQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGJhc2VQcm9wcylcbiAgICAgIFwicmVmXCIgIT09IHByb3BOYW1lICYmIChuZXdQcm9wc1twcm9wTmFtZV0gPSBiYXNlUHJvcHNbcHJvcE5hbWVdKTtcbiAgfVxuICBpZiAoKENvbXBvbmVudCA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHMpKSB7XG4gICAgbmV3UHJvcHMgPT09IGJhc2VQcm9wcyAmJiAobmV3UHJvcHMgPSBhc3NpZ24oe30sIG5ld1Byb3BzKSk7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUkNjcgaW4gQ29tcG9uZW50KVxuICAgICAgdm9pZCAwID09PSBuZXdQcm9wc1twcm9wTmFtZSQ2N10gJiZcbiAgICAgICAgKG5ld1Byb3BzW3Byb3BOYW1lJDY3XSA9IENvbXBvbmVudFtwcm9wTmFtZSQ2N10pO1xuICB9XG4gIHJldHVybiBuZXdQcm9wcztcbn1cbnZhciByZXBvcnRHbG9iYWxFcnJvciA9XG4gIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlcG9ydEVycm9yXG4gICAgPyByZXBvcnRFcnJvclxuICAgIDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygd2luZG93ICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd2luZG93LkVycm9yRXZlbnRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IHdpbmRvdy5FcnJvckV2ZW50KFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgYnViYmxlczogITAsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiAhMCxcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCF3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCkpIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvY2VzcyAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByb2Nlc3MuZW1pdFxuICAgICAgICApIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfTtcbmZ1bmN0aW9uIGRlZmF1bHRPblVuY2F1Z2h0RXJyb3IoZXJyb3IpIHtcbiAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9uQ2F1Z2h0RXJyb3IoZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yKGVycm9yKSB7XG4gIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbn1cbmZ1bmN0aW9uIGxvZ1VuY2F1Z2h0RXJyb3Iocm9vdCwgZXJyb3JJbmZvKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9uVW5jYXVnaHRFcnJvciA9IHJvb3Qub25VbmNhdWdodEVycm9yO1xuICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvckluZm8udmFsdWUsIHsgY29tcG9uZW50U3RhY2s6IGVycm9ySW5mby5zdGFjayB9KTtcbiAgfSBjYXRjaCAoZSQ2OCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZSQ2ODtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgYm91bmRhcnksIGVycm9ySW5mbykge1xuICB0cnkge1xuICAgIHZhciBvbkNhdWdodEVycm9yID0gcm9vdC5vbkNhdWdodEVycm9yO1xuICAgIG9uQ2F1Z2h0RXJyb3IoZXJyb3JJbmZvLnZhbHVlLCB7XG4gICAgICBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrLFxuICAgICAgZXJyb3JCb3VuZGFyeTogMSA9PT0gYm91bmRhcnkudGFnID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbFxuICAgIH0pO1xuICB9IGNhdGNoIChlJDY5KSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlJDY5O1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdCwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gIGxhbmUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gIGxhbmUudGFnID0gMztcbiAgbGFuZS5wYXlsb2FkID0geyBlbGVtZW50OiBudWxsIH07XG4gIGxhbmUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9nVW5jYXVnaHRFcnJvcihyb290LCBlcnJvckluZm8pO1xuICB9O1xuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSkge1xuICBsYW5lID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICBsYW5lLnRhZyA9IDM7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUodXBkYXRlLCByb290LCBmaWJlciwgZXJyb3JJbmZvKSB7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmaWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcikge1xuICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgZmliZXIsIGVycm9ySW5mbyk7XG4gICAgfTtcbiAgfVxuICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgbnVsbCAhPT0gaW5zdCAmJlxuICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3QuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAodXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgJiZcbiAgICAgICAgKG51bGwgPT09IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkXG4gICAgICAgICAgPyAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFt0aGlzXSkpXG4gICAgICAgICAgOiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQodGhpcykpO1xuICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgdGhpcy5jb21wb25lbnREaWRDYXRjaChlcnJvckluZm8udmFsdWUsIHtcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IG51bGwgIT09IHN0YWNrID8gc3RhY2sgOiBcIlwiXG4gICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKFxuICByb290LFxuICByZXR1cm5GaWJlcixcbiAgc291cmNlRmliZXIsXG4gIHZhbHVlLFxuICByb290UmVuZGVyTGFuZXNcbikge1xuICBzb3VyY2VGaWJlci5mbGFncyB8PSAzMjc2ODtcbiAgaWYgKFxuICAgIG51bGwgIT09IHZhbHVlICYmXG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUudGhlblxuICApIHtcbiAgICByZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcbiAgICBudWxsICE9PSByZXR1cm5GaWJlciAmJlxuICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgcm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAhMFxuICAgICAgKTtcbiAgICBzb3VyY2VGaWJlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgaWYgKG51bGwgIT09IHNvdXJjZUZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKHNvdXJjZUZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5XG4gICAgICAgICAgICAgID8gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpXG4gICAgICAgICAgICAgIDogbnVsbCA9PT0gc291cmNlRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gMyksXG4gICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgJj0gLTI1NyksXG4gICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzID0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIHZhbHVlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGVcbiAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIuZmxhZ3MgfD0gMTYzODQpXG4gICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBuZXcgU2V0KFt2YWx1ZV0pKVxuICAgICAgICAgICAgICAgICAgOiByZXR1cm5GaWJlci5hZGQodmFsdWUpLFxuICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAhMVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICB2YWx1ZSA9PT0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlXG4gICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDE2Mzg0KVxuICAgICAgICAgICAgICA6ICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgID8gKChyZXR1cm5GaWJlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgcmV0cnlRdWV1ZTogbmV3IFNldChbdmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gcmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICAgICAgOiAoKHNvdXJjZUZpYmVyID0gcmV0dXJuRmliZXIucmV0cnlRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAocmV0dXJuRmliZXIucmV0cnlRdWV1ZSA9IG5ldyBTZXQoW3ZhbHVlXSkpXG4gICAgICAgICAgICAgICAgICAgICAgOiBzb3VyY2VGaWJlci5hZGQodmFsdWUpKSxcbiAgICAgICAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MzUsIHNvdXJjZUZpYmVyLnRhZykpO1xuICAgIH1cbiAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBpZiAoaXNIeWRyYXRpbmcpXG4gICAgcmV0dXJuIChcbiAgICAgIChyZXR1cm5GaWJlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXJcbiAgICAgICAgPyAoMCA9PT0gKHJldHVybkZpYmVyLmZsYWdzICYgNjU1MzYpICYmIChyZXR1cm5GaWJlci5mbGFncyB8PSAyNTYpLFxuICAgICAgICAgIChyZXR1cm5GaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgKHJldHVybkZpYmVyLmxhbmVzID0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICB2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gJiZcbiAgICAgICAgICAgICgocm9vdCA9IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDIyKSwgeyBjYXVzZTogdmFsdWUgfSkpLFxuICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihyb290LCBzb3VyY2VGaWJlcikpKSlcbiAgICAgICAgOiAodmFsdWUgIT09IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uICYmXG4gICAgICAgICAgICAoKHJldHVybkZpYmVyID0gRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MjMpLCB7XG4gICAgICAgICAgICAgIGNhdXNlOiB2YWx1ZVxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIocmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyKVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgKHJvb3QgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAocm9vdC5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyAmPSAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAocm9vdC5sYW5lcyB8PSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICh2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcikpLFxuICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoXG4gICAgICAgICAgICByb290LnN0YXRlTm9kZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHJvb3QsIHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgNCAhPT0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAyKSksXG4gICAgICAhMVxuICAgICk7XG4gIHZhciB3cmFwcGVyRXJyb3IgPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUyMCksIHsgY2F1c2U6IHZhbHVlIH0pO1xuICB3cmFwcGVyRXJyb3IgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih3cmFwcGVyRXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9yc1xuICAgID8gKHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBbd3JhcHBlckVycm9yXSlcbiAgICA6IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMucHVzaCh3cmFwcGVyRXJyb3IpO1xuICA0ICE9PSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICYmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gMik7XG4gIGlmIChudWxsID09PSByZXR1cm5GaWJlcikgcmV0dXJuICEwO1xuICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gIHNvdXJjZUZpYmVyID0gcmV0dXJuRmliZXI7XG4gIGRvIHtcbiAgICBzd2l0Y2ggKHNvdXJjZUZpYmVyLnRhZykge1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgKHJvb3QgPSByb290UmVuZGVyTGFuZXMgJiAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgfD0gcm9vdCksXG4gICAgICAgICAgKHJvb3QgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoc291cmNlRmliZXIuc3RhdGVOb2RlLCB2YWx1ZSwgcm9vdCkpLFxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShzb3VyY2VGaWJlciwgcm9vdCksXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci50eXBlKSxcbiAgICAgICAgICAod3JhcHBlckVycm9yID0gc291cmNlRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAwID09PSAoc291cmNlRmliZXIuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuRmliZXIuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAgIChudWxsICE9PSB3cmFwcGVyRXJyb3IgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3cmFwcGVyRXJyb3IuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgfHxcbiAgICAgICAgICAgICAgICAgICFsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMod3JhcHBlckVycm9yKSkpKSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyAmPSAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyB8PSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUocm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUoc291cmNlRmliZXIsIHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAhMVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIHNvdXJjZUZpYmVyID0gc291cmNlRmliZXIucmV0dXJuO1xuICB9IHdoaWxlIChudWxsICE9PSBzb3VyY2VGaWJlcik7XG4gIHJldHVybiAhMTtcbn1cbnZhciBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24gPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ2MSkpLFxuICBkaWRSZWNlaXZlVXBkYXRlID0gITE7XG5mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9XG4gICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgPyBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKVxuICAgICAgOiByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBjdXJyZW50LmNoaWxkLFxuICAgICAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApO1xufVxuZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIENvbXBvbmVudCxcbiAgbmV4dFByb3BzLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIENvbXBvbmVudCA9IENvbXBvbmVudC5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIGlmIChcInJlZlwiIGluIG5leHRQcm9wcykge1xuICAgIHZhciBwcm9wc1dpdGhvdXRSZWYgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmV4dFByb3BzKVxuICAgICAgXCJyZWZcIiAhPT0ga2V5ICYmIChwcm9wc1dpdGhvdXRSZWZba2V5XSA9IG5leHRQcm9wc1trZXldKTtcbiAgfSBlbHNlIHByb3BzV2l0aG91dFJlZiA9IG5leHRQcm9wcztcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICBuZXh0UHJvcHMgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgY3VycmVudCxcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICBDb21wb25lbnQsXG4gICAgcHJvcHNXaXRob3V0UmVmLFxuICAgIHJlZixcbiAgICByZW5kZXJMYW5lc1xuICApO1xuICBrZXkgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICByZXR1cm4gKFxuICAgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICApO1xuICBpc0h5ZHJhdGluZyAmJiBrZXkgJiYgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIENvbXBvbmVudCxcbiAgbmV4dFByb3BzLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICBpZiAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAhc2hvdWxkQ29uc3RydWN0KHR5cGUpICYmXG4gICAgICB2b2lkIDAgPT09IHR5cGUuZGVmYXVsdFByb3BzICYmXG4gICAgICBudWxsID09PSBDb21wb25lbnQuY29tcGFyZVxuICAgIClcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy50YWcgPSAxNSksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gdHlwZSksXG4gICAgICAgIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApXG4gICAgICApO1xuICAgIGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICBDb21wb25lbnQudHlwZSxcbiAgICAgIG51bGwsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICk7XG4gICAgY3VycmVudC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgY3VycmVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudCk7XG4gIH1cbiAgdHlwZSA9IGN1cnJlbnQuY2hpbGQ7XG4gIGlmICghY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IHR5cGUubWVtb2l6ZWRQcm9wcztcbiAgICBDb21wb25lbnQgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICBDb21wb25lbnQgPSBudWxsICE9PSBDb21wb25lbnQgPyBDb21wb25lbnQgOiBzaGFsbG93RXF1YWw7XG4gICAgaWYgKENvbXBvbmVudChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZilcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgY3VycmVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHR5cGUsIG5leHRQcm9wcyk7XG4gIGN1cnJlbnQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudCk7XG59XG5mdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgQ29tcG9uZW50LFxuICBuZXh0UHJvcHMsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIGlmIChcbiAgICAgIHNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiZcbiAgICAgIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWZcbiAgICApXG4gICAgICBpZiAoXG4gICAgICAgICgoZGlkUmVjZWl2ZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG5leHRQcm9wcyA9IHByZXZQcm9wcyksXG4gICAgICAgIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSlcbiAgICAgIClcbiAgICAgICAgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMzEwNzIpICYmIChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXMpLFxuICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICApO1xuICB9XG4gIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICBjdXJyZW50LFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIENvbXBvbmVudCxcbiAgICBuZXh0UHJvcHMsXG4gICAgcmVuZGVyTGFuZXNcbiAgKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW4sXG4gICAgbmV4dElzRGV0YWNoZWQgPSAwICE9PSAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIDIpLFxuICAgIHByZXZTdGF0ZSA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKFwiaGlkZGVuXCIgPT09IG5leHRQcm9wcy5tb2RlIHx8IG5leHRJc0RldGFjaGVkKSB7XG4gICAgaWYgKDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkpIHtcbiAgICAgIG5leHRQcm9wcyA9XG4gICAgICAgIG51bGwgIT09IHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lcyA6IHJlbmRlckxhbmVzO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgICBmb3IgKG5leHRJc0RldGFjaGVkID0gMDsgbnVsbCAhPT0gbmV4dENoaWxkcmVuOyApXG4gICAgICAgICAgKG5leHRJc0RldGFjaGVkID1cbiAgICAgICAgICAgIG5leHRJc0RldGFjaGVkIHwgbmV4dENoaWxkcmVuLmxhbmVzIHwgbmV4dENoaWxkcmVuLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgKG5leHRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbi5zaWJsaW5nKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IG5leHRJc0RldGFjaGVkICYgfm5leHRQcm9wcztcbiAgICAgIH0gZWxzZSAod29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IDApLCAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsKTtcbiAgICAgIHJldHVybiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICgwICE9PSAocmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpKVxuICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7IGJhc2VMYW5lczogMCwgY2FjaGVQb29sOiBudWxsIH0pLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgcHVzaFRyYW5zaXRpb24oXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5jYWNoZVBvb2wgOiBudWxsXG4gICAgICAgICAgKSxcbiAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgPyBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKVxuICAgICAgICAgIDogcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjaygpLFxuICAgICAgICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gKFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gNTM2ODcwOTEyKSxcbiAgICAgICAgZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGUgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXMgOiByZW5kZXJMYW5lcyxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApXG4gICAgICApO1xuICB9IGVsc2VcbiAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgID8gKHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUuY2FjaGVQb29sKSxcbiAgICAgICAgcHVzaEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZSksXG4gICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCkpXG4gICAgICA6IChudWxsICE9PSBjdXJyZW50ICYmIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKSxcbiAgICAgICAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjaygpLFxuICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5mdW5jdGlvbiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIG5leHRCYXNlTGFuZXMsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG4gIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgbnVsbCA9PT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICA/IG51bGxcbiAgICAgIDogeyBwYXJlbnQ6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlLCBwb29sOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgfTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICBiYXNlTGFuZXM6IG5leHRCYXNlTGFuZXMsXG4gICAgY2FjaGVQb29sOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgfTtcbiAgbnVsbCAhPT0gY3VycmVudCAmJiBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2soKTtcbiAgcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsICEwKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIGlmIChudWxsID09PSByZWYpXG4gICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgbnVsbCAhPT0gY3VycmVudC5yZWYgJiZcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDk3NjY0KTtcbiAgZWxzZSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHJlZiAmJiBcIm9iamVjdFwiICE9PSB0eXBlb2YgcmVmKVxuICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyODQpKTtcbiAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKVxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA5NzY2NDtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gIGN1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIG5leHRQcm9wcyxcbiAgcmVuZGVyTGFuZXNcbikge1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIENvbXBvbmVudCA9IHJlbmRlcldpdGhIb29rcyhcbiAgICBjdXJyZW50LFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIENvbXBvbmVudCxcbiAgICBuZXh0UHJvcHMsXG4gICAgdm9pZCAwLFxuICAgIHJlbmRlckxhbmVzXG4gICk7XG4gIG5leHRQcm9wcyA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgIHJldHVybiAoXG4gICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICk7XG4gIGlzSHlkcmF0aW5nICYmIG5leHRQcm9wcyAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5mdW5jdGlvbiByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIG5leHRQcm9wcyxcbiAgQ29tcG9uZW50LFxuICBzZWNvbmRBcmcsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIG5leHRQcm9wcyA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIENvbXBvbmVudCxcbiAgICBuZXh0UHJvcHMsXG4gICAgc2Vjb25kQXJnXG4gICk7XG4gIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQpO1xuICBDb21wb25lbnQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICByZXR1cm4gKFxuICAgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICApO1xuICBpc0h5ZHJhdGluZyAmJiBDb21wb25lbnQgJiYgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gIGN1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIG5leHRQcm9wcyxcbiAgcmVuZGVyTGFuZXNcbikge1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgIGNvbnRleHRUeXBlID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjb250ZXh0VHlwZSAmJlxuICAgICAgbnVsbCAhPT0gY29udGV4dFR5cGUgJiZcbiAgICAgIChjb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpKTtcbiAgICBjb250ZXh0ID0gbmV3IENvbXBvbmVudChuZXh0UHJvcHMsIGNvbnRleHQpO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgbnVsbCAhPT0gY29udGV4dC5zdGF0ZSAmJiB2b2lkIDAgIT09IGNvbnRleHQuc3RhdGUgPyBjb250ZXh0LnN0YXRlIDogbnVsbDtcbiAgICBjb250ZXh0LnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY29udGV4dDtcbiAgICBjb250ZXh0Ll9yZWFjdEludGVybmFscyA9IHdvcmtJblByb2dyZXNzO1xuICAgIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgY29udGV4dC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBjb250ZXh0LnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBjb250ZXh0LnJlZnMgPSB7fTtcbiAgICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICAgIGNvbnRleHRUeXBlID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgIGNvbnRleHQuY29udGV4dCA9XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY29udGV4dFR5cGUgJiYgbnVsbCAhPT0gY29udGV4dFR5cGVcbiAgICAgICAgPyByZWFkQ29udGV4dChjb250ZXh0VHlwZSlcbiAgICAgICAgOiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgY29udGV4dC5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgY29udGV4dFR5cGUgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHRUeXBlICYmXG4gICAgICAoYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGNvbnRleHRUeXBlLFxuICAgICAgICBuZXh0UHJvcHNcbiAgICAgICksXG4gICAgICAoY29udGV4dC5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKTtcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250ZXh0LmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50V2lsbE1vdW50KSB8fFxuICAgICAgKChjb250ZXh0VHlwZSA9IGNvbnRleHQuc3RhdGUpLFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgY29udGV4dC5jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgIGNvbnRleHRUeXBlICE9PSBjb250ZXh0LnN0YXRlICYmXG4gICAgICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGNvbnRleHQsIGNvbnRleHQuc3RhdGUsIG51bGwpLFxuICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIGNvbnRleHQsIHJlbmRlckxhbmVzKSxcbiAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKSxcbiAgICAgIChjb250ZXh0LnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpO1xuICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KTtcbiAgICBuZXh0UHJvcHMgPSAhMDtcbiAgfSBlbHNlIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxcbiAgICAgIG9sZFByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCB1bnJlc29sdmVkT2xkUHJvcHMpO1xuICAgIGNvbnRleHQucHJvcHMgPSBvbGRQcm9wcztcbiAgICB2YXIgb2xkQ29udGV4dCA9IGNvbnRleHQuY29udGV4dCxcbiAgICAgIGNvbnRleHRUeXBlJGpzY29tcCQwID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgIGNvbnRleHRUeXBlID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjb250ZXh0VHlwZSRqc2NvbXAkMCAmJlxuICAgICAgbnVsbCAhPT0gY29udGV4dFR5cGUkanNjb21wJDAgJiZcbiAgICAgIChjb250ZXh0VHlwZSA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlJGpzY29tcCQwKSk7XG4gICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgY29udGV4dFR5cGUkanNjb21wJDAgPVxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250ZXh0LmdldFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuICAgIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyAhPT0gdW5yZXNvbHZlZE9sZFByb3BzO1xuICAgIGNvbnRleHRUeXBlJGpzY29tcCQwIHx8XG4gICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHx8XG4gICAgICAoKHVucmVzb2x2ZWRPbGRQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBjb250ZXh0VHlwZSkgJiZcbiAgICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgY29udGV4dFR5cGVcbiAgICAgICAgKSk7XG4gICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIGNvbnRleHQuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICBvbGRDb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICB1bnJlc29sdmVkT2xkUHJvcHMgfHwgb2xkU3RhdGUgIT09IG9sZENvbnRleHQgfHwgaGFzRm9yY2VVcGRhdGVcbiAgICAgID8gKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgKSxcbiAgICAgICAgICAob2xkQ29udGV4dCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKSxcbiAgICAgICAgKG9sZFByb3BzID1cbiAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgICAgICAgIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgICAgb2xkQ29udGV4dCxcbiAgICAgICAgICAgIGNvbnRleHRUeXBlXG4gICAgICAgICAgKSlcbiAgICAgICAgICA/IChjb250ZXh0VHlwZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnRXaWxsTW91bnQpIHx8XG4gICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgIGNvbnRleHQuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpKSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpKVxuICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBvbGRDb250ZXh0KSksXG4gICAgICAgIChjb250ZXh0LnByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgKGNvbnRleHQuc3RhdGUgPSBvbGRDb250ZXh0KSxcbiAgICAgICAgKGNvbnRleHQuY29udGV4dCA9IGNvbnRleHRUeXBlKSxcbiAgICAgICAgKG5leHRQcm9wcyA9IG9sZFByb3BzKSlcbiAgICAgIDogKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgIChuZXh0UHJvcHMgPSAhMSkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgY29udGV4dFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIGNvbnRleHRUeXBlJGpzY29tcCQwID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCBjb250ZXh0VHlwZSk7XG4gICAgY29udGV4dC5wcm9wcyA9IGNvbnRleHRUeXBlJGpzY29tcCQwO1xuICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBvbGRTdGF0ZSA9IGNvbnRleHQuY29udGV4dDtcbiAgICBvbGRDb250ZXh0ID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgIG9sZFByb3BzID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvbGRDb250ZXh0ICYmXG4gICAgICBudWxsICE9PSBvbGRDb250ZXh0ICYmXG4gICAgICAob2xkUHJvcHMgPSByZWFkQ29udGV4dChvbGRDb250ZXh0KSk7XG4gICAgdW5yZXNvbHZlZE9sZFByb3BzID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAob2xkQ29udGV4dCA9XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1bnJlc29sdmVkT2xkUHJvcHMgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUpIHx8XG4gICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHx8XG4gICAgICAoKGNvbnRleHRUeXBlICE9PSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHwgb2xkU3RhdGUgIT09IG9sZFByb3BzKSAmJlxuICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICBvbGRQcm9wc1xuICAgICAgICApKTtcbiAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBjb250ZXh0LnN0YXRlID0gb2xkU3RhdGU7XG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBjb250ZXh0VHlwZSAhPT0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgb2xkU3RhdGUgIT09IG5ld1N0YXRlIHx8XG4gICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAobnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgbnVsbCAhPT0gY3VycmVudC5kZXBlbmRlbmNpZXMgJiZcbiAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50LmRlcGVuZGVuY2llcykpXG4gICAgICA/IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1bnJlc29sdmVkT2xkUHJvcHMgJiZcbiAgICAgICAgICAoYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyxcbiAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICksXG4gICAgICAgICAgKG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpLFxuICAgICAgICAoY29udGV4dFR5cGUkanNjb21wJDAgPVxuICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgICAgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIGNvbnRleHRUeXBlJGpzY29tcCQwLFxuICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgIG9sZFByb3BzXG4gICAgICAgICAgKSB8fFxuICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50LmRlcGVuZGVuY2llcyAmJlxuICAgICAgICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQuZGVwZW5kZW5jaWVzKSkpXG4gICAgICAgICAgPyAob2xkQ29udGV4dCB8fFxuICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50V2lsbFVwZGF0ZSkgfHxcbiAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5ld1N0YXRlLCBvbGRQcm9wcyksXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICBvbGRQcm9wc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRVcGRhdGUgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCkpXG4gICAgICAgICAgOiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAgICAgKGNvbnRleHRUeXBlID09PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgICAgIChjb250ZXh0VHlwZSA9PT0gY3VycmVudC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZSkpLFxuICAgICAgICAoY29udGV4dC5wcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgIChjb250ZXh0LnN0YXRlID0gbmV3U3RhdGUpLFxuICAgICAgICAoY29udGV4dC5jb250ZXh0ID0gb2xkUHJvcHMpLFxuICAgICAgICAobmV4dFByb3BzID0gY29udGV4dFR5cGUkanNjb21wJDApKVxuICAgICAgOiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAoY29udGV4dFR5cGUgPT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNvbnRleHQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAoY29udGV4dFR5cGUgPT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgIChuZXh0UHJvcHMgPSAhMSkpO1xuICB9XG4gIGNvbnRleHQgPSBuZXh0UHJvcHM7XG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICBuZXh0UHJvcHMgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpO1xuICBjb250ZXh0IHx8IG5leHRQcm9wc1xuICAgID8gKChjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKSxcbiAgICAgIChDb21wb25lbnQgPVxuICAgICAgICBuZXh0UHJvcHMgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvclxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogY29udGV4dC5yZW5kZXIoKSksXG4gICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMSksXG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmIG5leHRQcm9wc1xuICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgY3VycmVudC5jaGlsZCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApKSlcbiAgICAgICAgOiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcyksXG4gICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGNvbnRleHQuc3RhdGUpLFxuICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCkpXG4gICAgOiAoY3VycmVudCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKSk7XG4gIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoXG4gIGN1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICBuZXh0Q2hpbGRyZW4sXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyNTY7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxudmFyIFNVU1BFTkRFRF9NQVJLRVIgPSB7IGRlaHlkcmF0ZWQ6IG51bGwsIHRyZWVDb250ZXh0OiBudWxsLCByZXRyeUxhbmU6IDAgfTtcbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykge1xuICByZXR1cm4geyBiYXNlTGFuZXM6IHJlbmRlckxhbmVzLCBjYWNoZVBvb2w6IGdldFN1c3BlbmRlZENhY2hlKCkgfTtcbn1cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICBjdXJyZW50LFxuICBwcmltYXJ5VHJlZURpZERlZmVyLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5jaGlsZExhbmVzICYgfnJlbmRlckxhbmVzIDogMDtcbiAgcHJpbWFyeVRyZWVEaWREZWZlciAmJiAoY3VycmVudCB8PSB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgc2hvd0ZhbGxiYWNrID0gITEsXG4gICAgZGlkU3VzcGVuZCA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCksXG4gICAgSlNDb21waWxlcl90ZW1wO1xuICAoSlNDb21waWxlcl90ZW1wID0gZGlkU3VzcGVuZCkgfHxcbiAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgID8gITFcbiAgICAgICAgOiAwICE9PSAoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICYgMikpO1xuICBKU0NvbXBpbGVyX3RlbXAgJiYgKChzaG93RmFsbGJhY2sgPSAhMCksICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTI5KSk7XG4gIEpTQ29tcGlsZXJfdGVtcCA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDMyKTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTMzO1xuICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgc2hvd0ZhbGxiYWNrXG4gICAgICAgID8gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKVxuICAgICAgICA6IHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgICAgICAgSlNDb21waWxlcl90ZW1wJGpzY29tcCQwO1xuICAgICAgICBpZiAoKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IG5leHRJbnN0YW5jZSkpIHtcbiAgICAgICAgICBjOiB7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBuZXh0SW5zdGFuY2U7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBuZXh0SW5zdGFuY2UgPSByb290T3JTaW5nbGV0b25Db250ZXh0O1xuICAgICAgICAgICAgICA4ICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAubm9kZVR5cGU7XG5cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIG5leHRJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBnZXROZXh0SHlkcmF0YWJsZShcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICAgIG5leHRJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEluc3RhbmNlID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudWxsICE9PSBuZXh0SW5zdGFuY2VcbiAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgICAgIGRlaHlkcmF0ZWQ6IG5leHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICB0cmVlQ29udGV4dDpcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHRyZWVDb250ZXh0UHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgPyB7IGlkOiB0cmVlQ29udGV4dElkLCBvdmVyZmxvdzogdHJlZUNvbnRleHRPdmVyZmxvdyB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICByZXRyeUxhbmU6IDUzNjg3MDkxMlxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKFxuICAgICAgICAgICAgICAgIDE4LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnN0YXRlTm9kZSA9IG5leHRJbnN0YW5jZSksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDApLFxuICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhMCkpXG4gICAgICAgICAgICA6IChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhMSk7XG4gICAgICAgIH1cbiAgICAgICAgSlNDb21waWxlcl90ZW1wJGpzY29tcCQwIHx8IHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBuZXh0SW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBuZXh0SW5zdGFuY2UgJiZcbiAgICAgICAgKChuZXh0SW5zdGFuY2UgPSBuZXh0SW5zdGFuY2UuZGVoeWRyYXRlZCksIG51bGwgIT09IG5leHRJbnN0YW5jZSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBcIiQhXCIgPT09IG5leHRJbnN0YW5jZS5kYXRhXG4gICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDE2KVxuICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA1MzY4NzA5MTIpLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIG5leHRJbnN0YW5jZSA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICBuZXh0UHJvcHMgPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgaWYgKHNob3dGYWxsYmFjaylcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIChzaG93RmFsbGJhY2sgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlKSxcbiAgICAgICAgKG5leHRJbnN0YW5jZSA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgICB7IG1vZGU6IFwiaGlkZGVuXCIsIGNoaWxkcmVuOiBuZXh0SW5zdGFuY2UgfSxcbiAgICAgICAgICBzaG93RmFsbGJhY2tcbiAgICAgICAgKSksXG4gICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKSksXG4gICAgICAgIChuZXh0SW5zdGFuY2UucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgKG5leHRJbnN0YW5jZS5zaWJsaW5nID0gbmV4dFByb3BzKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dEluc3RhbmNlKSxcbiAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgKHNob3dGYWxsYmFjay5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSksXG4gICAgICAgIChzaG93RmFsbGJhY2suY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgSlNDb21waWxlcl90ZW1wLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICkpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVIpLFxuICAgICAgICBuZXh0UHJvcHNcbiAgICAgICk7XG4gICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dEluc3RhbmNlKTtcbiAgfVxuICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIGlmIChcbiAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgJiZcbiAgICAoKG5leHRJbnN0YW5jZSA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5kZWh5ZHJhdGVkKSxcbiAgICBudWxsICE9PSBuZXh0SW5zdGFuY2UpXG4gICkge1xuICAgIGlmIChkaWRTdXNwZW5kKVxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTZcbiAgICAgICAgPyAocHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTI1NyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICkpKVxuICAgICAgICA6IG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA/IChyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpKVxuICAgICAgICAgIDogKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gbmV4dFByb3BzLmZhbGxiYWNrKSxcbiAgICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgICAgICAgIHsgbW9kZTogXCJ2aXNpYmxlXCIsIGNoaWxkcmVuOiBuZXh0UHJvcHMuY2hpbGRyZW4gfSxcbiAgICAgICAgICAgICAgbmV4dEluc3RhbmNlXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICBuZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2suZmxhZ3MgfD0gMiksXG4gICAgICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKG5leHRQcm9wcy5zaWJsaW5nID0gc2hvd0ZhbGxiYWNrKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgICAgIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgKG5leHRQcm9wcy5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHNob3dGYWxsYmFjaykpO1xuICAgIGVsc2UgaWYgKFxuICAgICAgKHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICBcIiQhXCIgPT09IG5leHRJbnN0YW5jZS5kYXRhKVxuICAgICkge1xuICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgbmV4dEluc3RhbmNlLm5leHRTaWJsaW5nICYmIG5leHRJbnN0YW5jZS5uZXh0U2libGluZy5kYXRhc2V0O1xuICAgICAgaWYgKEpTQ29tcGlsZXJfdGVtcCkgdmFyIGRpZ2VzdCA9IEpTQ29tcGlsZXJfdGVtcC5kZ3N0O1xuICAgICAgSlNDb21waWxlcl90ZW1wID0gZGlnZXN0O1xuICAgICAgbmV4dFByb3BzID0gRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MTkpKTtcbiAgICAgIG5leHRQcm9wcy5zdGFjayA9IFwiXCI7XG4gICAgICBuZXh0UHJvcHMuZGlnZXN0ID0gSlNDb21waWxlcl90ZW1wO1xuICAgICAgcXVldWVIeWRyYXRpb25FcnJvcih7IHZhbHVlOiBuZXh0UHJvcHMsIHNvdXJjZTogbnVsbCwgc3RhY2s6IG51bGwgfSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIChkaWRSZWNlaXZlVXBkYXRlIHx8XG4gICAgICAgIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgITEpLFxuICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IDAgIT09IChyZW5kZXJMYW5lcyAmIGN1cnJlbnQuY2hpbGRMYW5lcykpLFxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSB8fCBKU0NvbXBpbGVyX3RlbXApXG4gICAgKSB7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICBpZiAobnVsbCAhPT0gSlNDb21waWxlcl90ZW1wKSB7XG4gICAgICAgIG5leHRQcm9wcyA9IHJlbmRlckxhbmVzICYgLXJlbmRlckxhbmVzO1xuICAgICAgICBpZiAoMCAhPT0gKG5leHRQcm9wcyAmIDQyKSkgbmV4dFByb3BzID0gMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN3aXRjaCAobmV4dFByb3BzKSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG5leHRQcm9wcyA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBuZXh0UHJvcHMgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIG5leHRQcm9wcyA9IDE2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI4OlxuICAgICAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgICAgIGNhc2UgMTAyNDpcbiAgICAgICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgICAgIGNhc2UgODE5MjpcbiAgICAgICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICAgICAgY2FzZSA2NTUzNjpcbiAgICAgICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgICAgICBjYXNlIDUyNDI4ODpcbiAgICAgICAgICAgIGNhc2UgMTA0ODU3NjpcbiAgICAgICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgICAgICBuZXh0UHJvcHMgPSA2NDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgICAgICAgbmV4dFByb3BzID0gMTM0MjE3NzI4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG5leHRQcm9wcyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICBuZXh0UHJvcHMgPVxuICAgICAgICAgIDAgIT09IChuZXh0UHJvcHMgJiAoSlNDb21waWxlcl90ZW1wLnN1c3BlbmRlZExhbmVzIHwgcmVuZGVyTGFuZXMpKVxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IG5leHRQcm9wcztcbiAgICAgICAgaWYgKDAgIT09IG5leHRQcm9wcyAmJiBuZXh0UHJvcHMgIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5yZXRyeUxhbmUpXG4gICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAucmV0cnlMYW5lID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShjdXJyZW50LCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKEpTQ29tcGlsZXJfdGVtcCwgY3VycmVudCwgbmV4dFByb3BzKSxcbiAgICAgICAgICAgIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbilcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgXCIkP1wiID09PSBuZXh0SW5zdGFuY2UuZGF0YSB8fCByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICBcIiQ/XCIgPT09IG5leHRJbnN0YW5jZS5kYXRhXG4gICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKSksXG4gICAgICAgICAgKG5leHRJbnN0YW5jZS5fcmVhY3RSZXRyeSA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBudWxsKSlcbiAgICAgICAgOiAoKGN1cnJlbnQgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAudHJlZUNvbnRleHQpLFxuICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoXG4gICAgICAgICAgICBuZXh0SW5zdGFuY2UubmV4dFNpYmxpbmdcbiAgICAgICAgICApKSxcbiAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKGlzSHlkcmF0aW5nID0gITApLFxuICAgICAgICAgIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSxcbiAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAoKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZCksXG4gICAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93KSxcbiAgICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXIpLFxuICAgICAgICAgICAgKHRyZWVDb250ZXh0SWQgPSBjdXJyZW50LmlkKSxcbiAgICAgICAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gY3VycmVudC5vdmVyZmxvdyksXG4gICAgICAgICAgICAodHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQwOTYpKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gIH1cbiAgaWYgKHNob3dGYWxsYmFjaylcbiAgICByZXR1cm4gKFxuICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgIChzaG93RmFsbGJhY2sgPSBuZXh0UHJvcHMuZmFsbGJhY2spLFxuICAgICAgKG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgKGRpZ2VzdCA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5zaWJsaW5nKSxcbiAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAsIHtcbiAgICAgICAgbW9kZTogXCJoaWRkZW5cIixcbiAgICAgICAgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlblxuICAgICAgfSkpLFxuICAgICAgKG5leHRQcm9wcy5zdWJ0cmVlRmxhZ3MgPVxuICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAuc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgbnVsbCAhPT0gZGlnZXN0XG4gICAgICAgID8gKHNob3dGYWxsYmFjayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGRpZ2VzdCwgc2hvd0ZhbGxiYWNrKSlcbiAgICAgICAgOiAoKHNob3dGYWxsYmFjayA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgbmV4dEluc3RhbmNlLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHNob3dGYWxsYmFjay5mbGFncyB8PSAyKSksXG4gICAgICAoc2hvd0ZhbGxiYWNrLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgKG5leHRQcm9wcy5zaWJsaW5nID0gc2hvd0ZhbGxiYWNrKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRQcm9wcyksXG4gICAgICAobmV4dFByb3BzID0gc2hvd0ZhbGxiYWNrKSxcbiAgICAgIChzaG93RmFsbGJhY2sgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAobmV4dEluc3RhbmNlID0gY3VycmVudC5jaGlsZC5tZW1vaXplZFN0YXRlKSxcbiAgICAgIG51bGwgPT09IG5leHRJbnN0YW5jZVxuICAgICAgICA/IChuZXh0SW5zdGFuY2UgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKVxuICAgICAgICA6ICgoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gbmV4dEluc3RhbmNlLmNhY2hlUG9vbCksXG4gICAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwXG4gICAgICAgICAgICA/ICgoZGlnZXN0ID0gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUpLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAucGFyZW50ICE9PSBkaWdlc3RcbiAgICAgICAgICAgICAgICAgID8geyBwYXJlbnQ6IGRpZ2VzdCwgcG9vbDogZGlnZXN0IH1cbiAgICAgICAgICAgICAgICAgIDogSlNDb21waWxlcl90ZW1wJGpzY29tcCQwKSlcbiAgICAgICAgICAgIDogKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGdldFN1c3BlbmRlZENhY2hlKCkpLFxuICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSB7XG4gICAgICAgICAgICBiYXNlTGFuZXM6IG5leHRJbnN0YW5jZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIGNhY2hlUG9vbDogSlNDb21waWxlcl90ZW1wJGpzY29tcCQwXG4gICAgICAgICAgfSkpLFxuICAgICAgKHNob3dGYWxsYmFjay5tZW1vaXplZFN0YXRlID0gbmV4dEluc3RhbmNlKSxcbiAgICAgIChzaG93RmFsbGJhY2suY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICBuZXh0UHJvcHNcbiAgICApO1xuICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICByZW5kZXJMYW5lcyA9IGN1cnJlbnQuY2hpbGQ7XG4gIGN1cnJlbnQgPSByZW5kZXJMYW5lcy5zaWJsaW5nO1xuICByZW5kZXJMYW5lcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJlbmRlckxhbmVzLCB7XG4gICAgbW9kZTogXCJ2aXNpYmxlXCIsXG4gICAgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlblxuICB9KTtcbiAgcmVuZGVyTGFuZXMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsO1xuICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgKChKU0NvbXBpbGVyX3RlbXAgPSB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMpLFxuICAgIG51bGwgPT09IEpTQ29tcGlsZXJfdGVtcFxuICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IFtjdXJyZW50XSksICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxNikpXG4gICAgICA6IEpTQ29tcGlsZXJfdGVtcC5wdXNoKGN1cnJlbnQpKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHJldHVybiByZW5kZXJMYW5lcztcbn1cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbikge1xuICBwcmltYXJ5Q2hpbGRyZW4gPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgeyBtb2RlOiBcInZpc2libGVcIiwgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlbiB9LFxuICAgIHdvcmtJblByb2dyZXNzLm1vZGVcbiAgKTtcbiAgcHJpbWFyeUNoaWxkcmVuLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihvZmZzY3JlZW5Qcm9wcywgbW9kZSkge1xuICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKG9mZnNjcmVlblByb3BzLCBtb2RlLCAwLCBudWxsKTtcbn1cbmZ1bmN0aW9uIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgcmVuZGVyTGFuZXNcbikge1xuICByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpO1xuICBjdXJyZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW5cbiAgKTtcbiAgY3VycmVudC5mbGFncyB8PSAyO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoZmliZXIsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgZmliZXIubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChmaWJlci5yZXR1cm4sIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpO1xufVxuZnVuY3Rpb24gaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgaXNCYWNrd2FyZHMsXG4gIHRhaWwsXG4gIGxhc3RDb250ZW50Um93LFxuICB0YWlsTW9kZVxuKSB7XG4gIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIG51bGwgPT09IHJlbmRlclN0YXRlXG4gICAgPyAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgaXNCYWNrd2FyZHM6IGlzQmFja3dhcmRzLFxuICAgICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICAgIHJlbmRlcmluZ1N0YXJ0VGltZTogMCxcbiAgICAgICAgbGFzdDogbGFzdENvbnRlbnRSb3csXG4gICAgICAgIHRhaWw6IHRhaWwsXG4gICAgICAgIHRhaWxNb2RlOiB0YWlsTW9kZVxuICAgICAgfSlcbiAgICA6ICgocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcyksXG4gICAgICAocmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbnVsbCksXG4gICAgICAocmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMCksXG4gICAgICAocmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93KSxcbiAgICAgIChyZW5kZXJTdGF0ZS50YWlsID0gdGFpbCksXG4gICAgICAocmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZSkpO1xufVxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgIHJldmVhbE9yZGVyID0gbmV4dFByb3BzLnJldmVhbE9yZGVyLFxuICAgIHRhaWxNb2RlID0gbmV4dFByb3BzLnRhaWw7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMuY2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgbmV4dFByb3BzID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuICBpZiAoMCAhPT0gKG5leHRQcm9wcyAmIDIpKVxuICAgIChuZXh0UHJvcHMgPSAobmV4dFByb3BzICYgMSkgfCAyKSwgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCk7XG4gIGVsc2Uge1xuICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgIGE6IGZvciAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgaWYgKDEzID09PSBjdXJyZW50LnRhZylcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihjdXJyZW50LCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBlbHNlIGlmICgxOSA9PT0gY3VycmVudC50YWcpXG4gICAgICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGN1cnJlbnQsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGVsc2UgaWYgKG51bGwgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgICAgICBjdXJyZW50LmNoaWxkLnJldHVybiA9IGN1cnJlbnQ7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHdvcmtJblByb2dyZXNzKSBicmVhayBhO1xuICAgICAgICBmb3IgKDsgbnVsbCA9PT0gY3VycmVudC5zaWJsaW5nOyApIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudC5yZXR1cm4gfHwgY3VycmVudC5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC5zaWJsaW5nLnJldHVybiA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgfVxuICAgIG5leHRQcm9wcyAmPSAxO1xuICB9XG4gIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgbmV4dFByb3BzKTtcbiAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgIGNhc2UgXCJmb3J3YXJkc1wiOlxuICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIGZvciAocmV2ZWFsT3JkZXIgPSBudWxsOyBudWxsICE9PSByZW5kZXJMYW5lczsgKVxuICAgICAgICAoY3VycmVudCA9IHJlbmRlckxhbmVzLmFsdGVybmF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpICYmXG4gICAgICAgICAgICAocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgKHJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXMuc2libGluZyk7XG4gICAgICByZW5kZXJMYW5lcyA9IHJldmVhbE9yZGVyO1xuICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgPyAoKHJldmVhbE9yZGVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLCAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsKSlcbiAgICAgICAgOiAoKHJldmVhbE9yZGVyID0gcmVuZGVyTGFuZXMuc2libGluZyksIChyZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbCkpO1xuICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgITEsXG4gICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgdGFpbE1vZGVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYmFja3dhcmRzXCI6XG4gICAgICByZW5kZXJMYW5lcyA9IG51bGw7XG4gICAgICByZXZlYWxPcmRlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgZm9yICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7IG51bGwgIT09IHJldmVhbE9yZGVyOyApIHtcbiAgICAgICAgY3VycmVudCA9IHJldmVhbE9yZGVyLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCA9PT0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZXZlYWxPcmRlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gcmV2ZWFsT3JkZXIuc2libGluZztcbiAgICAgICAgcmV2ZWFsT3JkZXIuc2libGluZyA9IHJlbmRlckxhbmVzO1xuICAgICAgICByZW5kZXJMYW5lcyA9IHJldmVhbE9yZGVyO1xuICAgICAgICByZXZlYWxPcmRlciA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAhMCxcbiAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRhaWxNb2RlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRvZ2V0aGVyXCI6XG4gICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsICExLCBudWxsLCBudWxsLCB2b2lkIDApO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB9XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cbmZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIG51bGwgIT09IGN1cnJlbnQgJiYgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzKTtcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHdvcmtJblByb2dyZXNzLmxhbmVzO1xuICBpZiAoMCA9PT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpXG4gICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgITFcbiAgICAgICAgKSxcbiAgICAgICAgMCA9PT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpXG4gICAgICApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSByZXR1cm4gbnVsbDtcbiAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpXG4gICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNTMpKTtcbiAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyTGFuZXM7XG4gICAgZm9yIChyZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzczsgbnVsbCAhPT0gY3VycmVudC5zaWJsaW5nOyApXG4gICAgICAoY3VycmVudCA9IGN1cnJlbnQuc2libGluZyksXG4gICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcgPVxuICAgICAgICAgIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIGN1cnJlbnQucGVuZGluZ1Byb3BzKSksXG4gICAgICAgIChyZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuZnVuY3Rpb24gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKDAgIT09IChjdXJyZW50LmxhbmVzICYgcmVuZGVyTGFuZXMpKSByZXR1cm4gITA7XG4gIGN1cnJlbnQgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgcmV0dXJuIG51bGwgIT09IGN1cnJlbnQgJiYgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQpID8gITAgOiAhMTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgcmVuZGVyTGFuZXNcbikge1xuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgMzpcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKTtcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjc6XG4gICAgY2FzZSA1OlxuICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwOlxuICAgICAgcHVzaFByb3ZpZGVyKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTM6XG4gICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IHN0YXRlKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBzdGF0ZS5kZWh5ZHJhdGVkKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKDAgIT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkLmNoaWxkTGFuZXMpKVxuICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBjdXJyZW50ID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5zaWJsaW5nIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE5OlxuICAgICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEyOCk7XG4gICAgICBzdGF0ZSA9IDAgIT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuICAgICAgc3RhdGUgfHxcbiAgICAgICAgKHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgITFcbiAgICAgICAgKSxcbiAgICAgICAgKHN0YXRlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpKTtcbiAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgIGlmIChzdGF0ZSlcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjg7XG4gICAgICB9XG4gICAgICBkaWRTdXNwZW5kQmVmb3JlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIG51bGwgIT09IGRpZFN1c3BlbmRCZWZvcmUgJiZcbiAgICAgICAgKChkaWRTdXNwZW5kQmVmb3JlLnJlbmRlcmluZyA9IG51bGwpLFxuICAgICAgICAoZGlkU3VzcGVuZEJlZm9yZS50YWlsID0gbnVsbCksXG4gICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLmxhc3RFZmZlY3QgPSBudWxsKSk7XG4gICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgICBpZiAoc3RhdGUpIGJyZWFrO1xuICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDIyOlxuICAgIGNhc2UgMjM6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwKSxcbiAgICAgICAgdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICk7XG4gICAgY2FzZSAyNDpcbiAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICB9XG4gIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG59XG5mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChudWxsICE9PSBjdXJyZW50KVxuICAgIGlmIChjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcylcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAhMDtcbiAgICBlbHNlIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSAmJlxuICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpXG4gICAgICApXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMSksXG4gICAgICAgICAgYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgPyAhMCA6ICExO1xuICAgIH1cbiAgZWxzZVxuICAgIChkaWRSZWNlaXZlVXBkYXRlID0gITEpLFxuICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTA0ODU3NikgJiZcbiAgICAgICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdHJlZUZvcmtDb3VudCwgd29ya0luUHJvZ3Jlc3MuaW5kZXgpO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDA7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSAxNjpcbiAgICAgIGE6IHtcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSxcbiAgICAgICAgICBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgbGF6eUNvbXBvbmVudCA9IGluaXQobGF6eUNvbXBvbmVudC5fcGF5bG9hZCk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBsYXp5Q29tcG9uZW50O1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbGF6eUNvbXBvbmVudClcbiAgICAgICAgICBzaG91bGRDb25zdHJ1Y3QobGF6eUNvbXBvbmVudClcbiAgICAgICAgICAgID8gKChjdXJyZW50ID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMobGF6eUNvbXBvbmVudCwgY3VycmVudCkpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudGFnID0gMSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzLnRhZyA9IDApLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IGxhenlDb21wb25lbnQgJiYgbnVsbCAhPT0gbGF6eUNvbXBvbmVudClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChpbml0ID0gbGF6eUNvbXBvbmVudC4kJHR5cGVvZiksIGluaXQgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gMTE7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbml0ID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gMTQ7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShsYXp5Q29tcG9uZW50KSB8fCBsYXp5Q29tcG9uZW50O1xuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzA2LCB3b3JrSW5Qcm9ncmVzcywgXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAobGF6eUNvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAoaW5pdCA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzXG4gICAgICAgICkpLFxuICAgICAgICB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgaW5pdCxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApXG4gICAgICApO1xuICAgIGNhc2UgMzpcbiAgICAgIGE6IHtcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzg3KSk7XG4gICAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIGluaXQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBsYXp5Q29tcG9uZW50ID0gaW5pdC5lbGVtZW50O1xuICAgICAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIG5leHRQcm9wcyA9IG5leHRTdGF0ZS5jYWNoZTtcbiAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIG5leHRQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyAhPT0gaW5pdC5jYWNoZSAmJlxuICAgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgICAgIG5leHRQcm9wcyA9IG5leHRTdGF0ZS5lbGVtZW50O1xuICAgICAgICBpZiAoaW5pdC5pc0RlaHlkcmF0ZWQpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKChpbml0ID0ge1xuICAgICAgICAgICAgICBlbGVtZW50OiBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIGlzRGVoeWRyYXRlZDogITEsXG4gICAgICAgICAgICAgIGNhY2hlOiBuZXh0U3RhdGUuY2FjaGVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IGluaXQpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbml0KSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dFByb3BzICE9PSBsYXp5Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBsYXp5Q29tcG9uZW50ID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgICAgIEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDI0KSksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihsYXp5Q29tcG9uZW50KTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mby5maXJzdENoaWxkXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBpc0h5ZHJhdGluZyA9ICEwLFxuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkVycm9ycyA9IG51bGwsXG4gICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICEwLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzID0gbW91bnRDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICByZW5kZXJMYW5lcztcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMuZmxhZ3MgPSAocmVuZGVyTGFuZXMuZmxhZ3MgJiAtMykgfCA0MDk2KSxcbiAgICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGlmIChuZXh0UHJvcHMgPT09IGxhenlDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgY2FzZSAyNjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgPyAocmVuZGVyTGFuZXMgPSBnZXRSZXNvdXJjZShcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKVxuICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHJlbmRlckxhbmVzKVxuICAgICAgICAgICAgOiBpc0h5ZHJhdGluZyB8fFxuICAgICAgICAgICAgICAoKHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgICAgKGxhenlDb21wb25lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIoXG4gICAgICAgICAgICAgICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgICAgICApLmNyZWF0ZUVsZW1lbnQocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgKGxhenlDb21wb25lbnRbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIChsYXp5Q29tcG9uZW50W2ludGVybmFsUHJvcHNLZXldID0gY3VycmVudCksXG4gICAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGxhenlDb21wb25lbnQsIHJlbmRlckxhbmVzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShsYXp5Q29tcG9uZW50KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGxhenlDb21wb25lbnQpKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBnZXRSZXNvdXJjZShcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgKSksXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgY2FzZSAyNzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICgobGF6eUNvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9XG4gICAgICAgICAgICByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITApLFxuICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoXG4gICAgICAgICAgICBsYXp5Q29tcG9uZW50LmZpcnN0Q2hpbGRcbiAgICAgICAgICApKSksXG4gICAgICAgIChsYXp5Q29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCB8fCBpc0h5ZHJhdGluZ1xuICAgICAgICAgID8gcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBsYXp5Q29tcG9uZW50LFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBsYXp5Q29tcG9uZW50LFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgKTtcbiAgICBjYXNlIDU6XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCAmJiBpc0h5ZHJhdGluZykge1xuICAgICAgICBpZiAoKGluaXQgPSBsYXp5Q29tcG9uZW50ID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkpXG4gICAgICAgICAgKGxhenlDb21wb25lbnQgPSBjYW5IeWRyYXRlSW5zdGFuY2UoXG4gICAgICAgICAgICBsYXp5Q29tcG9uZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICApKSxcbiAgICAgICAgICAgIG51bGwgIT09IGxhenlDb21wb25lbnRcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGxhenlDb21wb25lbnQpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudC5maXJzdENoaWxkXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMSksXG4gICAgICAgICAgICAgICAgKGluaXQgPSAhMCkpXG4gICAgICAgICAgICAgIDogKGluaXQgPSAhMSk7XG4gICAgICAgIGluaXQgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpbml0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIG5leHRTdGF0ZSA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuICAgICAgbGF6eUNvbXBvbmVudCA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHNob3VsZFNldFRleHRDb250ZW50KGluaXQsIG5leHRQcm9wcylcbiAgICAgICAgPyAobGF6eUNvbXBvbmVudCA9IG51bGwpXG4gICAgICAgIDogbnVsbCAhPT0gbmV4dFN0YXRlICYmXG4gICAgICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQoaW5pdCwgbmV4dFN0YXRlKSAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAzMik7XG4gICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICgoaW5pdCA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIFRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICkpLFxuICAgICAgICAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUgPSBpbml0KSk7XG4gICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBsYXp5Q29tcG9uZW50LCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgY2FzZSA2OlxuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgJiYgaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgaWYgKChjdXJyZW50ID0gcmVuZGVyTGFuZXMgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSlcbiAgICAgICAgICAocmVuZGVyTGFuZXMgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsICE9PSByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50ID0gITApKVxuICAgICAgICAgICAgICA6IChjdXJyZW50ID0gITEpO1xuICAgICAgICBjdXJyZW50IHx8IHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDEzOlxuICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgKSxcbiAgICAgICAgKGxhenlDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKVxuICAgICAgICAgIDogcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBsYXp5Q29tcG9uZW50LFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICk7XG4gICAgY2FzZSAxMTpcbiAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gKFxuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgKTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gKFxuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgKTtcbiAgICBjYXNlIDEyOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICk7XG4gICAgY2FzZSAxMDpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChsYXp5Q29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlLCBsYXp5Q29tcG9uZW50LnZhbHVlKSxcbiAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBsYXp5Q29tcG9uZW50LmNoaWxkcmVuLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICApO1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChpbml0ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dCksXG4gICAgICAgIChsYXp5Q29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAoaW5pdCA9IHJlYWRDb250ZXh0KGluaXQpKSxcbiAgICAgICAgKGxhenlDb21wb25lbnQgPSBsYXp5Q29tcG9uZW50KGluaXQpKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEpLFxuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGF6eUNvbXBvbmVudCwgcmVuZGVyTGFuZXMpLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgKTtcbiAgICBjYXNlIDE0OlxuICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgIGNhc2UgMTU6XG4gICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgY2FzZSAxOTpcbiAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICBjYXNlIDIyOlxuICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIGNhc2UgMjQ6XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIChsYXp5Q29tcG9uZW50ID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KSksXG4gICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICA/ICgoaW5pdCA9IHBlZWtDYWNoZUZyb21Qb29sKCkpLFxuICAgICAgICAgICAgbnVsbCA9PT0gaW5pdCAmJlxuICAgICAgICAgICAgICAoKGluaXQgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QpLFxuICAgICAgICAgICAgICAobmV4dFByb3BzID0gY3JlYXRlQ2FjaGUoKSksXG4gICAgICAgICAgICAgIChpbml0LnBvb2xlZENhY2hlID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLnJlZkNvdW50KyssXG4gICAgICAgICAgICAgIG51bGwgIT09IG5leHRQcm9wcyAmJiAoaW5pdC5wb29sZWRDYWNoZUxhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKGluaXQgPSBuZXh0UHJvcHMpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgIGNhY2hlOiBpbml0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgaW5pdCkpXG4gICAgICAgICAgOiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgICAgKGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG51bGwsIG51bGwsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpKSxcbiAgICAgICAgICAgIChpbml0ID0gY3VycmVudC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgIGluaXQucGFyZW50ICE9PSBsYXp5Q29tcG9uZW50XG4gICAgICAgICAgICAgID8gKChpbml0ID0geyBwYXJlbnQ6IGxhenlDb21wb25lbnQsIGNhY2hlOiBsYXp5Q29tcG9uZW50IH0pLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5pdCksXG4gICAgICAgICAgICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3MubGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICBpbml0KSxcbiAgICAgICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgbGF6eUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgIDogKChsYXp5Q29tcG9uZW50ID0gbmV4dFByb3BzLmNhY2hlKSxcbiAgICAgICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgbGF6eUNvbXBvbmVudCksXG4gICAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudCAhPT0gaW5pdC5jYWNoZSAmJlxuICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgICApKSksXG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICApO1xuICAgIGNhc2UgMjk6XG4gICAgICB0aHJvdyB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIH1cbiAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNTYsIHdvcmtJblByb2dyZXNzLnRhZykpO1xufVxudmFyIHZhbHVlQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGwsXG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gIHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSk7XG4gIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQpIHtcbiAgY29udGV4dC5fY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgcG9wKHZhbHVlQ3Vyc29yKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgocGFyZW50LCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KSB7XG4gIGZvciAoOyBudWxsICE9PSBwYXJlbnQ7ICkge1xuICAgIHZhciBhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgIChwYXJlbnQuY2hpbGRMYW5lcyAmIHJlbmRlckxhbmVzKSAhPT0gcmVuZGVyTGFuZXNcbiAgICAgID8gKChwYXJlbnQuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcyksXG4gICAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpKVxuICAgICAgOiBudWxsICE9PSBhbHRlcm5hdGUgJiZcbiAgICAgICAgKGFsdGVybmF0ZS5jaGlsZExhbmVzICYgcmVuZGVyTGFuZXMpICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgIGlmIChwYXJlbnQgPT09IHByb3BhZ2F0aW9uUm9vdCkgYnJlYWs7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxufVxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gIHdvcmtJblByb2dyZXNzLFxuICBjb250ZXh0cyxcbiAgcmVuZGVyTGFuZXMsXG4gIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuKSB7XG4gIHZhciBmaWJlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICBudWxsICE9PSBmaWJlciAmJiAoZmliZXIucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpO1xuICBmb3IgKDsgbnVsbCAhPT0gZmliZXI7ICkge1xuICAgIHZhciBsaXN0ID0gZmliZXIuZGVwZW5kZW5jaWVzO1xuICAgIGlmIChudWxsICE9PSBsaXN0KSB7XG4gICAgICB2YXIgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICBsaXN0ID0gbGlzdC5maXJzdENvbnRleHQ7XG4gICAgICBhOiBmb3IgKDsgbnVsbCAhPT0gbGlzdDsgKSB7XG4gICAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IGZpYmVyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHRzW2ldKSB7XG4gICAgICAgICAgICBsaXN0LmxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgZGVwZW5kZW5jeSA9IGxpc3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgbnVsbCAhPT0gZGVwZW5kZW5jeSAmJiAoZGVwZW5kZW5jeS5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgICAgICAgICBsaXN0LnJldHVybixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlIHx8IChuZXh0RmliZXIgPSBudWxsKTtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgfVxuICAgICAgICBsaXN0ID0gZGVwZW5kZW5jeS5uZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoMTggPT09IGZpYmVyLnRhZykge1xuICAgICAgbmV4dEZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgICAgaWYgKG51bGwgPT09IG5leHRGaWJlcikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNDEpKTtcbiAgICAgIG5leHRGaWJlci5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgICAgIGxpc3QgPSBuZXh0RmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gbGlzdCAmJiAobGlzdC5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKG5leHRGaWJlciwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgfSBlbHNlIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgIGlmIChudWxsICE9PSBuZXh0RmliZXIpIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICBlbHNlXG4gICAgICBmb3IgKG5leHRGaWJlciA9IGZpYmVyOyBudWxsICE9PSBuZXh0RmliZXI7ICkge1xuICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZmliZXIgPSBuZXh0RmliZXIuc2libGluZztcbiAgICAgICAgaWYgKG51bGwgIT09IGZpYmVyKSB7XG4gICAgICAgICAgZmliZXIucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBmaWJlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgfVxuICAgIGZpYmVyID0gbmV4dEZpYmVyO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIHJlbmRlckxhbmVzLFxuICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbikge1xuICBjdXJyZW50ID0gbnVsbDtcbiAgZm9yIChcbiAgICB2YXIgcGFyZW50ID0gd29ya0luUHJvZ3Jlc3MsIGlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0ID0gITE7XG4gICAgbnVsbCAhPT0gcGFyZW50O1xuXG4gICkge1xuICAgIGlmICghaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQpXG4gICAgICBpZiAoMCAhPT0gKHBhcmVudC5mbGFncyAmIDUyNDI4OCkpIGlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0ID0gITA7XG4gICAgICBlbHNlIGlmICgwICE9PSAocGFyZW50LmZsYWdzICYgMjYyMTQ0KSkgYnJlYWs7XG4gICAgaWYgKDEwID09PSBwYXJlbnQudGFnKSB7XG4gICAgICB2YXIgY3VycmVudFBhcmVudCA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudFBhcmVudCkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzODcpKTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudC50eXBlO1xuICAgICAgICBvYmplY3RJcyhwYXJlbnQucGVuZGluZ1Byb3BzLnZhbHVlLCBjdXJyZW50UGFyZW50LnZhbHVlKSB8fFxuICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5wdXNoKGNvbnRleHQpIDogKGN1cnJlbnQgPSBbY29udGV4dF0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmVudCA9PT0gaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvci5jdXJyZW50KSB7XG4gICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50UGFyZW50KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM4NykpO1xuICAgICAgY3VycmVudFBhcmVudC5tZW1vaXplZFN0YXRlLm1lbW9pemVkU3RhdGUgIT09XG4gICAgICAgIHBhcmVudC5tZW1vaXplZFN0YXRlLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgKG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICA/IGN1cnJlbnQucHVzaChIb3N0VHJhbnNpdGlvbkNvbnRleHQpXG4gICAgICAgICAgOiAoY3VycmVudCA9IFtIb3N0VHJhbnNpdGlvbkNvbnRleHRdKSk7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cbiAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdXJyZW50LFxuICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbiAgICApO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyNjIxNDQ7XG59XG5mdW5jdGlvbiBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudERlcGVuZGVuY2llcykge1xuICBmb3IgKFxuICAgIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcbiAgICBudWxsICE9PSBjdXJyZW50RGVwZW5kZW5jaWVzO1xuXG4gICkge1xuICAgIGlmIChcbiAgICAgICFvYmplY3RJcyhcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcy5jb250ZXh0Ll9jdXJyZW50VmFsdWUsXG4gICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMubWVtb2l6ZWRWYWx1ZVxuICAgICAgKVxuICAgIClcbiAgICAgIHJldHVybiAhMDtcbiAgICBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcy5uZXh0O1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO1xuICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcyAmJiAod29ya0luUHJvZ3Jlc3MuZmlyc3RDb250ZXh0ID0gbnVsbCk7XG59XG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24oY29uc3VtZXIsIGNvbnRleHQpIHtcbiAgbnVsbCA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIgJiYgcHJlcGFyZVRvUmVhZENvbnRleHQoY29uc3VtZXIpO1xuICByZXR1cm4gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCk7XG59XG5mdW5jdGlvbiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgY29udGV4dCA9IHsgY29udGV4dDogY29udGV4dCwgbWVtb2l6ZWRWYWx1ZTogdmFsdWUsIG5leHQ6IG51bGwgfTtcbiAgaWYgKG51bGwgPT09IGxhc3RDb250ZXh0RGVwZW5kZW5jeSkge1xuICAgIGlmIChudWxsID09PSBjb25zdW1lcikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMDgpKTtcbiAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjb250ZXh0O1xuICAgIGNvbnN1bWVyLmRlcGVuZGVuY2llcyA9IHsgbGFuZXM6IDAsIGZpcnN0Q29udGV4dDogY29udGV4dCB9O1xuICAgIGNvbnN1bWVyLmZsYWdzIHw9IDUyNDI4ODtcbiAgfSBlbHNlIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dDtcbiAgcmV0dXJuIHZhbHVlO1xufVxudmFyIGhhc0ZvcmNlVXBkYXRlID0gITE7XG5mdW5jdGlvbiBpbml0aWFsaXplVXBkYXRlUXVldWUoZmliZXIpIHtcbiAgZmliZXIudXBkYXRlUXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBsYXN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBzaGFyZWQ6IHsgcGVuZGluZzogbnVsbCwgbGFuZXM6IDAsIGhpZGRlbkNhbGxiYWNrczogbnVsbCB9LFxuICAgIGNhbGxiYWNrczogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPT09IGN1cnJlbnQgJiZcbiAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnQuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50LmZpcnN0QmFzZVVwZGF0ZSxcbiAgICAgIGxhc3RCYXNlVXBkYXRlOiBjdXJyZW50Lmxhc3RCYXNlVXBkYXRlLFxuICAgICAgc2hhcmVkOiBjdXJyZW50LnNoYXJlZCxcbiAgICAgIGNhbGxiYWNrczogbnVsbFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlKGxhbmUpIHtcbiAgcmV0dXJuIHsgbGFuZTogbGFuZSwgdGFnOiAwLCBwYXlsb2FkOiBudWxsLCBjYWxsYmFjazogbnVsbCwgbmV4dDogbnVsbCB9O1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAobnVsbCA9PT0gdXBkYXRlUXVldWUpIHJldHVybiBudWxsO1xuICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLnNoYXJlZDtcbiAgaWYgKDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgMikpIHtcbiAgICB2YXIgcGVuZGluZyA9IHVwZGF0ZVF1ZXVlLnBlbmRpbmc7XG4gICAgbnVsbCA9PT0gcGVuZGluZ1xuICAgICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgICA6ICgodXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQpLCAocGVuZGluZy5uZXh0ID0gdXBkYXRlKSk7XG4gICAgdXBkYXRlUXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICB1cGRhdGUgPSBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbnVsbCwgbGFuZSk7XG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfVxuICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHVwZGF0ZVF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG59XG5mdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gIGZpYmVyID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmIChudWxsICE9PSBmaWJlciAmJiAoKGZpYmVyID0gZmliZXIuc2hhcmVkKSwgMCAhPT0gKGxhbmUgJiA0MTk0MTc2KSkpIHtcbiAgICB2YXIgcXVldWVMYW5lcyA9IGZpYmVyLmxhbmVzO1xuICAgIHF1ZXVlTGFuZXMgJj0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgbGFuZSB8PSBxdWV1ZUxhbmVzO1xuICAgIGZpYmVyLmxhbmVzID0gbGFuZTtcbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBsYW5lKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjYXB0dXJlZFVwZGF0ZSkge1xuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSxcbiAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICBpZiAoXG4gICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICgoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLCBxdWV1ZSA9PT0gY3VycmVudClcbiAgKSB7XG4gICAgdmFyIG5ld0ZpcnN0ID0gbnVsbCxcbiAgICAgIG5ld0xhc3QgPSBudWxsO1xuICAgIHF1ZXVlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuICAgIGlmIChudWxsICE9PSBxdWV1ZSkge1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogcXVldWUubGFuZSxcbiAgICAgICAgICB0YWc6IHF1ZXVlLnRhZyxcbiAgICAgICAgICBwYXlsb2FkOiBxdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICAgID8gKG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNsb25lKVxuICAgICAgICAgIDogKG5ld0xhc3QgPSBuZXdMYXN0Lm5leHQgPSBjbG9uZSk7XG4gICAgICAgIHF1ZXVlID0gcXVldWUubmV4dDtcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IHF1ZXVlKTtcbiAgICAgIG51bGwgPT09IG5ld0xhc3RcbiAgICAgICAgPyAobmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGUpXG4gICAgICAgIDogKG5ld0xhc3QgPSBuZXdMYXN0Lm5leHQgPSBjYXB0dXJlZFVwZGF0ZSk7XG4gICAgfSBlbHNlIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgIHF1ZXVlID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50LmJhc2VTdGF0ZSxcbiAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbmV3Rmlyc3QsXG4gICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgIHNoYXJlZDogY3VycmVudC5zaGFyZWQsXG4gICAgICBjYWxsYmFja3M6IGN1cnJlbnQuY2FsbGJhY2tzXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xuICAgIHJldHVybjtcbiAgfVxuICB3b3JrSW5Qcm9ncmVzcyA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1xuICAgID8gKHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlKVxuICAgIDogKHdvcmtJblByb2dyZXNzLm5leHQgPSBjYXB0dXJlZFVwZGF0ZSk7XG4gIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG59XG52YXIgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICExO1xuZnVuY3Rpb24gc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpIHtcbiAgaWYgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24pIHtcbiAgICB2YXIgZW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgaWYgKG51bGwgIT09IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlKSB0aHJvdyBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICB3b3JrSW5Qcm9ncmVzcyRqc2NvbXAkMCxcbiAgcHJvcHMsXG4gIGluc3RhbmNlJGpzY29tcCQwLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMTtcbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MkanNjb21wJDAudXBkYXRlUXVldWU7XG4gIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGUsXG4gICAgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICBwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZztcbiAgaWYgKG51bGwgIT09IHBlbmRpbmdRdWV1ZSkge1xuICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDtcbiAgICB2YXIgbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWUsXG4gICAgICBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgIGxhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgIG51bGwgPT09IGxhc3RCYXNlVXBkYXRlXG4gICAgICA/IChmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGUpXG4gICAgICA6IChsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlKTtcbiAgICBsYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MkanNjb21wJDAuYWx0ZXJuYXRlO1xuICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICgoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgKHBlbmRpbmdRdWV1ZSA9IGN1cnJlbnQubGFzdEJhc2VVcGRhdGUpLFxuICAgICAgcGVuZGluZ1F1ZXVlICE9PSBsYXN0QmFzZVVwZGF0ZSAmJlxuICAgICAgICAobnVsbCA9PT0gcGVuZGluZ1F1ZXVlXG4gICAgICAgICAgPyAoY3VycmVudC5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGUpXG4gICAgICAgICAgOiAocGVuZGluZ1F1ZXVlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGUpLFxuICAgICAgICAoY3VycmVudC5sYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlKSkpO1xuICB9XG4gIGlmIChudWxsICE9PSBmaXJzdEJhc2VVcGRhdGUpIHtcbiAgICB2YXIgbmV3U3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gICAgbGFzdEJhc2VVcGRhdGUgPSAwO1xuICAgIGN1cnJlbnQgPSBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZSA9IG51bGw7XG4gICAgcGVuZGluZ1F1ZXVlID0gZmlyc3RCYXNlVXBkYXRlO1xuICAgIGRvIHtcbiAgICAgIHZhciB1cGRhdGVMYW5lID0gcGVuZGluZ1F1ZXVlLmxhbmUgJiAtNTM2ODcwOTEzLFxuICAgICAgICBpc0hpZGRlblVwZGF0ZSA9IHVwZGF0ZUxhbmUgIT09IHBlbmRpbmdRdWV1ZS5sYW5lO1xuICAgICAgaWYgKFxuICAgICAgICBpc0hpZGRlblVwZGF0ZVxuICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICA6IChyZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICApIHtcbiAgICAgICAgMCAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMCk7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQubmV4dCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgIHRhZzogcGVuZGluZ1F1ZXVlLnRhZyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogcGVuZGluZ1F1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgYToge1xuICAgICAgICAgIHZhciB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzJGpzY29tcCQwLFxuICAgICAgICAgICAgdXBkYXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgICAgIHVwZGF0ZUxhbmUgPSBwcm9wcztcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZSRqc2NvbXAkMDtcbiAgICAgICAgICBzd2l0Y2ggKHVwZGF0ZS50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5jYWxsKGluc3RhbmNlLCBuZXdTdGF0ZSwgdXBkYXRlTGFuZSk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIC02NTUzNykgfCAxMjg7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gdXBkYXRlLnBheWxvYWQ7XG4gICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPVxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgICA/IHdvcmtJblByb2dyZXNzLmNhbGwoaW5zdGFuY2UsIG5ld1N0YXRlLCB1cGRhdGVMYW5lKVxuICAgICAgICAgICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHVwZGF0ZUxhbmUgfHwgdm9pZCAwID09PSB1cGRhdGVMYW5lKSBicmVhayBhO1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IGFzc2lnbih7fSwgbmV3U3RhdGUsIHVwZGF0ZUxhbmUpO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVMYW5lID0gcGVuZGluZ1F1ZXVlLmNhbGxiYWNrO1xuICAgICAgICBudWxsICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyRqc2NvbXAkMC5mbGFncyB8PSA2NCksXG4gICAgICAgICAgaXNIaWRkZW5VcGRhdGUgJiYgKHdvcmtJblByb2dyZXNzJGpzY29tcCQwLmZsYWdzIHw9IDgxOTIpLFxuICAgICAgICAgIChpc0hpZGRlblVwZGF0ZSA9IHF1ZXVlLmNhbGxiYWNrcyksXG4gICAgICAgICAgbnVsbCA9PT0gaXNIaWRkZW5VcGRhdGVcbiAgICAgICAgICAgID8gKHF1ZXVlLmNhbGxiYWNrcyA9IFt1cGRhdGVMYW5lXSlcbiAgICAgICAgICAgIDogaXNIaWRkZW5VcGRhdGUucHVzaCh1cGRhdGVMYW5lKSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0ge1xuICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgdGFnOiBwZW5kaW5nUXVldWUudGFnLFxuICAgICAgICAgIHBheWxvYWQ6IHBlbmRpbmdRdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgIGNhbGxiYWNrOiBwZW5kaW5nUXVldWUuY2FsbGJhY2ssXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9KSxcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICA/ICgoZmlyc3RQZW5kaW5nVXBkYXRlID0gY3VycmVudCA9IGlzSGlkZGVuVXBkYXRlKSxcbiAgICAgICAgICAgICAgKGxhc3RQZW5kaW5nVXBkYXRlID0gbmV3U3RhdGUpKVxuICAgICAgICAgICAgOiAoY3VycmVudCA9IGN1cnJlbnQubmV4dCA9IGlzSGlkZGVuVXBkYXRlKSxcbiAgICAgICAgICAobGFzdEJhc2VVcGRhdGUgfD0gdXBkYXRlTGFuZSk7XG4gICAgICBwZW5kaW5nUXVldWUgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgIGlmIChudWxsID09PSBwZW5kaW5nUXVldWUpXG4gICAgICAgIGlmICgoKHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nKSwgbnVsbCA9PT0gcGVuZGluZ1F1ZXVlKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIChpc0hpZGRlblVwZGF0ZSA9IHBlbmRpbmdRdWV1ZSksXG4gICAgICAgICAgICAocGVuZGluZ1F1ZXVlID0gaXNIaWRkZW5VcGRhdGUubmV4dCksXG4gICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUubmV4dCA9IG51bGwpLFxuICAgICAgICAgICAgKHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgKHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbCk7XG4gICAgfSB3aGlsZSAoMSk7XG4gICAgbnVsbCA9PT0gY3VycmVudCAmJiAobGFzdFBlbmRpbmdVcGRhdGUgPSBuZXdTdGF0ZSk7XG4gICAgcXVldWUuYmFzZVN0YXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY3VycmVudDtcbiAgICBudWxsID09PSBmaXJzdEJhc2VVcGRhdGUgJiYgKHF1ZXVlLnNoYXJlZC5sYW5lcyA9IDApO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBsYXN0QmFzZVVwZGF0ZTtcbiAgICB3b3JrSW5Qcm9ncmVzcyRqc2NvbXAkMC5sYW5lcyA9IGxhc3RCYXNlVXBkYXRlO1xuICAgIHdvcmtJblByb2dyZXNzJGpzY29tcCQwLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjaylcbiAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5MSwgY2FsbGJhY2spKTtcbiAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgY29udGV4dCkge1xuICB2YXIgY2FsbGJhY2tzID0gdXBkYXRlUXVldWUuY2FsbGJhY2tzO1xuICBpZiAobnVsbCAhPT0gY2FsbGJhY2tzKVxuICAgIGZvciAoXG4gICAgICB1cGRhdGVRdWV1ZS5jYWxsYmFja3MgPSBudWxsLCB1cGRhdGVRdWV1ZSA9IDA7XG4gICAgICB1cGRhdGVRdWV1ZSA8IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICB1cGRhdGVRdWV1ZSsrXG4gICAgKVxuICAgICAgY2FsbENhbGxiYWNrKGNhbGxiYWNrc1t1cGRhdGVRdWV1ZV0sIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG4gIHRyeSB7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlLFxuICAgICAgbGFzdEVmZmVjdCA9IG51bGwgIT09IHVwZGF0ZVF1ZXVlID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG4gICAgaWYgKG51bGwgIT09IGxhc3RFZmZlY3QpIHtcbiAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgIHVwZGF0ZVF1ZXVlID0gZmlyc3RFZmZlY3Q7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgodXBkYXRlUXVldWUudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuICAgICAgICAgIGxhc3RFZmZlY3QgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIGNyZWF0ZSA9IHVwZGF0ZVF1ZXVlLmNyZWF0ZSxcbiAgICAgICAgICAgIGluc3QgPSB1cGRhdGVRdWV1ZS5pbnN0O1xuICAgICAgICAgIGxhc3RFZmZlY3QgPSBjcmVhdGUoKTtcbiAgICAgICAgICBpbnN0LmRlc3Ryb3kgPSBsYXN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUubmV4dDtcbiAgICAgIH0gd2hpbGUgKHVwZGF0ZVF1ZXVlICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gIGZsYWdzLFxuICBmaW5pc2hlZFdvcmssXG4gIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IkanNjb21wJDBcbikge1xuICB0cnkge1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSxcbiAgICAgIGxhc3RFZmZlY3QgPSBudWxsICE9PSB1cGRhdGVRdWV1ZSA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuICAgIGlmIChudWxsICE9PSBsYXN0RWZmZWN0KSB7XG4gICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICB1cGRhdGVRdWV1ZSA9IGZpcnN0RWZmZWN0O1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKHVwZGF0ZVF1ZXVlLnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAgICB2YXIgaW5zdCA9IHVwZGF0ZVF1ZXVlLmluc3QsXG4gICAgICAgICAgICBkZXN0cm95ID0gaW5zdC5kZXN0cm95O1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IGRlc3Ryb3kpIHtcbiAgICAgICAgICAgIGluc3QuZGVzdHJveSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGxhc3RFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgICAgICB2YXIgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciA9IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IkanNjb21wJDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICBsYXN0RWZmZWN0LFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5uZXh0O1xuICAgICAgfSB3aGlsZSAodXBkYXRlUXVldWUgIT09IGZpcnN0RWZmZWN0KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIGlmIChudWxsICE9PSB1cGRhdGVRdWV1ZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgY3VycmVudCxcbiAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgaW5zdGFuY2Vcbikge1xuICBpbnN0YW5jZS5wcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgIGN1cnJlbnQudHlwZSxcbiAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgKTtcbiAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHRyeSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChudWxsICE9PSByZWYpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgdmFyIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpbnN0YW5jZVRvVXNlID0gaW5zdGFuY2U7XG4gICAgICB9XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWZcbiAgICAgICAgPyAoY3VycmVudC5yZWZDbGVhbnVwID0gcmVmKGluc3RhbmNlVG9Vc2UpKVxuICAgICAgICA6IChyZWYuY3VycmVudCA9IGluc3RhbmNlVG9Vc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHZhciByZWYgPSBjdXJyZW50LnJlZixcbiAgICByZWZDbGVhbnVwID0gY3VycmVudC5yZWZDbGVhbnVwO1xuICBpZiAobnVsbCAhPT0gcmVmKVxuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWZDbGVhbnVwKVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVmQ2xlYW51cCgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKGN1cnJlbnQucmVmQ2xlYW51cCA9IG51bGwpLFxuICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgIG51bGwgIT0gY3VycmVudCAmJiAoY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbCk7XG4gICAgICB9XG4gICAgZWxzZSBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmKVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVmKG51bGwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IkMTEyKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yJDExMik7XG4gICAgICB9XG4gICAgZWxzZSByZWYuY3VycmVudCA9IG51bGw7XG59XG5mdW5jdGlvbiBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKSB7XG4gIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gIHRyeSB7XG4gICAgYTogc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICBwcm9wcy5hdXRvRm9jdXMgJiYgaW5zdGFuY2UuZm9jdXMoKTtcbiAgICAgICAgYnJlYWsgYTtcbiAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgcHJvcHMuc3JjXG4gICAgICAgICAgPyAoaW5zdGFuY2Uuc3JjID0gcHJvcHMuc3JjKVxuICAgICAgICAgIDogcHJvcHMuc3JjU2V0ICYmIChpbnN0YW5jZS5zcmNzZXQgPSBwcm9wcy5zcmNTZXQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0SG9zdFVwZGF0ZShmaW5pc2hlZFdvcmssIG5ld1Byb3BzLCBvbGRQcm9wcykge1xuICB0cnkge1xuICAgIHZhciBkb21FbGVtZW50ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIGZpbmlzaGVkV29yay50eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgIGRvbUVsZW1lbnRbaW50ZXJuYWxQcm9wc0tleV0gPSBuZXdQcm9wcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHJldHVybiAoXG4gICAgNSA9PT0gZmliZXIudGFnIHx8XG4gICAgMyA9PT0gZmliZXIudGFnIHx8XG4gICAgMjYgPT09IGZpYmVyLnRhZyB8fFxuICAgIDI3ID09PSBmaWJlci50YWcgfHxcbiAgICA0ID09PSBmaWJlci50YWdcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gIGE6IGZvciAoOzspIHtcbiAgICBmb3IgKDsgbnVsbCA9PT0gZmliZXIuc2libGluZzsgKSB7XG4gICAgICBpZiAobnVsbCA9PT0gZmliZXIucmV0dXJuIHx8IGlzSG9zdFBhcmVudChmaWJlci5yZXR1cm4pKSByZXR1cm4gbnVsbDtcbiAgICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5zaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICBmb3IgKFxuICAgICAgZmliZXIgPSBmaWJlci5zaWJsaW5nO1xuICAgICAgNSAhPT0gZmliZXIudGFnICYmXG4gICAgICA2ICE9PSBmaWJlci50YWcgJiZcbiAgICAgIDI3ICE9PSBmaWJlci50YWcgJiZcbiAgICAgIDE4ICE9PSBmaWJlci50YWc7XG5cbiAgICApIHtcbiAgICAgIGlmIChmaWJlci5mbGFncyAmIDIpIGNvbnRpbnVlIGE7XG4gICAgICBpZiAobnVsbCA9PT0gZmliZXIuY2hpbGQgfHwgNCA9PT0gZmliZXIudGFnKSBjb250aW51ZSBhO1xuICAgICAgZWxzZSAoZmliZXIuY2hpbGQucmV0dXJuID0gZmliZXIpLCAoZmliZXIgPSBmaWJlci5jaGlsZCk7XG4gICAgfVxuICAgIGlmICghKGZpYmVyLmZsYWdzICYgMikpIHJldHVybiBmaWJlci5zdGF0ZU5vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZylcbiAgICAobm9kZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgIGJlZm9yZVxuICAgICAgICA/IDggPT09IHBhcmVudC5ub2RlVHlwZVxuICAgICAgICAgID8gcGFyZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGJlZm9yZSlcbiAgICAgICAgICA6IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgYmVmb3JlKVxuICAgICAgICA6ICg4ID09PSBwYXJlbnQubm9kZVR5cGVcbiAgICAgICAgICAgID8gKChiZWZvcmUgPSBwYXJlbnQucGFyZW50Tm9kZSksIGJlZm9yZS5pbnNlcnRCZWZvcmUobm9kZSwgcGFyZW50KSlcbiAgICAgICAgICAgIDogKChiZWZvcmUgPSBwYXJlbnQpLCBiZWZvcmUuYXBwZW5kQ2hpbGQobm9kZSkpLFxuICAgICAgICAgIChwYXJlbnQgPSBwYXJlbnQuX3JlYWN0Um9vdENvbnRhaW5lciksXG4gICAgICAgICAgKG51bGwgIT09IHBhcmVudCAmJiB2b2lkIDAgIT09IHBhcmVudCkgfHxcbiAgICAgICAgICAgIG51bGwgIT09IGJlZm9yZS5vbmNsaWNrIHx8XG4gICAgICAgICAgICAoYmVmb3JlLm9uY2xpY2sgPSBub29wJDEpKTtcbiAgZWxzZSBpZiAoNCAhPT0gdGFnICYmIDI3ICE9PSB0YWcgJiYgKChub2RlID0gbm9kZS5jaGlsZCksIG51bGwgIT09IG5vZGUpKVxuICAgIGZvciAoXG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIG51bGwgIT09IG5vZGU7XG5cbiAgICApXG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgKG5vZGUgPSBub2RlLnNpYmxpbmcpO1xufVxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgaWYgKDUgPT09IHRhZyB8fCA2ID09PSB0YWcpXG4gICAgKG5vZGUgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICBiZWZvcmUgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIGJlZm9yZSkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIGVsc2UgaWYgKDQgIT09IHRhZyAmJiAyNyAhPT0gdGFnICYmICgobm9kZSA9IG5vZGUuY2hpbGQpLCBudWxsICE9PSBub2RlKSlcbiAgICBmb3IgKFxuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSwgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIG51bGwgIT09IG5vZGU7XG5cbiAgICApXG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpLCAobm9kZSA9IG5vZGUuc2libGluZyk7XG59XG52YXIgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gITEsXG4gIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSAhMSxcbiAgbmVlZHNGb3JtUmVzZXQgPSAhMSxcbiAgUG9zc2libHlXZWFrU2V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha1NldCA/IFdlYWtTZXQgOiBTZXQsXG4gIG5leHRFZmZlY3QgPSBudWxsLFxuICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSAhMTtcbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaXJzdENoaWxkKSB7XG4gIHJvb3QgPSByb290LmNvbnRhaW5lckluZm87XG4gIGV2ZW50c0VuYWJsZWQgPSBfZW5hYmxlZDtcbiAgcm9vdCA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKHJvb3QpO1xuICBpZiAoaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHJvb3QpKSB7XG4gICAgaWYgKFwic2VsZWN0aW9uU3RhcnRcIiBpbiByb290KVxuICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcCA9IHtcbiAgICAgICAgc3RhcnQ6IHJvb3Quc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGVuZDogcm9vdC5zZWxlY3Rpb25FbmRcbiAgICAgIH07XG4gICAgZWxzZVxuICAgICAgYToge1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICgoSlNDb21waWxlcl90ZW1wID0gcm9vdC5vd25lckRvY3VtZW50KSAmJlxuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLmRlZmF1bHRWaWV3KSB8fFxuICAgICAgICAgIHdpbmRvdztcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9XG4gICAgICAgICAgSlNDb21waWxlcl90ZW1wLmdldFNlbGVjdGlvbiAmJiBKU0NvbXBpbGVyX3RlbXAuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgMCAhPT0gc2VsZWN0aW9uLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICAgICAgICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgICAgICAgIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAubm9kZVR5cGUsIGZvY3VzTm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICB9IGNhdGNoIChlJDIwKSB7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IDAsXG4gICAgICAgICAgICBzdGFydCA9IC0xLFxuICAgICAgICAgICAgZW5kID0gLTEsXG4gICAgICAgICAgICBpbmRleFdpdGhpbkFuY2hvciA9IDAsXG4gICAgICAgICAgICBpbmRleFdpdGhpbkZvY3VzID0gMCxcbiAgICAgICAgICAgIG5vZGUgPSByb290LFxuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgICAgYjogZm9yICg7Oykge1xuICAgICAgICAgICAgZm9yICh2YXIgbmV4dDsgOyApIHtcbiAgICAgICAgICAgICAgbm9kZSAhPT0gSlNDb21waWxlcl90ZW1wIHx8XG4gICAgICAgICAgICAgICAgKDAgIT09IGFuY2hvck9mZnNldCAmJiAzICE9PSBub2RlLm5vZGVUeXBlKSB8fFxuICAgICAgICAgICAgICAgIChzdGFydCA9IGxlbmd0aCArIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAgIG5vZGUgIT09IGZvY3VzTm9kZSB8fFxuICAgICAgICAgICAgICAgICgwICE9PSBzZWxlY3Rpb24gJiYgMyAhPT0gbm9kZS5ub2RlVHlwZSkgfHxcbiAgICAgICAgICAgICAgICAoZW5kID0gbGVuZ3RoICsgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgMyA9PT0gbm9kZS5ub2RlVHlwZSAmJiAobGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSAobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkpIGJyZWFrO1xuICAgICAgICAgICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgIGlmIChub2RlID09PSByb290KSBicmVhayBiO1xuICAgICAgICAgICAgICBwYXJlbnROb2RlID09PSBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICAgICArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgICAgICAoc3RhcnQgPSBsZW5ndGgpO1xuICAgICAgICAgICAgICBwYXJlbnROb2RlID09PSBmb2N1c05vZGUgJiZcbiAgICAgICAgICAgICAgICArK2luZGV4V2l0aGluRm9jdXMgPT09IHNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgICAgIChlbmQgPSBsZW5ndGgpO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSkgYnJlYWs7XG4gICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAtMSA9PT0gc3RhcnQgfHwgLTEgPT09IGVuZCA/IG51bGwgOiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgfSBlbHNlIEpTQ29tcGlsZXJfdGVtcCA9IG51bGw7XG4gICAgICB9XG4gICAgSlNDb21waWxlcl90ZW1wID0gSlNDb21waWxlcl90ZW1wIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9IGVsc2UgSlNDb21waWxlcl90ZW1wID0gbnVsbDtcbiAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSB7IGZvY3VzZWRFbGVtOiByb290LCBzZWxlY3Rpb25SYW5nZTogSlNDb21waWxlcl90ZW1wIH07XG4gIF9lbmFibGVkID0gITE7XG4gIGZvciAobmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7IG51bGwgIT09IG5leHRFZmZlY3Q7IClcbiAgICBpZiAoXG4gICAgICAoKGZpcnN0Q2hpbGQgPSBuZXh0RWZmZWN0KSxcbiAgICAgIChyb290ID0gZmlyc3RDaGlsZC5jaGlsZCksXG4gICAgICAwICE9PSAoZmlyc3RDaGlsZC5zdWJ0cmVlRmxhZ3MgJiAxMDI4KSAmJiBudWxsICE9PSByb290KVxuICAgIClcbiAgICAgIChyb290LnJldHVybiA9IGZpcnN0Q2hpbGQpLCAobmV4dEVmZmVjdCA9IHJvb3QpO1xuICAgIGVsc2VcbiAgICAgIGZvciAoOyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgZmlyc3RDaGlsZCA9IG5leHRFZmZlY3Q7XG4gICAgICAgIGZvY3VzTm9kZSA9IGZpcnN0Q2hpbGQuYWx0ZXJuYXRlO1xuICAgICAgICByb290ID0gZmlyc3RDaGlsZC5mbGFncztcbiAgICAgICAgc3dpdGNoIChmaXJzdENoaWxkLnRhZykge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGlmICgwICE9PSAocm9vdCAmIDEwMjQpICYmIG51bGwgIT09IGZvY3VzTm9kZSkge1xuICAgICAgICAgICAgICByb290ID0gdm9pZCAwO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSBmaXJzdENoaWxkO1xuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBmb2N1c05vZGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgZm9jdXNOb2RlID0gZm9jdXNOb2RlLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbiA9IEpTQ29tcGlsZXJfdGVtcC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkUHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAudHlwZSxcbiAgICAgICAgICAgICAgICAgIGFuY2hvck9mZnNldCxcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcC5lbGVtZW50VHlwZSA9PT0gSlNDb21waWxlcl90ZW1wLnR5cGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJvb3QgPSBzZWxlY3Rpb24uZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoXG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGZvY3VzTm9kZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlID0gcm9vdDtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcC5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmICgwICE9PSAocm9vdCAmIDEwMjQpKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChyb290ID0gZmlyc3RDaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IHJvb3Qubm9kZVR5cGUpLFxuICAgICAgICAgICAgICAgIDkgPT09IEpTQ29tcGlsZXJfdGVtcClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyU3BhcmluZ2x5KHJvb3QpO1xuICAgICAgICAgICAgICBlbHNlIGlmICgxID09PSBKU0NvbXBpbGVyX3RlbXApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChyb290Lm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiSEVBRFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIkhUTUxcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJCT0RZXCI6XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyU3BhcmluZ2x5KHJvb3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJvb3QudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICgwICE9PSAocm9vdCAmIDEwMjQpKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2MykpO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSBmaXJzdENoaWxkLnNpYmxpbmc7XG4gICAgICAgIGlmIChudWxsICE9PSByb290KSB7XG4gICAgICAgICAgcm9vdC5yZXR1cm4gPSBmaXJzdENoaWxkLnJldHVybjtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gcm9vdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZC5yZXR1cm47XG4gICAgICB9XG4gIHJlc29sdmVkUHJldlByb3BzID0gc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyO1xuICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSAhMTtcbiAgcmV0dXJuIHJlc29sdmVkUHJldlByb3BzO1xufVxuZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgMDpcbiAgICBjYXNlIDExOlxuICAgIGNhc2UgMTU6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDQgJiYgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudCg1LCBmaW5pc2hlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgaWYgKGZsYWdzICYgNClcbiAgICAgICAgaWYgKCgoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSksIG51bGwgPT09IGN1cnJlbnQpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmluaXNoZWRSb290LmNvbXBvbmVudERpZFVwZGF0ZShcbiAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IkMTExKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICBlcnJvciQxMTFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBmbGFncyAmIDY0ICYmIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGlmIChmbGFncyAmIDY0ICYmICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLCBudWxsICE9PSBmbGFncykpIHtcbiAgICAgICAgZmluaXNoZWRSb290ID0gbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IGZpbmlzaGVkV29yay5jaGlsZClcbiAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay5jaGlsZC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb21taXRDYWxsYmFja3MoZmxhZ3MsIGZpbmlzaGVkUm9vdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjY6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjc6XG4gICAgY2FzZSA1OlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgbnVsbCA9PT0gY3VycmVudCAmJiBmbGFncyAmIDQgJiYgY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTI6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEzOlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgZmxhZ3MgJiA0ICYmIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjI6XG4gICAgICBwcmV2UHJvcHMgPVxuICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSB8fCBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICBjdXJyZW50ID1cbiAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4sXG4gICAgICAgICAgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2UHJvcHM7XG4gICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gY3VycmVudCkgJiYgIXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuXG4gICAgICAgICAgPyByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiA4NzcyKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICB9XG4gICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAoXCJtYW51YWxcIiA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMubW9kZVxuICAgICAgICAgID8gc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybilcbiAgICAgICAgICA6IHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIG51bGwgIT09IGFsdGVybmF0ZSAmJlxuICAgICgoZmliZXIuYWx0ZXJuYXRlID0gbnVsbCksIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGFsdGVybmF0ZSkpO1xuICBmaWJlci5jaGlsZCA9IG51bGw7XG4gIGZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gIGZpYmVyLnNpYmxpbmcgPSBudWxsO1xuICA1ID09PSBmaWJlci50YWcgJiZcbiAgICAoKGFsdGVybmF0ZSA9IGZpYmVyLnN0YXRlTm9kZSksXG4gICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIGRldGFjaERlbGV0ZWRJbnN0YW5jZShhbHRlcm5hdGUpKTtcbiAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbiAgZmliZXIuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIGZpYmVyLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuICBmaWJlci51cGRhdGVRdWV1ZSA9IG51bGw7XG59XG52YXIgaG9zdFBhcmVudCA9IG51bGwsXG4gIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgZmluaXNoZWRSb290LFxuICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICBwYXJlbnRcbikge1xuICBmb3IgKHBhcmVudCA9IHBhcmVudC5jaGlsZDsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIHBhcmVudCksXG4gICAgICAocGFyZW50ID0gcGFyZW50LnNpYmxpbmcpO1xufVxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihcbiAgZmluaXNoZWRSb290LFxuICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICBkZWxldGVkRmliZXJcbikge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudClcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGRlbGV0ZWRGaWJlcik7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICBzd2l0Y2ggKGRlbGV0ZWRGaWJlci50YWcpIHtcbiAgICBjYXNlIDI2OlxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICAgICAgZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGVcbiAgICAgICAgPyBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZS5jb3VudC0tXG4gICAgICAgIDogZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICgoZGVsZXRlZEZpYmVyID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgICAgZGVsZXRlZEZpYmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGVsZXRlZEZpYmVyKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI3OlxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgIHZhciBwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQsXG4gICAgICAgIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICBob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICAgICAgZGVsZXRlZEZpYmVyID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIGZvciAoXG4gICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IgPSBkZWxldGVkRmliZXIuYXR0cmlidXRlcztcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5sZW5ndGg7XG5cbiAgICAgIClcbiAgICAgICAgZGVsZXRlZEZpYmVyLnJlbW92ZUF0dHJpYnV0ZU5vZGUobmVhcmVzdE1vdW50ZWRBbmNlc3RvclswXSk7XG4gICAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2UoZGVsZXRlZEZpYmVyKTtcbiAgICAgIGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgIGNhc2UgNjpcbiAgICAgIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50O1xuICAgICAgdmFyIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIkMTE5ID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgKTtcbiAgICAgIGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciQxMTk7XG4gICAgICBpZiAobnVsbCAhPT0gaG9zdFBhcmVudClcbiAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcilcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgKGZpbmlzaGVkUm9vdCA9IGhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgICAocHJldkhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgOCA9PT0gZmluaXNoZWRSb290Lm5vZGVUeXBlXG4gICAgICAgICAgICAgICAgPyBmaW5pc2hlZFJvb3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2SG9zdFBhcmVudClcbiAgICAgICAgICAgICAgICA6IGZpbmlzaGVkUm9vdC5yZW1vdmVDaGlsZChwcmV2SG9zdFBhcmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBob3N0UGFyZW50LnJlbW92ZUNoaWxkKGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE4OlxuICAgICAgbnVsbCAhPT0gaG9zdFBhcmVudCAmJlxuICAgICAgICAoaG9zdFBhcmVudElzQ29udGFpbmVyXG4gICAgICAgICAgPyAoKG5lYXJlc3RNb3VudGVkQW5jZXN0b3IgPSBob3N0UGFyZW50KSxcbiAgICAgICAgICAgIChkZWxldGVkRmliZXIgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIDggPT09IG5lYXJlc3RNb3VudGVkQW5jZXN0b3Iubm9kZVR5cGVcbiAgICAgICAgICAgICAgPyBjbGVhclN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogMSA9PT0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5ub2RlVHlwZSAmJlxuICAgICAgICAgICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpLFxuICAgICAgICAgICAgcmV0cnlJZkJsb2NrZWRPbihuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSlcbiAgICAgICAgICA6IGNsZWFyU3VzcGVuc2VCb3VuZGFyeShob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgICBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICEwO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICk7XG4gICAgICBob3N0UGFyZW50ID0gcHJldkhvc3RQYXJlbnQ7XG4gICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTE6XG4gICAgY2FzZSAxNDpcbiAgICBjYXNlIDE1OlxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoMiwgZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KDQsIGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgKHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpLFxuICAgICAgICAocHJldkhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJldkhvc3RQYXJlbnQuY29tcG9uZW50V2lsbFVubW91bnQgJiZcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgcHJldkhvc3RQYXJlbnRcbiAgICAgICAgICApKTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMTpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMjpcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID1cbiAgICAgICAgKHByZXZIb3N0UGFyZW50ID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikgfHxcbiAgICAgICAgbnVsbCAhPT0gZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgKTtcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAgaWYgKFxuICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlKSxcbiAgICBudWxsICE9PSBmaW5pc2hlZFJvb3QgJiZcbiAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgbnVsbCAhPT0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290LmRlaHlkcmF0ZWQpLCBudWxsICE9PSBmaW5pc2hlZFJvb3QpKSlcbiAgKVxuICAgIHRyeSB7XG4gICAgICByZXRyeUlmQmxvY2tlZE9uKGZpbmlzaGVkUm9vdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJldHJ5Q2FjaGUoZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgMTM6XG4gICAgY2FzZSAxOTpcbiAgICAgIHZhciByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gbmV3IFBvc3NpYmx5V2Vha1NldCgpKTtcbiAgICAgIHJldHVybiByZXRyeUNhY2hlO1xuICAgIGNhc2UgMjI6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSksXG4gICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLl9yZXRyeUNhY2hlKSxcbiAgICAgICAgbnVsbCA9PT0gcmV0cnlDYWNoZSAmJlxuICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLl9yZXRyeUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha1NldCgpKSxcbiAgICAgICAgcmV0cnlDYWNoZVxuICAgICAgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MzUsIGZpbmlzaGVkV29yay50YWcpKTtcbiAgfVxufVxuZnVuY3Rpb24gYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIHdha2VhYmxlcykge1xuICB2YXIgcmV0cnlDYWNoZSA9IGdldFJldHJ5Q2FjaGUoZmluaXNoZWRXb3JrKTtcbiAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgdmFyIHJldHJ5ID0gcmVzb2x2ZVJldHJ5V2FrZWFibGUuYmluZChudWxsLCBmaW5pc2hlZFdvcmssIHdha2VhYmxlKTtcbiAgICByZXRyeUNhY2hlLmhhcyh3YWtlYWJsZSkgfHxcbiAgICAgIChyZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSksIHdha2VhYmxlLnRoZW4ocmV0cnksIHJldHJ5KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290JGpzY29tcCQwLCBwYXJlbnRGaWJlcikge1xuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXSxcbiAgICAgICAgcm9vdCA9IHJvb3QkanNjb21wJDAsXG4gICAgICAgIHJldHVybkZpYmVyID0gcGFyZW50RmliZXIsXG4gICAgICAgIHBhcmVudCA9IHJldHVybkZpYmVyO1xuICAgICAgYTogZm9yICg7IG51bGwgIT09IHBhcmVudDsgKSB7XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMTtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICEwO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobnVsbCA9PT0gaG9zdFBhcmVudCkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNjApKTtcbiAgICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMTtcbiAgICAgIHJvb3QgPSBjaGlsZFRvRGVsZXRlLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IHJvb3QgJiYgKHJvb3QucmV0dXJuID0gbnVsbCk7XG4gICAgICBjaGlsZFRvRGVsZXRlLnJldHVybiA9IG51bGw7XG4gICAgfVxuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTM4NzgpXG4gICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihwYXJlbnRGaWJlciwgcm9vdCRqc2NvbXAkMCksXG4gICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xufVxudmFyIGN1cnJlbnRIb2lzdGFibGVSb290ID0gbnVsbDtcbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KSB7XG4gIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTE6XG4gICAgY2FzZSAxNDpcbiAgICBjYXNlIDE1OlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgKGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCgzLCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pLFxuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KDMsIGZpbmlzaGVkV29yayksXG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCg1LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiAmJlxuICAgICAgICAoKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yayAmJlxuICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsuY2FsbGJhY2tzKSxcbiAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgKChjdXJyZW50ID0gZmluaXNoZWRXb3JrLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MpLFxuICAgICAgICAgICAgKGZpbmlzaGVkV29yay5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzID1cbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCA/IGZsYWdzIDogY3VycmVudC5jb25jYXQoZmxhZ3MpKSkpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjY6XG4gICAgICB2YXIgaG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRSZXNvdXJjZSA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudClcbiAgICAgICAgICBpZiAobnVsbCA9PT0gZmxhZ3MpXG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSkge1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290O1xuICAgICAgICAgICAgICAgIGI6IHN3aXRjaCAoZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0aXRsZVwiKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICFjdXJyZW50UmVzb3VyY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2VbaW50ZXJuYWxIb2lzdGFibGVNYXJrZXJdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlW2ludGVybmFsSW5zdGFuY2VLZXldIHx8XG4gICAgICAgICAgICAgICAgICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLm5hbWVzcGFjZVVSSSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZS5oYXNBdHRyaWJ1dGUoXCJpdGVtcHJvcFwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRSZXNvdXJjZSA9IGhvaXN0YWJsZVJvb3QuY3JlYXRlRWxlbWVudChmbGFncykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5oZWFkLmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkID4gdGl0bGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGN1cnJlbnRSZXNvdXJjZSwgZmxhZ3MsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2VbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBmaW5pc2hlZFdvcms7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoY3VycmVudFJlc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MgPSBjdXJyZW50UmVzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVOb2RlcyA9IGdldEh5ZHJhdGFibGVIb2lzdGFibGVDYWNoZShcbiAgICAgICAgICAgICAgICAgICAgICBcImxpbmtcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImhyZWZcIixcbiAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290XG4gICAgICAgICAgICAgICAgICAgICkuZ2V0KGZsYWdzICsgKGN1cnJlbnQuaHJlZiB8fCBcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZU5vZGVzKVxuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5YmVOb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKChjdXJyZW50UmVzb3VyY2UgPSBtYXliZU5vZGVzW2ldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5ocmVmID8gbnVsbCA6IGN1cnJlbnQuaHJlZikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwicmVsXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5yZWwgPyBudWxsIDogY3VycmVudC5yZWwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmdldEF0dHJpYnV0ZShcInRpdGxlXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC50aXRsZSA/IG51bGwgOiBjdXJyZW50LnRpdGxlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IGN1cnJlbnQuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudC5jcm9zc09yaWdpbikpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVOb2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSA9IGhvaXN0YWJsZVJvb3QuY3JlYXRlRWxlbWVudChmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGN1cnJlbnRSZXNvdXJjZSwgZmxhZ3MsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LmhlYWQuYXBwZW5kQ2hpbGQoY3VycmVudFJlc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgKG1heWJlTm9kZXMgPSBnZXRIeWRyYXRhYmxlSG9pc3RhYmxlQ2FjaGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1ldGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICAgICAgICAgICkuZ2V0KGZsYWdzICsgKGN1cnJlbnQuY29udGVudCB8fCBcIlwiKSkpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWF5YmVOb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKChjdXJyZW50UmVzb3VyY2UgPSBtYXliZU5vZGVzW2ldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIiArIGN1cnJlbnQuY29udGVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IGN1cnJlbnQubmFtZSA/IG51bGwgOiBjdXJyZW50Lm5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmdldEF0dHJpYnV0ZShcInByb3BlcnR5XCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5wcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50LnByb3BlcnR5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJodHRwLWVxdWl2XCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5odHRwRXF1aXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudC5odHRwRXF1aXYpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmdldEF0dHJpYnV0ZShcImNoYXJzZXRcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LmNoYXJTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudC5jaGFyU2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlID0gaG9pc3RhYmxlUm9vdC5jcmVhdGVFbGVtZW50KGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoY3VycmVudFJlc291cmNlLCBmbGFncywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuaGVhZC5hcHBlbmRDaGlsZChjdXJyZW50UmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDY4LCBmbGFncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2VbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBmaW5pc2hlZFdvcms7XG4gICAgICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShjdXJyZW50UmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGZsYWdzID0gY3VycmVudFJlc291cmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBmbGFncztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBtb3VudEhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gYWNxdWlyZVJlc291cmNlKFxuICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICBmbGFncyxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjdXJyZW50UmVzb3VyY2UgIT09IGZsYWdzXG4gICAgICAgICAgICA/IChudWxsID09PSBjdXJyZW50UmVzb3VyY2VcbiAgICAgICAgICAgICAgICA/IG51bGwgIT09IGN1cnJlbnQuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3VycmVudCkpXG4gICAgICAgICAgICAgICAgOiBjdXJyZW50UmVzb3VyY2UuY291bnQtLSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gZmxhZ3NcbiAgICAgICAgICAgICAgICA/IG1vdW50SG9pc3RhYmxlKFxuICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogYWNxdWlyZVJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICBmbGFncyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6IG51bGwgPT09IGZsYWdzICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgY29tbWl0SG9zdFVwZGF0ZShcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI3OlxuICAgICAgaWYgKGZsYWdzICYgNCAmJiBudWxsID09PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlKSB7XG4gICAgICAgIGhvaXN0YWJsZVJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBjdXJyZW50UmVzb3VyY2UgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBub2RlID0gaG9pc3RhYmxlUm9vdC5maXJzdENoaWxkOyBub2RlOyApIHtcbiAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgIG5vZGVbaW50ZXJuYWxIb2lzdGFibGVNYXJrZXJdIHx8XG4gICAgICAgICAgICAgIFwiSEVBRFwiID09PSBub2RlTmFtZSB8fFxuICAgICAgICAgICAgICBcIkJPRFlcIiA9PT0gbm9kZU5hbWUgfHxcbiAgICAgICAgICAgICAgXCJTQ1JJUFRcIiA9PT0gbm9kZU5hbWUgfHxcbiAgICAgICAgICAgICAgXCJTVFlMRVwiID09PSBub2RlTmFtZSB8fFxuICAgICAgICAgICAgICAoXCJMSU5LXCIgPT09IG5vZGVOYW1lICYmXG4gICAgICAgICAgICAgICAgXCJzdHlsZXNoZWV0XCIgPT09IG5vZGUucmVsLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbmV4dE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlLCBhdHRyaWJ1dGVzID0gaG9pc3RhYmxlUm9vdC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgYXR0cmlidXRlcy5sZW5ndGg7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBob2lzdGFibGVSb290LnJlbW92ZUF0dHJpYnV0ZU5vZGUoYXR0cmlidXRlc1swXSk7XG4gICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoaG9pc3RhYmxlUm9vdCwgdHlwZSwgY3VycmVudFJlc291cmNlKTtcbiAgICAgICAgICBob2lzdGFibGVSb290W2ludGVybmFsSW5zdGFuY2VLZXldID0gZmluaXNoZWRXb3JrO1xuICAgICAgICAgIGhvaXN0YWJsZVJvb3RbaW50ZXJuYWxQcm9wc0tleV0gPSBjdXJyZW50UmVzb3VyY2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIDU6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIDMyKSB7XG4gICAgICAgIGhvaXN0YWJsZVJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGhvaXN0YWJsZVJvb3QsIFwiXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgbnVsbCAhPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICYmXG4gICAgICAgICgoaG9pc3RhYmxlUm9vdCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgY29tbWl0SG9zdFVwZGF0ZShcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogaG9pc3RhYmxlUm9vdFxuICAgICAgICApKTtcbiAgICAgIGZsYWdzICYgMTAyNCAmJiAobmVlZHNGb3JtUmVzZXQgPSAhMCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDY6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNjIpKTtcbiAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY3VycmVudC5ub2RlVmFsdWUgPSBmbGFncztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgdGFnQ2FjaGVzID0gbnVsbDtcbiAgICAgIGhvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBob2lzdGFibGVSb290O1xuICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBpZiAoZmxhZ3MgJiA0ICYmIG51bGwgIT09IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXRyeUlmQmxvY2tlZE9uKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIG5lZWRzRm9ybVJlc2V0ICYmXG4gICAgICAgICgobmVlZHNGb3JtUmVzZXQgPSAhMSksIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaW5pc2hlZFdvcmspKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGZsYWdzID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3QoXG4gICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgKTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBmbGFncztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTI6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTM6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZpbmlzaGVkV29yay5jaGlsZC5mbGFncyAmIDgxOTIgJiZcbiAgICAgICAgKG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSAhPT1cbiAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpICYmXG4gICAgICAgIChnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gbm93KCkpO1xuICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICgoZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMjpcbiAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgbm9kZSA9IG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgbmV4dE5vZGUgPSBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIG5vZGVOYW1lID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgdHlwZSA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBub2RlTmFtZSB8fCBub2RlO1xuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHR5cGUgfHwgbmV4dE5vZGU7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gdHlwZTtcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG5vZGVOYW1lO1xuICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIHJvb3QuX2N1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICByb290Ll92aXNpYmlsaXR5ICY9IC0zO1xuICAgICAgcm9vdC5fdmlzaWJpbGl0eSB8PSByb290Ll9wZW5kaW5nVmlzaWJpbGl0eSAmIDI7XG4gICAgICBpZiAoXG4gICAgICAgIGZsYWdzICYgODE5MiAmJlxuICAgICAgICAoKHJvb3QuX3Zpc2liaWxpdHkgPSBub2RlXG4gICAgICAgICAgPyByb290Ll92aXNpYmlsaXR5ICYgLTJcbiAgICAgICAgICA6IHJvb3QuX3Zpc2liaWxpdHkgfCAxKSxcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICAgICgocm9vdCA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSxcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICBuZXh0Tm9kZSB8fFxuICAgICAgICAgICAgcm9vdCB8fFxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKSksXG4gICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgXCJtYW51YWxcIiAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMubW9kZSlcbiAgICAgIClcbiAgICAgICAgYTogZm9yIChjdXJyZW50ID0gbnVsbCwgcm9vdCA9IGZpbmlzaGVkV29yazsgOyApIHtcbiAgICAgICAgICBpZiAoNSA9PT0gcm9vdC50YWcgfHwgMjYgPT09IHJvb3QudGFnIHx8IDI3ID09PSByb290LnRhZykge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgbmV4dE5vZGUgPSBjdXJyZW50ID0gcm9vdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoKChob2lzdGFibGVSb290ID0gbmV4dE5vZGUuc3RhdGVOb2RlKSwgbm9kZSkpXG4gICAgICAgICAgICAgICAgICAoY3VycmVudFJlc291cmNlID0gaG9pc3RhYmxlUm9vdC5zdHlsZSksXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGN1cnJlbnRSZXNvdXJjZS5zZXRQcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgID8gY3VycmVudFJlc291cmNlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW1wb3J0YW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IChjdXJyZW50UmVzb3VyY2UuZGlzcGxheSA9IFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1heWJlTm9kZXMgPSBuZXh0Tm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBpID0gbmV4dE5vZGUubWVtb2l6ZWRQcm9wcy5zdHlsZTtcbiAgICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5ID1cbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBpICYmIG51bGwgIT09IGkgJiYgaS5oYXNPd25Qcm9wZXJ0eShcImRpc3BsYXlcIilcbiAgICAgICAgICAgICAgICAgICAgICA/IGkuZGlzcGxheVxuICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgIG1heWJlTm9kZXMuc3R5bGUuZGlzcGxheSA9XG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT0gZGlzcGxheSB8fCBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IChcIlwiICsgZGlzcGxheSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0Tm9kZSwgbmV4dE5vZGUucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKDYgPT09IHJvb3QudGFnKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHJvb3Q7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV4dE5vZGUuc3RhdGVOb2RlLm5vZGVWYWx1ZSA9IG5vZGVcbiAgICAgICAgICAgICAgICAgID8gXCJcIlxuICAgICAgICAgICAgICAgICAgOiBuZXh0Tm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHROb2RlLCBuZXh0Tm9kZS5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAoKDIyICE9PSByb290LnRhZyAmJiAyMyAhPT0gcm9vdC50YWcpIHx8XG4gICAgICAgICAgICAgIG51bGwgPT09IHJvb3QubWVtb2l6ZWRTdGF0ZSB8fFxuICAgICAgICAgICAgICByb290ID09PSBmaW5pc2hlZFdvcmspICYmXG4gICAgICAgICAgICBudWxsICE9PSByb290LmNoaWxkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByb290LmNoaWxkLnJldHVybiA9IHJvb3Q7XG4gICAgICAgICAgICByb290ID0gcm9vdC5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vdCA9PT0gZmluaXNoZWRXb3JrKSBicmVhayBhO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSByb290LnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHJvb3QucmV0dXJuIHx8IHJvb3QucmV0dXJuID09PSBmaW5pc2hlZFdvcmspIGJyZWFrIGE7XG4gICAgICAgICAgICBjdXJyZW50ID09PSByb290ICYmIChjdXJyZW50ID0gbnVsbCk7XG4gICAgICAgICAgICByb290ID0gcm9vdC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQgPT09IHJvb3QgJiYgKGN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgICByb290LnNpYmxpbmcucmV0dXJuID0gcm9vdC5yZXR1cm47XG4gICAgICAgICAgcm9vdCA9IHJvb3Quc2libGluZztcbiAgICAgICAgfVxuICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICgoY3VycmVudCA9IGZsYWdzLnJldHJ5UXVldWUpLFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MucmV0cnlRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGN1cnJlbnQpKSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOTpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICgoZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMTpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgaWYgKGZsYWdzICYgMikge1xuICAgIHRyeSB7XG4gICAgICBpZiAoMjcgIT09IGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgYToge1xuICAgICAgICAgIGZvciAodmFyIHBhcmVudCA9IGZpbmlzaGVkV29yay5yZXR1cm47IG51bGwgIT09IHBhcmVudDsgKSB7XG4gICAgICAgICAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTYwKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQudGFnKSB7XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIHZhciBwYXJlbnQkanNjb21wJDAgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICBiZWZvcmUgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgYmVmb3JlLCBwYXJlbnQkanNjb21wJDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdmFyIHBhcmVudCQxMTMgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmZsYWdzICYgMzIgJiZcbiAgICAgICAgICAgICAgKHNldFRleHRDb250ZW50KHBhcmVudCQxMTMsIFwiXCIpLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmZsYWdzICY9IC0zMykpO1xuICAgICAgICAgICAgdmFyIGJlZm9yZSQxMTQgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgYmVmb3JlJDExNCwgcGFyZW50JDExMyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdmFyIHBhcmVudCQxMTUgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICAgIGJlZm9yZSQxMTYgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBiZWZvcmUkMTE2LFxuICAgICAgICAgICAgICBwYXJlbnQkMTE1XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTYxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuICAgIGZpbmlzaGVkV29yay5mbGFncyAmPSAtMztcbiAgfVxuICBmbGFncyAmIDQwOTYgJiYgKGZpbmlzaGVkV29yay5mbGFncyAmPSAtNDA5Nyk7XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVJlc2V0Rm9ybXMocGFyZW50RmliZXIpIHtcbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjQpXG4gICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgICB2YXIgZmliZXIgPSBwYXJlbnRGaWJlcjtcbiAgICAgIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaWJlcik7XG4gICAgICA1ID09PSBmaWJlci50YWcgJiYgZmliZXIuZmxhZ3MgJiAxMDI0ICYmIGZpYmVyLnN0YXRlTm9kZS5yZXNldCgpO1xuICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyKSB7XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiA4NzcyKVxuICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIocm9vdCwgcGFyZW50RmliZXIuYWx0ZXJuYXRlLCBwYXJlbnRGaWJlciksXG4gICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xufVxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgdmFyIGZpbmlzaGVkV29yayA9IHBhcmVudEZpYmVyO1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxMTpcbiAgICAgIGNhc2UgMTQ6XG4gICAgICBjYXNlIDE1OlxuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoNCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCAmJlxuICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNjpcbiAgICAgIGNhc2UgMjc6XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjI6XG4gICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICB9XG4gICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICB9XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gIHBhcmVudEZpYmVyLFxuICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4pIHtcbiAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9XG4gICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiAwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgODc3Mik7XG4gIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgIHZhciBjdXJyZW50ID0gcGFyZW50RmliZXIuYWx0ZXJuYXRlLFxuICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290JGpzY29tcCQwLFxuICAgICAgZmluaXNoZWRXb3JrID0gcGFyZW50RmliZXIsXG4gICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTE6XG4gICAgICBjYXNlIDE1OlxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApO1xuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KDQsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBmaW5pc2hlZFJvb3QgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZpbmlzaGVkUm9vdC5jb21wb25lbnREaWRNb3VudClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmluaXNoZWRSb290LmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBmaW5pc2hlZFJvb3QgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgICBpZiAobnVsbCAhPT0gZmluaXNoZWRSb290KSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBoaWRkZW5DYWxsYmFja3MgPSBmaW5pc2hlZFJvb3Quc2hhcmVkLmhpZGRlbkNhbGxiYWNrcztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBoaWRkZW5DYWxsYmFja3MpXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPSBudWxsLCBmaW5pc2hlZFJvb3QgPSAwO1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA8IGhpZGRlbkNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290KytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGNhbGxDYWxsYmFjayhoaWRkZW5DYWxsYmFja3NbZmluaXNoZWRSb290XSwgaW5zdGFuY2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBjdXJyZW50LnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjY6XG4gICAgICBjYXNlIDI3OlxuICAgICAgY2FzZSA1OlxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApO1xuICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspO1xuICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyOlxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyMjpcbiAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgfVxuICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHByZXZpb3VzQ2FjaGUgPSBudWxsO1xuICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgIChwcmV2aW91c0NhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKTtcbiAgY3VycmVudCA9IG51bGw7XG4gIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCk7XG4gIGN1cnJlbnQgIT09IHByZXZpb3VzQ2FjaGUgJiZcbiAgICAobnVsbCAhPSBjdXJyZW50ICYmIGN1cnJlbnQucmVmQ291bnQrKyxcbiAgICBudWxsICE9IHByZXZpb3VzQ2FjaGUgJiYgcmVsZWFzZUNhY2hlKHByZXZpb3VzQ2FjaGUpKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBjdXJyZW50ID0gbnVsbDtcbiAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgIChjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlKTtcbiAgZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gIGZpbmlzaGVkV29yayAhPT0gY3VycmVudCAmJlxuICAgIChmaW5pc2hlZFdvcmsucmVmQ291bnQrKywgbnVsbCAhPSBjdXJyZW50ICYmIHJlbGVhc2VDYWNoZShjdXJyZW50KSk7XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgcm9vdCxcbiAgcGFyZW50RmliZXIsXG4gIGNvbW1pdHRlZExhbmVzLFxuICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuKSB7XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKFxuICAgICAgICByb290LFxuICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICApLFxuICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gIGZpbmlzaGVkUm9vdCxcbiAgZmluaXNoZWRXb3JrLFxuICBjb21taXR0ZWRMYW5lcyxcbiAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbikge1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgMDpcbiAgICBjYXNlIDExOlxuICAgIGNhc2UgMTU6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgKTtcbiAgICAgIGZsYWdzICYgMjA0OCAmJiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KDksIGZpbmlzaGVkV29yayk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgKTtcbiAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAoKGZpbmlzaGVkUm9vdCA9IG51bGwpLFxuICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgIGZpbmlzaGVkV29yayAhPT0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgKGZpbmlzaGVkV29yay5yZWZDb3VudCsrLFxuICAgICAgICAgIG51bGwgIT0gZmluaXNoZWRSb290ICYmIHJlbGVhc2VDYWNoZShmaW5pc2hlZFJvb3QpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEyOlxuICAgICAgaWYgKGZsYWdzICYgMjA0OCkge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICk7XG4gICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgIGlkID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5pZCxcbiAgICAgICAgICAgIG9uUG9zdENvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Qb3N0Q29tbWl0O1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9uUG9zdENvbW1pdCAmJlxuICAgICAgICAgICAgb25Qb3N0Q29tbWl0KFxuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSA/IFwibW91bnRcIiA6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgICAgIC0wXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjI6XG4gICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlXG4gICAgICAgID8gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5fdmlzaWJpbGl0eSAmIDRcbiAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspXG4gICAgICAgIDogX2ZpbmlzaGVkV29yayRtZW1vaXplMi5fdmlzaWJpbGl0eSAmIDRcbiAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAoKF9maW5pc2hlZFdvcmskbWVtb2l6ZTIuX3Zpc2liaWxpdHkgfD0gNCksXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgICAgICAgICApKTtcbiAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI0OlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICk7XG4gICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoZmluaXNoZWRXb3JrLmFsdGVybmF0ZSwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gIHBhcmVudEZpYmVyLFxuICBjb21taXR0ZWRMYW5lcyRqc2NvbXAkMCxcbiAgY29tbWl0dGVkVHJhbnNpdGlvbnMkanNjb21wJDAsXG4gIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbikge1xuICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1Nik7XG4gIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgIHZhciBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICBmaW5pc2hlZFdvcmsgPSBwYXJlbnRGaWJlcixcbiAgICAgIGNvbW1pdHRlZExhbmVzID0gY29tbWl0dGVkTGFuZXMkanNjb21wJDAsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyA9IGNvbW1pdHRlZFRyYW5zaXRpb25zJGpzY29tcCQwLFxuICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDExOlxuICAgICAgY2FzZSAxNTpcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApO1xuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KDgsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyMzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIyOlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgID8gaW5zdGFuY2UuX3Zpc2liaWxpdHkgJiA0XG4gICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgOiAoKGluc3RhbmNlLl92aXNpYmlsaXR5IHw9IDQpLFxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApKTtcbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OlxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICB9XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gIGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgcGFyZW50RmliZXJcbikge1xuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgICB2YXIgZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290JGpzY29tcCQwLFxuICAgICAgICBmaW5pc2hlZFdvcmsgPSBwYXJlbnRGaWJlcixcbiAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgfVxufVxudmFyIHN1c3BlbnNleUNvbW1pdEZsYWcgPSA4MTkyO1xuZnVuY3Rpb24gcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KHBhcmVudEZpYmVyKSB7XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKVxuICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKHBhcmVudEZpYmVyKSxcbiAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgMjY6XG4gICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnICYmXG4gICAgICAgIG51bGwgIT09IGZpYmVyLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgc3VzcGVuZFJlc291cmNlKFxuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290LFxuICAgICAgICAgIGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wc1xuICAgICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICBjYXNlIDQ6XG4gICAgICB2YXIgcHJldmlvdXNIb2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3QoZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gcHJldmlvdXNIb2lzdGFibGVSb290O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMjpcbiAgICAgIG51bGwgPT09IGZpYmVyLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgKChwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBmaWJlci5hbHRlcm5hdGUpLFxuICAgICAgICBudWxsICE9PSBwcmV2aW91c0hvaXN0YWJsZVJvb3QgJiZcbiAgICAgICAgbnVsbCAhPT0gcHJldmlvdXNIb2lzdGFibGVSb290Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA/ICgocHJldmlvdXNIb2lzdGFibGVSb290ID0gc3VzcGVuc2V5Q29tbWl0RmxhZyksXG4gICAgICAgICAgICAoc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDE2Nzc3MjE2KSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlciksXG4gICAgICAgICAgICAoc3VzcGVuc2V5Q29tbWl0RmxhZyA9IHByZXZpb3VzSG9pc3RhYmxlUm9vdCkpXG4gICAgICAgICAgOiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcikge1xuICB2YXIgcHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLmFsdGVybmF0ZTtcbiAgaWYgKFxuICAgIG51bGwgIT09IHByZXZpb3VzRmliZXIgJiZcbiAgICAoKHBhcmVudEZpYmVyID0gcHJldmlvdXNGaWJlci5jaGlsZCksIG51bGwgIT09IHBhcmVudEZpYmVyKVxuICApIHtcbiAgICBwcmV2aW91c0ZpYmVyLmNoaWxkID0gbnVsbDtcbiAgICBkb1xuICAgICAgKHByZXZpb3VzRmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKSxcbiAgICAgICAgKHBhcmVudEZpYmVyLnNpYmxpbmcgPSBudWxsKSxcbiAgICAgICAgKHBhcmVudEZpYmVyID0gcHJldmlvdXNGaWJlcik7XG4gICAgd2hpbGUgKG51bGwgIT09IHBhcmVudEZpYmVyKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgaWYgKG51bGwgIT09IGRlbGV0aW9ucylcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgIHBhcmVudEZpYmVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpO1xuICB9XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIocGFyZW50RmliZXIpLFxuICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTE6XG4gICAgY2FzZSAxNTpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZpbmlzaGVkV29yay5mbGFncyAmIDIwNDggJiZcbiAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KDksIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEyOlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMjpcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgaW5zdGFuY2UuX3Zpc2liaWxpdHkgJiA0ICYmXG4gICAgICAobnVsbCA9PT0gZmluaXNoZWRXb3JrLnJldHVybiB8fCAxMyAhPT0gZmluaXNoZWRXb3JrLnJldHVybi50YWcpXG4gICAgICAgID8gKChpbnN0YW5jZS5fdmlzaWJpbGl0eSAmPSAtNSksXG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspKVxuICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgdmFyIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyLmRlbGV0aW9ucztcbiAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5mbGFncyAmIDE2KSkge1xuICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTtcbiAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICAgICAgY2hpbGRUb0RlbGV0ZSxcbiAgICAgICAgICBwYXJlbnRGaWJlclxuICAgICAgICApO1xuICAgICAgfVxuICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgfVxuICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICBkZWxldGlvbnMgPSBwYXJlbnRGaWJlcjtcbiAgICBzd2l0Y2ggKGRlbGV0aW9ucy50YWcpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTE6XG4gICAgICBjYXNlIDE1OlxuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoOCwgZGVsZXRpb25zLCBkZWxldGlvbnMucmV0dXJuKTtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhkZWxldGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjI6XG4gICAgICAgIGkgPSBkZWxldGlvbnMuc3RhdGVOb2RlO1xuICAgICAgICBpLl92aXNpYmlsaXR5ICYgNCAmJlxuICAgICAgICAgICgoaS5fdmlzaWJpbGl0eSAmPSAtNSksXG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhkZWxldGlvbnMpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGRlbGV0aW9ucyk7XG4gICAgfVxuICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgZGVsZXRlZFN1YnRyZWVSb290LFxuICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4pIHtcbiAgZm9yICg7IG51bGwgIT09IG5leHRFZmZlY3Q7ICkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTE6XG4gICAgICBjYXNlIDE1OlxuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoOCwgZmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjM6XG4gICAgICBjYXNlIDIyOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIG51bGwgIT09IGZpYmVyLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBjYWNoZSA9IGZpYmVyLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2w7XG4gICAgICAgICAgbnVsbCAhPSBjYWNoZSAmJiBjYWNoZS5yZWZDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDpcbiAgICAgICAgcmVsZWFzZUNhY2hlKGZpYmVyLm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgIH1cbiAgICBjYWNoZSA9IGZpYmVyLmNoaWxkO1xuICAgIGlmIChudWxsICE9PSBjYWNoZSkgKGNhY2hlLnJldHVybiA9IGZpYmVyKSwgKG5leHRFZmZlY3QgPSBjYWNoZSk7XG4gICAgZWxzZVxuICAgICAgYTogZm9yIChmaWJlciA9IGRlbGV0ZWRTdWJ0cmVlUm9vdDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgIGNhY2hlID0gbmV4dEVmZmVjdDtcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBjYWNoZS5zaWJsaW5nLFxuICAgICAgICAgIHJldHVybkZpYmVyID0gY2FjaGUucmV0dXJuO1xuICAgICAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhjYWNoZSk7XG4gICAgICAgIGlmIChjYWNoZSA9PT0gZmliZXIpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICBicmVhayBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9PSBzaWJsaW5nKSB7XG4gICAgICAgICAgc2libGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgICAgICBicmVhayBhO1xuICAgICAgICB9XG4gICAgICAgIG5leHRFZmZlY3QgPSByZXR1cm5GaWJlcjtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLnNpYmxpbmcgPVxuICAgIHRoaXMuY2hpbGQgPVxuICAgIHRoaXMucmV0dXJuID1cbiAgICB0aGlzLnN0YXRlTm9kZSA9XG4gICAgdGhpcy50eXBlID1cbiAgICB0aGlzLmVsZW1lbnRUeXBlID1cbiAgICAgIG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuICB0aGlzLnJlZkNsZWFudXAgPSB0aGlzLnJlZiA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICB0aGlzLmRlcGVuZGVuY2llcyA9XG4gICAgdGhpcy5tZW1vaXplZFN0YXRlID1cbiAgICB0aGlzLnVwZGF0ZVF1ZXVlID1cbiAgICB0aGlzLm1lbW9pemVkUHJvcHMgPVxuICAgICAgbnVsbDtcbiAgdGhpcy5tb2RlID0gbW9kZTtcbiAgdGhpcy5zdWJ0cmVlRmxhZ3MgPSB0aGlzLmZsYWdzID0gMDtcbiAgdGhpcy5kZWxldGlvbnMgPSBudWxsO1xuICB0aGlzLmNoaWxkTGFuZXMgPSB0aGlzLmxhbmVzID0gMDtcbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJJbXBsQ2xhc3ModGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn1cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgQ29tcG9uZW50ID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEoIUNvbXBvbmVudCB8fCAhQ29tcG9uZW50LmlzUmVhY3RDb21wb25lbnQpO1xufVxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzKSB7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1xuICAgID8gKCh3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKFxuICAgICAgICBjdXJyZW50LnRhZyxcbiAgICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgICBjdXJyZW50LmtleSxcbiAgICAgICAgY3VycmVudC5tb2RlXG4gICAgICApKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9IGN1cnJlbnQuZWxlbWVudFR5cGUpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50KSxcbiAgICAgIChjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzKSlcbiAgICA6ICgod29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IDApLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGwpKTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBjdXJyZW50LmZsYWdzICYgMzE0NTcyODA7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gIHBlbmRpbmdQcm9wcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPVxuICAgIG51bGwgPT09IHBlbmRpbmdQcm9wc1xuICAgICAgPyBudWxsXG4gICAgICA6IHsgbGFuZXM6IHBlbmRpbmdQcm9wcy5sYW5lcywgZmlyc3RDb250ZXh0OiBwZW5kaW5nUHJvcHMuZmlyc3RDb250ZXh0IH07XG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG4gIHdvcmtJblByb2dyZXNzLnJlZkNsZWFudXAgPSBjdXJyZW50LnJlZkNsZWFudXA7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3Mod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IDMxNDU3MjgyO1xuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgbnVsbCA9PT0gY3VycmVudFxuICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gMCksXG4gICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcyksXG4gICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbnVsbCksXG4gICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbCksXG4gICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gbnVsbCksXG4gICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbnVsbCkpXG4gICAgOiAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXMpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcyksXG4gICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgKHJlbmRlckxhbmVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9XG4gICAgICAgIG51bGwgPT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIGxhbmVzOiByZW5kZXJMYW5lcy5sYW5lcyxcbiAgICAgICAgICAgICAgZmlyc3RDb250ZXh0OiByZW5kZXJMYW5lcy5maXJzdENvbnRleHRcbiAgICAgICAgICAgIH0pKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICB0eXBlLFxuICBrZXksXG4gIHBlbmRpbmdQcm9wcyxcbiAgb3duZXIsXG4gIG1vZGUsXG4gIGxhbmVzXG4pIHtcbiAgdmFyIGZpYmVyVGFnID0gMDtcbiAgb3duZXIgPSB0eXBlO1xuICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSkgc2hvdWxkQ29uc3RydWN0KHR5cGUpICYmIChmaWJlclRhZyA9IDEpO1xuICBlbHNlIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSlcbiAgICBmaWJlclRhZyA9IGlzSG9zdEhvaXN0YWJsZVR5cGUoXG4gICAgICB0eXBlLFxuICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICApXG4gICAgICA/IDI2XG4gICAgICA6IFwiaHRtbFwiID09PSB0eXBlIHx8IFwiaGVhZFwiID09PSB0eXBlIHx8IFwiYm9keVwiID09PSB0eXBlXG4gICAgICAgID8gMjdcbiAgICAgICAgOiA1O1xuICBlbHNlXG4gICAgYTogc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChwZW5kaW5nUHJvcHMuY2hpbGRyZW4sIG1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IDg7XG4gICAgICAgIG1vZGUgfD0gMjQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICh0eXBlID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoMTIsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlIHwgMikpLFxuICAgICAgICAgICh0eXBlLmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRSksXG4gICAgICAgICAgKHR5cGUubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgdHlwZVxuICAgICAgICApO1xuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICh0eXBlID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoMTMsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSksXG4gICAgICAgICAgKHR5cGUuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFKSxcbiAgICAgICAgICAodHlwZS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICB0eXBlXG4gICAgICAgICk7XG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAodHlwZSA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKDE5LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkpLFxuICAgICAgICAgICh0eXBlLmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFKSxcbiAgICAgICAgICAodHlwZS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICB0eXBlXG4gICAgICAgICk7XG4gICAgICBjYXNlIFJFQUNUX09GRlNDUkVFTl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCAhPT0gdHlwZSlcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBmaWJlclRhZyA9IDEwO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgICBmaWJlclRhZyA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgZmliZXJUYWcgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBmaWJlclRhZyA9IDE2O1xuICAgICAgICAgICAgICBvd25lciA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgfVxuICAgICAgICBmaWJlclRhZyA9IDI5O1xuICAgICAgICBwZW5kaW5nUHJvcHMgPSBFcnJvcihcbiAgICAgICAgICBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzMCwgbnVsbCA9PT0gdHlwZSA/IFwibnVsbFwiIDogdHlwZW9mIHR5cGUsIFwiXCIpXG4gICAgICAgICk7XG4gICAgICAgIG93bmVyID0gbnVsbDtcbiAgICB9XG4gIGtleSA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGtleS5lbGVtZW50VHlwZSA9IHR5cGU7XG4gIGtleS50eXBlID0gb3duZXI7XG4gIGtleS5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgZWxlbWVudHMgPSBjcmVhdGVGaWJlckltcGxDbGFzcyg3LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgZWxlbWVudHMubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGVsZW1lbnRzO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICBwZW5kaW5nUHJvcHMgPSBjcmVhdGVGaWJlckltcGxDbGFzcygyMiwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBwZW5kaW5nUHJvcHMuZWxlbWVudFR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgcGVuZGluZ1Byb3BzLmxhbmVzID0gbGFuZXM7XG4gIHZhciBwcmltYXJ5Q2hpbGRJbnN0YW5jZSA9IHtcbiAgICBfdmlzaWJpbGl0eTogMSxcbiAgICBfcGVuZGluZ1Zpc2liaWxpdHk6IDEsXG4gICAgX3BlbmRpbmdNYXJrZXJzOiBudWxsLFxuICAgIF9yZXRyeUNhY2hlOiBudWxsLFxuICAgIF90cmFuc2l0aW9uczogbnVsbCxcbiAgICBfY3VycmVudDogbnVsbCxcbiAgICBkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaWJlciA9IHByaW1hcnlDaGlsZEluc3RhbmNlLl9jdXJyZW50O1xuICAgICAgaWYgKG51bGwgPT09IGZpYmVyKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ1NikpO1xuICAgICAgaWYgKDAgPT09IChwcmltYXJ5Q2hpbGRJbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiAyKSkge1xuICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAoKHByaW1hcnlDaGlsZEluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSB8PSAyKSxcbiAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGF0dGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZpYmVyID0gcHJpbWFyeUNoaWxkSW5zdGFuY2UuX2N1cnJlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gZmliZXIpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDU2KSk7XG4gICAgICBpZiAoMCAhPT0gKHByaW1hcnlDaGlsZEluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIDIpKSB7XG4gICAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICgocHJpbWFyeUNoaWxkSW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICY9IC0zKSxcbiAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHBlbmRpbmdQcm9wcy5zdGF0ZU5vZGUgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZTtcbiAgcmV0dXJuIHBlbmRpbmdQcm9wcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgY29udGVudCA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKDYsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICBjb250ZW50LmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBjb250ZW50O1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgbW9kZSwgbGFuZXMpIHtcbiAgbW9kZSA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKFxuICAgIDQsXG4gICAgbnVsbCAhPT0gcG9ydGFsLmNoaWxkcmVuID8gcG9ydGFsLmNoaWxkcmVuIDogW10sXG4gICAgcG9ydGFsLmtleSxcbiAgICBtb2RlXG4gICk7XG4gIG1vZGUubGFuZXMgPSBsYW5lcztcbiAgbW9kZS5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIG1vZGU7XG59XG5mdW5jdGlvbiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSB7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQ7XG59XG5mdW5jdGlvbiBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHJlc291cmNlKSB7XG4gIGlmIChcInN0eWxlc2hlZXRcIiAhPT0gcmVzb3VyY2UudHlwZSB8fCAwICE9PSAocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIDQpKVxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNztcbiAgZWxzZSBpZiAoKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxNjc3NzIxNiksICFwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpKSkge1xuICAgIHJlc291cmNlID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICBpZiAoXG4gICAgICBudWxsICE9PSByZXNvdXJjZSAmJlxuICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDQxOTQxNzYpID09PVxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgPyBudWxsICE9PSBzaGVsbEJvdW5kYXJ5XG4gICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYyOTE0NTYwKSAhPT1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpKSB8fFxuICAgICAgICAgIHJlc291cmNlICE9PSBzaGVsbEJvdW5kYXJ5KVxuICAgIClcbiAgICAgIHRocm93IChcbiAgICAgICAgKChzdXNwZW5kZWRUaGVuYWJsZSA9IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSksXG4gICAgICAgIFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbilcbiAgICAgICk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MjtcbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmV0cnlRdWV1ZSkge1xuICBudWxsICE9PSByZXRyeVF1ZXVlICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxNjM4NCAmJlxuICAgICgocmV0cnlRdWV1ZSA9XG4gICAgICAyMiAhPT0gd29ya0luUHJvZ3Jlc3MudGFnID8gY2xhaW1OZXh0UmV0cnlMYW5lKCkgOiA1MzY4NzA5MTIpLFxuICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyB8PSByZXRyeVF1ZXVlKSxcbiAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzIHw9IHJldHJ5UXVldWUpKTtcbn1cbmZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpXG4gICAgc3dpdGNoIChyZW5kZXJTdGF0ZS50YWlsTW9kZSkge1xuICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICBmb3IgKHZhciBsYXN0VGFpbE5vZGUgPSBudWxsOyBudWxsICE9PSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2s7IClcbiAgICAgICAgICBudWxsICE9PSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2suYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAobGFzdFRhaWxOb2RlID0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSxcbiAgICAgICAgICAgIChoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgPSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2suc2libGluZyk7XG4gICAgICAgIG51bGwgPT09IGxhc3RUYWlsTm9kZVxuICAgICAgICAgID8gKHJlbmRlclN0YXRlLnRhaWwgPSBudWxsKVxuICAgICAgICAgIDogKGxhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNvbGxhcHNlZFwiOlxuICAgICAgICBsYXN0VGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICBmb3IgKHZhciBsYXN0VGFpbE5vZGUkMTMxID0gbnVsbDsgbnVsbCAhPT0gbGFzdFRhaWxOb2RlOyApXG4gICAgICAgICAgbnVsbCAhPT0gbGFzdFRhaWxOb2RlLmFsdGVybmF0ZSAmJiAobGFzdFRhaWxOb2RlJDEzMSA9IGxhc3RUYWlsTm9kZSksXG4gICAgICAgICAgICAobGFzdFRhaWxOb2RlID0gbGFzdFRhaWxOb2RlLnNpYmxpbmcpO1xuICAgICAgICBudWxsID09PSBsYXN0VGFpbE5vZGUkMTMxXG4gICAgICAgICAgPyBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgfHwgbnVsbCA9PT0gcmVuZGVyU3RhdGUudGFpbFxuICAgICAgICAgICAgPyAocmVuZGVyU3RhdGUudGFpbCA9IG51bGwpXG4gICAgICAgICAgICA6IChyZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsKVxuICAgICAgICAgIDogKGxhc3RUYWlsTm9kZSQxMzEuc2libGluZyA9IG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICB2YXIgZGlkQmFpbG91dCA9XG4gICAgICBudWxsICE9PSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQsXG4gICAgbmV3Q2hpbGRMYW5lcyA9IDAsXG4gICAgc3VidHJlZUZsYWdzID0gMDtcbiAgaWYgKGRpZEJhaWxvdXQpXG4gICAgZm9yICh2YXIgY2hpbGQkMTMyID0gY29tcGxldGVkV29yay5jaGlsZDsgbnVsbCAhPT0gY2hpbGQkMTMyOyApXG4gICAgICAobmV3Q2hpbGRMYW5lcyB8PSBjaGlsZCQxMzIubGFuZXMgfCBjaGlsZCQxMzIuY2hpbGRMYW5lcyksXG4gICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQkMTMyLnN1YnRyZWVGbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBjaGlsZCQxMzIuZmxhZ3MgJiAzMTQ1NzI4MCksXG4gICAgICAgIChjaGlsZCQxMzIucmV0dXJuID0gY29tcGxldGVkV29yayksXG4gICAgICAgIChjaGlsZCQxMzIgPSBjaGlsZCQxMzIuc2libGluZyk7XG4gIGVsc2VcbiAgICBmb3IgKGNoaWxkJDEzMiA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7IG51bGwgIT09IGNoaWxkJDEzMjsgKVxuICAgICAgKG5ld0NoaWxkTGFuZXMgfD0gY2hpbGQkMTMyLmxhbmVzIHwgY2hpbGQkMTMyLmNoaWxkTGFuZXMpLFxuICAgICAgICAoc3VidHJlZUZsYWdzIHw9IGNoaWxkJDEzMi5zdWJ0cmVlRmxhZ3MpLFxuICAgICAgICAoc3VidHJlZUZsYWdzIHw9IGNoaWxkJDEzMi5mbGFncyksXG4gICAgICAgIChjaGlsZCQxMzIucmV0dXJuID0gY29tcGxldGVkV29yayksXG4gICAgICAgIChjaGlsZCQxMzIgPSBjaGlsZCQxMzIuc2libGluZyk7XG4gIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgcmV0dXJuIGRpZEJhaWxvdXQ7XG59XG5mdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgMTY6XG4gICAgY2FzZSAxNTpcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxMTpcbiAgICBjYXNlIDc6XG4gICAgY2FzZSA4OlxuICAgIGNhc2UgMTI6XG4gICAgY2FzZSA5OlxuICAgIGNhc2UgMTQ6XG4gICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgIGNhc2UgMzpcbiAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiAobmV3UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZSAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpO1xuICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0KTtcbiAgICAgIHBvcEhvc3RDb250YWluZXIoKTtcbiAgICAgIHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0ICYmXG4gICAgICAgICgocmVuZGVyTGFuZXMuY29udGV4dCA9IHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0KSxcbiAgICAgICAgKHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0ID0gbnVsbCkpO1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgbnVsbCA9PT0gY3VycmVudC5jaGlsZClcbiAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgPyBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgIDogbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KSkgfHxcbiAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICBudWxsICE9PSBoeWRyYXRpb25FcnJvcnMgJiZcbiAgICAgICAgICAgICAgKHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKSxcbiAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpKSk7XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgMjY6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAocmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgID8gKG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgPyAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykpXG4gICAgICAgICAgICAgIDogKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTcpKSlcbiAgICAgICAgICA6IHJlbmRlckxhbmVzXG4gICAgICAgICAgICA/IHJlbmRlckxhbmVzICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgPyAobWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykpXG4gICAgICAgICAgICAgIDogKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTcpKVxuICAgICAgICAgICAgOiAoY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTcpKSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDI3OlxuICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmVuZGVyTGFuZXMgPSByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2NikpO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgPyBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdXJyZW50KVxuICAgICAgICAgIDogKChjdXJyZW50ID0gcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgfVxuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDU6XG4gICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTY2KSk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgICBpZiAocG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKFxuICAgICAgICAgICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgICAgc3dpdGNoIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSB0eXBlLmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgICAgICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSB0eXBlLmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgICAgICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHN3aXRjaCAocmVuZGVyTGFuZXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdHlwZS5jcmVhdGVFbGVtZW50TlMoXG4gICAgICAgICAgICAgICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHR5cGUuY3JlYXRlRWxlbWVudE5TKFxuICAgICAgICAgICAgICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdHlwZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudC5pbm5lckhUTUwgPSBcIjxzY3JpcHQ+XFx4M2Mvc2NyaXB0PlwiO1xuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmVtb3ZlQ2hpbGQoY3VycmVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3UHJvcHMuaXNcbiAgICAgICAgICAgICAgICAgICAgICA/IHR5cGUuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCB7IGlzOiBuZXdQcm9wcy5pcyB9KVxuICAgICAgICAgICAgICAgICAgICAgIDogdHlwZS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgbmV3UHJvcHMubXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgICAgPyAoY3VycmVudC5tdWx0aXBsZSA9ICEwKVxuICAgICAgICAgICAgICAgICAgICA6IG5ld1Byb3BzLnNpemUgJiYgKGN1cnJlbnQuc2l6ZSA9IG5ld1Byb3BzLnNpemUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3UHJvcHMuaXNcbiAgICAgICAgICAgICAgICAgICAgICA/IHR5cGUuY3JlYXRlRWxlbWVudChyZW5kZXJMYW5lcywgeyBpczogbmV3UHJvcHMuaXMgfSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHR5cGUuY3JlYXRlRWxlbWVudChyZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIGN1cnJlbnRbaW50ZXJuYWxQcm9wc0tleV0gPSBuZXdQcm9wcztcbiAgICAgICAgICBhOiBmb3IgKHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gdHlwZTsgKSB7XG4gICAgICAgICAgICBpZiAoNSA9PT0gdHlwZS50YWcgfHwgNiA9PT0gdHlwZS50YWcpXG4gICAgICAgICAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQodHlwZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoNCAhPT0gdHlwZS50YWcgJiYgMjcgIT09IHR5cGUudGFnICYmIG51bGwgIT09IHR5cGUuY2hpbGQpIHtcbiAgICAgICAgICAgICAgdHlwZS5jaGlsZC5yZXR1cm4gPSB0eXBlO1xuICAgICAgICAgICAgICB0eXBlID0gdHlwZS5jaGlsZDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrIGE7XG4gICAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gdHlwZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHR5cGUucmV0dXJuIHx8IHR5cGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB0eXBlID0gdHlwZS5yZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlLnNpYmxpbmcucmV0dXJuID0gdHlwZS5yZXR1cm47XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50O1xuICAgICAgICAgIGE6IHN3aXRjaCAoXG4gICAgICAgICAgICAoc2V0SW5pdGlhbFByb3BlcnRpZXMoY3VycmVudCwgcmVuZGVyTGFuZXMsIG5ld1Byb3BzKSwgcmVuZGVyTGFuZXMpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgICAgICBjdXJyZW50ID0gISFuZXdQcm9wcy5hdXRvRm9jdXM7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSAhMDtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTc7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDY6XG4gICAgICBpZiAoY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG5ld1Byb3BzICYmIG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2NikpO1xuICAgICAgICBjdXJyZW50ID0gcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgICAgaWYgKHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICB0eXBlID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHR5cGUpXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBuZXdQcm9wcyA9IHR5cGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50W2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgY3VycmVudCA9XG4gICAgICAgICAgICBjdXJyZW50Lm5vZGVWYWx1ZSA9PT0gcmVuZGVyTGFuZXMgfHxcbiAgICAgICAgICAgIChudWxsICE9PSBuZXdQcm9wcyAmJiAhMCA9PT0gbmV3UHJvcHMuc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB8fFxuICAgICAgICAgICAgY2hlY2tGb3JVbm1hdGNoZWRUZXh0KGN1cnJlbnQubm9kZVZhbHVlLCByZW5kZXJMYW5lcylcbiAgICAgICAgICAgICAgPyAhMFxuICAgICAgICAgICAgICA6ICExO1xuICAgICAgICAgIGN1cnJlbnQgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgKGN1cnJlbnQgPVxuICAgICAgICAgICAgZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKGN1cnJlbnQpLmNyZWF0ZVRleHROb2RlKFxuICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoY3VycmVudFtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAxMzpcbiAgICAgIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAobnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmRlaHlkcmF0ZWQpXG4gICAgICApIHtcbiAgICAgICAgdHlwZSA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKG51bGwgIT09IG5ld1Byb3BzICYmIG51bGwgIT09IG5ld1Byb3BzLmRlaHlkcmF0ZWQpIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMxOCkpO1xuICAgICAgICAgICAgdHlwZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICB0eXBlID0gbnVsbCAhPT0gdHlwZSA/IHR5cGUuZGVoeWRyYXRlZCA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzE3KSk7XG4gICAgICAgICAgICB0eXBlW2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCksXG4gICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdHlwZSA9ICExO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBudWxsICE9PSBoeWRyYXRpb25FcnJvcnMgJiZcbiAgICAgICAgICAgIChxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGh5ZHJhdGlvbkVycm9ycyksIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSksXG4gICAgICAgICAgICAodHlwZSA9ICEwKTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KVxuICAgICAgICAgICAgcmV0dXJuIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSlcbiAgICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzKSwgd29ya0luUHJvZ3Jlc3M7XG4gICAgICByZW5kZXJMYW5lcyA9IG51bGwgIT09IG5ld1Byb3BzO1xuICAgICAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKHJlbmRlckxhbmVzKSB7XG4gICAgICAgIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUgJiZcbiAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICh0eXBlID0gbmV3UHJvcHMuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICAgICAgICB2YXIgY2FjaGUkMTQ0ID0gbnVsbDtcbiAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgKGNhY2hlJDE0NCA9IG5ld1Byb3BzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICAgICAgICBjYWNoZSQxNDQgIT09IHR5cGUgJiYgKG5ld1Byb3BzLmZsYWdzIHw9IDIwNDgpO1xuICAgICAgfVxuICAgICAgcmVuZGVyTGFuZXMgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkLmZsYWdzIHw9IDgxOTIpO1xuICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUpO1xuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKCksXG4gICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgIGNhc2UgMTA6XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlKSwgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGxcbiAgICAgICk7XG4gICAgY2FzZSAxOTpcbiAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yKTtcbiAgICAgIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgPT09IHR5cGUpIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgIG5ld1Byb3BzID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KTtcbiAgICAgIGNhY2hlJDE0NCA9IHR5cGUucmVuZGVyaW5nO1xuICAgICAgaWYgKG51bGwgPT09IGNhY2hlJDE0NClcbiAgICAgICAgaWYgKG5ld1Byb3BzKSBjdXRPZmZUYWlsSWZOZWVkZWQodHlwZSwgITEpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAwICE9PSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzIHx8XG4gICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiAwICE9PSAoY3VycmVudC5mbGFncyAmIDEyOCkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IGN1cnJlbnQ7ICkge1xuICAgICAgICAgICAgICBjYWNoZSQxNDQgPSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCk7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSBjYWNoZSQxNDQpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjg7XG4gICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHR5cGUsICExKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY2FjaGUkMTQ0LnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgICAgICBmb3IgKHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IHJlbmRlckxhbmVzOyApXG4gICAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzKHJlbmRlckxhbmVzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXMuc2libGluZyk7XG4gICAgICAgICAgICAgICAgcHVzaChcbiAgICAgICAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgICAgICAgICAgICAoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICYgMSkgfCAyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsICE9PSB0eXBlLnRhaWwgJiZcbiAgICAgICAgICAgIG5vdygpID4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSAmJlxuICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgKG5ld1Byb3BzID0gITApLFxuICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHR5cGUsICExKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDQxOTQzMDQpKTtcbiAgICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICghbmV3UHJvcHMpXG4gICAgICAgICAgaWYgKCgoY3VycmVudCA9IGZpbmRGaXJzdFN1c3BlbmRlZChjYWNoZSQxNDQpKSwgbnVsbCAhPT0gY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAobmV3UHJvcHMgPSAhMCksXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHR5cGUsICEwKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gdHlwZS50YWlsICYmXG4gICAgICAgICAgICAgICAgXCJoaWRkZW5cIiA9PT0gdHlwZS50YWlsTW9kZSAmJlxuICAgICAgICAgICAgICAgICFjYWNoZSQxNDQuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgIWlzSHlkcmF0aW5nKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAyICogbm93KCkgLSB0eXBlLnJlbmRlcmluZ1N0YXJ0VGltZSA+XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgJiZcbiAgICAgICAgICAgICAgNTM2ODcwOTEyICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHR5cGUsICExKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gNDE5NDMwNCkpO1xuICAgICAgICB0eXBlLmlzQmFja3dhcmRzXG4gICAgICAgICAgPyAoKGNhY2hlJDE0NC5zaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2FjaGUkMTQ0KSlcbiAgICAgICAgICA6ICgoY3VycmVudCA9IHR5cGUubGFzdCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKGN1cnJlbnQuc2libGluZyA9IGNhY2hlJDE0NClcbiAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjYWNoZSQxNDQpLFxuICAgICAgICAgICAgKHR5cGUubGFzdCA9IGNhY2hlJDE0NCkpO1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgIT09IHR5cGUudGFpbClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB0eXBlLnRhaWwpLFxuICAgICAgICAgICh0eXBlLnJlbmRlcmluZyA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAodHlwZS50YWlsID0gd29ya0luUHJvZ3Jlc3Muc2libGluZyksXG4gICAgICAgICAgKHR5cGUucmVuZGVyaW5nU3RhcnRUaW1lID0gbm93KCkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gbnVsbCksXG4gICAgICAgICAgKGN1cnJlbnQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICAgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgbmV3UHJvcHMgPyAoY3VycmVudCAmIDEpIHwgMiA6IGN1cnJlbnQgJiAxKSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICApO1xuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDIyOlxuICAgIGNhc2UgMjM6XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICBwb3BIaWRkZW5Db250ZXh0KCksXG4gICAgICAgIChuZXdQcm9wcyA9IG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgPyAobnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKVxuICAgICAgICAgIDogbmV3UHJvcHMgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpLFxuICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgID8gMCAhPT0gKHJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSAmJlxuICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSAmJlxuICAgICAgICAgICAgKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzICYgNiAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MikpXG4gICAgICAgICAgOiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgKHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUpLFxuICAgICAgICBudWxsICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLnJldHJ5UXVldWUpLFxuICAgICAgICAocmVuZGVyTGFuZXMgPSBudWxsKSxcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAocmVuZGVyTGFuZXMgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAobmV3UHJvcHMgPSBudWxsKSxcbiAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgKG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgIG5ld1Byb3BzICE9PSByZW5kZXJMYW5lcyAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSksXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgY2FzZSAyNDpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChyZW5kZXJMYW5lcyA9IG51bGwpLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGUgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQpLFxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDI1OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNTYsIHdvcmtJblByb2dyZXNzLnRhZykpO1xufVxuZnVuY3Rpb24gdW53aW5kV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgIDogbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQpLFxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKCksXG4gICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MpLFxuICAgICAgICAwICE9PSAoY3VycmVudCAmIDY1NTM2KSAmJiAwID09PSAoY3VycmVudCAmIDEyOClcbiAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLCB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICA6IG51bGxcbiAgICAgICk7XG4gICAgY2FzZSAyNjpcbiAgICBjYXNlIDI3OlxuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgY2FzZSAxMzpcbiAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQuZGVoeWRyYXRlZCkge1xuICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlKVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzQwKSk7XG4gICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcbiAgICAgIHJldHVybiBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSwgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgIDogbnVsbDtcbiAgICBjYXNlIDE5OlxuICAgICAgcmV0dXJuIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yKSwgbnVsbDtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gcG9wSG9zdENvbnRhaW5lcigpLCBudWxsO1xuICAgIGNhc2UgMTA6XG4gICAgICByZXR1cm4gcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MudHlwZSksIG51bGw7XG4gICAgY2FzZSAyMjpcbiAgICBjYXNlIDIzOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgcG9wSGlkZGVuQ29udGV4dCgpLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIHBvcChyZXN1bWVkQ2FjaGUpLFxuICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgY3VycmVudCAmIDY1NTM2XG4gICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSwgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgOiBudWxsXG4gICAgICApO1xuICAgIGNhc2UgMjQ6XG4gICAgICByZXR1cm4gcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0KSwgbnVsbDtcbiAgICBjYXNlIDI1OlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgaW50ZXJydXB0ZWRXb3JrKSB7XG4gIHBvcFRyZWVDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgIGNhc2UgMzpcbiAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCk7XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI2OlxuICAgIGNhc2UgMjc6XG4gICAgY2FzZSA1OlxuICAgICAgcG9wSG9zdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTM6XG4gICAgICBwb3BTdXNwZW5zZUhhbmRsZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTk6XG4gICAgICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwOlxuICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrLnR5cGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMjpcbiAgICBjYXNlIDIzOlxuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICBwb3BIaWRkZW5Db250ZXh0KCk7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmIHBvcChyZXN1bWVkQ2FjaGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNDpcbiAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCk7XG4gIH1cbn1cbnZhciBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICAgIGdldENhY2hlRm9yVHlwZTogZnVuY3Rpb24gKHJlc291cmNlVHlwZSkge1xuICAgICAgdmFyIGNhY2hlID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KSxcbiAgICAgICAgY2FjaGVGb3JUeXBlID0gY2FjaGUuZGF0YS5nZXQocmVzb3VyY2VUeXBlKTtcbiAgICAgIHZvaWQgMCA9PT0gY2FjaGVGb3JUeXBlICYmXG4gICAgICAgICgoY2FjaGVGb3JUeXBlID0gcmVzb3VyY2VUeXBlKCkpLFxuICAgICAgICBjYWNoZS5kYXRhLnNldChyZXNvdXJjZVR5cGUsIGNhY2hlRm9yVHlwZSkpO1xuICAgICAgcmV0dXJuIGNhY2hlRm9yVHlwZTtcbiAgICB9XG4gIH0sXG4gIFBvc3NpYmx5V2Vha01hcCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwLFxuICBleGVjdXRpb25Db250ZXh0ID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3MgPSBudWxsLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDAsXG4gIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGwsXG4gIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9ICExLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9ICExLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMSxcbiAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IDAsXG4gIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGwsXG4gIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9ICExLFxuICBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5LFxuICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbCxcbiAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsLFxuICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICExLFxuICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGwsXG4gIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gMCxcbiAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSAwLFxuICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbCxcbiAgbmVzdGVkVXBkYXRlQ291bnQgPSAwLFxuICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZUxhbmUoKSB7XG4gIGlmICgwICE9PSAoZXhlY3V0aW9uQ29udGV4dCAmIDIpICYmIDAgIT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKVxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIC13b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgaWYgKG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQpIHtcbiAgICB2YXIgYWN0aW9uU2NvcGVMYW5lID0gY3VycmVudEVudGFuZ2xlZExhbmU7XG4gICAgcmV0dXJuIDAgIT09IGFjdGlvblNjb3BlTGFuZSA/IGFjdGlvblNjb3BlTGFuZSA6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpO1xuICB9XG4gIHJldHVybiByZXNvbHZlVXBkYXRlUHJpb3JpdHkoKTtcbn1cbmZ1bmN0aW9uIHJlcXVlc3REZWZlcnJlZExhbmUoKSB7XG4gIDAgPT09IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lICYmXG4gICAgKHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID1cbiAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikgfHwgaXNIeWRyYXRpbmdcbiAgICAgICAgPyBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpXG4gICAgICAgIDogNTM2ODcwOTEyKTtcbiAgdmFyIHN1c3BlbnNlSGFuZGxlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIG51bGwgIT09IHN1c3BlbnNlSGFuZGxlciAmJiAoc3VzcGVuc2VIYW5kbGVyLmZsYWdzIHw9IDMyKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gIGlmIChcbiAgICAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmIDIgPT09IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB8fFxuICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdFxuICApXG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgMCksXG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgcm9vdCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgbGFuZSk7XG4gIGlmICgwID09PSAoZXhlY3V0aW9uQ29udGV4dCAmIDIpIHx8IHJvb3QgIT09IHdvcmtJblByb2dyZXNzUm9vdClcbiAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAgICgwID09PSAoZXhlY3V0aW9uQ29udGV4dCAmIDIpICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyB8PSBsYW5lKSxcbiAgICAgIDQgPT09IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgJiZcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAhMVxuICAgICAgICApKSxcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QkanNjb21wJDAsIGxhbmVzLCBmb3JjZVN5bmMpIHtcbiAgaWYgKDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgNikpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzI3KSk7XG4gIHZhciBzaG91bGRUaW1lU2xpY2UgPVxuICAgICAgKCFmb3JjZVN5bmMgJiZcbiAgICAgICAgMCA9PT0gKGxhbmVzICYgNjApICYmXG4gICAgICAgIDAgPT09IChsYW5lcyAmIHJvb3QkanNjb21wJDAuZXhwaXJlZExhbmVzKSkgfHxcbiAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCRqc2NvbXAkMCwgbGFuZXMpLFxuICAgIGV4aXRTdGF0dXMgPSBzaG91bGRUaW1lU2xpY2VcbiAgICAgID8gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCRqc2NvbXAkMCwgbGFuZXMpXG4gICAgICA6IHJlbmRlclJvb3RTeW5jKHJvb3QkanNjb21wJDAsIGxhbmVzLCAhMCksXG4gICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IHNob3VsZFRpbWVTbGljZTtcbiAgZG8ge1xuICAgIGlmICgwID09PSBleGl0U3RhdHVzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyAmJlxuICAgICAgICAhc2hvdWxkVGltZVNsaWNlICYmXG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QkanNjb21wJDAsIGxhbmVzLCAwLCAhMSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKDYgPT09IGV4aXRTdGF0dXMpXG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgbGFuZXMsXG4gICAgICAgIDAsXG4gICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICk7XG4gICAgZWxzZSB7XG4gICAgICBmb3JjZVN5bmMgPSByb290JGpzY29tcCQwLmN1cnJlbnQuYWx0ZXJuYXRlO1xuICAgICAgaWYgKFxuICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ICYmXG4gICAgICAgICFpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZm9yY2VTeW5jKVxuICAgICAgKSB7XG4gICAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290JGpzY29tcCQwLCBsYW5lcywgITEpO1xuICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gITE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKDIgPT09IGV4aXRTdGF0dXMpIHtcbiAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IGxhbmVzO1xuICAgICAgICBpZiAocm9vdCRqc2NvbXAkMC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmIHJlbmRlcldhc0NvbmN1cnJlbnQpXG4gICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IDA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcm9vdCRqc2NvbXAkMC5wZW5kaW5nTGFuZXMgJiAtNTM2ODcwOTEzKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICAgICAgICAwICE9PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICAgICAgICA/IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICAgICAgIDogSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYgNTM2ODcwOTEyXG4gICAgICAgICAgICAgICAgICA/IDUzNjg3MDkxMlxuICAgICAgICAgICAgICAgICAgOiAwKTtcbiAgICAgICAgaWYgKDAgIT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICAgIGxhbmVzID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHZhciByb290ID0gcm9vdCRqc2NvbXAkMDtcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzO1xuICAgICAgICAgICAgdmFyIHdhc1Jvb3REZWh5ZHJhdGVkID0gcm9vdC5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkO1xuICAgICAgICAgICAgd2FzUm9vdERlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgKHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkuZmxhZ3MgfD0gMjU2KTtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHJlbmRlclJvb3RTeW5jKFxuICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKDIgIT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyICYmXG4gICAgICAgICAgICAgICAgIXdhc1Jvb3REZWh5ZHJhdGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgfD0gcmVuZGVyV2FzQ29uY3VycmVudDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyB8PVxuICAgICAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudDtcbiAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gNDtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycztcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBleGl0U3RhdHVzO1xuICAgICAgICAgICAgICBudWxsICE9PSByZW5kZXJXYXNDb25jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhyZW5kZXJXYXNDb25jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSAhMTtcbiAgICAgICAgICBpZiAoMiAhPT0gZXhpdFN0YXR1cykgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgxID09PSBleGl0U3RhdHVzKSB7XG4gICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QkanNjb21wJDAsIDApO1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290JGpzY29tcCQwLCBsYW5lcywgMCwgITApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGE6IHtcbiAgICAgICAgc2hvdWxkVGltZVNsaWNlID0gcm9vdCRqc2NvbXAkMDtcbiAgICAgICAgc3dpdGNoIChleGl0U3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzQ1KSk7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgaWYgKChsYW5lcyAmIDQxOTQxNzYpID09PSBsYW5lcykge1xuICAgICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMyOSkpO1xuICAgICAgICB9XG4gICAgICAgIHNob3VsZFRpbWVTbGljZS5maW5pc2hlZFdvcmsgPSBmb3JjZVN5bmM7XG4gICAgICAgIHNob3VsZFRpbWVTbGljZS5maW5pc2hlZExhbmVzID0gbGFuZXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAobGFuZXMgJiA2MjkxNDU2MCkgPT09IGxhbmVzICYmXG4gICAgICAgICAgKChyZW5kZXJXYXNDb25jdXJyZW50ID0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSArIDMwMCAtIG5vdygpKSxcbiAgICAgICAgICAxMCA8IHJlbmRlcldhc0NvbmN1cnJlbnQpXG4gICAgICAgICkge1xuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICgwICE9PSBnZXROZXh0TGFuZXMoc2hvdWxkVGltZVNsaWNlLCAwKSkgYnJlYWsgYTtcbiAgICAgICAgICBzaG91bGRUaW1lU2xpY2UudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChcbiAgICAgICAgICAgIGNvbW1pdFJvb3RXaGVuUmVhZHkuYmluZChcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICBmb3JjZVN5bmMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgLTAsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhayBhO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1pdFJvb3RXaGVuUmVhZHkoXG4gICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgIGZvcmNlU3luYyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIC0wLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIH0gd2hpbGUgKDEpO1xuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCRqc2NvbXAkMCk7XG59XG5mdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycykge1xuICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9yc1xuICAgID8gKHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gZXJyb3JzKVxuICAgIDogd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMucHVzaC5hcHBseShcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgIGVycm9yc1xuICAgICAgKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdFJvb3RXaGVuUmVhZHkoXG4gIHJvb3QsXG4gIGZpbmlzaGVkV29yayxcbiAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gIHRyYW5zaXRpb25zLFxuICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gIGxhbmVzLFxuICBzcGF3bmVkTGFuZSxcbiAgdXBkYXRlZExhbmVzLFxuICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICBkaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4pIHtcbiAgdmFyIHN1YnRyZWVGbGFncyA9IGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3M7XG4gIGlmIChzdWJ0cmVlRmxhZ3MgJiA4MTkyIHx8IDE2Nzg1NDA4ID09PSAoc3VidHJlZUZsYWdzICYgMTY3ODU0MDgpKVxuICAgIGlmIChcbiAgICAgICgoc3VzcGVuZGVkU3RhdGUgPSB7IHN0eWxlc2hlZXRzOiBudWxsLCBjb3VudDogMCwgdW5zdXNwZW5kOiBub29wIH0pLFxuICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoZmluaXNoZWRXb3JrKSxcbiAgICAgIChmaW5pc2hlZFdvcmsgPSB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5KCkpLFxuICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrKVxuICAgICkge1xuICAgICAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gZmluaXNoZWRXb3JrKFxuICAgICAgICBjb21taXRSb290LmJpbmQoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICByb290LFxuICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAxLFxuICAgICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgc3Bhd25lZExhbmUsICFkaWRTa2lwU3VzcGVuZGVkU2libGluZ3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgY29tbWl0Um9vdChcbiAgICByb290LFxuICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgIHRyYW5zaXRpb25zLFxuICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICBzcGF3bmVkTGFuZSxcbiAgICB1cGRhdGVkTGFuZXMsXG4gICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyhmaW5pc2hlZFdvcmspIHtcbiAgZm9yICh2YXIgbm9kZSA9IGZpbmlzaGVkV29yazsgOyApIHtcbiAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgaWYgKFxuICAgICAgKDAgPT09IHRhZyB8fCAxMSA9PT0gdGFnIHx8IDE1ID09PSB0YWcpICYmXG4gICAgICBub2RlLmZsYWdzICYgMTYzODQgJiZcbiAgICAgICgodGFnID0gbm9kZS51cGRhdGVRdWV1ZSksXG4gICAgICBudWxsICE9PSB0YWcgJiYgKCh0YWcgPSB0YWcuc3RvcmVzKSwgbnVsbCAhPT0gdGFnKSlcbiAgICApXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2sgPSB0YWdbaV0sXG4gICAgICAgICAgZ2V0U25hcHNob3QgPSBjaGVjay5nZXRTbmFwc2hvdDtcbiAgICAgICAgY2hlY2sgPSBjaGVjay52YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIW9iamVjdElzKGdldFNuYXBzaG90KCksIGNoZWNrKSkgcmV0dXJuICExO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIHRhZyA9IG5vZGUuY2hpbGQ7XG4gICAgaWYgKG5vZGUuc3VidHJlZUZsYWdzICYgMTYzODQgJiYgbnVsbCAhPT0gdGFnKVxuICAgICAgKHRhZy5yZXR1cm4gPSBub2RlKSwgKG5vZGUgPSB0YWcpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykgYnJlYWs7XG4gICAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgaWYgKG51bGwgPT09IG5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBmaW5pc2hlZFdvcmspIHJldHVybiAhMDtcbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQoXG4gIHJvb3QsXG4gIHN1c3BlbmRlZExhbmVzLFxuICBzcGF3bmVkTGFuZSxcbiAgZGlkQXR0ZW1wdEVudGlyZVRyZWVcbikge1xuICBzdXNwZW5kZWRMYW5lcyAmPSB+d29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXM7XG4gIHN1c3BlbmRlZExhbmVzICY9IH53b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcztcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7XG4gIGRpZEF0dGVtcHRFbnRpcmVUcmVlICYmIChyb290Lndhcm1MYW5lcyB8PSBzdXNwZW5kZWRMYW5lcyk7XG4gIGRpZEF0dGVtcHRFbnRpcmVUcmVlID0gcm9vdC5leHBpcmF0aW9uVGltZXM7XG4gIGZvciAodmFyIGxhbmVzID0gc3VzcGVuZGVkTGFuZXM7IDAgPCBsYW5lczsgKSB7XG4gICAgdmFyIGluZGV4JDYgPSAzMSAtIGNsejMyKGxhbmVzKSxcbiAgICAgIGxhbmUgPSAxIDw8IGluZGV4JDY7XG4gICAgZGlkQXR0ZW1wdEVudGlyZVRyZWVbaW5kZXgkNl0gPSAtMTtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxuICAwICE9PSBzcGF3bmVkTGFuZSAmJlxuICAgIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCBzdXNwZW5kZWRMYW5lcyk7XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNXb3JrJDEoKSB7XG4gIHJldHVybiAwID09PSAoZXhlY3V0aW9uQ29udGV4dCAmIDYpXG4gICAgPyAoZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpLCAhMSlcbiAgICA6ICEwO1xufVxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCkge1xuICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBpZiAoMCA9PT0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pXG4gICAgICB2YXIgaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgIGVsc2VcbiAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIChsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGwpLFxuICAgICAgICByZXNldEhvb2tzT25VbndpbmQoaW50ZXJydXB0ZWRXb3JrKSxcbiAgICAgICAgKHRoZW5hYmxlU3RhdGUkMSA9IG51bGwpLFxuICAgICAgICAodGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDApLFxuICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgIGZvciAoOyBudWxsICE9PSBpbnRlcnJ1cHRlZFdvcms7IClcbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmsuYWx0ZXJuYXRlLCBpbnRlcnJ1cHRlZFdvcmspLFxuICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybik7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IDA7XG4gIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuICAtMSAhPT0gdGltZW91dEhhbmRsZSAmJlxuICAgICgocm9vdC50aW1lb3V0SGFuZGxlID0gLTEpLCBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpKTtcbiAgdGltZW91dEhhbmRsZSA9IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdDtcbiAgbnVsbCAhPT0gdGltZW91dEhhbmRsZSAmJlxuICAgICgocm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbCksIHRpbWVvdXRIYW5kbGUoKSk7XG4gIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICB3b3JrSW5Qcm9ncmVzcyA9IHRpbWVvdXRIYW5kbGUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyb290LmN1cnJlbnQsIG51bGwpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IGxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDA7XG4gIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSAhMTtcbiAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIGxhbmVzKTtcbiAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITE7XG4gIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9XG4gICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPVxuICAgIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID1cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9XG4gICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID1cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID1cbiAgICAgIDA7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9XG4gICAgbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9ICExO1xuICAwICE9PSAobGFuZXMgJiA4KSAmJiAobGFuZXMgfD0gbGFuZXMgJiAzMik7XG4gIHZhciBhbGxFbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG4gIGlmICgwICE9PSBhbGxFbnRhbmdsZWRMYW5lcylcbiAgICBmb3IgKFxuICAgICAgcm9vdCA9IHJvb3QuZW50YW5nbGVtZW50cywgYWxsRW50YW5nbGVkTGFuZXMgJj0gbGFuZXM7XG4gICAgICAwIDwgYWxsRW50YW5nbGVkTGFuZXM7XG5cbiAgICApIHtcbiAgICAgIHZhciBpbmRleCQ0ID0gMzEgLSBjbHozMihhbGxFbnRhbmdsZWRMYW5lcyksXG4gICAgICAgIGxhbmUgPSAxIDw8IGluZGV4JDQ7XG4gICAgICBsYW5lcyB8PSByb290W2luZGV4JDRdO1xuICAgICAgYWxsRW50YW5nbGVkTGFuZXMgJj0gfmxhbmU7XG4gICAgfVxuICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGxhbmVzO1xuICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gIHJldHVybiB0aW1lb3V0SGFuZGxlO1xufVxuZnVuY3Rpb24gaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgID8gKCh0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCkpLFxuICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMykpXG4gICAgOiB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uXG4gICAgICA/ICgodGhyb3duVmFsdWUgPSBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gNCkpXG4gICAgICA6ICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9XG4gICAgICAgICAgdGhyb3duVmFsdWUgPT09IFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvblxuICAgICAgICAgICAgPyA4XG4gICAgICAgICAgICA6IG51bGwgIT09IHRocm93blZhbHVlICYmXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRocm93blZhbHVlICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdGhyb3duVmFsdWUudGhlblxuICAgICAgICAgICAgICA/IDZcbiAgICAgICAgICAgICAgOiAxKTtcbiAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IHRocm93blZhbHVlO1xuICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcyAmJlxuICAgICgod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IDEpLFxuICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICByb290LFxuICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICApKTtcbn1cbmZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICByZXR1cm4gbnVsbCA9PT0gcHJldkRpc3BhdGNoZXIgPyBDb250ZXh0T25seURpc3BhdGNoZXIgOiBwcmV2RGlzcGF0Y2hlcjtcbn1cbmZ1bmN0aW9uIHB1c2hBc3luY0Rpc3BhdGNoZXIoKSB7XG4gIHZhciBwcmV2QXN5bmNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IERlZmF1bHRBc3luY0Rpc3BhdGNoZXI7XG4gIHJldHVybiBwcmV2QXN5bmNEaXNwYXRjaGVyO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IDQ7XG4gIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyB8fFxuICAgICgod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA0MTk0MTc2KSAhPT1cbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICBudWxsICE9PSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSB8fFxuICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9ICEwKTtcbiAgKDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgJiAxMzQyMTc3MjcpICYmXG4gICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzICYgMTM0MjE3NzI3KSkgfHxcbiAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgfHxcbiAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAhMVxuICAgICk7XG59XG5mdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgc2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmcpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSAyO1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKVxuICAgICh3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbCksIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgbGFuZXMgPSAhMTtcbiAgdmFyIGV4aXRTdGF0dXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICBhOiBkb1xuICAgIHRyeSB7XG4gICAgICBpZiAoMCAhPT0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gJiYgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgdmFyIHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB0aHJvd25WYWx1ZSA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWU7XG4gICAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pIHtcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSA2O1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIG51bGwgPT09IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQgJiYgKGxhbmVzID0gITApO1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSAwO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlLCByZWFzb24pO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZyAmJlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSAwO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIChyZWFzb24gPSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDApLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgIGV4aXRTdGF0dXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUkMTY0KSB7XG4gICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSQxNjQpO1xuICAgIH1cbiAgd2hpbGUgKDEpO1xuICBsYW5lcyAmJiByb290LnNoZWxsU3VzcGVuZENvdW50ZXIrKztcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gIG51bGwgPT09IHdvcmtJblByb2dyZXNzICYmXG4gICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwKSxcbiAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCkpO1xuICByZXR1cm4gZXhpdFN0YXR1cztcbn1cbmZ1bmN0aW9uIHdvcmtMb29wU3luYygpIHtcbiAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzOyApIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gMjtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKSxcbiAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgPyAoKHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93KCkgKyA1MDApLFxuICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpKVxuICAgIDogKHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhcbiAgICAgICAgcm9vdCxcbiAgICAgICAgbGFuZXNcbiAgICAgICkpO1xuICBhOiBkb1xuICAgIHRyeSB7XG4gICAgICBpZiAoMCAhPT0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gJiYgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgbGFuZXMgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgdmFyIHRocm93blZhbHVlID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZTtcbiAgICAgICAgYjogc3dpdGNoICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCBsYW5lcywgdGhyb3duVmFsdWUsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKGlzVGhlbmFibGVSZXNvbHZlZCh0aHJvd25WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSAwO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayhsYW5lcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFuZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIDIgPT09IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICYmXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gNyk7XG4gICAgICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aHJvd25WYWx1ZS50aGVuKGxhbmVzLCBsYW5lcyk7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gNztcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSA1O1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpc1RoZW5hYmxlUmVzb2x2ZWQodGhyb3duVmFsdWUpXG4gICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDApLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayhsYW5lcykpXG4gICAgICAgICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDApLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCBsYW5lcywgdGhyb3duVmFsdWUsIDcpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgIHJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgIHZhciBob3N0RmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgICBpZiAocmVzb3VyY2UgPyBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpIDogMSkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSAwO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB2YXIgc2libGluZyA9IGhvc3RGaWJlci5zaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHNpYmxpbmcpIHdvcmtJblByb2dyZXNzID0gc2libGluZztcbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBob3N0RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlVW5pdE9mV29yayhyZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MgPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSAwO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIGxhbmVzLCB0aHJvd25WYWx1ZSwgNSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDA7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgbGFuZXMsIHRocm93blZhbHVlLCA2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IDY7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ2MikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrTG9vcENvbmN1cnJlbnQoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDE2Nikge1xuICAgICAgaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUkMTY2KTtcbiAgICB9XG4gIHdoaWxlICgxKTtcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyO1xuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykgcmV0dXJuIDA7XG4gIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMDtcbiAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbn1cbmZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcbiAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzICYmICFzaG91bGRZaWVsZCgpOyApXG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xufVxuZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICB2YXIgbmV4dCA9IGJlZ2luV29yayh1bml0T2ZXb3JrLmFsdGVybmF0ZSwgdW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpO1xuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgbnVsbCA9PT0gbmV4dCA/IGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSA6ICh3b3JrSW5Qcm9ncmVzcyA9IG5leHQpO1xufVxuZnVuY3Rpb24gcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIHZhciBuZXh0ID0gdW5pdE9mV29yaztcbiAgdmFyIGN1cnJlbnQgPSBuZXh0LmFsdGVybmF0ZTtcbiAgc3dpdGNoIChuZXh0LnRhZykge1xuICAgIGNhc2UgMTU6XG4gICAgY2FzZSAwOlxuICAgICAgbmV4dCA9IHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBuZXh0LFxuICAgICAgICBuZXh0LnBlbmRpbmdQcm9wcyxcbiAgICAgICAgbmV4dC50eXBlLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMTpcbiAgICAgIG5leHQgPSByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgbmV4dCxcbiAgICAgICAgbmV4dC5wZW5kaW5nUHJvcHMsXG4gICAgICAgIG5leHQudHlwZS5yZW5kZXIsXG4gICAgICAgIG5leHQucmVmLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIHJlc2V0SG9va3NPblVud2luZChuZXh0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIG5leHQpLFxuICAgICAgICAobmV4dCA9IHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzKG5leHQsIGVudGFuZ2xlZFJlbmRlckxhbmVzKSksXG4gICAgICAgIChuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIG5leHQsIGVudGFuZ2xlZFJlbmRlckxhbmVzKSk7XG4gIH1cbiAgdW5pdE9mV29yay5tZW1vaXplZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG4gIG51bGwgPT09IG5leHQgPyBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykgOiAod29ya0luUHJvZ3Jlc3MgPSBuZXh0KTtcbn1cbmZ1bmN0aW9uIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gIHJvb3QsXG4gIHVuaXRPZldvcmssXG4gIHRocm93blZhbHVlLFxuICBzdXNwZW5kZWRSZWFzb25cbikge1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIHJlc2V0SG9va3NPblVud2luZCh1bml0T2ZXb3JrKTtcbiAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gIHZhciByZXR1cm5GaWJlciA9IHVuaXRPZldvcmsucmV0dXJuO1xuICB0cnkge1xuICAgIGlmIChcbiAgICAgIHRocm93RXhjZXB0aW9uKFxuICAgICAgICByb290LFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICApXG4gICAgKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gMTtcbiAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgICApO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAobnVsbCAhPT0gcmV0dXJuRmliZXIpIHRocm93ICgod29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlciksIGVycm9yKTtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gMTtcbiAgICBsb2dVbmNhdWdodEVycm9yKFxuICAgICAgcm9vdCxcbiAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgKTtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh1bml0T2ZXb3JrLmZsYWdzICYgMzI3NjgpIHtcbiAgICBpZiAoaXNIeWRyYXRpbmcgfHwgMSA9PT0gc3VzcGVuZGVkUmVhc29uKSByb290ID0gITA7XG4gICAgZWxzZSBpZiAoXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyB8fFxuICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKVxuICAgIClcbiAgICAgIHJvb3QgPSAhMTtcbiAgICBlbHNlIGlmIChcbiAgICAgICgod29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gcm9vdCA9ICEwKSxcbiAgICAgIDIgPT09IHN1c3BlbmRlZFJlYXNvbiB8fCAzID09PSBzdXNwZW5kZWRSZWFzb24gfHwgNiA9PT0gc3VzcGVuZGVkUmVhc29uKVxuICAgIClcbiAgICAgIChzdXNwZW5kZWRSZWFzb24gPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgbnVsbCAhPT0gc3VzcGVuZGVkUmVhc29uICYmXG4gICAgICAgICAgMTMgPT09IHN1c3BlbmRlZFJlYXNvbi50YWcgJiZcbiAgICAgICAgICAoc3VzcGVuZGVkUmVhc29uLmZsYWdzIHw9IDE2Mzg0KTtcbiAgICB1bndpbmRVbml0T2ZXb3JrKHVuaXRPZldvcmssIHJvb3QpO1xuICB9IGVsc2UgY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspO1xufVxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgdmFyIGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuICBkbyB7XG4gICAgaWYgKDAgIT09IChjb21wbGV0ZWRXb3JrLmZsYWdzICYgMzI3NjgpKSB7XG4gICAgICB1bndpbmRVbml0T2ZXb3JrKFxuICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVuaXRPZldvcmsgPSBjb21wbGV0ZWRXb3JrLnJldHVybjtcbiAgICB2YXIgbmV4dCA9IGNvbXBsZXRlV29yayhcbiAgICAgIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgY29tcGxldGVkV29yayxcbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzXG4gICAgKTtcbiAgICBpZiAobnVsbCAhPT0gbmV4dCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb21wbGV0ZWRXb3JrID0gY29tcGxldGVkV29yay5zaWJsaW5nO1xuICAgIGlmIChudWxsICE9PSBjb21wbGV0ZWRXb3JrKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG4gIH0gd2hpbGUgKG51bGwgIT09IGNvbXBsZXRlZFdvcmspO1xuICAwID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICYmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gNSk7XG59XG5mdW5jdGlvbiB1bndpbmRVbml0T2ZXb3JrKHVuaXRPZldvcmssIHNraXBTaWJsaW5ncykge1xuICBkbyB7XG4gICAgdmFyIG5leHQgPSB1bndpbmRXb3JrKHVuaXRPZldvcmsuYWx0ZXJuYXRlLCB1bml0T2ZXb3JrKTtcbiAgICBpZiAobnVsbCAhPT0gbmV4dCkge1xuICAgICAgbmV4dC5mbGFncyAmPSAzMjc2NztcbiAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmV4dCA9IHVuaXRPZldvcmsucmV0dXJuO1xuICAgIG51bGwgIT09IG5leHQgJiZcbiAgICAgICgobmV4dC5mbGFncyB8PSAzMjc2OCksIChuZXh0LnN1YnRyZWVGbGFncyA9IDApLCAobmV4dC5kZWxldGlvbnMgPSBudWxsKSk7XG4gICAgaWYgKFxuICAgICAgIXNraXBTaWJsaW5ncyAmJlxuICAgICAgKCh1bml0T2ZXb3JrID0gdW5pdE9mV29yay5zaWJsaW5nKSwgbnVsbCAhPT0gdW5pdE9mV29yaylcbiAgICApIHtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gdW5pdE9mV29yaztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MgPSB1bml0T2ZXb3JrID0gbmV4dDtcbiAgfSB3aGlsZSAobnVsbCAhPT0gdW5pdE9mV29yayk7XG4gIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSA2O1xuICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG59XG5mdW5jdGlvbiBjb21taXRSb290KFxuICByb290LFxuICByZWNvdmVyYWJsZUVycm9ycyxcbiAgdHJhbnNpdGlvbnMsXG4gIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgc3Bhd25lZExhbmUsXG4gIHVwZGF0ZWRMYW5lcyxcbiAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbikge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgdHJ5IHtcbiAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IDIpLFxuICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSxcbiAgICAgIGNvbW1pdFJvb3RJbXBsKFxuICAgICAgICByb290LFxuICAgICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgICAgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHksXG4gICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgICApO1xuICB9IGZpbmFsbHkge1xuICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdFJvb3RJbXBsKFxuICByb290LFxuICByZWNvdmVyYWJsZUVycm9ycyxcbiAgdHJhbnNpdGlvbnMsXG4gIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgcmVuZGVyUHJpb3JpdHlMZXZlbCxcbiAgc3Bhd25lZExhbmUsXG4gIHVwZGF0ZWRMYW5lcyxcbiAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuKSB7XG4gIGRvIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgd2hpbGUgKG51bGwgIT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKTtcbiAgaWYgKDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgNikpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzI3KSk7XG4gIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlID0gcm9vdC5maW5pc2hlZExhbmVzO1xuICBpZiAobnVsbCA9PT0gZmluaXNoZWRXb3JrKSByZXR1cm4gbnVsbDtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSAwO1xuICBpZiAoZmluaXNoZWRXb3JrID09PSByb290LmN1cnJlbnQpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTc3KSk7XG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gMDtcbiAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbDtcbiAgdmFyIHJlbWFpbmluZ0xhbmVzID0gZmluaXNoZWRXb3JrLmxhbmVzIHwgZmluaXNoZWRXb3JrLmNoaWxkTGFuZXM7XG4gIHJlbWFpbmluZ0xhbmVzIHw9IGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcztcbiAgbWFya1Jvb3RGaW5pc2hlZChcbiAgICByb290LFxuICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICByZW1haW5pbmdMYW5lcyxcbiAgICBzcGF3bmVkTGFuZSxcbiAgICB1cGRhdGVkTGFuZXMsXG4gICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICApO1xuICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAoKHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbCksXG4gICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCkpO1xuICAoMCA9PT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxMDI1NikgJiZcbiAgICAwID09PSAoZmluaXNoZWRXb3JrLmZsYWdzICYgMTAyNTYpKSB8fFxuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzIHx8XG4gICAgKChyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICEwKSxcbiAgICAocGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lcyksXG4gICAgKHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucyksXG4gICAgc2NoZWR1bGVDYWxsYmFjayQxKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoITApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkpO1xuICB0cmFuc2l0aW9ucyA9IDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxNTk5MCk7XG4gIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTU5OTApIHx8IHRyYW5zaXRpb25zXG4gICAgPyAoKHRyYW5zaXRpb25zID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCksXG4gICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgKHNwYXduZWRMYW5lID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCksXG4gICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IDIpLFxuICAgICAgKHVwZGF0ZWRMYW5lcyA9IGV4ZWN1dGlvbkNvbnRleHQpLFxuICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgfD0gNCksXG4gICAgICBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KSxcbiAgICAgIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24sIHJvb3QuY29udGFpbmVySW5mbyksXG4gICAgICAoX2VuYWJsZWQgPSAhIWV2ZW50c0VuYWJsZWQpLFxuICAgICAgKHNlbGVjdGlvbkluZm9ybWF0aW9uID0gZXZlbnRzRW5hYmxlZCA9IG51bGwpLFxuICAgICAgKHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yayksXG4gICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayksXG4gICAgICByZXF1ZXN0UGFpbnQoKSxcbiAgICAgIChleGVjdXRpb25Db250ZXh0ID0gdXBkYXRlZExhbmVzKSxcbiAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gc3Bhd25lZExhbmUpLFxuICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSB0cmFuc2l0aW9ucykpXG4gICAgOiAocm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrKTtcbiAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHNcbiAgICA/ICgocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSAhMSksXG4gICAgICAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290KSxcbiAgICAgIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSkpXG4gICAgOiByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTtcbiAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgMCA9PT0gcmVtYWluaW5nTGFuZXMgJiYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbCk7XG4gIG9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLCByZW5kZXJQcmlvcml0eUxldmVsKTtcbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICBpZiAobnVsbCAhPT0gcmVjb3ZlcmFibGVFcnJvcnMpXG4gICAgZm9yIChcbiAgICAgIHJlbmRlclByaW9yaXR5TGV2ZWwgPSByb290Lm9uUmVjb3ZlcmFibGVFcnJvciwgZmluaXNoZWRXb3JrID0gMDtcbiAgICAgIGZpbmlzaGVkV29yayA8IHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDtcbiAgICAgIGZpbmlzaGVkV29yaysrXG4gICAgKVxuICAgICAgKHJlbWFpbmluZ0xhbmVzID0gcmVjb3ZlcmFibGVFcnJvcnNbZmluaXNoZWRXb3JrXSksXG4gICAgICAgIHJlbmRlclByaW9yaXR5TGV2ZWwocmVtYWluaW5nTGFuZXMudmFsdWUsIHtcbiAgICAgICAgICBjb21wb25lbnRTdGFjazogcmVtYWluaW5nTGFuZXMuc3RhY2tcbiAgICAgICAgfSk7XG4gIDAgIT09IChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyAmIDMpICYmIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgMCAhPT0gKGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSAmIDQxOTQyMTgpICYmIDAgIT09IChyZW1haW5pbmdMYW5lcyAmIDQyKVxuICAgID8gcm9vdCA9PT0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzXG4gICAgICA/IG5lc3RlZFVwZGF0ZUNvdW50KytcbiAgICAgIDogKChuZXN0ZWRVcGRhdGVDb3VudCA9IDApLCAocm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdCkpXG4gICAgOiAobmVzdGVkVXBkYXRlQ291bnQgPSAwKTtcbiAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAgMCA9PT0gKHJvb3QucG9vbGVkQ2FjaGVMYW5lcyAmPSByZW1haW5pbmdMYW5lcykgJiZcbiAgICAoKHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wb29sZWRDYWNoZSksXG4gICAgbnVsbCAhPSByZW1haW5pbmdMYW5lcyAmJlxuICAgICAgKChyb290LnBvb2xlZENhY2hlID0gbnVsbCksIHJlbGVhc2VDYWNoZShyZW1haW5pbmdMYW5lcykpKTtcbn1cbmZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSB7XG4gIGlmIChudWxsICE9PSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cykge1xuICAgIHZhciByb290JDE3MCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLFxuICAgICAgcmVtYWluaW5nTGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcztcbiAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IDA7XG4gICAgdmFyIHJlbmRlclByaW9yaXR5ID0gbGFuZXNUb0V2ZW50UHJpb3JpdHkocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMpLFxuICAgICAgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgcHJldmlvdXNQcmlvcml0eSA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnA7XG4gICAgdHJ5IHtcbiAgICAgIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSAzMiA+IHJlbmRlclByaW9yaXR5ID8gMzIgOiByZW5kZXJQcmlvcml0eTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgaWYgKG51bGwgPT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKVxuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVuZGVyUHJpb3JpdHkgPSBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zO1xuICAgICAgICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbDtcbiAgICAgICAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyxcbiAgICAgICAgICBsYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzO1xuICAgICAgICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7XG4gICAgICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gMDtcbiAgICAgICAgaWYgKDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgNikpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMzEpKTtcbiAgICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSA0O1xuICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIocm9vdC5jdXJyZW50KTtcbiAgICAgICAgY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihyb290LCByb290LmN1cnJlbnQsIGxhbmVzLCByZW5kZXJQcmlvcml0eSk7XG4gICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaW5qZWN0ZWRIb29rICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdFxuICAgICAgICApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QkMTcwLCByZW1haW5pbmdMYW5lcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gIHNvdXJjZUZpYmVyID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgc291cmNlRmliZXIgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLnN0YXRlTm9kZSwgc291cmNlRmliZXIsIDIpO1xuICByb290RmliZXIgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgc291cmNlRmliZXIsIDIpO1xuICBudWxsICE9PSByb290RmliZXIgJiZcbiAgICAobWFya1Jvb3RVcGRhdGVkJDEocm9vdEZpYmVyLCAyKSwgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3RGaWJlcikpO1xufVxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3Ioc291cmNlRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKSB7XG4gIGlmICgzID09PSBzb3VyY2VGaWJlci50YWcpXG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gIGVsc2VcbiAgICBmb3IgKDsgbnVsbCAhPT0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvcjsgKSB7XG4gICAgICBpZiAoMyA9PT0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50YWcpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICBlcnJvclxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoMSA9PT0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50YWcpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICB0eXBlb2YgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAgICAgKG51bGwgPT09IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIHx8XG4gICAgICAgICAgICAgICFsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgc291cmNlRmliZXIgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgc291cmNlRmliZXIpO1xuICAgICAgICAgIGVycm9yID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSgyKTtcbiAgICAgICAgICBpbnN0YW5jZSA9IGVucXVldWVVcGRhdGUobmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IsIDIpO1xuICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlICYmXG4gICAgICAgICAgICAoaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgc291cmNlRmliZXJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtYXJrUm9vdFVwZGF0ZWQkMShpbnN0YW5jZSwgMiksXG4gICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoaW5zdGFuY2UpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciA9IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IucmV0dXJuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuICBpZiAobnVsbCA9PT0gcGluZ0NhY2hlKSB7XG4gICAgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG4gICAgdmFyIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpO1xuICB9IGVsc2VcbiAgICAodGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSkpLFxuICAgICAgdm9pZCAwID09PSB0aHJlYWRJRHMgJiZcbiAgICAgICAgKCh0aHJlYWRJRHMgPSBuZXcgU2V0KCkpLCBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpKTtcbiAgdGhyZWFkSURzLmhhcyhsYW5lcykgfHxcbiAgICAoKHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICEwKSxcbiAgICB0aHJlYWRJRHMuYWRkKGxhbmVzKSxcbiAgICAocm9vdCA9IHBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKSksXG4gICAgd2FrZWFibGUudGhlbihyb290LCByb290KSk7XG59XG5mdW5jdGlvbiBwaW5nU3VzcGVuZGVkUm9vdChyb290LCB3YWtlYWJsZSwgcGluZ2VkTGFuZXMpIHtcbiAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuICBudWxsICE9PSBwaW5nQ2FjaGUgJiYgcGluZ0NhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xuICByb290Lndhcm1MYW5lcyAmPSB+cGluZ2VkTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCAmJlxuICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHBpbmdlZExhbmVzKSA9PT0gcGluZ2VkTGFuZXMgJiZcbiAgICAoNCA9PT0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyB8fFxuICAgICgzID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICYmXG4gICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MjkxNDU2MCkgPT09XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICAzMDAgPiBub3coKSAtIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUpXG4gICAgICA/IDAgPT09IChleGVjdXRpb25Db250ZXh0ICYgMikgJiYgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgMClcbiAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIHw9IHBpbmdlZExhbmVzKSxcbiAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID0gMCkpO1xuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG59XG5mdW5jdGlvbiByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKSB7XG4gIDAgPT09IHJldHJ5TGFuZSAmJiAocmV0cnlMYW5lID0gY2xhaW1OZXh0UmV0cnlMYW5lKCkpO1xuICBib3VuZGFyeUZpYmVyID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gIG51bGwgIT09IGJvdW5kYXJ5RmliZXIgJiZcbiAgICAobWFya1Jvb3RVcGRhdGVkJDEoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKSxcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoYm91bmRhcnlGaWJlcikpO1xufVxuZnVuY3Rpb24gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShib3VuZGFyeUZpYmVyKSB7XG4gIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlLFxuICAgIHJldHJ5TGFuZSA9IDA7XG4gIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICB2YXIgcmV0cnlMYW5lID0gMDtcbiAgc3dpdGNoIChib3VuZGFyeUZpYmVyLnRhZykge1xuICAgIGNhc2UgMTM6XG4gICAgICB2YXIgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICBudWxsICE9PSBzdXNwZW5zZVN0YXRlICYmIChyZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE5OlxuICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMjpcbiAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZS5fcmV0cnlDYWNoZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMxNCkpO1xuICB9XG4gIG51bGwgIT09IHJldHJ5Q2FjaGUgJiYgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2skMShwcmlvcml0eUxldmVsLCBjYWxsYmFjaykge1xuICByZXR1cm4gc2NoZWR1bGVDYWxsYmFjayQzKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKTtcbn1cbnZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsLFxuICBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGwsXG4gIGRpZFNjaGVkdWxlTWljcm90YXNrID0gITEsXG4gIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICExLFxuICBpc0ZsdXNoaW5nV29yayA9ICExLFxuICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IDA7XG5mdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCkge1xuICByb290ICE9PSBsYXN0U2NoZWR1bGVkUm9vdCAmJlxuICAgIG51bGwgPT09IHJvb3QubmV4dCAmJlxuICAgIChudWxsID09PSBsYXN0U2NoZWR1bGVkUm9vdFxuICAgICAgPyAoZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290KVxuICAgICAgOiAobGFzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0ID0gcm9vdCkpO1xuICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMDtcbiAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgfHxcbiAgICAoKGRpZFNjaGVkdWxlTWljcm90YXNrID0gITApLFxuICAgIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2spKTtcbn1cbmZ1bmN0aW9uIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKHN5bmNUcmFuc2l0aW9uTGFuZXMsIG9ubHlMZWdhY3kpIHtcbiAgaWYgKCFpc0ZsdXNoaW5nV29yayAmJiBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmspIHtcbiAgICBpc0ZsdXNoaW5nV29yayA9ICEwO1xuICAgIGRvIHtcbiAgICAgIHZhciBkaWRQZXJmb3JtU29tZVdvcmsgPSAhMTtcbiAgICAgIGZvciAodmFyIHJvb3QkMTcyID0gZmlyc3RTY2hlZHVsZWRSb290OyBudWxsICE9PSByb290JDE3MjsgKSB7XG4gICAgICAgIGlmICghb25seUxlZ2FjeSlcbiAgICAgICAgICBpZiAoMCAhPT0gc3luY1RyYW5zaXRpb25MYW5lcykge1xuICAgICAgICAgICAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QkMTcyLnBlbmRpbmdMYW5lcztcbiAgICAgICAgICAgIGlmICgwID09PSBwZW5kaW5nTGFuZXMpIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAwO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3QkMTcyLnN1c3BlbmRlZExhbmVzLFxuICAgICAgICAgICAgICAgIHBpbmdlZExhbmVzID0gcm9vdCQxNzIucGluZ2VkTGFuZXM7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgICAgKDEgPDwgKDMxIC0gY2x6MzIoNDIgfCBzeW5jVHJhbnNpdGlvbkxhbmVzKSArIDEpKSAtIDE7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmPVxuICAgICAgICAgICAgICAgIHBlbmRpbmdMYW5lcyAmIH4oc3VzcGVuZGVkTGFuZXMgJiB+cGluZ2VkTGFuZXMpO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmIDIwMTMyNjY3N1xuICAgICAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYgMjAxMzI2Njc3KSB8IDFcbiAgICAgICAgICAgICAgICAgIDogSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgID8gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IHwgMlxuICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAwICE9PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiZcbiAgICAgICAgICAgICAgKChkaWRQZXJmb3JtU29tZVdvcmsgPSAhMCksXG4gICAgICAgICAgICAgIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290JDE3MiwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gZ2V0TmV4dExhbmVzKFxuICAgICAgICAgICAgICAgIHJvb3QkMTcyLFxuICAgICAgICAgICAgICAgIHJvb3QkMTcyID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgOiAwXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAwID09PSAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYgMykgfHxcbiAgICAgICAgICAgICAgICBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QkMTcyLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHx8XG4gICAgICAgICAgICAgICAgKChkaWRQZXJmb3JtU29tZVdvcmsgPSAhMCksXG4gICAgICAgICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QkMTcyLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpKTtcbiAgICAgICAgcm9vdCQxNzIgPSByb290JDE3Mi5uZXh0O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGRpZFBlcmZvcm1Tb21lV29yayk7XG4gICAgaXNGbHVzaGluZ1dvcmsgPSAhMTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKCkge1xuICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSBkaWRTY2hlZHVsZU1pY3JvdGFzayA9ICExO1xuICB2YXIgc3luY1RyYW5zaXRpb25MYW5lcyA9IDA7XG4gIDAgIT09IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lICYmXG4gICAgKHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24oKSAmJlxuICAgICAgKHN5bmNUcmFuc2l0aW9uTGFuZXMgPSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSksXG4gICAgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gMCkpO1xuICBmb3IgKFxuICAgIHZhciBjdXJyZW50VGltZSA9IG5vdygpLCBwcmV2ID0gbnVsbCwgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICBudWxsICE9PSByb290O1xuXG4gICkge1xuICAgIHZhciBuZXh0ID0gcm9vdC5uZXh0LFxuICAgICAgbmV4dExhbmVzID0gc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBjdXJyZW50VGltZSk7XG4gICAgaWYgKDAgPT09IG5leHRMYW5lcylcbiAgICAgIChyb290Lm5leHQgPSBudWxsKSxcbiAgICAgICAgbnVsbCA9PT0gcHJldiA/IChmaXJzdFNjaGVkdWxlZFJvb3QgPSBuZXh0KSA6IChwcmV2Lm5leHQgPSBuZXh0KSxcbiAgICAgICAgbnVsbCA9PT0gbmV4dCAmJiAobGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2KTtcbiAgICBlbHNlIGlmIChcbiAgICAgICgocHJldiA9IHJvb3QpLCAwICE9PSBzeW5jVHJhbnNpdGlvbkxhbmVzIHx8IDAgIT09IChuZXh0TGFuZXMgJiAzKSlcbiAgICApXG4gICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMDtcbiAgICByb290ID0gbmV4dDtcbiAgfVxuICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbChzeW5jVHJhbnNpdGlvbkxhbmVzLCAhMSk7XG59XG5mdW5jdGlvbiBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIGZvciAoXG4gICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcyxcbiAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcyxcbiAgICAgIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzLFxuICAgICAgbGFuZXMgPSByb290LnBlbmRpbmdMYW5lcyAmIC02MjkxNDU2MTtcbiAgICAwIDwgbGFuZXM7XG5cbiAgKSB7XG4gICAgdmFyIGluZGV4JDUgPSAzMSAtIGNsejMyKGxhbmVzKSxcbiAgICAgIGxhbmUgPSAxIDw8IGluZGV4JDUsXG4gICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lc1tpbmRleCQ1XTtcbiAgICBpZiAoLTEgPT09IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBpZiAoMCA9PT0gKGxhbmUgJiBzdXNwZW5kZWRMYW5lcykgfHwgMCAhPT0gKGxhbmUgJiBwaW5nZWRMYW5lcykpXG4gICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleCQ1XSA9IGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSk7XG4gICAgfSBlbHNlIGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lICYmIChyb290LmV4cGlyZWRMYW5lcyB8PSBsYW5lKTtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxuICBjdXJyZW50VGltZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgc3VzcGVuZGVkTGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgc3VzcGVuZGVkTGFuZXMgPSBnZXROZXh0TGFuZXMoXG4gICAgcm9vdCxcbiAgICByb290ID09PSBjdXJyZW50VGltZSA/IHN1c3BlbmRlZExhbmVzIDogMFxuICApO1xuICBwaW5nZWRMYW5lcyA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICBpZiAoXG4gICAgMCA9PT0gc3VzcGVuZGVkTGFuZXMgfHxcbiAgICAocm9vdCA9PT0gY3VycmVudFRpbWUgJiYgMiA9PT0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pIHx8XG4gICAgbnVsbCAhPT0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0XG4gIClcbiAgICByZXR1cm4gKFxuICAgICAgbnVsbCAhPT0gcGluZ2VkTGFuZXMgJiZcbiAgICAgICAgbnVsbCAhPT0gcGluZ2VkTGFuZXMgJiZcbiAgICAgICAgY2FuY2VsQ2FsbGJhY2skMShwaW5nZWRMYW5lcyksXG4gICAgICAocm9vdC5jYWxsYmFja05vZGUgPSBudWxsKSxcbiAgICAgIChyb290LmNhbGxiYWNrUHJpb3JpdHkgPSAwKVxuICAgICk7XG4gIGlmIChcbiAgICAwID09PSAoc3VzcGVuZGVkTGFuZXMgJiAzKSB8fFxuICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgc3VzcGVuZGVkTGFuZXMpXG4gICkge1xuICAgIGN1cnJlbnRUaW1lID0gc3VzcGVuZGVkTGFuZXMgJiAtc3VzcGVuZGVkTGFuZXM7XG4gICAgaWYgKGN1cnJlbnRUaW1lID09PSByb290LmNhbGxiYWNrUHJpb3JpdHkpIHJldHVybiBjdXJyZW50VGltZTtcbiAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBjYW5jZWxDYWxsYmFjayQxKHBpbmdlZExhbmVzKTtcbiAgICBzd2l0Y2ggKGxhbmVzVG9FdmVudFByaW9yaXR5KHN1c3BlbmRlZExhbmVzKSkge1xuICAgICAgY2FzZSAyOlxuICAgICAgY2FzZSA4OlxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzI6XG4gICAgICAgIHN1c3BlbmRlZExhbmVzID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgIH1cbiAgICBwaW5nZWRMYW5lcyA9IHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzay5iaW5kKG51bGwsIHJvb3QpO1xuICAgIHN1c3BlbmRlZExhbmVzID0gc2NoZWR1bGVDYWxsYmFjayQzKHN1c3BlbmRlZExhbmVzLCBwaW5nZWRMYW5lcyk7XG4gICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gY3VycmVudFRpbWU7XG4gICAgcm9vdC5jYWxsYmFja05vZGUgPSBzdXNwZW5kZWRMYW5lcztcbiAgICByZXR1cm4gY3VycmVudFRpbWU7XG4gIH1cbiAgbnVsbCAhPT0gcGluZ2VkTGFuZXMgJiYgbnVsbCAhPT0gcGluZ2VkTGFuZXMgJiYgY2FuY2VsQ2FsbGJhY2skMShwaW5nZWRMYW5lcyk7XG4gIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDI7XG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgcmV0dXJuIDI7XG59XG5mdW5jdGlvbiBwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2socm9vdCwgZGlkVGltZW91dCkge1xuICB2YXIgb3JpZ2luYWxDYWxsYmFja05vZGUgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgaWYgKGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSAmJiByb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA9IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA9IGdldE5leHRMYW5lcyhcbiAgICByb290LFxuICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwIDogMFxuICApO1xuICBpZiAoMCA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDApIHJldHVybiBudWxsO1xuICBwZXJmb3JtV29ya09uUm9vdChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCwgZGlkVGltZW91dCk7XG4gIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgbm93KCkpO1xuICByZXR1cm4gbnVsbCAhPSByb290LmNhbGxiYWNrTm9kZSAmJiByb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGVcbiAgICA/IHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzay5iaW5kKG51bGwsIHJvb3QpXG4gICAgOiBudWxsO1xufVxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIGxhbmVzKSB7XG4gIGlmIChmbHVzaFBhc3NpdmVFZmZlY3RzKCkpIHJldHVybiBudWxsO1xuICBwZXJmb3JtV29ya09uUm9vdChyb290LCBsYW5lcywgITApO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVJbW1lZGlhdGVUYXNrKGNiKSB7XG4gIHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAwICE9PSAoZXhlY3V0aW9uQ29udGV4dCAmIDYpXG4gICAgICA/IHNjaGVkdWxlQ2FsbGJhY2skMyhJbW1lZGlhdGVQcmlvcml0eSwgY2IpXG4gICAgICA6IGNiKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVxdWVzdFRyYW5zaXRpb25MYW5lKCkge1xuICAwID09PSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSAmJlxuICAgIChjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkpO1xuICByZXR1cm4gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmU7XG59XG5mdW5jdGlvbiBjb2VyY2VGb3JtQWN0aW9uUHJvcChhY3Rpb25Qcm9wKSB7XG4gIHJldHVybiBudWxsID09IGFjdGlvblByb3AgfHxcbiAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgYWN0aW9uUHJvcCB8fFxuICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgYWN0aW9uUHJvcFxuICAgID8gbnVsbFxuICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uUHJvcFxuICAgICAgPyBhY3Rpb25Qcm9wXG4gICAgICA6IHNhbml0aXplVVJMKFwiXCIgKyBhY3Rpb25Qcm9wKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1EYXRhV2l0aFN1Ym1pdHRlcihmb3JtLCBzdWJtaXR0ZXIpIHtcbiAgdmFyIHRlbXAgPSBzdWJtaXR0ZXIub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gIHRlbXAubmFtZSA9IHN1Ym1pdHRlci5uYW1lO1xuICB0ZW1wLnZhbHVlID0gc3VibWl0dGVyLnZhbHVlO1xuICBmb3JtLmlkICYmIHRlbXAuc2V0QXR0cmlidXRlKFwiZm9ybVwiLCBmb3JtLmlkKTtcbiAgc3VibWl0dGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRlbXAsIHN1Ym1pdHRlcik7XG4gIGZvcm0gPSBuZXcgRm9ybURhdGEoZm9ybSk7XG4gIHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZW1wKTtcbiAgcmV0dXJuIGZvcm07XG59XG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDEoXG4gIGRpc3BhdGNoUXVldWUsXG4gIGRvbUV2ZW50TmFtZSxcbiAgbWF5YmVUYXJnZXRJbnN0LFxuICBuYXRpdmVFdmVudCxcbiAgbmF0aXZlRXZlbnRUYXJnZXRcbikge1xuICBpZiAoXG4gICAgXCJzdWJtaXRcIiA9PT0gZG9tRXZlbnROYW1lICYmXG4gICAgbWF5YmVUYXJnZXRJbnN0ICYmXG4gICAgbWF5YmVUYXJnZXRJbnN0LnN0YXRlTm9kZSA9PT0gbmF0aXZlRXZlbnRUYXJnZXRcbiAgKSB7XG4gICAgdmFyIGFjdGlvbiA9IGNvZXJjZUZvcm1BY3Rpb25Qcm9wKFxuICAgICAgICAobmF0aXZlRXZlbnRUYXJnZXRbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbCkuYWN0aW9uXG4gICAgICApLFxuICAgICAgc3VibWl0dGVyID0gbmF0aXZlRXZlbnQuc3VibWl0dGVyO1xuICAgIHN1Ym1pdHRlciAmJlxuICAgICAgKChkb21FdmVudE5hbWUgPSAoZG9tRXZlbnROYW1lID0gc3VibWl0dGVyW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGwpXG4gICAgICAgID8gY29lcmNlRm9ybUFjdGlvblByb3AoZG9tRXZlbnROYW1lLmZvcm1BY3Rpb24pXG4gICAgICAgIDogc3VibWl0dGVyLmdldEF0dHJpYnV0ZShcImZvcm1BY3Rpb25cIikpLFxuICAgICAgbnVsbCAhPT0gZG9tRXZlbnROYW1lICYmICgoYWN0aW9uID0gZG9tRXZlbnROYW1lKSwgKHN1Ym1pdHRlciA9IG51bGwpKSk7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KFxuICAgICAgXCJhY3Rpb25cIixcbiAgICAgIFwiYWN0aW9uXCIsXG4gICAgICBudWxsLFxuICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICk7XG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgbGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIGlmICgwICE9PSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSkge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtRGF0YSA9IHN1Ym1pdHRlclxuICAgICAgICAgICAgICAgICAgPyBjcmVhdGVGb3JtRGF0YVdpdGhTdWJtaXR0ZXIobmF0aXZlRXZlbnRUYXJnZXQsIHN1Ym1pdHRlcilcbiAgICAgICAgICAgICAgICAgIDogbmV3IEZvcm1EYXRhKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBzdGFydEhvc3RUcmFuc2l0aW9uKFxuICAgICAgICAgICAgICAgICAgbWF5YmVUYXJnZXRJbnN0LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbmF0aXZlRXZlbnRUYXJnZXQubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBmb3JtRGF0YVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY3Rpb24gJiZcbiAgICAgICAgICAgICAgICAoZXZlbnQucHJldmVudERlZmF1bHQoKSxcbiAgICAgICAgICAgICAgICAoZm9ybURhdGEgPSBzdWJtaXR0ZXJcbiAgICAgICAgICAgICAgICAgID8gY3JlYXRlRm9ybURhdGFXaXRoU3VibWl0dGVyKG5hdGl2ZUV2ZW50VGFyZ2V0LCBzdWJtaXR0ZXIpXG4gICAgICAgICAgICAgICAgICA6IG5ldyBGb3JtRGF0YShuYXRpdmVFdmVudFRhcmdldCkpLFxuICAgICAgICAgICAgICAgIHN0YXJ0SG9zdFRyYW5zaXRpb24oXG4gICAgICAgICAgICAgICAgICBtYXliZVRhcmdldEluc3QsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmc6ICEwLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBuYXRpdmVFdmVudFRhcmdldC5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgZm9ybURhdGFcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxufVxuZm9yIChcbiAgdmFyIGkkanNjb21wJGlubGluZV8xNDM5ID0gMDtcbiAgaSRqc2NvbXAkaW5saW5lXzE0MzkgPCBzaW1wbGVFdmVudFBsdWdpbkV2ZW50cy5sZW5ndGg7XG4gIGkkanNjb21wJGlubGluZV8xNDM5Kytcbikge1xuICB2YXIgZXZlbnROYW1lJGpzY29tcCRpbmxpbmVfMTQ0MCA9XG4gICAgICBzaW1wbGVFdmVudFBsdWdpbkV2ZW50c1tpJGpzY29tcCRpbmxpbmVfMTQzOV0sXG4gICAgZG9tRXZlbnROYW1lJGpzY29tcCRpbmxpbmVfMTQ0MSA9XG4gICAgICBldmVudE5hbWUkanNjb21wJGlubGluZV8xNDQwLnRvTG93ZXJDYXNlKCksXG4gICAgY2FwaXRhbGl6ZWRFdmVudCRqc2NvbXAkaW5saW5lXzE0NDIgPVxuICAgICAgZXZlbnROYW1lJGpzY29tcCRpbmxpbmVfMTQ0MFswXS50b1VwcGVyQ2FzZSgpICtcbiAgICAgIGV2ZW50TmFtZSRqc2NvbXAkaW5saW5lXzE0NDAuc2xpY2UoMSk7XG4gIHJlZ2lzdGVyU2ltcGxlRXZlbnQoXG4gICAgZG9tRXZlbnROYW1lJGpzY29tcCRpbmxpbmVfMTQ0MSxcbiAgICBcIm9uXCIgKyBjYXBpdGFsaXplZEV2ZW50JGpzY29tcCRpbmxpbmVfMTQ0MlxuICApO1xufVxucmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fRU5ELCBcIm9uQW5pbWF0aW9uRW5kXCIpO1xucmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fSVRFUkFUSU9OLCBcIm9uQW5pbWF0aW9uSXRlcmF0aW9uXCIpO1xucmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fU1RBUlQsIFwib25BbmltYXRpb25TdGFydFwiKTtcbnJlZ2lzdGVyU2ltcGxlRXZlbnQoXCJkYmxjbGlja1wiLCBcIm9uRG91YmxlQ2xpY2tcIik7XG5yZWdpc3RlclNpbXBsZUV2ZW50KFwiZm9jdXNpblwiLCBcIm9uRm9jdXNcIik7XG5yZWdpc3RlclNpbXBsZUV2ZW50KFwiZm9jdXNvdXRcIiwgXCJvbkJsdXJcIik7XG5yZWdpc3RlclNpbXBsZUV2ZW50KFRSQU5TSVRJT05fUlVOLCBcIm9uVHJhbnNpdGlvblJ1blwiKTtcbnJlZ2lzdGVyU2ltcGxlRXZlbnQoVFJBTlNJVElPTl9TVEFSVCwgXCJvblRyYW5zaXRpb25TdGFydFwiKTtcbnJlZ2lzdGVyU2ltcGxlRXZlbnQoVFJBTlNJVElPTl9DQU5DRUwsIFwib25UcmFuc2l0aW9uQ2FuY2VsXCIpO1xucmVnaXN0ZXJTaW1wbGVFdmVudChUUkFOU0lUSU9OX0VORCwgXCJvblRyYW5zaXRpb25FbmRcIik7XG5yZWdpc3RlckRpcmVjdEV2ZW50KFwib25Nb3VzZUVudGVyXCIsIFtcIm1vdXNlb3V0XCIsIFwibW91c2VvdmVyXCJdKTtcbnJlZ2lzdGVyRGlyZWN0RXZlbnQoXCJvbk1vdXNlTGVhdmVcIiwgW1wibW91c2VvdXRcIiwgXCJtb3VzZW92ZXJcIl0pO1xucmVnaXN0ZXJEaXJlY3RFdmVudChcIm9uUG9pbnRlckVudGVyXCIsIFtcInBvaW50ZXJvdXRcIiwgXCJwb2ludGVyb3ZlclwiXSk7XG5yZWdpc3RlckRpcmVjdEV2ZW50KFwib25Qb2ludGVyTGVhdmVcIiwgW1wicG9pbnRlcm91dFwiLCBcInBvaW50ZXJvdmVyXCJdKTtcbnJlZ2lzdGVyVHdvUGhhc2VFdmVudChcbiAgXCJvbkNoYW5nZVwiLFxuICBcImNoYW5nZSBjbGljayBmb2N1c2luIGZvY3Vzb3V0IGlucHV0IGtleWRvd24ga2V5dXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXCIgXCIpXG4pO1xucmVnaXN0ZXJUd29QaGFzZUV2ZW50KFxuICBcIm9uU2VsZWN0XCIsXG4gIFwiZm9jdXNvdXQgY29udGV4dG1lbnUgZHJhZ2VuZCBmb2N1c2luIGtleWRvd24ga2V5dXAgbW91c2Vkb3duIG1vdXNldXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXG4gICAgXCIgXCJcbiAgKVxuKTtcbnJlZ2lzdGVyVHdvUGhhc2VFdmVudChcIm9uQmVmb3JlSW5wdXRcIiwgW1xuICBcImNvbXBvc2l0aW9uZW5kXCIsXG4gIFwia2V5cHJlc3NcIixcbiAgXCJ0ZXh0SW5wdXRcIixcbiAgXCJwYXN0ZVwiXG5dKTtcbnJlZ2lzdGVyVHdvUGhhc2VFdmVudChcbiAgXCJvbkNvbXBvc2l0aW9uRW5kXCIsXG4gIFwiY29tcG9zaXRpb25lbmQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIilcbik7XG5yZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gIFwib25Db21wb3NpdGlvblN0YXJ0XCIsXG4gIFwiY29tcG9zaXRpb25zdGFydCBmb2N1c291dCBrZXlkb3duIGtleXByZXNzIGtleXVwIG1vdXNlZG93blwiLnNwbGl0KFwiIFwiKVxuKTtcbnJlZ2lzdGVyVHdvUGhhc2VFdmVudChcbiAgXCJvbkNvbXBvc2l0aW9uVXBkYXRlXCIsXG4gIFwiY29tcG9zaXRpb251cGRhdGUgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIilcbik7XG52YXIgbWVkaWFFdmVudFR5cGVzID1cbiAgICBcImFib3J0IGNhbnBsYXkgY2FucGxheXRocm91Z2ggZHVyYXRpb25jaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgbG9hZGVkZGF0YSBsb2FkZWRtZXRhZGF0YSBsb2Fkc3RhcnQgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVjaGFuZ2UgcmVzaXplIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VzcGVuZCB0aW1ldXBkYXRlIHZvbHVtZWNoYW5nZSB3YWl0aW5nXCIuc3BsaXQoXG4gICAgICBcIiBcIlxuICAgICksXG4gIG5vbkRlbGVnYXRlZEV2ZW50cyA9IG5ldyBTZXQoXG4gICAgXCJiZWZvcmV0b2dnbGUgY2FuY2VsIGNsb3NlIGludmFsaWQgbG9hZCBzY3JvbGwgc2Nyb2xsZW5kIHRvZ2dsZVwiXG4gICAgICAuc3BsaXQoXCIgXCIpXG4gICAgICAuY29uY2F0KG1lZGlhRXZlbnRUeXBlcylcbiAgKTtcbmZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsIGV2ZW50U3lzdGVtRmxhZ3MpIHtcbiAgZXZlbnRTeXN0ZW1GbGFncyA9IDAgIT09IChldmVudFN5c3RlbUZsYWdzICYgNCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZGlzcGF0Y2hRdWV1ZSRpID0gZGlzcGF0Y2hRdWV1ZVtpXSxcbiAgICAgIGV2ZW50ID0gX2Rpc3BhdGNoUXVldWUkaS5ldmVudDtcbiAgICBfZGlzcGF0Y2hRdWV1ZSRpID0gX2Rpc3BhdGNoUXVldWUkaS5saXN0ZW5lcnM7XG4gICAgYToge1xuICAgICAgdmFyIHByZXZpb3VzSW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgICBpZiAoZXZlbnRTeXN0ZW1GbGFncylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgaSRqc2NvbXAkMCA9IF9kaXNwYXRjaFF1ZXVlJGkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAwIDw9IGkkanNjb21wJDA7XG4gICAgICAgICAgaSRqc2NvbXAkMC0tXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkaSA9IF9kaXNwYXRjaFF1ZXVlJGlbaSRqc2NvbXAkMF0sXG4gICAgICAgICAgICBpbnN0YW5jZSA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmluc3RhbmNlLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5saXN0ZW5lcjtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IHByZXZpb3VzSW5zdGFuY2UgJiYgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IF9kaXNwYXRjaExpc3RlbmVycyRpO1xuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcmV2aW91c0luc3RhbmNlKGV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICBwcmV2aW91c0luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICBpJGpzY29tcCQwIDwgX2Rpc3BhdGNoUXVldWUkaS5sZW5ndGg7XG4gICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICkge1xuICAgICAgICAgIF9kaXNwYXRjaExpc3RlbmVycyRpID0gX2Rpc3BhdGNoUXVldWUkaVtpJGpzY29tcCQwXTtcbiAgICAgICAgICBpbnN0YW5jZSA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmluc3RhbmNlO1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgIF9kaXNwYXRjaExpc3RlbmVycyRpID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9PSBwcmV2aW91c0luc3RhbmNlICYmIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpXG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIHByZXZpb3VzSW5zdGFuY2UgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaTtcbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJldmlvdXNJbnN0YW5jZShldmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0RWxlbWVudCkge1xuICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gdGFyZ2V0RWxlbWVudFtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldO1xuICB2b2lkIDAgPT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJlxuICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB0YXJnZXRFbGVtZW50W2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPVxuICAgICAgbmV3IFNldCgpKTtcbiAgdmFyIGxpc3RlbmVyU2V0S2V5ID0gZG9tRXZlbnROYW1lICsgXCJfX2J1YmJsZVwiO1xuICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuaGFzKGxpc3RlbmVyU2V0S2V5KSB8fFxuICAgIChhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBkb21FdmVudE5hbWUsIDIsICExKSxcbiAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuYWRkKGxpc3RlbmVyU2V0S2V5KSk7XG59XG5mdW5jdGlvbiBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSwgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciwgdGFyZ2V0KSB7XG4gIHZhciBldmVudFN5c3RlbUZsYWdzID0gMDtcbiAgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciAmJiAoZXZlbnRTeXN0ZW1GbGFncyB8PSA0KTtcbiAgYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIGRvbUV2ZW50TmFtZSxcbiAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXJcbiAgKTtcbn1cbnZhciBsaXN0ZW5pbmdNYXJrZXIgPSBcIl9yZWFjdExpc3RlbmluZ1wiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5mdW5jdGlvbiBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhyb290Q29udGFpbmVyRWxlbWVudCkge1xuICBpZiAoIXJvb3RDb250YWluZXJFbGVtZW50W2xpc3RlbmluZ01hcmtlcl0pIHtcbiAgICByb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdID0gITA7XG4gICAgYWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvbUV2ZW50TmFtZSkge1xuICAgICAgXCJzZWxlY3Rpb25jaGFuZ2VcIiAhPT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgIChub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkgfHxcbiAgICAgICAgICBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSwgITEsIHJvb3RDb250YWluZXJFbGVtZW50KSxcbiAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsICEwLCByb290Q29udGFpbmVyRWxlbWVudCkpO1xuICAgIH0pO1xuICAgIHZhciBvd25lckRvY3VtZW50ID1cbiAgICAgIDkgPT09IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlXG4gICAgICAgID8gcm9vdENvbnRhaW5lckVsZW1lbnRcbiAgICAgICAgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIG51bGwgPT09IG93bmVyRG9jdW1lbnQgfHxcbiAgICAgIG93bmVyRG9jdW1lbnRbbGlzdGVuaW5nTWFya2VyXSB8fFxuICAgICAgKChvd25lckRvY3VtZW50W2xpc3RlbmluZ01hcmtlcl0gPSAhMCksXG4gICAgICBsaXN0ZW5Ub05hdGl2ZUV2ZW50KFwic2VsZWN0aW9uY2hhbmdlXCIsICExLCBvd25lckRvY3VtZW50KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKFxuICB0YXJnZXRDb250YWluZXIsXG4gIGRvbUV2ZW50TmFtZSxcbiAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lclxuKSB7XG4gIHN3aXRjaCAoZ2V0RXZlbnRQcmlvcml0eShkb21FdmVudE5hbWUpKSB7XG4gICAgY2FzZSAyOlxuICAgICAgdmFyIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRGlzY3JldGVFdmVudDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgODpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoQ29udGludW91c0V2ZW50O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRXZlbnQ7XG4gIH1cbiAgZXZlbnRTeXN0ZW1GbGFncyA9IGxpc3RlbmVyV3JhcHBlci5iaW5kKFxuICAgIG51bGwsXG4gICAgZG9tRXZlbnROYW1lLFxuICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgdGFyZ2V0Q29udGFpbmVyXG4gICk7XG4gIGxpc3RlbmVyV3JhcHBlciA9IHZvaWQgMDtcbiAgIXBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkIHx8XG4gICAgKFwidG91Y2hzdGFydFwiICE9PSBkb21FdmVudE5hbWUgJiZcbiAgICAgIFwidG91Y2htb3ZlXCIgIT09IGRvbUV2ZW50TmFtZSAmJlxuICAgICAgXCJ3aGVlbFwiICE9PSBkb21FdmVudE5hbWUpIHx8XG4gICAgKGxpc3RlbmVyV3JhcHBlciA9ICEwKTtcbiAgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lclxuICAgID8gdm9pZCAwICE9PSBsaXN0ZW5lcldyYXBwZXJcbiAgICAgID8gdGFyZ2V0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB7XG4gICAgICAgICAgY2FwdHVyZTogITAsXG4gICAgICAgICAgcGFzc2l2ZTogbGlzdGVuZXJXcmFwcGVyXG4gICAgICAgIH0pXG4gICAgICA6IHRhcmdldENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgITApXG4gICAgOiB2b2lkIDAgIT09IGxpc3RlbmVyV3JhcHBlclxuICAgICAgPyB0YXJnZXRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHtcbiAgICAgICAgICBwYXNzaXZlOiBsaXN0ZW5lcldyYXBwZXJcbiAgICAgICAgfSlcbiAgICAgIDogdGFyZ2V0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCAhMSk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oXG4gIGRvbUV2ZW50TmFtZSxcbiAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgbmF0aXZlRXZlbnQsXG4gIHRhcmdldEluc3QkanNjb21wJDAsXG4gIHRhcmdldENvbnRhaW5lclxuKSB7XG4gIHZhciBhbmNlc3Rvckluc3QgPSB0YXJnZXRJbnN0JGpzY29tcCQwO1xuICBpZiAoXG4gICAgMCA9PT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiAxKSAmJlxuICAgIDAgPT09IChldmVudFN5c3RlbUZsYWdzICYgMikgJiZcbiAgICBudWxsICE9PSB0YXJnZXRJbnN0JGpzY29tcCQwXG4gIClcbiAgICBhOiBmb3IgKDs7KSB7XG4gICAgICBpZiAobnVsbCA9PT0gdGFyZ2V0SW5zdCRqc2NvbXAkMCkgcmV0dXJuO1xuICAgICAgdmFyIG5vZGVUYWcgPSB0YXJnZXRJbnN0JGpzY29tcCQwLnRhZztcbiAgICAgIGlmICgzID09PSBub2RlVGFnIHx8IDQgPT09IG5vZGVUYWcpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRhcmdldEluc3QkanNjb21wJDAuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjb250YWluZXIgPT09IHRhcmdldENvbnRhaW5lciB8fFxuICAgICAgICAgICg4ID09PSBjb250YWluZXIubm9kZVR5cGUgJiYgY29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRhcmdldENvbnRhaW5lcilcbiAgICAgICAgKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoNCA9PT0gbm9kZVRhZylcbiAgICAgICAgICBmb3IgKG5vZGVUYWcgPSB0YXJnZXRJbnN0JGpzY29tcCQwLnJldHVybjsgbnVsbCAhPT0gbm9kZVRhZzsgKSB7XG4gICAgICAgICAgICB2YXIgZ3JhbmRUYWcgPSBub2RlVGFnLnRhZztcbiAgICAgICAgICAgIGlmICgzID09PSBncmFuZFRhZyB8fCA0ID09PSBncmFuZFRhZylcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgoZ3JhbmRUYWcgPSBub2RlVGFnLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgICAgICBncmFuZFRhZyA9PT0gdGFyZ2V0Q29udGFpbmVyIHx8XG4gICAgICAgICAgICAgICAgICAoOCA9PT0gZ3JhbmRUYWcubm9kZVR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgZ3JhbmRUYWcucGFyZW50Tm9kZSA9PT0gdGFyZ2V0Q29udGFpbmVyKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIG5vZGVUYWcgPSBub2RlVGFnLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBjb250YWluZXI7ICkge1xuICAgICAgICAgIG5vZGVUYWcgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xuICAgICAgICAgIGlmIChudWxsID09PSBub2RlVGFnKSByZXR1cm47XG4gICAgICAgICAgZ3JhbmRUYWcgPSBub2RlVGFnLnRhZztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICA1ID09PSBncmFuZFRhZyB8fFxuICAgICAgICAgICAgNiA9PT0gZ3JhbmRUYWcgfHxcbiAgICAgICAgICAgIDI2ID09PSBncmFuZFRhZyB8fFxuICAgICAgICAgICAgMjcgPT09IGdyYW5kVGFnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0YXJnZXRJbnN0JGpzY29tcCQwID0gYW5jZXN0b3JJbnN0ID0gbm9kZVRhZztcbiAgICAgICAgICAgIGNvbnRpbnVlIGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0YXJnZXRJbnN0JGpzY29tcCQwID0gdGFyZ2V0SW5zdCRqc2NvbXAkMC5yZXR1cm47XG4gICAgfVxuICBiYXRjaGVkVXBkYXRlcyQxKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGFuY2VzdG9ySW5zdCxcbiAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpLFxuICAgICAgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICAgIGE6IHtcbiAgICAgIHZhciByZWFjdE5hbWUgPSB0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcy5nZXQoZG9tRXZlbnROYW1lKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IHJlYWN0TmFtZSkge1xuICAgICAgICB2YXIgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRXZlbnQsXG4gICAgICAgICAgcmVhY3RFdmVudFR5cGUgPSBkb21FdmVudE5hbWU7XG4gICAgICAgIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgICAgICAgY2FzZSBcImtleXByZXNzXCI6XG4gICAgICAgICAgICBpZiAoMCA9PT0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkpIGJyZWFrIGE7XG4gICAgICAgICAgY2FzZSBcImtleWRvd25cIjpcbiAgICAgICAgICBjYXNlIFwia2V5dXBcIjpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUgPSBcImZvY3VzXCI7XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgICAgICAgICByZWFjdEV2ZW50VHlwZSA9IFwiYmx1clwiO1xuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJiZWZvcmVibHVyXCI6XG4gICAgICAgICAgY2FzZSBcImFmdGVyYmx1clwiOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjbGlja1wiOlxuICAgICAgICAgICAgaWYgKDIgPT09IG5hdGl2ZUV2ZW50LmJ1dHRvbikgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIFwiYXV4Y2xpY2tcIjpcbiAgICAgICAgICBjYXNlIFwiZGJsY2xpY2tcIjpcbiAgICAgICAgICBjYXNlIFwibW91c2Vkb3duXCI6XG4gICAgICAgICAgY2FzZSBcIm1vdXNlbW92ZVwiOlxuICAgICAgICAgIGNhc2UgXCJtb3VzZXVwXCI6XG4gICAgICAgICAgY2FzZSBcIm1vdXNlb3V0XCI6XG4gICAgICAgICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgICAgIGNhc2UgXCJjb250ZXh0bWVudVwiOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkcmFnXCI6XG4gICAgICAgICAgY2FzZSBcImRyYWdlbmRcIjpcbiAgICAgICAgICBjYXNlIFwiZHJhZ2VudGVyXCI6XG4gICAgICAgICAgY2FzZSBcImRyYWdleGl0XCI6XG4gICAgICAgICAgY2FzZSBcImRyYWdsZWF2ZVwiOlxuICAgICAgICAgIGNhc2UgXCJkcmFnb3ZlclwiOlxuICAgICAgICAgIGNhc2UgXCJkcmFnc3RhcnRcIjpcbiAgICAgICAgICBjYXNlIFwiZHJvcFwiOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRvdWNoY2FuY2VsXCI6XG4gICAgICAgICAgY2FzZSBcInRvdWNoZW5kXCI6XG4gICAgICAgICAgY2FzZSBcInRvdWNobW92ZVwiOlxuICAgICAgICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fRU5EOlxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX0lURVJBVElPTjpcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVEFSVDpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBUUkFOU0lUSU9OX0VORDpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICAgICAgICBjYXNlIFwic2Nyb2xsZW5kXCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIndoZWVsXCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNvcHlcIjpcbiAgICAgICAgICBjYXNlIFwiY3V0XCI6XG4gICAgICAgICAgY2FzZSBcInBhc3RlXCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOlxuICAgICAgICAgIGNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpcbiAgICAgICAgICBjYXNlIFwicG9pbnRlcmNhbmNlbFwiOlxuICAgICAgICAgIGNhc2UgXCJwb2ludGVyZG93blwiOlxuICAgICAgICAgIGNhc2UgXCJwb2ludGVybW92ZVwiOlxuICAgICAgICAgIGNhc2UgXCJwb2ludGVyb3V0XCI6XG4gICAgICAgICAgY2FzZSBcInBvaW50ZXJvdmVyXCI6XG4gICAgICAgICAgY2FzZSBcInBvaW50ZXJ1cFwiOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRvZ2dsZVwiOlxuICAgICAgICAgIGNhc2UgXCJiZWZvcmV0b2dnbGVcIjpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1RvZ2dsZUV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbkNhcHR1cmVQaGFzZSA9IDAgIT09IChldmVudFN5c3RlbUZsYWdzICYgNCksXG4gICAgICAgICAgYWNjdW11bGF0ZVRhcmdldE9ubHkgPVxuICAgICAgICAgICAgIWluQ2FwdHVyZVBoYXNlICYmXG4gICAgICAgICAgICAoXCJzY3JvbGxcIiA9PT0gZG9tRXZlbnROYW1lIHx8IFwic2Nyb2xsZW5kXCIgPT09IGRvbUV2ZW50TmFtZSksXG4gICAgICAgICAgcmVhY3RFdmVudE5hbWUgPSBpbkNhcHR1cmVQaGFzZVxuICAgICAgICAgICAgPyBudWxsICE9PSByZWFjdE5hbWVcbiAgICAgICAgICAgICAgPyByZWFjdE5hbWUgKyBcIkNhcHR1cmVcIlxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIDogcmVhY3ROYW1lO1xuICAgICAgICBpbkNhcHR1cmVQaGFzZSA9IFtdO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRhcmdldEluc3QsIGxhc3RIb3N0Q29tcG9uZW50O1xuICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCA9IF9pbnN0YW5jZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgX2luc3RhbmNlID0gX2luc3RhbmNlLnRhZztcbiAgICAgICAgICAoNSAhPT0gX2luc3RhbmNlICYmIDI2ICE9PSBfaW5zdGFuY2UgJiYgMjcgIT09IF9pbnN0YW5jZSkgfHxcbiAgICAgICAgICAgIG51bGwgPT09IGxhc3RIb3N0Q29tcG9uZW50IHx8XG4gICAgICAgICAgICBudWxsID09PSByZWFjdEV2ZW50TmFtZSB8fFxuICAgICAgICAgICAgKChfaW5zdGFuY2UgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgcmVhY3RFdmVudE5hbWUpKSxcbiAgICAgICAgICAgIG51bGwgIT0gX2luc3RhbmNlICYmXG4gICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlLnB1c2goXG4gICAgICAgICAgICAgICAgY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgX2luc3RhbmNlLCBsYXN0SG9zdENvbXBvbmVudClcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGVUYXJnZXRPbmx5KSBicmVhaztcbiAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAwIDwgaW5DYXB0dXJlUGhhc2UubGVuZ3RoICYmXG4gICAgICAgICAgKChyZWFjdE5hbWUgPSBuZXcgU3ludGhldGljRXZlbnRDdG9yKFxuICAgICAgICAgICAgcmVhY3ROYW1lLFxuICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICkpLFxuICAgICAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7IGV2ZW50OiByZWFjdE5hbWUsIGxpc3RlbmVyczogaW5DYXB0dXJlUGhhc2UgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoMCA9PT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiA3KSkge1xuICAgICAgYToge1xuICAgICAgICByZWFjdE5hbWUgPVxuICAgICAgICAgIFwibW91c2VvdmVyXCIgPT09IGRvbUV2ZW50TmFtZSB8fCBcInBvaW50ZXJvdmVyXCIgPT09IGRvbUV2ZW50TmFtZTtcbiAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID1cbiAgICAgICAgICBcIm1vdXNlb3V0XCIgPT09IGRvbUV2ZW50TmFtZSB8fCBcInBvaW50ZXJvdXRcIiA9PT0gZG9tRXZlbnROYW1lO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcmVhY3ROYW1lICYmXG4gICAgICAgICAgbmF0aXZlRXZlbnQgIT09IGN1cnJlbnRSZXBsYXlpbmdFdmVudCAmJlxuICAgICAgICAgIChyZWFjdEV2ZW50VHlwZSA9XG4gICAgICAgICAgICBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSAmJlxuICAgICAgICAgIChnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWFjdEV2ZW50VHlwZSkgfHxcbiAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldKVxuICAgICAgICApXG4gICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgaWYgKFN5bnRoZXRpY0V2ZW50Q3RvciB8fCByZWFjdE5hbWUpIHtcbiAgICAgICAgICByZWFjdE5hbWUgPVxuICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgICA/IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgIDogKHJlYWN0TmFtZSA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQpXG4gICAgICAgICAgICAgICAgPyByZWFjdE5hbWUuZGVmYXVsdFZpZXcgfHwgcmVhY3ROYW1lLnBhcmVudFdpbmRvd1xuICAgICAgICAgICAgICAgIDogd2luZG93O1xuICAgICAgICAgIGlmIChTeW50aGV0aWNFdmVudEN0b3IpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChyZWFjdEV2ZW50VHlwZSA9XG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQpLFxuICAgICAgICAgICAgICAoU3ludGhldGljRXZlbnRDdG9yID0gdGFyZ2V0SW5zdCksXG4gICAgICAgICAgICAgIChyZWFjdEV2ZW50VHlwZSA9IHJlYWN0RXZlbnRUeXBlXG4gICAgICAgICAgICAgICAgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWFjdEV2ZW50VHlwZSlcbiAgICAgICAgICAgICAgICA6IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSByZWFjdEV2ZW50VHlwZSAmJlxuICAgICAgICAgICAgICAgICgoYWNjdW11bGF0ZVRhcmdldE9ubHkgPVxuICAgICAgICAgICAgICAgICAgZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihyZWFjdEV2ZW50VHlwZSkpLFxuICAgICAgICAgICAgICAgIChpbkNhcHR1cmVQaGFzZSA9IHJlYWN0RXZlbnRUeXBlLnRhZyksXG4gICAgICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUgIT09IGFjY3VtdWxhdGVUYXJnZXRPbmx5IHx8XG4gICAgICAgICAgICAgICAgICAoNSAhPT0gaW5DYXB0dXJlUGhhc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgMjcgIT09IGluQ2FwdHVyZVBoYXNlICYmXG4gICAgICAgICAgICAgICAgICAgIDYgIT09IGluQ2FwdHVyZVBoYXNlKSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgKFN5bnRoZXRpY0V2ZW50Q3RvciA9IG51bGwpLCAocmVhY3RFdmVudFR5cGUgPSB0YXJnZXRJbnN0KTtcbiAgICAgICAgICBpZiAoU3ludGhldGljRXZlbnRDdG9yICE9PSByZWFjdEV2ZW50VHlwZSkge1xuICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICAgICAgX2luc3RhbmNlID0gXCJvbk1vdXNlTGVhdmVcIjtcbiAgICAgICAgICAgIHJlYWN0RXZlbnROYW1lID0gXCJvbk1vdXNlRW50ZXJcIjtcbiAgICAgICAgICAgIGluc3RhbmNlID0gXCJtb3VzZVwiO1xuICAgICAgICAgICAgaWYgKFwicG9pbnRlcm91dFwiID09PSBkb21FdmVudE5hbWUgfHwgXCJwb2ludGVyb3ZlclwiID09PSBkb21FdmVudE5hbWUpXG4gICAgICAgICAgICAgIChpbkNhcHR1cmVQaGFzZSA9IFN5bnRoZXRpY1BvaW50ZXJFdmVudCksXG4gICAgICAgICAgICAgICAgKF9pbnN0YW5jZSA9IFwib25Qb2ludGVyTGVhdmVcIiksXG4gICAgICAgICAgICAgICAgKHJlYWN0RXZlbnROYW1lID0gXCJvblBvaW50ZXJFbnRlclwiKSxcbiAgICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICBhY2N1bXVsYXRlVGFyZ2V0T25seSA9XG4gICAgICAgICAgICAgIG51bGwgPT0gU3ludGhldGljRXZlbnRDdG9yXG4gICAgICAgICAgICAgICAgPyByZWFjdE5hbWVcbiAgICAgICAgICAgICAgICA6IGdldE5vZGVGcm9tSW5zdGFuY2UoU3ludGhldGljRXZlbnRDdG9yKTtcbiAgICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50ID1cbiAgICAgICAgICAgICAgbnVsbCA9PSByZWFjdEV2ZW50VHlwZVxuICAgICAgICAgICAgICAgID8gcmVhY3ROYW1lXG4gICAgICAgICAgICAgICAgOiBnZXROb2RlRnJvbUluc3RhbmNlKHJlYWN0RXZlbnRUeXBlKTtcbiAgICAgICAgICAgIHJlYWN0TmFtZSA9IG5ldyBpbkNhcHR1cmVQaGFzZShcbiAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICBpbnN0YW5jZSArIFwibGVhdmVcIixcbiAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yLFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWFjdE5hbWUudGFyZ2V0ID0gYWNjdW11bGF0ZVRhcmdldE9ubHk7XG4gICAgICAgICAgICByZWFjdE5hbWUucmVsYXRlZFRhcmdldCA9IGxhc3RIb3N0Q29tcG9uZW50O1xuICAgICAgICAgICAgX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KSA9PT0gdGFyZ2V0SW5zdCAmJlxuICAgICAgICAgICAgICAoKGluQ2FwdHVyZVBoYXNlID0gbmV3IGluQ2FwdHVyZVBoYXNlKFxuICAgICAgICAgICAgICAgIHJlYWN0RXZlbnROYW1lLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlICsgXCJlbnRlclwiLFxuICAgICAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlLFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoaW5DYXB0dXJlUGhhc2UudGFyZ2V0ID0gbGFzdEhvc3RDb21wb25lbnQpLFxuICAgICAgICAgICAgICAoaW5DYXB0dXJlUGhhc2UucmVsYXRlZFRhcmdldCA9IGFjY3VtdWxhdGVUYXJnZXRPbmx5KSxcbiAgICAgICAgICAgICAgKF9pbnN0YW5jZSA9IGluQ2FwdHVyZVBoYXNlKSk7XG4gICAgICAgICAgICBhY2N1bXVsYXRlVGFyZ2V0T25seSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIGlmIChTeW50aGV0aWNFdmVudEN0b3IgJiYgcmVhY3RFdmVudFR5cGUpXG4gICAgICAgICAgICAgIGI6IHtcbiAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSA9IFN5bnRoZXRpY0V2ZW50Q3RvcjtcbiAgICAgICAgICAgICAgICByZWFjdEV2ZW50TmFtZSA9IHJlYWN0RXZlbnRUeXBlO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBpbkNhcHR1cmVQaGFzZTtcbiAgICAgICAgICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBnZXRQYXJlbnQobGFzdEhvc3RDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UrKztcbiAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IHJlYWN0RXZlbnROYW1lO1xuICAgICAgICAgICAgICAgICAgX2luc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZ2V0UGFyZW50KF9pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCsrO1xuICAgICAgICAgICAgICAgIGZvciAoOyAwIDwgaW5zdGFuY2UgLSBsYXN0SG9zdENvbXBvbmVudDsgKVxuICAgICAgICAgICAgICAgICAgKGluQ2FwdHVyZVBoYXNlID0gZ2V0UGFyZW50KGluQ2FwdHVyZVBoYXNlKSksIGluc3RhbmNlLS07XG4gICAgICAgICAgICAgICAgZm9yICg7IDAgPCBsYXN0SG9zdENvbXBvbmVudCAtIGluc3RhbmNlOyApXG4gICAgICAgICAgICAgICAgICAocmVhY3RFdmVudE5hbWUgPSBnZXRQYXJlbnQocmVhY3RFdmVudE5hbWUpKSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQtLTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaW5zdGFuY2UtLTsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID09PSByZWFjdEV2ZW50TmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAobnVsbCAhPT0gcmVhY3RFdmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSA9PT0gcmVhY3RFdmVudE5hbWUuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UgPSBnZXRQYXJlbnQoaW5DYXB0dXJlUGhhc2UpO1xuICAgICAgICAgICAgICAgICAgcmVhY3RFdmVudE5hbWUgPSBnZXRQYXJlbnQocmVhY3RFdmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaW5DYXB0dXJlUGhhc2UgPSBudWxsO1xuICAgICAgICAgICAgbnVsbCAhPT0gU3ludGhldGljRXZlbnRDdG9yICYmXG4gICAgICAgICAgICAgIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgICAgICAgICByZWFjdE5hbWUsXG4gICAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yLFxuICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBudWxsICE9PSByZWFjdEV2ZW50VHlwZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBhY2N1bXVsYXRlVGFyZ2V0T25seSAmJlxuICAgICAgICAgICAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZVRhcmdldE9ubHksXG4gICAgICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUsXG4gICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UsXG4gICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGE6IHtcbiAgICAgICAgcmVhY3ROYW1lID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG4gICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9XG4gICAgICAgICAgcmVhY3ROYW1lLm5vZGVOYW1lICYmIHJlYWN0TmFtZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJzZWxlY3RcIiA9PT0gU3ludGhldGljRXZlbnRDdG9yIHx8XG4gICAgICAgICAgKFwiaW5wdXRcIiA9PT0gU3ludGhldGljRXZlbnRDdG9yICYmIFwiZmlsZVwiID09PSByZWFjdE5hbWUudHlwZSlcbiAgICAgICAgKVxuICAgICAgICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICAgICAgZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHJlYWN0TmFtZSkpXG4gICAgICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZClcbiAgICAgICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudDtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgICAgICAgIHZhciBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgKFN5bnRoZXRpY0V2ZW50Q3RvciA9IHJlYWN0TmFtZS5ub2RlTmFtZSksXG4gICAgICAgICAgICAhU3ludGhldGljRXZlbnRDdG9yIHx8XG4gICAgICAgICAgICBcImlucHV0XCIgIT09IFN5bnRoZXRpY0V2ZW50Q3Rvci50b0xvd2VyQ2FzZSgpIHx8XG4gICAgICAgICAgICAoXCJjaGVja2JveFwiICE9PSByZWFjdE5hbWUudHlwZSAmJiBcInJhZGlvXCIgIT09IHJlYWN0TmFtZS50eXBlKVxuICAgICAgICAgICAgICA/IHRhcmdldEluc3QgJiZcbiAgICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQodGFyZ2V0SW5zdC5lbGVtZW50VHlwZSkgJiZcbiAgICAgICAgICAgICAgICAoZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQpXG4gICAgICAgICAgICAgIDogKGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgJiZcbiAgICAgICAgICAoZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0RnVuYyhkb21FdmVudE5hbWUsIHRhcmdldEluc3QpKVxuICAgICAgICApIHtcbiAgICAgICAgICBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoXG4gICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLFxuICAgICAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMsXG4gICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhayBhO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyAmJiBoYW5kbGVFdmVudEZ1bmMoZG9tRXZlbnROYW1lLCByZWFjdE5hbWUsIHRhcmdldEluc3QpO1xuICAgICAgICBcImZvY3Vzb3V0XCIgPT09IGRvbUV2ZW50TmFtZSAmJlxuICAgICAgICAgIHRhcmdldEluc3QgJiZcbiAgICAgICAgICBcIm51bWJlclwiID09PSByZWFjdE5hbWUudHlwZSAmJlxuICAgICAgICAgIG51bGwgIT0gdGFyZ2V0SW5zdC5tZW1vaXplZFByb3BzLnZhbHVlICYmXG4gICAgICAgICAgc2V0RGVmYXVsdFZhbHVlKHJlYWN0TmFtZSwgXCJudW1iZXJcIiwgcmVhY3ROYW1lLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc1RleHRJbnB1dEVsZW1lbnQoaGFuZGxlRXZlbnRGdW5jKSB8fFxuICAgICAgICAgICAgXCJ0cnVlXCIgPT09IGhhbmRsZUV2ZW50RnVuYy5jb250ZW50RWRpdGFibGVcbiAgICAgICAgICApXG4gICAgICAgICAgICAoYWN0aXZlRWxlbWVudCA9IGhhbmRsZUV2ZW50RnVuYyksXG4gICAgICAgICAgICAgIChhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3QpLFxuICAgICAgICAgICAgICAobGFzdFNlbGVjdGlvbiA9IG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gYWN0aXZlRWxlbWVudEluc3QgPSBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1vdXNlZG93blwiOlxuICAgICAgICAgIG1vdXNlRG93biA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29udGV4dG1lbnVcIjpcbiAgICAgICAgY2FzZSBcIm1vdXNldXBcIjpcbiAgICAgICAgY2FzZSBcImRyYWdlbmRcIjpcbiAgICAgICAgICBtb3VzZURvd24gPSAhMTtcbiAgICAgICAgICBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2VsZWN0aW9uY2hhbmdlXCI6XG4gICAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJrZXlkb3duXCI6XG4gICAgICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgICAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICB9XG4gICAgICB2YXIgZmFsbGJhY2tEYXRhO1xuICAgICAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpXG4gICAgICAgIGI6IHtcbiAgICAgICAgICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjpcbiAgICAgICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFwib25Db21wb3NpdGlvblN0YXJ0XCI7XG4gICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJvbkNvbXBvc2l0aW9uRW5kXCI7XG4gICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpcbiAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJvbkNvbXBvc2l0aW9uVXBkYXRlXCI7XG4gICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50VHlwZSA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBpc0NvbXBvc2luZ1xuICAgICAgICAgID8gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpICYmXG4gICAgICAgICAgICAoZXZlbnRUeXBlID0gXCJvbkNvbXBvc2l0aW9uRW5kXCIpXG4gICAgICAgICAgOiBcImtleWRvd25cIiA9PT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgICAyMjkgPT09IG5hdGl2ZUV2ZW50LmtleUNvZGUgJiZcbiAgICAgICAgICAgIChldmVudFR5cGUgPSBcIm9uQ29tcG9zaXRpb25TdGFydFwiKTtcbiAgICAgIGV2ZW50VHlwZSAmJlxuICAgICAgICAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiZcbiAgICAgICAgICBcImtvXCIgIT09IG5hdGl2ZUV2ZW50LmxvY2FsZSAmJlxuICAgICAgICAgIChpc0NvbXBvc2luZyB8fCBcIm9uQ29tcG9zaXRpb25TdGFydFwiICE9PSBldmVudFR5cGVcbiAgICAgICAgICAgID8gXCJvbkNvbXBvc2l0aW9uRW5kXCIgPT09IGV2ZW50VHlwZSAmJlxuICAgICAgICAgICAgICBpc0NvbXBvc2luZyAmJlxuICAgICAgICAgICAgICAoZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpKVxuICAgICAgICAgICAgOiAoKHJvb3QgPSBuYXRpdmVFdmVudFRhcmdldCksXG4gICAgICAgICAgICAgIChzdGFydFRleHQgPSBcInZhbHVlXCIgaW4gcm9vdCA/IHJvb3QudmFsdWUgOiByb290LnRleHRDb250ZW50KSxcbiAgICAgICAgICAgICAgKGlzQ29tcG9zaW5nID0gITApKSksXG4gICAgICAgIChoYW5kbGVFdmVudEZ1bmMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCwgZXZlbnRUeXBlKSksXG4gICAgICAgIDAgPCBoYW5kbGVFdmVudEZ1bmMubGVuZ3RoICYmXG4gICAgICAgICAgKChldmVudFR5cGUgPSBuZXcgU3ludGhldGljQ29tcG9zaXRpb25FdmVudChcbiAgICAgICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgKSksXG4gICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IGV2ZW50VHlwZSwgbGlzdGVuZXJzOiBoYW5kbGVFdmVudEZ1bmMgfSksXG4gICAgICAgICAgZmFsbGJhY2tEYXRhXG4gICAgICAgICAgICA/IChldmVudFR5cGUuZGF0YSA9IGZhbGxiYWNrRGF0YSlcbiAgICAgICAgICAgIDogKChmYWxsYmFja0RhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGZhbGxiYWNrRGF0YSAmJiAoZXZlbnRUeXBlLmRhdGEgPSBmYWxsYmFja0RhdGEpKSkpO1xuICAgICAgaWYgKFxuICAgICAgICAoZmFsbGJhY2tEYXRhID0gY2FuVXNlVGV4dElucHV0RXZlbnRcbiAgICAgICAgICA/IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudClcbiAgICAgICAgICA6IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSlcbiAgICAgIClcbiAgICAgICAgKGV2ZW50VHlwZSA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LCBcIm9uQmVmb3JlSW5wdXRcIikpLFxuICAgICAgICAgIDAgPCBldmVudFR5cGUubGVuZ3RoICYmXG4gICAgICAgICAgICAoKGhhbmRsZUV2ZW50RnVuYyA9IG5ldyBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KFxuICAgICAgICAgICAgICBcIm9uQmVmb3JlSW5wdXRcIixcbiAgICAgICAgICAgICAgXCJiZWZvcmVpbnB1dFwiLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgZXZlbnQ6IGhhbmRsZUV2ZW50RnVuYyxcbiAgICAgICAgICAgICAgbGlzdGVuZXJzOiBldmVudFR5cGVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKGhhbmRsZUV2ZW50RnVuYy5kYXRhID0gZmFsbGJhY2tEYXRhKSk7XG4gICAgICBleHRyYWN0RXZlbnRzJDEoXG4gICAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgdGFyZ2V0SW5zdCxcbiAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCkge1xuICByZXR1cm4ge1xuICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgY3VycmVudFRhcmdldDogY3VycmVudFRhcmdldFxuICB9O1xufVxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLCByZWFjdE5hbWUpIHtcbiAgZm9yIChcbiAgICB2YXIgY2FwdHVyZU5hbWUgPSByZWFjdE5hbWUgKyBcIkNhcHR1cmVcIiwgbGlzdGVuZXJzID0gW107XG4gICAgbnVsbCAhPT0gdGFyZ2V0RmliZXI7XG5cbiAgKSB7XG4gICAgdmFyIF9pbnN0YW5jZTIgPSB0YXJnZXRGaWJlcixcbiAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTIuc3RhdGVOb2RlO1xuICAgIF9pbnN0YW5jZTIgPSBfaW5zdGFuY2UyLnRhZztcbiAgICAoNSAhPT0gX2luc3RhbmNlMiAmJiAyNiAhPT0gX2luc3RhbmNlMiAmJiAyNyAhPT0gX2luc3RhbmNlMikgfHxcbiAgICAgIG51bGwgPT09IHN0YXRlTm9kZSB8fFxuICAgICAgKChfaW5zdGFuY2UyID0gZ2V0TGlzdGVuZXIodGFyZ2V0RmliZXIsIGNhcHR1cmVOYW1lKSksXG4gICAgICBudWxsICE9IF9pbnN0YW5jZTIgJiZcbiAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoXG4gICAgICAgICAgY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcih0YXJnZXRGaWJlciwgX2luc3RhbmNlMiwgc3RhdGVOb2RlKVxuICAgICAgICApLFxuICAgICAgKF9pbnN0YW5jZTIgPSBnZXRMaXN0ZW5lcih0YXJnZXRGaWJlciwgcmVhY3ROYW1lKSksXG4gICAgICBudWxsICE9IF9pbnN0YW5jZTIgJiZcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goXG4gICAgICAgICAgY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcih0YXJnZXRGaWJlciwgX2luc3RhbmNlMiwgc3RhdGVOb2RlKVxuICAgICAgICApKTtcbiAgICB0YXJnZXRGaWJlciA9IHRhcmdldEZpYmVyLnJldHVybjtcbiAgfVxuICByZXR1cm4gbGlzdGVuZXJzO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgaWYgKG51bGwgPT09IGluc3QpIHJldHVybiBudWxsO1xuICBkbyBpbnN0ID0gaW5zdC5yZXR1cm47XG4gIHdoaWxlIChpbnN0ICYmIDUgIT09IGluc3QudGFnICYmIDI3ICE9PSBpbnN0LnRhZyk7XG4gIHJldHVybiBpbnN0ID8gaW5zdCA6IG51bGw7XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KFxuICBkaXNwYXRjaFF1ZXVlLFxuICBldmVudCxcbiAgdGFyZ2V0LFxuICBjb21tb24sXG4gIGluQ2FwdHVyZVBoYXNlXG4pIHtcbiAgZm9yIChcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50Ll9yZWFjdE5hbWUsIGxpc3RlbmVycyA9IFtdO1xuICAgIG51bGwgIT09IHRhcmdldCAmJiB0YXJnZXQgIT09IGNvbW1vbjtcblxuICApIHtcbiAgICB2YXIgX2luc3RhbmNlMyA9IHRhcmdldCxcbiAgICAgIGFsdGVybmF0ZSA9IF9pbnN0YW5jZTMuYWx0ZXJuYXRlLFxuICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlMy5zdGF0ZU5vZGU7XG4gICAgX2luc3RhbmNlMyA9IF9pbnN0YW5jZTMudGFnO1xuICAgIGlmIChudWxsICE9PSBhbHRlcm5hdGUgJiYgYWx0ZXJuYXRlID09PSBjb21tb24pIGJyZWFrO1xuICAgICg1ICE9PSBfaW5zdGFuY2UzICYmIDI2ICE9PSBfaW5zdGFuY2UzICYmIDI3ICE9PSBfaW5zdGFuY2UzKSB8fFxuICAgICAgbnVsbCA9PT0gc3RhdGVOb2RlIHx8XG4gICAgICAoKGFsdGVybmF0ZSA9IHN0YXRlTm9kZSksXG4gICAgICBpbkNhcHR1cmVQaGFzZVxuICAgICAgICA/ICgoc3RhdGVOb2RlID0gZ2V0TGlzdGVuZXIodGFyZ2V0LCByZWdpc3RyYXRpb25OYW1lKSksXG4gICAgICAgICAgbnVsbCAhPSBzdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KFxuICAgICAgICAgICAgICBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKHRhcmdldCwgc3RhdGVOb2RlLCBhbHRlcm5hdGUpXG4gICAgICAgICAgICApKVxuICAgICAgICA6IGluQ2FwdHVyZVBoYXNlIHx8XG4gICAgICAgICAgKChzdGF0ZU5vZGUgPSBnZXRMaXN0ZW5lcih0YXJnZXQsIHJlZ2lzdHJhdGlvbk5hbWUpKSxcbiAgICAgICAgICBudWxsICE9IHN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goXG4gICAgICAgICAgICAgIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIodGFyZ2V0LCBzdGF0ZU5vZGUsIGFsdGVybmF0ZSlcbiAgICAgICAgICAgICkpKTtcbiAgICB0YXJnZXQgPSB0YXJnZXQucmV0dXJuO1xuICB9XG4gIDAgIT09IGxpc3RlbmVycy5sZW5ndGggJiZcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goeyBldmVudDogZXZlbnQsIGxpc3RlbmVyczogbGlzdGVuZXJzIH0pO1xufVxudmFyIE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2csXG4gIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcbmZ1bmN0aW9uIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShtYXJrdXApIHtcbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSB0eXBlb2YgbWFya3VwID8gbWFya3VwIDogXCJcIiArIG1hcmt1cClcbiAgICAucmVwbGFjZShOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgsIFwiXFxuXCIpXG4gICAgLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGNoZWNrRm9yVW5tYXRjaGVkVGV4dChzZXJ2ZXJUZXh0LCBjbGllbnRUZXh0KSB7XG4gIGNsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gIHJldHVybiBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVGV4dCkgPT09IGNsaWVudFRleHQgPyAhMCA6ICExO1xufVxuZnVuY3Rpb24gbm9vcCQxKCkge31cbmZ1bmN0aW9uIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBrZXksIHZhbHVlLCBwcm9wcywgcHJldlZhbHVlKSB7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgPyBcImJvZHlcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgKFwidGV4dGFyZWFcIiA9PT0gdGFnICYmIFwiXCIgPT09IHZhbHVlKSB8fFxuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIHZhbHVlKVxuICAgICAgICA6IChcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgfHwgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHZhbHVlKSAmJlxuICAgICAgICAgIFwiYm9keVwiICE9PSB0YWcgJiZcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBcIlwiICsgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgc2V0VmFsdWVGb3JLbm93bkF0dHJpYnV0ZShkb21FbGVtZW50LCBcImNsYXNzXCIsIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0YWJJbmRleFwiOlxuICAgICAgc2V0VmFsdWVGb3JLbm93bkF0dHJpYnV0ZShkb21FbGVtZW50LCBcInRhYmluZGV4XCIsIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkaXJcIjpcbiAgICBjYXNlIFwicm9sZVwiOlxuICAgIGNhc2UgXCJ2aWV3Qm94XCI6XG4gICAgY2FzZSBcIndpZHRoXCI6XG4gICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgc2V0VmFsdWVGb3JLbm93bkF0dHJpYnV0ZShkb21FbGVtZW50LCBrZXksIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgdmFsdWUsIHByZXZWYWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHRhZykge1xuICAgICAgICBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwiZGF0YVwiLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJzcmNcIjpcbiAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgaWYgKFwiXCIgPT09IHZhbHVlICYmIChcImFcIiAhPT0gdGFnIHx8IFwiaHJlZlwiICE9PSBrZXkpKSB7XG4gICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBudWxsID09IHZhbHVlIHx8XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICApIHtcbiAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKFwiXCIgKyB2YWx1ZSk7XG4gICAgICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICBjYXNlIFwiZm9ybUFjdGlvblwiOlxuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBcImphdmFzY3JpcHQ6dGhyb3cgbmV3IEVycm9yKCdBIFJlYWN0IGZvcm0gd2FzIHVuZXhwZWN0ZWRseSBzdWJtaXR0ZWQuIElmIHlvdSBjYWxsZWQgZm9ybS5zdWJtaXQoKSBtYW51YWxseSwgY29uc2lkZXIgdXNpbmcgZm9ybS5yZXF1ZXN0U3VibWl0KCkgaW5zdGVhZC4gSWYgeW91XFxcXCdyZSB0cnlpbmcgdG8gdXNlIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpIGluIGEgc3VibWl0IGV2ZW50IGhhbmRsZXIsIGNvbnNpZGVyIGFsc28gY2FsbGluZyBldmVudC5wcmV2ZW50RGVmYXVsdCgpLicpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2VcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJldlZhbHVlICYmXG4gICAgICAgICAgKFwiZm9ybUFjdGlvblwiID09PSBrZXlcbiAgICAgICAgICAgID8gKFwiaW5wdXRcIiAhPT0gdGFnICYmXG4gICAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIFwibmFtZVwiLCBwcm9wcy5uYW1lLCBwcm9wcywgbnVsbCksXG4gICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgXCJmb3JtRW5jVHlwZVwiLFxuICAgICAgICAgICAgICAgIHByb3BzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICBcImZvcm1NZXRob2RcIixcbiAgICAgICAgICAgICAgICBwcm9wcy5mb3JtTWV0aG9kLFxuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICBcImZvcm1UYXJnZXRcIixcbiAgICAgICAgICAgICAgICBwcm9wcy5mb3JtVGFyZ2V0LFxuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIDogKHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBcImVuY1R5cGVcIiwgcHJvcHMuZW5jVHlwZSwgcHJvcHMsIG51bGwpLFxuICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgXCJtZXRob2RcIiwgcHJvcHMubWV0aG9kLCBwcm9wcywgbnVsbCksXG4gICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBcInRhcmdldFwiLCBwcm9wcy50YXJnZXQsIHByb3BzLCBudWxsKSkpO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsID09IHZhbHVlIHx8XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICApIHtcbiAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKFwiXCIgKyB2YWx1ZSk7XG4gICAgICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgICBudWxsICE9IHZhbHVlICYmIChkb21FbGVtZW50Lm9uY2xpY2sgPSBub29wJDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9uU2Nyb2xsXCI6XG4gICAgICBudWxsICE9IHZhbHVlICYmIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJzY3JvbGxcIiwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib25TY3JvbGxFbmRcIjpcbiAgICAgIG51bGwgIT0gdmFsdWUgJiYgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbGVuZFwiLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgaWYgKG51bGwgIT0gdmFsdWUpIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiB2YWx1ZSB8fCAhKFwiX19odG1sXCIgaW4gdmFsdWUpKVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNjEpKTtcbiAgICAgICAga2V5ID0gdmFsdWUuX19odG1sO1xuICAgICAgICBpZiAobnVsbCAhPSBrZXkpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wcy5jaGlsZHJlbikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2MCkpO1xuICAgICAgICAgIGRvbUVsZW1lbnQuaW5uZXJIVE1MID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgIGRvbUVsZW1lbnQubXVsdGlwbGUgPVxuICAgICAgICB2YWx1ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgIGRvbUVsZW1lbnQubXV0ZWQgPVxuICAgICAgICB2YWx1ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgY2FzZSBcInJlZlwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImF1dG9Gb2N1c1wiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInhsaW5rSHJlZlwiOlxuICAgICAgaWYgKFxuICAgICAgICBudWxsID09IHZhbHVlIHx8XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICApIHtcbiAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ4bGluazpocmVmXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGtleSA9IHNhbml0aXplVVJMKFwiXCIgKyB2YWx1ZSk7XG4gICAgICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZU5TKFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICAgICAgXCJ4bGluazpocmVmXCIsXG4gICAgICAgIGtleVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb250ZW50RWRpdGFibGVcIjpcbiAgICBjYXNlIFwic3BlbGxDaGVja1wiOlxuICAgIGNhc2UgXCJkcmFnZ2FibGVcIjpcbiAgICBjYXNlIFwidmFsdWVcIjpcbiAgICBjYXNlIFwiYXV0b1JldmVyc2VcIjpcbiAgICBjYXNlIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiOlxuICAgIGNhc2UgXCJmb2N1c2FibGVcIjpcbiAgICBjYXNlIFwicHJlc2VydmVBbHBoYVwiOlxuICAgICAgbnVsbCAhPSB2YWx1ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSlcbiAgICAgICAgOiBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImluZXJ0XCI6XG4gICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgIGNhc2UgXCJhc3luY1wiOlxuICAgIGNhc2UgXCJhdXRvUGxheVwiOlxuICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgY2FzZSBcImRlZmVyXCI6XG4gICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgY2FzZSBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiOlxuICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICBjYXNlIFwibG9vcFwiOlxuICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgY2FzZSBcIm9wZW5cIjpcbiAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgY2FzZSBcInNlYW1sZXNzXCI6XG4gICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgdmFsdWUgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiYgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICAgID8gZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiKVxuICAgICAgICA6IGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2FwdHVyZVwiOlxuICAgIGNhc2UgXCJkb3dubG9hZFwiOlxuICAgICAgITAgPT09IHZhbHVlXG4gICAgICAgID8gZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiKVxuICAgICAgICA6ICExICE9PSB2YWx1ZSAmJlxuICAgICAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgID8gZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICAgICAgICA6IGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29sc1wiOlxuICAgIGNhc2UgXCJyb3dzXCI6XG4gICAgY2FzZSBcInNpemVcIjpcbiAgICBjYXNlIFwic3BhblwiOlxuICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgIWlzTmFOKHZhbHVlKSAmJlxuICAgICAgMSA8PSB2YWx1ZVxuICAgICAgICA/IGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpXG4gICAgICAgIDogZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyb3dTcGFuXCI6XG4gICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICBudWxsID09IHZhbHVlIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICBpc05hTih2YWx1ZSlcbiAgICAgICAgPyBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgICAgIDogZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicG9wb3ZlclwiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImJlZm9yZXRvZ2dsZVwiLCBkb21FbGVtZW50KTtcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJ0b2dnbGVcIiwgZG9tRWxlbWVudCk7XG4gICAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBcInBvcG92ZXJcIiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInhsaW5rQWN0dWF0ZVwiOlxuICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICAgICAgXCJ4bGluazphY3R1YXRlXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInhsaW5rQXJjcm9sZVwiOlxuICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICAgICAgXCJ4bGluazphcmNyb2xlXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInhsaW5rUm9sZVwiOlxuICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICAgICAgXCJ4bGluazpyb2xlXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInhsaW5rU2hvd1wiOlxuICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICAgICAgXCJ4bGluazpzaG93XCIsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInhsaW5rVGl0bGVcIjpcbiAgICAgIHNldFZhbHVlRm9yTmFtZXNwYWNlZEF0dHJpYnV0ZShcbiAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgICAgIFwieGxpbms6dGl0bGVcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtUeXBlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOnR5cGVcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieG1sQmFzZVwiOlxuICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgICAgICBcInhtbDpiYXNlXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInhtbExhbmdcIjpcbiAgICAgIHNldFZhbHVlRm9yTmFtZXNwYWNlZEF0dHJpYnV0ZShcbiAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgICAgICAgXCJ4bWw6bGFuZ1wiLFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ4bWxTcGFjZVwiOlxuICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgICAgICBcInhtbDpzcGFjZVwiLFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpc1wiOlxuICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgXCJpc1wiLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKFxuICAgICAgICAhKDIgPCBrZXkubGVuZ3RoKSB8fFxuICAgICAgICAoXCJvXCIgIT09IGtleVswXSAmJiBcIk9cIiAhPT0ga2V5WzBdKSB8fFxuICAgICAgICAoXCJuXCIgIT09IGtleVsxXSAmJiBcIk5cIiAhPT0ga2V5WzFdKVxuICAgICAgKVxuICAgICAgICAoa2V5ID0gYWxpYXNlcy5nZXQoa2V5KSB8fCBrZXkpLFxuICAgICAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIGtleSwgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRQcm9wT25DdXN0b21FbGVtZW50KGRvbUVsZW1lbnQsIHRhZywga2V5LCB2YWx1ZSwgcHJvcHMsIHByZXZWYWx1ZSkge1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgdmFsdWUsIHByZXZWYWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgIGlmIChudWxsICE9IHZhbHVlKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgdmFsdWUgfHwgIShcIl9faHRtbFwiIGluIHZhbHVlKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDYxKSk7XG4gICAgICAgIGtleSA9IHZhbHVlLl9faHRtbDtcbiAgICAgICAgaWYgKG51bGwgIT0ga2V5KSB7XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcHMuY2hpbGRyZW4pIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNjApKTtcbiAgICAgICAgICBkb21FbGVtZW50LmlubmVySFRNTCA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgPyBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCB2YWx1ZSlcbiAgICAgICAgOiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHZhbHVlIHx8IFwiYmlnaW50XCIgPT09IHR5cGVvZiB2YWx1ZSkgJiZcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBcIlwiICsgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9uU2Nyb2xsXCI6XG4gICAgICBudWxsICE9IHZhbHVlICYmIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJzY3JvbGxcIiwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib25TY3JvbGxFbmRcIjpcbiAgICAgIG51bGwgIT0gdmFsdWUgJiYgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbGVuZFwiLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgICBudWxsICE9IHZhbHVlICYmIChkb21FbGVtZW50Lm9uY2xpY2sgPSBub29wJDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgY2FzZSBcInJlZlwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlubmVyVGV4dFwiOlxuICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICghcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICBhOiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJvXCIgPT09IGtleVswXSAmJlxuICAgICAgICAgICAgXCJuXCIgPT09IGtleVsxXSAmJlxuICAgICAgICAgICAgKChwcm9wcyA9IGtleS5lbmRzV2l0aChcIkNhcHR1cmVcIikpLFxuICAgICAgICAgICAgKHRhZyA9IGtleS5zbGljZSgyLCBwcm9wcyA/IGtleS5sZW5ndGggLSA3IDogdm9pZCAwKSksXG4gICAgICAgICAgICAocHJldlZhbHVlID0gZG9tRWxlbWVudFtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsKSxcbiAgICAgICAgICAgIChwcmV2VmFsdWUgPSBudWxsICE9IHByZXZWYWx1ZSA/IHByZXZWYWx1ZVtrZXldIDogbnVsbCksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2VmFsdWUgJiZcbiAgICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRhZywgcHJldlZhbHVlLCBwcm9wcyksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByZXZWYWx1ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBwcmV2VmFsdWUgJiZcbiAgICAgICAgICAgICAgKGtleSBpbiBkb21FbGVtZW50XG4gICAgICAgICAgICAgICAgPyAoZG9tRWxlbWVudFtrZXldID0gbnVsbClcbiAgICAgICAgICAgICAgICA6IGRvbUVsZW1lbnQuaGFzQXR0cmlidXRlKGtleSkgJiZcbiAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSkpO1xuICAgICAgICAgICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRhZywgdmFsdWUsIHByb3BzKTtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleSBpbiBkb21FbGVtZW50XG4gICAgICAgICAgICA/IChkb21FbGVtZW50W2tleV0gPSB2YWx1ZSlcbiAgICAgICAgICAgIDogITAgPT09IHZhbHVlXG4gICAgICAgICAgICAgID8gZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiKVxuICAgICAgICAgICAgICA6IHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIFwiZGl2XCI6XG4gICAgY2FzZSBcInNwYW5cIjpcbiAgICBjYXNlIFwic3ZnXCI6XG4gICAgY2FzZSBcInBhdGhcIjpcbiAgICBjYXNlIFwiYVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwibGlcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBkb21FbGVtZW50KTtcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJsb2FkXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgdmFyIGhhc1NyYyA9ICExLFxuICAgICAgICBoYXNTcmNTZXQgPSAhMSxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwic3JjXCI6XG4gICAgICAgICAgICAgICAgaGFzU3JjID0gITA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzcmNTZXRcIjpcbiAgICAgICAgICAgICAgICBoYXNTcmNTZXQgPSAhMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTM3LCB0YWcpKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgcHJvcEtleSwgcHJvcFZhbHVlLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGhhc1NyY1NldCAmJlxuICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgXCJzcmNTZXRcIiwgcHJvcHMuc3JjU2V0LCBwcm9wcywgbnVsbCk7XG4gICAgICBoYXNTcmMgJiYgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIFwic3JjXCIsIHByb3BzLnNyYywgcHJvcHMsIG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImludmFsaWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gKHByb3BLZXkgPSBwcm9wVmFsdWUgPSBoYXNTcmNTZXQgPSBudWxsKSxcbiAgICAgICAgY2hlY2tlZCA9IG51bGwsXG4gICAgICAgIGRlZmF1bHRDaGVja2VkID0gbnVsbDtcbiAgICAgIGZvciAoaGFzU3JjIGluIHByb3BzKVxuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoaGFzU3JjKSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUkMTg2ID0gcHJvcHNbaGFzU3JjXTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkMTg2KVxuICAgICAgICAgICAgc3dpdGNoIChoYXNTcmMpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICBoYXNTcmNTZXQgPSBwcm9wVmFsdWUkMTg2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IHByb3BWYWx1ZSQxODY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgY2hlY2tlZCA9IHByb3BWYWx1ZSQxODY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcFZhbHVlJDE4NjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgcHJvcEtleSA9IHByb3BWYWx1ZSQxODY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWUkMTg2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJDE4NilcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTM3LCB0YWcpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgaGFzU3JjLCBwcm9wVmFsdWUkMTg2LCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGluaXRJbnB1dChcbiAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgcHJvcEtleSxcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgICBjaGVja2VkLFxuICAgICAgICBkZWZhdWx0Q2hlY2tlZCxcbiAgICAgICAgcHJvcFZhbHVlLFxuICAgICAgICBoYXNTcmNTZXQsXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImludmFsaWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICBoYXNTcmMgPSBwcm9wVmFsdWUgPSBwcm9wS2V5ID0gbnVsbDtcbiAgICAgIGZvciAoaGFzU3JjU2V0IGluIHByb3BzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkoaGFzU3JjU2V0KSAmJlxuICAgICAgICAgICgoZGVmYXVsdFZhbHVlID0gcHJvcHNbaGFzU3JjU2V0XSksIG51bGwgIT0gZGVmYXVsdFZhbHVlKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChoYXNTcmNTZXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBwcm9wS2V5ID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgcHJvcFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICBoYXNTcmMgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgaGFzU3JjU2V0LCBkZWZhdWx0VmFsdWUsIHByb3BzLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICB0YWcgPSBwcm9wS2V5O1xuICAgICAgcHJvcHMgPSBwcm9wVmFsdWU7XG4gICAgICBkb21FbGVtZW50Lm11bHRpcGxlID0gISFoYXNTcmM7XG4gICAgICBudWxsICE9IHRhZ1xuICAgICAgICA/IHVwZGF0ZU9wdGlvbnMoZG9tRWxlbWVudCwgISFoYXNTcmMsIHRhZywgITEpXG4gICAgICAgIDogbnVsbCAhPSBwcm9wcyAmJiB1cGRhdGVPcHRpb25zKGRvbUVsZW1lbnQsICEhaGFzU3JjLCBwcm9wcywgITApO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImludmFsaWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wS2V5ID0gaGFzU3JjU2V0ID0gaGFzU3JjID0gbnVsbDtcbiAgICAgIGZvciAocHJvcFZhbHVlIGluIHByb3BzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcFZhbHVlKSAmJlxuICAgICAgICAgICgoZGVmYXVsdFZhbHVlID0gcHJvcHNbcHJvcFZhbHVlXSksIG51bGwgIT0gZGVmYXVsdFZhbHVlKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBoYXNTcmMgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICBoYXNTcmNTZXQgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgIHByb3BLZXkgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IGRlZmF1bHRWYWx1ZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5MSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBwcm9wVmFsdWUsIGRlZmF1bHRWYWx1ZSwgcHJvcHMsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgIGluaXRUZXh0YXJlYShkb21FbGVtZW50LCBoYXNTcmMsIGhhc1NyY1NldCwgcHJvcEtleSk7XG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICBmb3IgKGNoZWNrZWQgaW4gcHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShjaGVja2VkKSAmJlxuICAgICAgICAgICgoaGFzU3JjID0gcHJvcHNbY2hlY2tlZF0pLCBudWxsICE9IGhhc1NyYylcbiAgICAgICAgKVxuICAgICAgICAgIHN3aXRjaCAoY2hlY2tlZCkge1xuICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQuc2VsZWN0ZWQgPVxuICAgICAgICAgICAgICAgIGhhc1NyYyAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGhhc1NyYyAmJlxuICAgICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBoYXNTcmM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIGNoZWNrZWQsIGhhc1NyYywgcHJvcHMsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICBjYXNlIFwiZGlhbG9nXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiY2FuY2VsXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImNsb3NlXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlmcmFtZVwiOlxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJsb2FkXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInZpZGVvXCI6XG4gICAgY2FzZSBcImF1ZGlvXCI6XG4gICAgICBmb3IgKGhhc1NyYyA9IDA7IGhhc1NyYyA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGhhc1NyYysrKVxuICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1toYXNTcmNdLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImVycm9yXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZGV0YWlsc1wiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInRvZ2dsZVwiLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlbWJlZFwiOlxuICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICBjYXNlIFwibGlua1wiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImVycm9yXCIsIGRvbUVsZW1lbnQpLFxuICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBkb21FbGVtZW50KTtcbiAgICBjYXNlIFwiYXJlYVwiOlxuICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgY2FzZSBcImJyXCI6XG4gICAgY2FzZSBcImNvbFwiOlxuICAgIGNhc2UgXCJoclwiOlxuICAgIGNhc2UgXCJrZXlnZW5cIjpcbiAgICBjYXNlIFwibWV0YVwiOlxuICAgIGNhc2UgXCJwYXJhbVwiOlxuICAgIGNhc2UgXCJ0cmFja1wiOlxuICAgIGNhc2UgXCJ3YnJcIjpcbiAgICBjYXNlIFwibWVudWl0ZW1cIjpcbiAgICAgIGZvciAoZGVmYXVsdENoZWNrZWQgaW4gcHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShkZWZhdWx0Q2hlY2tlZCkgJiZcbiAgICAgICAgICAoKGhhc1NyYyA9IHByb3BzW2RlZmF1bHRDaGVja2VkXSksIG51bGwgIT0gaGFzU3JjKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChkZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMzcsIHRhZykpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIGRlZmF1bHRDaGVja2VkLCBoYXNTcmMsIHByb3BzLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChpc0N1c3RvbUVsZW1lbnQodGFnKSkge1xuICAgICAgICBmb3IgKHByb3BWYWx1ZSQxODYgaW4gcHJvcHMpXG4gICAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcFZhbHVlJDE4NikgJiZcbiAgICAgICAgICAgICgoaGFzU3JjID0gcHJvcHNbcHJvcFZhbHVlJDE4Nl0pLFxuICAgICAgICAgICAgdm9pZCAwICE9PSBoYXNTcmMgJiZcbiAgICAgICAgICAgICAgc2V0UHJvcE9uQ3VzdG9tRWxlbWVudChcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWUkMTg2LFxuICAgICAgICAgICAgICAgIGhhc1NyYyxcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuICBmb3IgKGRlZmF1bHRWYWx1ZSBpbiBwcm9wcylcbiAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShkZWZhdWx0VmFsdWUpICYmXG4gICAgICAoKGhhc1NyYyA9IHByb3BzW2RlZmF1bHRWYWx1ZV0pLFxuICAgICAgbnVsbCAhPSBoYXNTcmMgJiZcbiAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIGRlZmF1bHRWYWx1ZSwgaGFzU3JjLCBwcm9wcywgbnVsbCkpO1xufVxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIGxhc3RQcm9wcywgbmV4dFByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBcImRpdlwiOlxuICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgY2FzZSBcInN2Z1wiOlxuICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgY2FzZSBcImFcIjpcbiAgICBjYXNlIFwiZ1wiOlxuICAgIGNhc2UgXCJwXCI6XG4gICAgY2FzZSBcImxpXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgIHZhciBuYW1lID0gbnVsbCxcbiAgICAgICAgdHlwZSA9IG51bGwsXG4gICAgICAgIHZhbHVlID0gbnVsbCxcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gbnVsbCxcbiAgICAgICAgbGFzdERlZmF1bHRWYWx1ZSA9IG51bGwsXG4gICAgICAgIGNoZWNrZWQgPSBudWxsLFxuICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IG51bGw7XG4gICAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICAgIHZhciBsYXN0UHJvcCA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgICAgaWYgKGxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSAmJiBudWxsICE9IGxhc3RQcm9wKVxuICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWUgPSBsYXN0UHJvcDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fFxuICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBwcm9wS2V5LCBudWxsLCBuZXh0UHJvcHMsIGxhc3RQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwcm9wS2V5JDIwMyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIHByb3BLZXkgPSBuZXh0UHJvcHNbcHJvcEtleSQyMDNdO1xuICAgICAgICBsYXN0UHJvcCA9IGxhc3RQcm9wc1twcm9wS2V5JDIwM107XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSQyMDMpICYmXG4gICAgICAgICAgKG51bGwgIT0gcHJvcEtleSB8fCBudWxsICE9IGxhc3RQcm9wKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChwcm9wS2V5JDIwMykge1xuICAgICAgICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgICAgICAgdHlwZSA9IHByb3BLZXk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgbmFtZSA9IHByb3BLZXk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgY2hlY2tlZCA9IHByb3BLZXk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcEtleTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcEtleTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wS2V5KVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTM3LCB0YWcpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBwcm9wS2V5ICE9PSBsYXN0UHJvcCAmJlxuICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgcHJvcEtleSQyMDMsXG4gICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgbGFzdFByb3BcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVwZGF0ZUlucHV0KFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgICBsYXN0RGVmYXVsdFZhbHVlLFxuICAgICAgICBjaGVja2VkLFxuICAgICAgICBkZWZhdWx0Q2hlY2tlZCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICBwcm9wS2V5ID0gdmFsdWUgPSBkZWZhdWx0VmFsdWUgPSBwcm9wS2V5JDIwMyA9IG51bGw7XG4gICAgICBmb3IgKHR5cGUgaW4gbGFzdFByb3BzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChsYXN0RGVmYXVsdFZhbHVlID0gbGFzdFByb3BzW3R5cGVdKSxcbiAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkodHlwZSkgJiYgbnVsbCAhPSBsYXN0RGVmYXVsdFZhbHVlKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgcHJvcEtleSA9IGxhc3REZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkodHlwZSkgfHxcbiAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgbGFzdERlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgZm9yIChuYW1lIGluIG5leHRQcm9wcylcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgodHlwZSA9IG5leHRQcm9wc1tuYW1lXSksXG4gICAgICAgICAgKGxhc3REZWZhdWx0VmFsdWUgPSBsYXN0UHJvcHNbbmFtZV0pLFxuICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICAgICAgKG51bGwgIT0gdHlwZSB8fCBudWxsICE9IGxhc3REZWZhdWx0VmFsdWUpKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgcHJvcEtleSQyMDMgPSB0eXBlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gdHlwZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgdmFsdWUgPSB0eXBlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdHlwZSAhPT0gbGFzdERlZmF1bHRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICBsYXN0RGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICB0YWcgPSBkZWZhdWx0VmFsdWU7XG4gICAgICBsYXN0UHJvcHMgPSB2YWx1ZTtcbiAgICAgIG5leHRQcm9wcyA9IHByb3BLZXk7XG4gICAgICBudWxsICE9IHByb3BLZXkkMjAzXG4gICAgICAgID8gdXBkYXRlT3B0aW9ucyhkb21FbGVtZW50LCAhIWxhc3RQcm9wcywgcHJvcEtleSQyMDMsICExKVxuICAgICAgICA6ICEhbmV4dFByb3BzICE9PSAhIWxhc3RQcm9wcyAmJlxuICAgICAgICAgIChudWxsICE9IHRhZ1xuICAgICAgICAgICAgPyB1cGRhdGVPcHRpb25zKGRvbUVsZW1lbnQsICEhbGFzdFByb3BzLCB0YWcsICEwKVxuICAgICAgICAgICAgOiB1cGRhdGVPcHRpb25zKGRvbUVsZW1lbnQsICEhbGFzdFByb3BzLCBsYXN0UHJvcHMgPyBbXSA6IFwiXCIsICExKSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICBwcm9wS2V5ID0gcHJvcEtleSQyMDMgPSBudWxsO1xuICAgICAgZm9yIChkZWZhdWx0VmFsdWUgaW4gbGFzdFByb3BzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChuYW1lID0gbGFzdFByb3BzW2RlZmF1bHRWYWx1ZV0pLFxuICAgICAgICAgIGxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShkZWZhdWx0VmFsdWUpICYmXG4gICAgICAgICAgICBudWxsICE9IG5hbWUgJiZcbiAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgKVxuICAgICAgICAgIHN3aXRjaCAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgZGVmYXVsdFZhbHVlLCBudWxsLCBuZXh0UHJvcHMsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgIGZvciAodmFsdWUgaW4gbmV4dFByb3BzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChuYW1lID0gbmV4dFByb3BzW3ZhbHVlXSksXG4gICAgICAgICAgKHR5cGUgPSBsYXN0UHJvcHNbdmFsdWVdKSxcbiAgICAgICAgICBuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIChudWxsICE9IG5hbWUgfHwgbnVsbCAhPSB0eXBlKSlcbiAgICAgICAgKVxuICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBwcm9wS2V5JDIwMyA9IG5hbWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICBwcm9wS2V5ID0gbmFtZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gbmFtZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5MSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG5hbWUgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgdmFsdWUsIG5hbWUsIG5leHRQcm9wcywgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgdXBkYXRlVGV4dGFyZWEoZG9tRWxlbWVudCwgcHJvcEtleSQyMDMsIHByb3BLZXkpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgIGZvciAodmFyIHByb3BLZXkkMjE5IGluIGxhc3RQcm9wcylcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgocHJvcEtleSQyMDMgPSBsYXN0UHJvcHNbcHJvcEtleSQyMTldKSxcbiAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSQyMTkpICYmXG4gICAgICAgICAgICBudWxsICE9IHByb3BLZXkkMjAzICYmXG4gICAgICAgICAgICAhbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkkMjE5KSlcbiAgICAgICAgKVxuICAgICAgICAgIHN3aXRjaCAocHJvcEtleSQyMTkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgICBkb21FbGVtZW50LnNlbGVjdGVkID0gITE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICBwcm9wS2V5JDIxOSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICBwcm9wS2V5JDIwM1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIGZvciAobGFzdERlZmF1bHRWYWx1ZSBpbiBuZXh0UHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKHByb3BLZXkkMjAzID0gbmV4dFByb3BzW2xhc3REZWZhdWx0VmFsdWVdKSxcbiAgICAgICAgICAocHJvcEtleSA9IGxhc3RQcm9wc1tsYXN0RGVmYXVsdFZhbHVlXSksXG4gICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KGxhc3REZWZhdWx0VmFsdWUpICYmXG4gICAgICAgICAgICBwcm9wS2V5JDIwMyAhPT0gcHJvcEtleSAmJlxuICAgICAgICAgICAgKG51bGwgIT0gcHJvcEtleSQyMDMgfHwgbnVsbCAhPSBwcm9wS2V5KSlcbiAgICAgICAgKVxuICAgICAgICAgIHN3aXRjaCAobGFzdERlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQuc2VsZWN0ZWQgPVxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjAzICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcHJvcEtleSQyMDMgJiZcbiAgICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgcHJvcEtleSQyMDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICBsYXN0RGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjAzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICBwcm9wS2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgXCJpbWdcIjpcbiAgICBjYXNlIFwibGlua1wiOlxuICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgY2FzZSBcImJhc2VcIjpcbiAgICBjYXNlIFwiYnJcIjpcbiAgICBjYXNlIFwiY29sXCI6XG4gICAgY2FzZSBcImVtYmVkXCI6XG4gICAgY2FzZSBcImhyXCI6XG4gICAgY2FzZSBcImtleWdlblwiOlxuICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgY2FzZSBcInBhcmFtXCI6XG4gICAgY2FzZSBcInNvdXJjZVwiOlxuICAgIGNhc2UgXCJ0cmFja1wiOlxuICAgIGNhc2UgXCJ3YnJcIjpcbiAgICBjYXNlIFwibWVudWl0ZW1cIjpcbiAgICAgIGZvciAodmFyIHByb3BLZXkkMjI0IGluIGxhc3RQcm9wcylcbiAgICAgICAgKHByb3BLZXkkMjAzID0gbGFzdFByb3BzW3Byb3BLZXkkMjI0XSksXG4gICAgICAgICAgbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkkMjI0KSAmJlxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wS2V5JDIwMyAmJlxuICAgICAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5JDIyNCkgJiZcbiAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBwcm9wS2V5JDIyNCwgbnVsbCwgbmV4dFByb3BzLCBwcm9wS2V5JDIwMyk7XG4gICAgICBmb3IgKGNoZWNrZWQgaW4gbmV4dFByb3BzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChwcm9wS2V5JDIwMyA9IG5leHRQcm9wc1tjaGVja2VkXSksXG4gICAgICAgICAgKHByb3BLZXkgPSBsYXN0UHJvcHNbY2hlY2tlZF0pLFxuICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShjaGVja2VkKSAmJlxuICAgICAgICAgICAgcHJvcEtleSQyMDMgIT09IHByb3BLZXkgJiZcbiAgICAgICAgICAgIChudWxsICE9IHByb3BLZXkkMjAzIHx8IG51bGwgIT0gcHJvcEtleSkpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKGNoZWNrZWQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BLZXkkMjAzKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTM3LCB0YWcpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICAgICAgcHJvcEtleSQyMDMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIHByb3BLZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChpc0N1c3RvbUVsZW1lbnQodGFnKSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wS2V5JDIyOSBpbiBsYXN0UHJvcHMpXG4gICAgICAgICAgKHByb3BLZXkkMjAzID0gbGFzdFByb3BzW3Byb3BLZXkkMjI5XSksXG4gICAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSQyMjkpICYmXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gcHJvcEtleSQyMDMgJiZcbiAgICAgICAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5JDIyOSkgJiZcbiAgICAgICAgICAgICAgc2V0UHJvcE9uQ3VzdG9tRWxlbWVudChcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICBwcm9wS2V5JDIyOSxcbiAgICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjAzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIGZvciAoZGVmYXVsdENoZWNrZWQgaW4gbmV4dFByb3BzKVxuICAgICAgICAgIChwcm9wS2V5JDIwMyA9IG5leHRQcm9wc1tkZWZhdWx0Q2hlY2tlZF0pLFxuICAgICAgICAgICAgKHByb3BLZXkgPSBsYXN0UHJvcHNbZGVmYXVsdENoZWNrZWRdKSxcbiAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdENoZWNrZWQpIHx8XG4gICAgICAgICAgICAgIHByb3BLZXkkMjAzID09PSBwcm9wS2V5IHx8XG4gICAgICAgICAgICAgICh2b2lkIDAgPT09IHByb3BLZXkkMjAzICYmIHZvaWQgMCA9PT0gcHJvcEtleSkgfHxcbiAgICAgICAgICAgICAgc2V0UHJvcE9uQ3VzdG9tRWxlbWVudChcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCxcbiAgICAgICAgICAgICAgICBwcm9wS2V5JDIwMyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgcHJvcEtleVxuICAgICAgICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbiAgZm9yICh2YXIgcHJvcEtleSQyMzQgaW4gbGFzdFByb3BzKVxuICAgIChwcm9wS2V5JDIwMyA9IGxhc3RQcm9wc1twcm9wS2V5JDIzNF0pLFxuICAgICAgbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkkMjM0KSAmJlxuICAgICAgICBudWxsICE9IHByb3BLZXkkMjAzICYmXG4gICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSQyMzQpICYmXG4gICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBwcm9wS2V5JDIzNCwgbnVsbCwgbmV4dFByb3BzLCBwcm9wS2V5JDIwMyk7XG4gIGZvciAobGFzdFByb3AgaW4gbmV4dFByb3BzKVxuICAgIChwcm9wS2V5JDIwMyA9IG5leHRQcm9wc1tsYXN0UHJvcF0pLFxuICAgICAgKHByb3BLZXkgPSBsYXN0UHJvcHNbbGFzdFByb3BdKSxcbiAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkobGFzdFByb3ApIHx8XG4gICAgICAgIHByb3BLZXkkMjAzID09PSBwcm9wS2V5IHx8XG4gICAgICAgIChudWxsID09IHByb3BLZXkkMjAzICYmIG51bGwgPT0gcHJvcEtleSkgfHxcbiAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIGxhc3RQcm9wLCBwcm9wS2V5JDIwMywgbmV4dFByb3BzLCBwcm9wS2V5KTtcbn1cbnZhciBldmVudHNFbmFibGVkID0gbnVsbCxcbiAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiA5ID09PSByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZVxuICAgID8gcm9vdENvbnRhaW5lckVsZW1lbnRcbiAgICA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRPd25Ib3N0Q29udGV4dChuYW1lc3BhY2VVUkkpIHtcbiAgc3dpdGNoIChuYW1lc3BhY2VVUkkpIHtcbiAgICBjYXNlIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI6XG4gICAgICByZXR1cm4gMjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkSG9zdENvbnRleHRQcm9kKHBhcmVudE5hbWVzcGFjZSwgdHlwZSkge1xuICBpZiAoMCA9PT0gcGFyZW50TmFtZXNwYWNlKVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICByZXR1cm4gMSA9PT0gcGFyZW50TmFtZXNwYWNlICYmIFwiZm9yZWlnbk9iamVjdFwiID09PSB0eXBlXG4gICAgPyAwXG4gICAgOiBwYXJlbnROYW1lc3BhY2U7XG59XG5mdW5jdGlvbiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gKFxuICAgIFwidGV4dGFyZWFcIiA9PT0gdHlwZSB8fFxuICAgIFwibm9zY3JpcHRcIiA9PT0gdHlwZSB8fFxuICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiB8fFxuICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiB8fFxuICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiB8fFxuICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiZcbiAgICAgIG51bGwgIT09IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmXG4gICAgICBudWxsICE9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbClcbiAgKTtcbn1cbnZhciBjdXJyZW50UG9wc3RhdGVUcmFuc2l0aW9uRXZlbnQgPSBudWxsO1xuZnVuY3Rpb24gc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbigpIHtcbiAgdmFyIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuICBpZiAoZXZlbnQgJiYgXCJwb3BzdGF0ZVwiID09PSBldmVudC50eXBlKSB7XG4gICAgaWYgKGV2ZW50ID09PSBjdXJyZW50UG9wc3RhdGVUcmFuc2l0aW9uRXZlbnQpIHJldHVybiAhMTtcbiAgICBjdXJyZW50UG9wc3RhdGVUcmFuc2l0aW9uRXZlbnQgPSBldmVudDtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgY3VycmVudFBvcHN0YXRlVHJhbnNpdGlvbkV2ZW50ID0gbnVsbDtcbiAgcmV0dXJuICExO1xufVxudmFyIHNjaGVkdWxlVGltZW91dCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHNldFRpbWVvdXQgPyBzZXRUaW1lb3V0IDogdm9pZCAwLFxuICBjYW5jZWxUaW1lb3V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogdm9pZCAwLFxuICBsb2NhbFByb21pc2UgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBQcm9taXNlID8gUHJvbWlzZSA6IHZvaWQgMCxcbiAgc2NoZWR1bGVNaWNyb3Rhc2sgPVxuICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHF1ZXVlTWljcm90YXNrXG4gICAgICA/IHF1ZXVlTWljcm90YXNrXG4gICAgICA6IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBsb2NhbFByb21pc2VcbiAgICAgICAgPyBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFByb21pc2VcbiAgICAgICAgICAgICAgLnJlc29sdmUobnVsbClcbiAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgIC5jYXRjaChoYW5kbGVFcnJvckluTmV4dFRpY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBzY2hlZHVsZVRpbWVvdXQ7XG5mdW5jdGlvbiBoYW5kbGVFcnJvckluTmV4dFRpY2soZXJyb3IpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xufVxuZnVuY3Rpb24gY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KHBhcmVudEluc3RhbmNlLCBzdXNwZW5zZUluc3RhbmNlKSB7XG4gIHZhciBub2RlID0gc3VzcGVuc2VJbnN0YW5jZSxcbiAgICBkZXB0aCA9IDA7XG4gIGRvIHtcbiAgICB2YXIgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIGlmIChuZXh0Tm9kZSAmJiA4ID09PSBuZXh0Tm9kZS5ub2RlVHlwZSlcbiAgICAgIGlmICgoKG5vZGUgPSBuZXh0Tm9kZS5kYXRhKSwgXCIvJFwiID09PSBub2RlKSkge1xuICAgICAgICBpZiAoMCA9PT0gZGVwdGgpIHtcbiAgICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChuZXh0Tm9kZSk7XG4gICAgICAgICAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGgtLTtcbiAgICAgIH0gZWxzZSAoXCIkXCIgIT09IG5vZGUgJiYgXCIkP1wiICE9PSBub2RlICYmIFwiJCFcIiAhPT0gbm9kZSkgfHwgZGVwdGgrKztcbiAgICBub2RlID0gbmV4dE5vZGU7XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY2xlYXJDb250YWluZXJTcGFyaW5nbHkoY29udGFpbmVyKSB7XG4gIHZhciBuZXh0Tm9kZSA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICBuZXh0Tm9kZSAmJiAxMCA9PT0gbmV4dE5vZGUubm9kZVR5cGUgJiYgKG5leHROb2RlID0gbmV4dE5vZGUubmV4dFNpYmxpbmcpO1xuICBmb3IgKDsgbmV4dE5vZGU7ICkge1xuICAgIHZhciBub2RlID0gbmV4dE5vZGU7XG4gICAgbmV4dE5vZGUgPSBuZXh0Tm9kZS5uZXh0U2libGluZztcbiAgICBzd2l0Y2ggKG5vZGUubm9kZU5hbWUpIHtcbiAgICAgIGNhc2UgXCJIVE1MXCI6XG4gICAgICBjYXNlIFwiSEVBRFwiOlxuICAgICAgY2FzZSBcIkJPRFlcIjpcbiAgICAgICAgY2xlYXJDb250YWluZXJTcGFyaW5nbHkobm9kZSk7XG4gICAgICAgIGRldGFjaERlbGV0ZWRJbnN0YW5jZShub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIFwiU0NSSVBUXCI6XG4gICAgICBjYXNlIFwiU1RZTEVcIjpcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIFwiTElOS1wiOlxuICAgICAgICBpZiAoXCJzdHlsZXNoZWV0XCIgPT09IG5vZGUucmVsLnRvTG93ZXJDYXNlKCkpIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIGluUm9vdE9yU2luZ2xldG9uKSB7XG4gIGZvciAoOyAxID09PSBpbnN0YW5jZS5ub2RlVHlwZTsgKSB7XG4gICAgdmFyIGFueVByb3BzID0gcHJvcHM7XG4gICAgaWYgKGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgaWYgKFxuICAgICAgICAhaW5Sb290T3JTaW5nbGV0b24gJiZcbiAgICAgICAgKFwiSU5QVVRcIiAhPT0gaW5zdGFuY2Uubm9kZU5hbWUgfHwgXCJoaWRkZW5cIiAhPT0gaW5zdGFuY2UudHlwZSlcbiAgICAgIClcbiAgICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICghaW5Sb290T3JTaW5nbGV0b24pXG4gICAgICBpZiAoXCJpbnB1dFwiID09PSB0eXBlICYmIFwiaGlkZGVuXCIgPT09IGluc3RhbmNlLnR5cGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBudWxsID09IGFueVByb3BzLm5hbWUgPyBudWxsIDogXCJcIiArIGFueVByb3BzLm5hbWU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcImhpZGRlblwiID09PSBhbnlQcm9wcy50eXBlICYmXG4gICAgICAgICAgaW5zdGFuY2UuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSA9PT0gbmFtZVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfSBlbHNlIHJldHVybiBpbnN0YW5jZTtcbiAgICBlbHNlIGlmICghaW5zdGFuY2VbaW50ZXJuYWxIb2lzdGFibGVNYXJrZXJdKVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgICAgaWYgKCFpbnN0YW5jZS5oYXNBdHRyaWJ1dGUoXCJpdGVtcHJvcFwiKSkgYnJlYWs7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgIG5hbWUgPSBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJyZWxcIik7XG4gICAgICAgICAgaWYgKFwic3R5bGVzaGVldFwiID09PSBuYW1lICYmIGluc3RhbmNlLmhhc0F0dHJpYnV0ZShcImRhdGEtcHJlY2VkZW5jZVwiKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgbmFtZSAhPT0gYW55UHJvcHMucmVsIHx8XG4gICAgICAgICAgICBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpICE9PVxuICAgICAgICAgICAgICAobnVsbCA9PSBhbnlQcm9wcy5ocmVmID8gbnVsbCA6IGFueVByb3BzLmhyZWYpIHx8XG4gICAgICAgICAgICBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiKSAhPT1cbiAgICAgICAgICAgICAgKG51bGwgPT0gYW55UHJvcHMuY3Jvc3NPcmlnaW4gPyBudWxsIDogYW55UHJvcHMuY3Jvc3NPcmlnaW4pIHx8XG4gICAgICAgICAgICBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKSAhPT1cbiAgICAgICAgICAgICAgKG51bGwgPT0gYW55UHJvcHMudGl0bGUgPyBudWxsIDogYW55UHJvcHMudGl0bGUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBpZiAoaW5zdGFuY2UuaGFzQXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpKSBicmVhaztcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICBuYW1lID0gaW5zdGFuY2UuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChuYW1lICE9PSAobnVsbCA9PSBhbnlQcm9wcy5zcmMgPyBudWxsIDogYW55UHJvcHMuc3JjKSB8fFxuICAgICAgICAgICAgICBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpICE9PVxuICAgICAgICAgICAgICAgIChudWxsID09IGFueVByb3BzLnR5cGUgPyBudWxsIDogYW55UHJvcHMudHlwZSkgfHxcbiAgICAgICAgICAgICAgaW5zdGFuY2UuZ2V0QXR0cmlidXRlKFwiY3Jvc3NvcmlnaW5cIikgIT09XG4gICAgICAgICAgICAgICAgKG51bGwgPT0gYW55UHJvcHMuY3Jvc3NPcmlnaW4gPyBudWxsIDogYW55UHJvcHMuY3Jvc3NPcmlnaW4pKSAmJlxuICAgICAgICAgICAgbmFtZSAmJlxuICAgICAgICAgICAgaW5zdGFuY2UuaGFzQXR0cmlidXRlKFwiYXN5bmNcIikgJiZcbiAgICAgICAgICAgICFpbnN0YW5jZS5oYXNBdHRyaWJ1dGUoXCJpdGVtcHJvcFwiKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9XG4gICAgaW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShpbnN0YW5jZS5uZXh0U2libGluZyk7XG4gICAgaWYgKG51bGwgPT09IGluc3RhbmNlKSBicmVhaztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQsIGluUm9vdE9yU2luZ2xldG9uKSB7XG4gIGlmIChcIlwiID09PSB0ZXh0KSByZXR1cm4gbnVsbDtcbiAgZm9yICg7IDMgIT09IGluc3RhbmNlLm5vZGVUeXBlOyApIHtcbiAgICBpZiAoXG4gICAgICAoMSAhPT0gaW5zdGFuY2Uubm9kZVR5cGUgfHxcbiAgICAgICAgXCJJTlBVVFwiICE9PSBpbnN0YW5jZS5ub2RlTmFtZSB8fFxuICAgICAgICBcImhpZGRlblwiICE9PSBpbnN0YW5jZS50eXBlKSAmJlxuICAgICAgIWluUm9vdE9yU2luZ2xldG9uXG4gICAgKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShpbnN0YW5jZS5uZXh0U2libGluZyk7XG4gICAgaWYgKG51bGwgPT09IGluc3RhbmNlKSByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZShub2RlKSB7XG4gIGZvciAoOyBudWxsICE9IG5vZGU7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgdmFyIG5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICBpZiAoMSA9PT0gbm9kZVR5cGUgfHwgMyA9PT0gbm9kZVR5cGUpIGJyZWFrO1xuICAgIGlmICg4ID09PSBub2RlVHlwZSkge1xuICAgICAgbm9kZVR5cGUgPSBub2RlLmRhdGE7XG4gICAgICBpZiAoXG4gICAgICAgIFwiJFwiID09PSBub2RlVHlwZSB8fFxuICAgICAgICBcIiQhXCIgPT09IG5vZGVUeXBlIHx8XG4gICAgICAgIFwiJD9cIiA9PT0gbm9kZVR5cGUgfHxcbiAgICAgICAgXCJGIVwiID09PSBub2RlVHlwZSB8fFxuICAgICAgICBcIkZcIiA9PT0gbm9kZVR5cGVcbiAgICAgIClcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAoXCIvJFwiID09PSBub2RlVHlwZSkgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXRJbnN0YW5jZSkge1xuICB0YXJnZXRJbnN0YW5jZSA9IHRhcmdldEluc3RhbmNlLnByZXZpb3VzU2libGluZztcbiAgZm9yICh2YXIgZGVwdGggPSAwOyB0YXJnZXRJbnN0YW5jZTsgKSB7XG4gICAgaWYgKDggPT09IHRhcmdldEluc3RhbmNlLm5vZGVUeXBlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRhcmdldEluc3RhbmNlLmRhdGE7XG4gICAgICBpZiAoXCIkXCIgPT09IGRhdGEgfHwgXCIkIVwiID09PSBkYXRhIHx8IFwiJD9cIiA9PT0gZGF0YSkge1xuICAgICAgICBpZiAoMCA9PT0gZGVwdGgpIHJldHVybiB0YXJnZXRJbnN0YW5jZTtcbiAgICAgICAgZGVwdGgtLTtcbiAgICAgIH0gZWxzZSBcIi8kXCIgPT09IGRhdGEgJiYgZGVwdGgrKztcbiAgICB9XG4gICAgdGFyZ2V0SW5zdGFuY2UgPSB0YXJnZXRJbnN0YW5jZS5wcmV2aW91c1NpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICBwcm9wcyA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVySW5zdGFuY2UpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgdHlwZSA9IHByb3BzLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIGlmICghdHlwZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NTIpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICB0eXBlID0gcHJvcHMuaGVhZDtcbiAgICAgIGlmICghdHlwZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NTMpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICB0eXBlID0gcHJvcHMuYm9keTtcbiAgICAgIGlmICghdHlwZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NTQpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ1MSkpO1xuICB9XG59XG52YXIgcHJlbG9hZFByb3BzTWFwID0gbmV3IE1hcCgpLFxuICBwcmVjb25uZWN0c1NldCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGdldEhvaXN0YWJsZVJvb3QoY29udGFpbmVyKSB7XG4gIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250YWluZXIuZ2V0Um9vdE5vZGVcbiAgICA/IGNvbnRhaW5lci5nZXRSb290Tm9kZSgpXG4gICAgOiBjb250YWluZXIub3duZXJEb2N1bWVudDtcbn1cbnZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5kO1xuUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZCA9IHtcbiAgZjogZmx1c2hTeW5jV29yayxcbiAgcjogcmVxdWVzdEZvcm1SZXNldCxcbiAgRDogcHJlZmV0Y2hETlMsXG4gIEM6IHByZWNvbm5lY3QsXG4gIEw6IHByZWxvYWQsXG4gIG06IHByZWxvYWRNb2R1bGUsXG4gIFg6IHByZWluaXRTY3JpcHQsXG4gIFM6IHByZWluaXRTdHlsZSxcbiAgTTogcHJlaW5pdE1vZHVsZVNjcmlwdFxufTtcbmZ1bmN0aW9uIGZsdXNoU3luY1dvcmsoKSB7XG4gIHZhciBwcmV2aW91c1dhc1JlbmRlcmluZyA9IHByZXZpb3VzRGlzcGF0Y2hlci5mKCksXG4gICAgd2FzUmVuZGVyaW5nID0gZmx1c2hTeW5jV29yayQxKCk7XG4gIHJldHVybiBwcmV2aW91c1dhc1JlbmRlcmluZyB8fCB3YXNSZW5kZXJpbmc7XG59XG5mdW5jdGlvbiByZXF1ZXN0Rm9ybVJlc2V0KGZvcm0pIHtcbiAgdmFyIGZvcm1JbnN0ID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShmb3JtKTtcbiAgbnVsbCAhPT0gZm9ybUluc3QgJiYgNSA9PT0gZm9ybUluc3QudGFnICYmIFwiZm9ybVwiID09PSBmb3JtSW5zdC50eXBlXG4gICAgPyByZXF1ZXN0Rm9ybVJlc2V0JDEoZm9ybUluc3QpXG4gICAgOiBwcmV2aW91c0Rpc3BhdGNoZXIucihmb3JtKTtcbn1cbnZhciBnbG9iYWxEb2N1bWVudCA9IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBkb2N1bWVudCA/IG51bGwgOiBkb2N1bWVudDtcbmZ1bmN0aW9uIHByZWNvbm5lY3RBcyhyZWwsIGhyZWYsIGNyb3NzT3JpZ2luKSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2xvYmFsRG9jdW1lbnQ7XG4gIGlmIChvd25lckRvY3VtZW50ICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHtcbiAgICB2YXIgbGltaXRlZEVzY2FwZWRIcmVmID1cbiAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoaHJlZik7XG4gICAgbGltaXRlZEVzY2FwZWRIcmVmID1cbiAgICAgICdsaW5rW3JlbD1cIicgKyByZWwgKyAnXCJdW2hyZWY9XCInICsgbGltaXRlZEVzY2FwZWRIcmVmICsgJ1wiXSc7XG4gICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNyb3NzT3JpZ2luICYmXG4gICAgICAobGltaXRlZEVzY2FwZWRIcmVmICs9ICdbY3Jvc3NvcmlnaW49XCInICsgY3Jvc3NPcmlnaW4gKyAnXCJdJyk7XG4gICAgcHJlY29ubmVjdHNTZXQuaGFzKGxpbWl0ZWRFc2NhcGVkSHJlZikgfHxcbiAgICAgIChwcmVjb25uZWN0c1NldC5hZGQobGltaXRlZEVzY2FwZWRIcmVmKSxcbiAgICAgIChyZWwgPSB7IHJlbDogcmVsLCBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sIGhyZWY6IGhyZWYgfSksXG4gICAgICBudWxsID09PSBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobGltaXRlZEVzY2FwZWRIcmVmKSAmJlxuICAgICAgICAoKGhyZWYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpKSxcbiAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoaHJlZiwgXCJsaW5rXCIsIHJlbCksXG4gICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaHJlZiksXG4gICAgICAgIG93bmVyRG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChocmVmKSkpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVmZXRjaEROUyhocmVmKSB7XG4gIHByZXZpb3VzRGlzcGF0Y2hlci5EKGhyZWYpO1xuICBwcmVjb25uZWN0QXMoXCJkbnMtcHJlZmV0Y2hcIiwgaHJlZiwgbnVsbCk7XG59XG5mdW5jdGlvbiBwcmVjb25uZWN0KGhyZWYsIGNyb3NzT3JpZ2luKSB7XG4gIHByZXZpb3VzRGlzcGF0Y2hlci5DKGhyZWYsIGNyb3NzT3JpZ2luKTtcbiAgcHJlY29ubmVjdEFzKFwicHJlY29ubmVjdFwiLCBocmVmLCBjcm9zc09yaWdpbik7XG59XG5mdW5jdGlvbiBwcmVsb2FkKGhyZWYsIGFzLCBvcHRpb25zKSB7XG4gIHByZXZpb3VzRGlzcGF0Y2hlci5MKGhyZWYsIGFzLCBvcHRpb25zKTtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxEb2N1bWVudDtcbiAgaWYgKG93bmVyRG9jdW1lbnQgJiYgaHJlZiAmJiBhcykge1xuICAgIHZhciBwcmVsb2FkU2VsZWN0b3IgPVxuICAgICAgJ2xpbmtbcmVsPVwicHJlbG9hZFwiXVthcz1cIicgK1xuICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhhcykgK1xuICAgICAgJ1wiXSc7XG4gICAgXCJpbWFnZVwiID09PSBhc1xuICAgICAgPyBvcHRpb25zICYmIG9wdGlvbnMuaW1hZ2VTcmNTZXRcbiAgICAgICAgPyAoKHByZWxvYWRTZWxlY3RvciArPVxuICAgICAgICAgICAgJ1tpbWFnZXNyY3NldD1cIicgK1xuICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhcbiAgICAgICAgICAgICAgb3B0aW9ucy5pbWFnZVNyY1NldFxuICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAnXCJdJyksXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW1hZ2VTaXplcyAmJlxuICAgICAgICAgICAgKHByZWxvYWRTZWxlY3RvciArPVxuICAgICAgICAgICAgICAnW2ltYWdlc2l6ZXM9XCInICtcbiAgICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhcbiAgICAgICAgICAgICAgICBvcHRpb25zLmltYWdlU2l6ZXNcbiAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICdcIl0nKSlcbiAgICAgICAgOiAocHJlbG9hZFNlbGVjdG9yICs9XG4gICAgICAgICAgICAnW2hyZWY9XCInICtcbiAgICAgICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoaHJlZikgK1xuICAgICAgICAgICAgJ1wiXScpXG4gICAgICA6IChwcmVsb2FkU2VsZWN0b3IgKz1cbiAgICAgICAgICAnW2hyZWY9XCInICtcbiAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGhyZWYpICtcbiAgICAgICAgICAnXCJdJyk7XG4gICAgdmFyIGtleSA9IHByZWxvYWRTZWxlY3RvcjtcbiAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAga2V5ID0gZ2V0U3R5bGVLZXkoaHJlZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICBrZXkgPSBnZXRTY3JpcHRLZXkoaHJlZik7XG4gICAgfVxuICAgIHByZWxvYWRQcm9wc01hcC5oYXMoa2V5KSB8fFxuICAgICAgKChocmVmID0gYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICBocmVmOlxuICAgICAgICAgICAgXCJpbWFnZVwiID09PSBhcyAmJiBvcHRpb25zICYmIG9wdGlvbnMuaW1hZ2VTcmNTZXQgPyB2b2lkIDAgOiBocmVmLFxuICAgICAgICAgIGFzOiBhc1xuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zXG4gICAgICApKSxcbiAgICAgIHByZWxvYWRQcm9wc01hcC5zZXQoa2V5LCBocmVmKSxcbiAgICAgIG51bGwgIT09IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihwcmVsb2FkU2VsZWN0b3IpIHx8XG4gICAgICAgIChcInN0eWxlXCIgPT09IGFzICYmXG4gICAgICAgICAgb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoa2V5KSkpIHx8XG4gICAgICAgIChcInNjcmlwdFwiID09PSBhcyAmJlxuICAgICAgICAgIG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihnZXRTY3JpcHRTZWxlY3RvckZyb21LZXkoa2V5KSkpIHx8XG4gICAgICAgICgoYXMgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpKSxcbiAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoYXMsIFwibGlua1wiLCBocmVmKSxcbiAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShhcyksXG4gICAgICAgIG93bmVyRG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChhcykpKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJlbG9hZE1vZHVsZShocmVmLCBvcHRpb25zKSB7XG4gIHByZXZpb3VzRGlzcGF0Y2hlci5tKGhyZWYsIG9wdGlvbnMpO1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICBpZiAob3duZXJEb2N1bWVudCAmJiBocmVmKSB7XG4gICAgdmFyIGFzID0gb3B0aW9ucyAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hcyA/IG9wdGlvbnMuYXMgOiBcInNjcmlwdFwiLFxuICAgICAgcHJlbG9hZFNlbGVjdG9yID1cbiAgICAgICAgJ2xpbmtbcmVsPVwibW9kdWxlcHJlbG9hZFwiXVthcz1cIicgK1xuICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGFzKSArXG4gICAgICAgICdcIl1baHJlZj1cIicgK1xuICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGhyZWYpICtcbiAgICAgICAgJ1wiXScsXG4gICAgICBrZXkgPSBwcmVsb2FkU2VsZWN0b3I7XG4gICAgc3dpdGNoIChhcykge1xuICAgICAgY2FzZSBcImF1ZGlvd29ya2xldFwiOlxuICAgICAgY2FzZSBcInBhaW50d29ya2xldFwiOlxuICAgICAgY2FzZSBcInNlcnZpY2V3b3JrZXJcIjpcbiAgICAgIGNhc2UgXCJzaGFyZWR3b3JrZXJcIjpcbiAgICAgIGNhc2UgXCJ3b3JrZXJcIjpcbiAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAga2V5ID0gZ2V0U2NyaXB0S2V5KGhyZWYpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhcHJlbG9hZFByb3BzTWFwLmhhcyhrZXkpICYmXG4gICAgICAoKGhyZWYgPSBhc3NpZ24oeyByZWw6IFwibW9kdWxlcHJlbG9hZFwiLCBocmVmOiBocmVmIH0sIG9wdGlvbnMpKSxcbiAgICAgIHByZWxvYWRQcm9wc01hcC5zZXQoa2V5LCBocmVmKSxcbiAgICAgIG51bGwgPT09IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihwcmVsb2FkU2VsZWN0b3IpKVxuICAgICkge1xuICAgICAgc3dpdGNoIChhcykge1xuICAgICAgICBjYXNlIFwiYXVkaW93b3JrbGV0XCI6XG4gICAgICAgIGNhc2UgXCJwYWludHdvcmtsZXRcIjpcbiAgICAgICAgY2FzZSBcInNlcnZpY2V3b3JrZXJcIjpcbiAgICAgICAgY2FzZSBcInNoYXJlZHdvcmtlclwiOlxuICAgICAgICBjYXNlIFwid29ya2VyXCI6XG4gICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICBpZiAob3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFzID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGFzLCBcImxpbmtcIiwgaHJlZik7XG4gICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGFzKTtcbiAgICAgIG93bmVyRG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChhcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcmVpbml0U3R5bGUoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucykge1xuICBwcmV2aW91c0Rpc3BhdGNoZXIuUyhocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKTtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxEb2N1bWVudDtcbiAgaWYgKG93bmVyRG9jdW1lbnQgJiYgaHJlZikge1xuICAgIHZhciBzdHlsZXMgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChvd25lckRvY3VtZW50KS5ob2lzdGFibGVTdHlsZXMsXG4gICAgICBrZXkgPSBnZXRTdHlsZUtleShocmVmKTtcbiAgICBwcmVjZWRlbmNlID0gcHJlY2VkZW5jZSB8fCBcImRlZmF1bHRcIjtcbiAgICB2YXIgcmVzb3VyY2UgPSBzdHlsZXMuZ2V0KGtleSk7XG4gICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgdmFyIHN0YXRlID0geyBsb2FkaW5nOiAwLCBwcmVsb2FkOiBudWxsIH07XG4gICAgICBpZiAoXG4gICAgICAgIChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KGtleSlcbiAgICAgICAgKSlcbiAgICAgIClcbiAgICAgICAgc3RhdGUubG9hZGluZyA9IDU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaHJlZiA9IGFzc2lnbihcbiAgICAgICAgICB7IHJlbDogXCJzdHlsZXNoZWV0XCIsIGhyZWY6IGhyZWYsIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHByZWNlZGVuY2UgfSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIChvcHRpb25zID0gcHJlbG9hZFByb3BzTWFwLmdldChrZXkpKSAmJlxuICAgICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU3R5bGVzaGVldChocmVmLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGxpbmsgPSAocmVzb3VyY2UgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpKTtcbiAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShsaW5rKTtcbiAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMobGluaywgXCJsaW5rXCIsIGhyZWYpO1xuICAgICAgICBsaW5rLl9wID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGxpbmsub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICBsaW5rLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZS5sb2FkaW5nIHw9IDE7XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUubG9hZGluZyB8PSAyO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUubG9hZGluZyB8PSA0O1xuICAgICAgICBpbnNlcnRTdHlsZXNoZWV0KHJlc291cmNlLCBwcmVjZWRlbmNlLCBvd25lckRvY3VtZW50KTtcbiAgICAgIH1cbiAgICAgIHJlc291cmNlID0ge1xuICAgICAgICB0eXBlOiBcInN0eWxlc2hlZXRcIixcbiAgICAgICAgaW5zdGFuY2U6IHJlc291cmNlLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICB9O1xuICAgICAgc3R5bGVzLnNldChrZXksIHJlc291cmNlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWluaXRTY3JpcHQoc3JjLCBvcHRpb25zKSB7XG4gIHByZXZpb3VzRGlzcGF0Y2hlci5YKHNyYywgb3B0aW9ucyk7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2xvYmFsRG9jdW1lbnQ7XG4gIGlmIChvd25lckRvY3VtZW50ICYmIHNyYykge1xuICAgIHZhciBzY3JpcHRzID0gZ2V0UmVzb3VyY2VzRnJvbVJvb3Qob3duZXJEb2N1bWVudCkuaG9pc3RhYmxlU2NyaXB0cyxcbiAgICAgIGtleSA9IGdldFNjcmlwdEtleShzcmMpLFxuICAgICAgcmVzb3VyY2UgPSBzY3JpcHRzLmdldChrZXkpO1xuICAgIHJlc291cmNlIHx8XG4gICAgICAoKHJlc291cmNlID0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpKSksXG4gICAgICByZXNvdXJjZSB8fFxuICAgICAgICAoKHNyYyA9IGFzc2lnbih7IHNyYzogc3JjLCBhc3luYzogITAgfSwgb3B0aW9ucykpLFxuICAgICAgICAob3B0aW9ucyA9IHByZWxvYWRQcm9wc01hcC5nZXQoa2V5KSkgJiZcbiAgICAgICAgICBhZG9wdFByZWxvYWRQcm9wc0ZvclNjcmlwdChzcmMsIG9wdGlvbnMpLFxuICAgICAgICAocmVzb3VyY2UgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpLFxuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKHJlc291cmNlKSxcbiAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMocmVzb3VyY2UsIFwibGlua1wiLCBzcmMpLFxuICAgICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQocmVzb3VyY2UpKSxcbiAgICAgIChyZXNvdXJjZSA9IHtcbiAgICAgICAgdHlwZTogXCJzY3JpcHRcIixcbiAgICAgICAgaW5zdGFuY2U6IHJlc291cmNlLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgc3RhdGU6IG51bGxcbiAgICAgIH0pLFxuICAgICAgc2NyaXB0cy5zZXQoa2V5LCByZXNvdXJjZSkpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVpbml0TW9kdWxlU2NyaXB0KHNyYywgb3B0aW9ucykge1xuICBwcmV2aW91c0Rpc3BhdGNoZXIuTShzcmMsIG9wdGlvbnMpO1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICBpZiAob3duZXJEb2N1bWVudCAmJiBzcmMpIHtcbiAgICB2YXIgc2NyaXB0cyA9IGdldFJlc291cmNlc0Zyb21Sb290KG93bmVyRG9jdW1lbnQpLmhvaXN0YWJsZVNjcmlwdHMsXG4gICAgICBrZXkgPSBnZXRTY3JpcHRLZXkoc3JjKSxcbiAgICAgIHJlc291cmNlID0gc2NyaXB0cy5nZXQoa2V5KTtcbiAgICByZXNvdXJjZSB8fFxuICAgICAgKChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihnZXRTY3JpcHRTZWxlY3RvckZyb21LZXkoa2V5KSkpLFxuICAgICAgcmVzb3VyY2UgfHxcbiAgICAgICAgKChzcmMgPSBhc3NpZ24oeyBzcmM6IHNyYywgYXN5bmM6ICEwLCB0eXBlOiBcIm1vZHVsZVwiIH0sIG9wdGlvbnMpKSxcbiAgICAgICAgKG9wdGlvbnMgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KGtleSkpICYmXG4gICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTY3JpcHQoc3JjLCBvcHRpb25zKSxcbiAgICAgICAgKHJlc291cmNlID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSxcbiAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShyZXNvdXJjZSksXG4gICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKHJlc291cmNlLCBcImxpbmtcIiwgc3JjKSxcbiAgICAgICAgb3duZXJEb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHJlc291cmNlKSksXG4gICAgICAocmVzb3VyY2UgPSB7XG4gICAgICAgIHR5cGU6IFwic2NyaXB0XCIsXG4gICAgICAgIGluc3RhbmNlOiByZXNvdXJjZSxcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICAgIHN0YXRlOiBudWxsXG4gICAgICB9KSxcbiAgICAgIHNjcmlwdHMuc2V0KGtleSwgcmVzb3VyY2UpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVzb3VyY2UodHlwZSwgY3VycmVudFByb3BzLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnRSZXNvdXJjZSkge1xuICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudClcbiAgICA/IGdldEhvaXN0YWJsZVJvb3QoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KVxuICAgIDogbnVsbDtcbiAgaWYgKCFKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDQ2KSk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgIHJldHVybiBcInN0cmluZ1wiID09PSB0eXBlb2YgcGVuZGluZ1Byb3BzLnByZWNlZGVuY2UgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHBlbmRpbmdQcm9wcy5ocmVmXG4gICAgICAgID8gKChjdXJyZW50UHJvcHMgPSBnZXRTdHlsZUtleShwZW5kaW5nUHJvcHMuaHJlZikpLFxuICAgICAgICAgIChwZW5kaW5nUHJvcHMgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICkuaG9pc3RhYmxlU3R5bGVzKSxcbiAgICAgICAgICAoY3VycmVudFJlc291cmNlID0gcGVuZGluZ1Byb3BzLmdldChjdXJyZW50UHJvcHMpKSxcbiAgICAgICAgICBjdXJyZW50UmVzb3VyY2UgfHxcbiAgICAgICAgICAgICgoY3VycmVudFJlc291cmNlID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInN0eWxlXCIsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgc3RhdGU6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcGVuZGluZ1Byb3BzLnNldChjdXJyZW50UHJvcHMsIGN1cnJlbnRSZXNvdXJjZSkpLFxuICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgOiB7IHR5cGU6IFwidm9pZFwiLCBpbnN0YW5jZTogbnVsbCwgY291bnQ6IDAsIHN0YXRlOiBudWxsIH07XG4gICAgY2FzZSBcImxpbmtcIjpcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHlsZXNoZWV0XCIgPT09IHBlbmRpbmdQcm9wcy5yZWwgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHBlbmRpbmdQcm9wcy5ocmVmICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMucHJlY2VkZW5jZVxuICAgICAgKSB7XG4gICAgICAgIHR5cGUgPSBnZXRTdHlsZUtleShwZW5kaW5nUHJvcHMuaHJlZik7XG4gICAgICAgIHZhciBzdHlsZXMkMjQyID0gZ2V0UmVzb3VyY2VzRnJvbVJvb3QoXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICApLmhvaXN0YWJsZVN0eWxlcyxcbiAgICAgICAgICByZXNvdXJjZSQyNDMgPSBzdHlsZXMkMjQyLmdldCh0eXBlKTtcbiAgICAgICAgcmVzb3VyY2UkMjQzIHx8XG4gICAgICAgICAgKChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0Lm93bmVyRG9jdW1lbnQgfHwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSxcbiAgICAgICAgICAocmVzb3VyY2UkMjQzID0ge1xuICAgICAgICAgICAgdHlwZTogXCJzdHlsZXNoZWV0XCIsXG4gICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgc3RhdGU6IHsgbG9hZGluZzogMCwgcHJlbG9hZDogbnVsbCB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc3R5bGVzJDI0Mi5zZXQodHlwZSwgcmVzb3VyY2UkMjQzKSxcbiAgICAgICAgICAoc3R5bGVzJDI0MiA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgZ2V0U3R5bGVzaGVldFNlbGVjdG9yRnJvbUtleSh0eXBlKVxuICAgICAgICAgICkpICYmXG4gICAgICAgICAgICAhc3R5bGVzJDI0Mi5fcCAmJlxuICAgICAgICAgICAgKChyZXNvdXJjZSQyNDMuaW5zdGFuY2UgPSBzdHlsZXMkMjQyKSxcbiAgICAgICAgICAgIChyZXNvdXJjZSQyNDMuc3RhdGUubG9hZGluZyA9IDUpKSxcbiAgICAgICAgICBwcmVsb2FkUHJvcHNNYXAuaGFzKHR5cGUpIHx8XG4gICAgICAgICAgICAoKHBlbmRpbmdQcm9wcyA9IHtcbiAgICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgICAgYXM6IFwic3R5bGVcIixcbiAgICAgICAgICAgICAgaHJlZjogcGVuZGluZ1Byb3BzLmhyZWYsXG4gICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBwZW5kaW5nUHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgIGludGVncml0eTogcGVuZGluZ1Byb3BzLmludGVncml0eSxcbiAgICAgICAgICAgICAgbWVkaWE6IHBlbmRpbmdQcm9wcy5tZWRpYSxcbiAgICAgICAgICAgICAgaHJlZkxhbmc6IHBlbmRpbmdQcm9wcy5ocmVmTGFuZyxcbiAgICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHBlbmRpbmdQcm9wcy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcmVsb2FkUHJvcHNNYXAuc2V0KHR5cGUsIHBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICBzdHlsZXMkMjQyIHx8XG4gICAgICAgICAgICAgIHByZWxvYWRTdHlsZXNoZWV0KFxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIHBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICByZXNvdXJjZSQyNDMuc3RhdGVcbiAgICAgICAgICAgICAgKSkpO1xuICAgICAgICBpZiAoY3VycmVudFByb3BzICYmIG51bGwgPT09IGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUyOCwgXCJcIikpO1xuICAgICAgICByZXR1cm4gcmVzb3VyY2UkMjQzO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQcm9wcyAmJiBudWxsICE9PSBjdXJyZW50UmVzb3VyY2UpXG4gICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNTI5LCBcIlwiKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY3VycmVudFByb3BzID0gcGVuZGluZ1Byb3BzLmFzeW5jKSxcbiAgICAgICAgKHBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcy5zcmMpLFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcGVuZGluZ1Byb3BzICYmXG4gICAgICAgIGN1cnJlbnRQcm9wcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjdXJyZW50UHJvcHMgJiZcbiAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGN1cnJlbnRQcm9wc1xuICAgICAgICAgID8gKChjdXJyZW50UHJvcHMgPSBnZXRTY3JpcHRLZXkocGVuZGluZ1Byb3BzKSksXG4gICAgICAgICAgICAocGVuZGluZ1Byb3BzID0gZ2V0UmVzb3VyY2VzRnJvbVJvb3QoXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICAgKS5ob2lzdGFibGVTY3JpcHRzKSxcbiAgICAgICAgICAgIChjdXJyZW50UmVzb3VyY2UgPSBwZW5kaW5nUHJvcHMuZ2V0KGN1cnJlbnRQcm9wcykpLFxuICAgICAgICAgICAgY3VycmVudFJlc291cmNlIHx8XG4gICAgICAgICAgICAgICgoY3VycmVudFJlc291cmNlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG51bGxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHBlbmRpbmdQcm9wcy5zZXQoY3VycmVudFByb3BzLCBjdXJyZW50UmVzb3VyY2UpKSxcbiAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgICA6IHsgdHlwZTogXCJ2b2lkXCIsIGluc3RhbmNlOiBudWxsLCBjb3VudDogMCwgc3RhdGU6IG51bGwgfVxuICAgICAgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NDQsIHR5cGUpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3R5bGVLZXkoaHJlZikge1xuICByZXR1cm4gJ2hyZWY9XCInICsgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhocmVmKSArICdcIic7XG59XG5mdW5jdGlvbiBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KGtleSkge1xuICByZXR1cm4gJ2xpbmtbcmVsPVwic3R5bGVzaGVldFwiXVsnICsga2V5ICsgXCJdXCI7XG59XG5mdW5jdGlvbiBzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMocmF3UHJvcHMpIHtcbiAgcmV0dXJuIGFzc2lnbih7fSwgcmF3UHJvcHMsIHtcbiAgICBcImRhdGEtcHJlY2VkZW5jZVwiOiByYXdQcm9wcy5wcmVjZWRlbmNlLFxuICAgIHByZWNlZGVuY2U6IG51bGxcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVsb2FkU3R5bGVzaGVldChvd25lckRvY3VtZW50LCBrZXksIHByZWxvYWRQcm9wcywgc3RhdGUpIHtcbiAgb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsaW5rW3JlbD1cInByZWxvYWRcIl1bYXM9XCJzdHlsZVwiXVsnICsga2V5ICsgXCJdXCIpXG4gICAgPyAoc3RhdGUubG9hZGluZyA9IDEpXG4gICAgOiAoKGtleSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIikpLFxuICAgICAgKHN0YXRlLnByZWxvYWQgPSBrZXkpLFxuICAgICAga2V5LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0ZS5sb2FkaW5nIHw9IDEpO1xuICAgICAgfSksXG4gICAgICBrZXkuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0ZS5sb2FkaW5nIHw9IDIpO1xuICAgICAgfSksXG4gICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhrZXksIFwibGlua1wiLCBwcmVsb2FkUHJvcHMpLFxuICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShrZXkpLFxuICAgICAgb3duZXJEb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGtleSkpO1xufVxuZnVuY3Rpb24gZ2V0U2NyaXB0S2V5KHNyYykge1xuICByZXR1cm4gJ1tzcmM9XCInICsgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhzcmMpICsgJ1wiXSc7XG59XG5mdW5jdGlvbiBnZXRTY3JpcHRTZWxlY3RvckZyb21LZXkoa2V5KSB7XG4gIHJldHVybiBcInNjcmlwdFthc3luY11cIiArIGtleTtcbn1cbmZ1bmN0aW9uIGFjcXVpcmVSZXNvdXJjZShob2lzdGFibGVSb290LCByZXNvdXJjZSwgcHJvcHMpIHtcbiAgcmVzb3VyY2UuY291bnQrKztcbiAgaWYgKG51bGwgPT09IHJlc291cmNlLmluc3RhbmNlKVxuICAgIHN3aXRjaCAocmVzb3VyY2UudHlwZSkge1xuICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGhvaXN0YWJsZVJvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAnc3R5bGVbZGF0YS1ocmVmfj1cIicgK1xuICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3Rlcyhwcm9wcy5ocmVmKSArXG4gICAgICAgICAgICAnXCJdJ1xuICAgICAgICApO1xuICAgICAgICBpZiAoaW5zdGFuY2UpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZXNvdXJjZS5pbnN0YW5jZSA9IGluc3RhbmNlKSxcbiAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaW5zdGFuY2UpLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgICAgICB2YXIgc3R5bGVQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICBcImRhdGEtaHJlZlwiOiBwcm9wcy5ocmVmLFxuICAgICAgICAgIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHByb3BzLnByZWNlZGVuY2UsXG4gICAgICAgICAgaHJlZjogbnVsbCxcbiAgICAgICAgICBwcmVjZWRlbmNlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpbnN0YW5jZSA9IChob2lzdGFibGVSb290Lm93bmVyRG9jdW1lbnQgfHwgaG9pc3RhYmxlUm9vdCkuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBcInN0eWxlXCJcbiAgICAgICAgKTtcbiAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShpbnN0YW5jZSk7XG4gICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGluc3RhbmNlLCBcInN0eWxlXCIsIHN0eWxlUHJvcHMpO1xuICAgICAgICBpbnNlcnRTdHlsZXNoZWV0KGluc3RhbmNlLCBwcm9wcy5wcmVjZWRlbmNlLCBob2lzdGFibGVSb290KTtcbiAgICAgICAgcmV0dXJuIChyZXNvdXJjZS5pbnN0YW5jZSA9IGluc3RhbmNlKTtcbiAgICAgIGNhc2UgXCJzdHlsZXNoZWV0XCI6XG4gICAgICAgIHN0eWxlUHJvcHMgPSBnZXRTdHlsZUtleShwcm9wcy5ocmVmKTtcbiAgICAgICAgdmFyIGluc3RhbmNlJDI0OCA9IGhvaXN0YWJsZVJvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KHN0eWxlUHJvcHMpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpbnN0YW5jZSQyNDgpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nIHw9IDQpLFxuICAgICAgICAgICAgKHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2UkMjQ4KSxcbiAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaW5zdGFuY2UkMjQ4KSxcbiAgICAgICAgICAgIGluc3RhbmNlJDI0OFxuICAgICAgICAgICk7XG4gICAgICAgIGluc3RhbmNlID0gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHByb3BzKTtcbiAgICAgICAgKHN0eWxlUHJvcHMgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KHN0eWxlUHJvcHMpKSAmJlxuICAgICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU3R5bGVzaGVldChpbnN0YW5jZSwgc3R5bGVQcm9wcyk7XG4gICAgICAgIGluc3RhbmNlJDI0OCA9IChcbiAgICAgICAgICBob2lzdGFibGVSb290Lm93bmVyRG9jdW1lbnQgfHwgaG9pc3RhYmxlUm9vdFxuICAgICAgICApLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlJDI0OCk7XG4gICAgICAgIHZhciBsaW5rSW5zdGFuY2UgPSBpbnN0YW5jZSQyNDg7XG4gICAgICAgIGxpbmtJbnN0YW5jZS5fcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBsaW5rSW5zdGFuY2Uub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICBsaW5rSW5zdGFuY2Uub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGluc3RhbmNlJDI0OCwgXCJsaW5rXCIsIGluc3RhbmNlKTtcbiAgICAgICAgcmVzb3VyY2Uuc3RhdGUubG9hZGluZyB8PSA0O1xuICAgICAgICBpbnNlcnRTdHlsZXNoZWV0KGluc3RhbmNlJDI0OCwgcHJvcHMucHJlY2VkZW5jZSwgaG9pc3RhYmxlUm9vdCk7XG4gICAgICAgIHJldHVybiAocmVzb3VyY2UuaW5zdGFuY2UgPSBpbnN0YW5jZSQyNDgpO1xuICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICBpbnN0YW5jZSQyNDggPSBnZXRTY3JpcHRLZXkocHJvcHMuc3JjKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChzdHlsZVByb3BzID0gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgZ2V0U2NyaXB0U2VsZWN0b3JGcm9tS2V5KGluc3RhbmNlJDI0OClcbiAgICAgICAgICApKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZXNvdXJjZS5pbnN0YW5jZSA9IHN0eWxlUHJvcHMpLFxuICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShzdHlsZVByb3BzKSxcbiAgICAgICAgICAgIHN0eWxlUHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICBpbnN0YW5jZSA9IHByb3BzO1xuICAgICAgICBpZiAoKHN0eWxlUHJvcHMgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KGluc3RhbmNlJDI0OCkpKVxuICAgICAgICAgIChpbnN0YW5jZSA9IGFzc2lnbih7fSwgcHJvcHMpKSxcbiAgICAgICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU2NyaXB0KGluc3RhbmNlLCBzdHlsZVByb3BzKTtcbiAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290O1xuICAgICAgICBzdHlsZVByb3BzID0gaG9pc3RhYmxlUm9vdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKHN0eWxlUHJvcHMpO1xuICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhzdHlsZVByb3BzLCBcImxpbmtcIiwgaW5zdGFuY2UpO1xuICAgICAgICBob2lzdGFibGVSb290LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVQcm9wcyk7XG4gICAgICAgIHJldHVybiAocmVzb3VyY2UuaW5zdGFuY2UgPSBzdHlsZVByb3BzKTtcbiAgICAgIGNhc2UgXCJ2b2lkXCI6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NDMsIHJlc291cmNlLnR5cGUpKTtcbiAgICB9XG4gIGVsc2VcbiAgICBcInN0eWxlc2hlZXRcIiA9PT0gcmVzb3VyY2UudHlwZSAmJlxuICAgICAgMCA9PT0gKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgJiA0KSAmJlxuICAgICAgKChpbnN0YW5jZSA9IHJlc291cmNlLmluc3RhbmNlKSxcbiAgICAgIChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nIHw9IDQpLFxuICAgICAgaW5zZXJ0U3R5bGVzaGVldChpbnN0YW5jZSwgcHJvcHMucHJlY2VkZW5jZSwgaG9pc3RhYmxlUm9vdCkpO1xuICByZXR1cm4gcmVzb3VyY2UuaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBpbnNlcnRTdHlsZXNoZWV0KGluc3RhbmNlLCBwcmVjZWRlbmNlLCByb290KSB7XG4gIGZvciAoXG4gICAgdmFyIG5vZGVzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAnbGlua1tyZWw9XCJzdHlsZXNoZWV0XCJdW2RhdGEtcHJlY2VkZW5jZV0sc3R5bGVbZGF0YS1wcmVjZWRlbmNlXSdcbiAgICAgICksXG4gICAgICBsYXN0ID0gbm9kZXMubGVuZ3RoID8gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsLFxuICAgICAgcHJpb3IgPSBsYXN0LFxuICAgICAgaSA9IDA7XG4gICAgaSA8IG5vZGVzLmxlbmd0aDtcbiAgICBpKytcbiAgKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAobm9kZS5kYXRhc2V0LnByZWNlZGVuY2UgPT09IHByZWNlZGVuY2UpIHByaW9yID0gbm9kZTtcbiAgICBlbHNlIGlmIChwcmlvciAhPT0gbGFzdCkgYnJlYWs7XG4gIH1cbiAgcHJpb3JcbiAgICA/IHByaW9yLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGluc3RhbmNlLCBwcmlvci5uZXh0U2libGluZylcbiAgICA6ICgocHJlY2VkZW5jZSA9IDkgPT09IHJvb3Qubm9kZVR5cGUgPyByb290LmhlYWQgOiByb290KSxcbiAgICAgIHByZWNlZGVuY2UuaW5zZXJ0QmVmb3JlKGluc3RhbmNlLCBwcmVjZWRlbmNlLmZpcnN0Q2hpbGQpKTtcbn1cbmZ1bmN0aW9uIGFkb3B0UHJlbG9hZFByb3BzRm9yU3R5bGVzaGVldChzdHlsZXNoZWV0UHJvcHMsIHByZWxvYWRQcm9wcykge1xuICBudWxsID09IHN0eWxlc2hlZXRQcm9wcy5jcm9zc09yaWdpbiAmJlxuICAgIChzdHlsZXNoZWV0UHJvcHMuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkUHJvcHMuY3Jvc3NPcmlnaW4pO1xuICBudWxsID09IHN0eWxlc2hlZXRQcm9wcy5yZWZlcnJlclBvbGljeSAmJlxuICAgIChzdHlsZXNoZWV0UHJvcHMucmVmZXJyZXJQb2xpY3kgPSBwcmVsb2FkUHJvcHMucmVmZXJyZXJQb2xpY3kpO1xuICBudWxsID09IHN0eWxlc2hlZXRQcm9wcy50aXRsZSAmJiAoc3R5bGVzaGVldFByb3BzLnRpdGxlID0gcHJlbG9hZFByb3BzLnRpdGxlKTtcbn1cbmZ1bmN0aW9uIGFkb3B0UHJlbG9hZFByb3BzRm9yU2NyaXB0KHNjcmlwdFByb3BzLCBwcmVsb2FkUHJvcHMpIHtcbiAgbnVsbCA9PSBzY3JpcHRQcm9wcy5jcm9zc09yaWdpbiAmJlxuICAgIChzY3JpcHRQcm9wcy5jcm9zc09yaWdpbiA9IHByZWxvYWRQcm9wcy5jcm9zc09yaWdpbik7XG4gIG51bGwgPT0gc2NyaXB0UHJvcHMucmVmZXJyZXJQb2xpY3kgJiZcbiAgICAoc2NyaXB0UHJvcHMucmVmZXJyZXJQb2xpY3kgPSBwcmVsb2FkUHJvcHMucmVmZXJyZXJQb2xpY3kpO1xuICBudWxsID09IHNjcmlwdFByb3BzLmludGVncml0eSAmJlxuICAgIChzY3JpcHRQcm9wcy5pbnRlZ3JpdHkgPSBwcmVsb2FkUHJvcHMuaW50ZWdyaXR5KTtcbn1cbnZhciB0YWdDYWNoZXMgPSBudWxsO1xuZnVuY3Rpb24gZ2V0SHlkcmF0YWJsZUhvaXN0YWJsZUNhY2hlKHR5cGUsIGtleUF0dHJpYnV0ZSwgb3duZXJEb2N1bWVudCkge1xuICBpZiAobnVsbCA9PT0gdGFnQ2FjaGVzKSB7XG4gICAgdmFyIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHZhciBjYWNoZXMgPSAodGFnQ2FjaGVzID0gbmV3IE1hcCgpKTtcbiAgICBjYWNoZXMuc2V0KG93bmVyRG9jdW1lbnQsIGNhY2hlKTtcbiAgfSBlbHNlXG4gICAgKGNhY2hlcyA9IHRhZ0NhY2hlcyksXG4gICAgICAoY2FjaGUgPSBjYWNoZXMuZ2V0KG93bmVyRG9jdW1lbnQpKSxcbiAgICAgIGNhY2hlIHx8ICgoY2FjaGUgPSBuZXcgTWFwKCkpLCBjYWNoZXMuc2V0KG93bmVyRG9jdW1lbnQsIGNhY2hlKSk7XG4gIGlmIChjYWNoZS5oYXModHlwZSkpIHJldHVybiBjYWNoZTtcbiAgY2FjaGUuc2V0KHR5cGUsIG51bGwpO1xuICBvd25lckRvY3VtZW50ID0gb3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0eXBlKTtcbiAgZm9yIChjYWNoZXMgPSAwOyBjYWNoZXMgPCBvd25lckRvY3VtZW50Lmxlbmd0aDsgY2FjaGVzKyspIHtcbiAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnRbY2FjaGVzXTtcbiAgICBpZiAoXG4gICAgICAhKFxuICAgICAgICBub2RlW2ludGVybmFsSG9pc3RhYmxlTWFya2VyXSB8fFxuICAgICAgICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldIHx8XG4gICAgICAgIChcImxpbmtcIiA9PT0gdHlwZSAmJiBcInN0eWxlc2hlZXRcIiA9PT0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJyZWxcIikpXG4gICAgICApICYmXG4gICAgICBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgIT09IG5vZGUubmFtZXNwYWNlVVJJXG4gICAgKSB7XG4gICAgICB2YXIgbm9kZUtleSA9IG5vZGUuZ2V0QXR0cmlidXRlKGtleUF0dHJpYnV0ZSkgfHwgXCJcIjtcbiAgICAgIG5vZGVLZXkgPSB0eXBlICsgbm9kZUtleTtcbiAgICAgIHZhciBleGlzdGluZyA9IGNhY2hlLmdldChub2RlS2V5KTtcbiAgICAgIGV4aXN0aW5nID8gZXhpc3RpbmcucHVzaChub2RlKSA6IGNhY2hlLnNldChub2RlS2V5LCBbbm9kZV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FjaGU7XG59XG5mdW5jdGlvbiBtb3VudEhvaXN0YWJsZShob2lzdGFibGVSb290LCB0eXBlLCBpbnN0YW5jZSkge1xuICBob2lzdGFibGVSb290ID0gaG9pc3RhYmxlUm9vdC5vd25lckRvY3VtZW50IHx8IGhvaXN0YWJsZVJvb3Q7XG4gIGhvaXN0YWJsZVJvb3QuaGVhZC5pbnNlcnRCZWZvcmUoXG4gICAgaW5zdGFuY2UsXG4gICAgXCJ0aXRsZVwiID09PSB0eXBlID8gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFwiaGVhZCA+IHRpdGxlXCIpIDogbnVsbFxuICApO1xufVxuZnVuY3Rpb24gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwcm9wcywgaG9zdENvbnRleHQpIHtcbiAgaWYgKDEgPT09IGhvc3RDb250ZXh0IHx8IG51bGwgIT0gcHJvcHMuaXRlbVByb3ApIHJldHVybiAhMTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIm1ldGFcIjpcbiAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgIHJldHVybiAhMDtcbiAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgfHxcbiAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLmhyZWYgfHxcbiAgICAgICAgXCJcIiA9PT0gcHJvcHMuaHJlZlxuICAgICAgKVxuICAgICAgICBicmVhaztcbiAgICAgIHJldHVybiAhMDtcbiAgICBjYXNlIFwibGlua1wiOlxuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMucmVsIHx8XG4gICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcm9wcy5ocmVmIHx8XG4gICAgICAgIFwiXCIgPT09IHByb3BzLmhyZWYgfHxcbiAgICAgICAgcHJvcHMub25Mb2FkIHx8XG4gICAgICAgIHByb3BzLm9uRXJyb3JcbiAgICAgIClcbiAgICAgICAgYnJlYWs7XG4gICAgICBzd2l0Y2ggKHByb3BzLnJlbCkge1xuICAgICAgICBjYXNlIFwic3R5bGVzaGVldFwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodHlwZSA9IHByb3BzLmRpc2FibGVkKSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5wcmVjZWRlbmNlICYmIG51bGwgPT0gdHlwZVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgIGlmIChcbiAgICAgICAgcHJvcHMuYXN5bmMgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcHJvcHMuYXN5bmMgJiZcbiAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHByb3BzLmFzeW5jICYmXG4gICAgICAgICFwcm9wcy5vbkxvYWQgJiZcbiAgICAgICAgIXByb3BzLm9uRXJyb3IgJiZcbiAgICAgICAgcHJvcHMuc3JjICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5zcmNcbiAgICAgIClcbiAgICAgICAgcmV0dXJuICEwO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIHByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSkge1xuICByZXR1cm4gXCJzdHlsZXNoZWV0XCIgPT09IHJlc291cmNlLnR5cGUgJiYgMCA9PT0gKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgJiAzKVxuICAgID8gITFcbiAgICA6ICEwO1xufVxudmFyIHN1c3BlbmRlZFN0YXRlID0gbnVsbDtcbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gc3VzcGVuZFJlc291cmNlKGhvaXN0YWJsZVJvb3QsIHJlc291cmNlLCBwcm9wcykge1xuICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkU3RhdGUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDc1KSk7XG4gIHZhciBzdGF0ZSA9IHN1c3BlbmRlZFN0YXRlO1xuICBpZiAoXG4gICAgXCJzdHlsZXNoZWV0XCIgPT09IHJlc291cmNlLnR5cGUgJiZcbiAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLm1lZGlhIHx8XG4gICAgICAhMSAhPT0gbWF0Y2hNZWRpYShwcm9wcy5tZWRpYSkubWF0Y2hlcykgJiZcbiAgICAwID09PSAocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIDQpXG4gICkge1xuICAgIGlmIChudWxsID09PSByZXNvdXJjZS5pbnN0YW5jZSkge1xuICAgICAgdmFyIGtleSA9IGdldFN0eWxlS2V5KHByb3BzLmhyZWYpLFxuICAgICAgICBpbnN0YW5jZSA9IGhvaXN0YWJsZVJvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KGtleSlcbiAgICAgICAgKTtcbiAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBob2lzdGFibGVSb290ID0gaW5zdGFuY2UuX3A7XG4gICAgICAgIG51bGwgIT09IGhvaXN0YWJsZVJvb3QgJiZcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGhvaXN0YWJsZVJvb3QudGhlbiAmJlxuICAgICAgICAgIChzdGF0ZS5jb3VudCsrLFxuICAgICAgICAgIChzdGF0ZSA9IG9uVW5zdXNwZW5kLmJpbmQoc3RhdGUpKSxcbiAgICAgICAgICBob2lzdGFibGVSb290LnRoZW4oc3RhdGUsIHN0YXRlKSk7XG4gICAgICAgIHJlc291cmNlLnN0YXRlLmxvYWRpbmcgfD0gNDtcbiAgICAgICAgcmVzb3VyY2UuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShpbnN0YW5jZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlID0gaG9pc3RhYmxlUm9vdC5vd25lckRvY3VtZW50IHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICBwcm9wcyA9IHN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyhwcm9wcyk7XG4gICAgICAoa2V5ID0gcHJlbG9hZFByb3BzTWFwLmdldChrZXkpKSAmJlxuICAgICAgICBhZG9wdFByZWxvYWRQcm9wc0ZvclN0eWxlc2hlZXQocHJvcHMsIGtleSk7XG4gICAgICBpbnN0YW5jZSA9IGluc3RhbmNlLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShpbnN0YW5jZSk7XG4gICAgICB2YXIgbGlua0luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICBsaW5rSW5zdGFuY2UuX3AgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxpbmtJbnN0YW5jZS5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICBsaW5rSW5zdGFuY2Uub25lcnJvciA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoaW5zdGFuY2UsIFwibGlua1wiLCBwcm9wcyk7XG4gICAgICByZXNvdXJjZS5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIH1cbiAgICBudWxsID09PSBzdGF0ZS5zdHlsZXNoZWV0cyAmJiAoc3RhdGUuc3R5bGVzaGVldHMgPSBuZXcgTWFwKCkpO1xuICAgIHN0YXRlLnN0eWxlc2hlZXRzLnNldChyZXNvdXJjZSwgaG9pc3RhYmxlUm9vdCk7XG4gICAgKGhvaXN0YWJsZVJvb3QgPSByZXNvdXJjZS5zdGF0ZS5wcmVsb2FkKSAmJlxuICAgICAgMCA9PT0gKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgJiAzKSAmJlxuICAgICAgKHN0YXRlLmNvdW50KyssXG4gICAgICAocmVzb3VyY2UgPSBvblVuc3VzcGVuZC5iaW5kKHN0YXRlKSksXG4gICAgICBob2lzdGFibGVSb290LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlc291cmNlKSxcbiAgICAgIGhvaXN0YWJsZVJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlc291cmNlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhaXRGb3JDb21taXRUb0JlUmVhZHkoKSB7XG4gIGlmIChudWxsID09PSBzdXNwZW5kZWRTdGF0ZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NzUpKTtcbiAgdmFyIHN0YXRlID0gc3VzcGVuZGVkU3RhdGU7XG4gIHN0YXRlLnN0eWxlc2hlZXRzICYmXG4gICAgMCA9PT0gc3RhdGUuY291bnQgJiZcbiAgICBpbnNlcnRTdXNwZW5kZWRTdHlsZXNoZWV0cyhzdGF0ZSwgc3RhdGUuc3R5bGVzaGVldHMpO1xuICByZXR1cm4gMCA8IHN0YXRlLmNvdW50XG4gICAgPyBmdW5jdGlvbiAoY29tbWl0KSB7XG4gICAgICAgIHZhciBzdHlsZXNoZWV0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZS5zdHlsZXNoZWV0cyAmJlxuICAgICAgICAgICAgaW5zZXJ0U3VzcGVuZGVkU3R5bGVzaGVldHMoc3RhdGUsIHN0YXRlLnN0eWxlc2hlZXRzKTtcbiAgICAgICAgICBpZiAoc3RhdGUudW5zdXNwZW5kKSB7XG4gICAgICAgICAgICB2YXIgdW5zdXNwZW5kID0gc3RhdGUudW5zdXNwZW5kO1xuICAgICAgICAgICAgc3RhdGUudW5zdXNwZW5kID0gbnVsbDtcbiAgICAgICAgICAgIHVuc3VzcGVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNmU0KTtcbiAgICAgICAgc3RhdGUudW5zdXNwZW5kID0gY29tbWl0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlLnVuc3VzcGVuZCA9IG51bGw7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHN0eWxlc2hlZXRUaW1lcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgOiBudWxsO1xufVxuZnVuY3Rpb24gb25VbnN1c3BlbmQoKSB7XG4gIHRoaXMuY291bnQtLTtcbiAgaWYgKDAgPT09IHRoaXMuY291bnQpXG4gICAgaWYgKHRoaXMuc3R5bGVzaGVldHMpIGluc2VydFN1c3BlbmRlZFN0eWxlc2hlZXRzKHRoaXMsIHRoaXMuc3R5bGVzaGVldHMpO1xuICAgIGVsc2UgaWYgKHRoaXMudW5zdXNwZW5kKSB7XG4gICAgICB2YXIgdW5zdXNwZW5kID0gdGhpcy51bnN1c3BlbmQ7XG4gICAgICB0aGlzLnVuc3VzcGVuZCA9IG51bGw7XG4gICAgICB1bnN1c3BlbmQoKTtcbiAgICB9XG59XG52YXIgcHJlY2VkZW5jZXNCeVJvb3QgPSBudWxsO1xuZnVuY3Rpb24gaW5zZXJ0U3VzcGVuZGVkU3R5bGVzaGVldHMoc3RhdGUsIHJlc291cmNlcykge1xuICBzdGF0ZS5zdHlsZXNoZWV0cyA9IG51bGw7XG4gIG51bGwgIT09IHN0YXRlLnVuc3VzcGVuZCAmJlxuICAgIChzdGF0ZS5jb3VudCsrLFxuICAgIChwcmVjZWRlbmNlc0J5Um9vdCA9IG5ldyBNYXAoKSksXG4gICAgcmVzb3VyY2VzLmZvckVhY2goaW5zZXJ0U3R5bGVzaGVldEludG9Sb290LCBzdGF0ZSksXG4gICAgKHByZWNlZGVuY2VzQnlSb290ID0gbnVsbCksXG4gICAgb25VbnN1c3BlbmQuY2FsbChzdGF0ZSkpO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVzaGVldEludG9Sb290KHJvb3QsIHJlc291cmNlKSB7XG4gIGlmICghKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgJiA0KSkge1xuICAgIHZhciBwcmVjZWRlbmNlcyA9IHByZWNlZGVuY2VzQnlSb290LmdldChyb290KTtcbiAgICBpZiAocHJlY2VkZW5jZXMpIHZhciBsYXN0ID0gcHJlY2VkZW5jZXMuZ2V0KG51bGwpO1xuICAgIGVsc2Uge1xuICAgICAgcHJlY2VkZW5jZXMgPSBuZXcgTWFwKCk7XG4gICAgICBwcmVjZWRlbmNlc0J5Um9vdC5zZXQocm9vdCwgcHJlY2VkZW5jZXMpO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIG5vZGVzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgXCJsaW5rW2RhdGEtcHJlY2VkZW5jZV0sc3R5bGVbZGF0YS1wcmVjZWRlbmNlXVwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgaSA8IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwiTElOS1wiID09PSBub2RlLm5vZGVOYW1lIHx8XG4gICAgICAgICAgXCJub3QgYWxsXCIgIT09IG5vZGUuZ2V0QXR0cmlidXRlKFwibWVkaWFcIilcbiAgICAgICAgKVxuICAgICAgICAgIHByZWNlZGVuY2VzLnNldChub2RlLmRhdGFzZXQucHJlY2VkZW5jZSwgbm9kZSksIChsYXN0ID0gbm9kZSk7XG4gICAgICB9XG4gICAgICBsYXN0ICYmIHByZWNlZGVuY2VzLnNldChudWxsLCBsYXN0KTtcbiAgICB9XG4gICAgbm9kZXMgPSByZXNvdXJjZS5pbnN0YW5jZTtcbiAgICBub2RlID0gbm9kZXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpO1xuICAgIGkgPSBwcmVjZWRlbmNlcy5nZXQobm9kZSkgfHwgbGFzdDtcbiAgICBpID09PSBsYXN0ICYmIHByZWNlZGVuY2VzLnNldChudWxsLCBub2Rlcyk7XG4gICAgcHJlY2VkZW5jZXMuc2V0KG5vZGUsIG5vZGVzKTtcbiAgICB0aGlzLmNvdW50Kys7XG4gICAgbGFzdCA9IG9uVW5zdXNwZW5kLmJpbmQodGhpcyk7XG4gICAgbm9kZXMuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbGFzdCk7XG4gICAgbm9kZXMuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGxhc3QpO1xuICAgIGlcbiAgICAgID8gaS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlcywgaS5uZXh0U2libGluZylcbiAgICAgIDogKChyb290ID0gOSA9PT0gcm9vdC5ub2RlVHlwZSA/IHJvb3QuaGVhZCA6IHJvb3QpLFxuICAgICAgICByb290Lmluc2VydEJlZm9yZShub2Rlcywgcm9vdC5maXJzdENoaWxkKSk7XG4gICAgcmVzb3VyY2Uuc3RhdGUubG9hZGluZyB8PSA0O1xuICB9XG59XG52YXIgSG9zdFRyYW5zaXRpb25Db250ZXh0ID0ge1xuICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICBQcm92aWRlcjogbnVsbCxcbiAgQ29uc3VtZXI6IG51bGwsXG4gIF9jdXJyZW50VmFsdWU6IHNoYXJlZE5vdFBlbmRpbmdPYmplY3QsXG4gIF9jdXJyZW50VmFsdWUyOiBzaGFyZWROb3RQZW5kaW5nT2JqZWN0LFxuICBfdGhyZWFkQ291bnQ6IDBcbn07XG5mdW5jdGlvbiBGaWJlclJvb3ROb2RlKFxuICBjb250YWluZXJJbmZvLFxuICB0YWcsXG4gIGh5ZHJhdGUsXG4gIGlkZW50aWZpZXJQcmVmaXgsXG4gIG9uVW5jYXVnaHRFcnJvcixcbiAgb25DYXVnaHRFcnJvcixcbiAgb25SZWNvdmVyYWJsZUVycm9yLFxuICBmb3JtU3RhdGVcbikge1xuICB0aGlzLnRhZyA9IDE7XG4gIHRoaXMuY29udGFpbmVySW5mbyA9IGNvbnRhaW5lckluZm87XG4gIHRoaXMuZmluaXNoZWRXb3JrID1cbiAgICB0aGlzLnBpbmdDYWNoZSA9XG4gICAgdGhpcy5jdXJyZW50ID1cbiAgICB0aGlzLnBlbmRpbmdDaGlsZHJlbiA9XG4gICAgICBudWxsO1xuICB0aGlzLnRpbWVvdXRIYW5kbGUgPSAtMTtcbiAgdGhpcy5jYWxsYmFja05vZGUgPVxuICAgIHRoaXMubmV4dCA9XG4gICAgdGhpcy5wZW5kaW5nQ29udGV4dCA9XG4gICAgdGhpcy5jb250ZXh0ID1cbiAgICB0aGlzLmNhbmNlbFBlbmRpbmdDb21taXQgPVxuICAgICAgbnVsbDtcbiAgdGhpcy5jYWxsYmFja1ByaW9yaXR5ID0gMDtcbiAgdGhpcy5leHBpcmF0aW9uVGltZXMgPSBjcmVhdGVMYW5lTWFwKC0xKTtcbiAgdGhpcy5lbnRhbmdsZWRMYW5lcyA9XG4gICAgdGhpcy5zaGVsbFN1c3BlbmRDb3VudGVyID1cbiAgICB0aGlzLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzID1cbiAgICB0aGlzLmZpbmlzaGVkTGFuZXMgPVxuICAgIHRoaXMuZXhwaXJlZExhbmVzID1cbiAgICB0aGlzLndhcm1MYW5lcyA9XG4gICAgdGhpcy5waW5nZWRMYW5lcyA9XG4gICAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9XG4gICAgdGhpcy5wZW5kaW5nTGFuZXMgPVxuICAgICAgMDtcbiAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcCgwKTtcbiAgdGhpcy5oaWRkZW5VcGRhdGVzID0gY3JlYXRlTGFuZU1hcChudWxsKTtcbiAgdGhpcy5pZGVudGlmaWVyUHJlZml4ID0gaWRlbnRpZmllclByZWZpeDtcbiAgdGhpcy5vblVuY2F1Z2h0RXJyb3IgPSBvblVuY2F1Z2h0RXJyb3I7XG4gIHRoaXMub25DYXVnaHRFcnJvciA9IG9uQ2F1Z2h0RXJyb3I7XG4gIHRoaXMub25SZWNvdmVyYWJsZUVycm9yID0gb25SZWNvdmVyYWJsZUVycm9yO1xuICB0aGlzLnBvb2xlZENhY2hlID0gbnVsbDtcbiAgdGhpcy5wb29sZWRDYWNoZUxhbmVzID0gMDtcbiAgdGhpcy5mb3JtU3RhdGUgPSBmb3JtU3RhdGU7XG4gIHRoaXMuaW5jb21wbGV0ZVRyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KFxuICBjb250YWluZXJJbmZvLFxuICB0YWcsXG4gIGh5ZHJhdGUsXG4gIGluaXRpYWxDaGlsZHJlbixcbiAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICBpc1N0cmljdE1vZGUsXG4gIGlkZW50aWZpZXJQcmVmaXgsXG4gIG9uVW5jYXVnaHRFcnJvcixcbiAgb25DYXVnaHRFcnJvcixcbiAgb25SZWNvdmVyYWJsZUVycm9yLFxuICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICBmb3JtU3RhdGVcbikge1xuICBjb250YWluZXJJbmZvID0gbmV3IEZpYmVyUm9vdE5vZGUoXG4gICAgY29udGFpbmVySW5mbyxcbiAgICB0YWcsXG4gICAgaHlkcmF0ZSxcbiAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICBvbkNhdWdodEVycm9yLFxuICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICBmb3JtU3RhdGVcbiAgKTtcbiAgdGFnID0gMTtcbiAgITAgPT09IGlzU3RyaWN0TW9kZSAmJiAodGFnIHw9IDI0KTtcbiAgaXNTdHJpY3RNb2RlID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoMywgbnVsbCwgbnVsbCwgdGFnKTtcbiAgY29udGFpbmVySW5mby5jdXJyZW50ID0gaXNTdHJpY3RNb2RlO1xuICBpc1N0cmljdE1vZGUuc3RhdGVOb2RlID0gY29udGFpbmVySW5mbztcbiAgdGFnID0gY3JlYXRlQ2FjaGUoKTtcbiAgdGFnLnJlZkNvdW50Kys7XG4gIGNvbnRhaW5lckluZm8ucG9vbGVkQ2FjaGUgPSB0YWc7XG4gIHRhZy5yZWZDb3VudCsrO1xuICBpc1N0cmljdE1vZGUubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICBlbGVtZW50OiBpbml0aWFsQ2hpbGRyZW4sXG4gICAgaXNEZWh5ZHJhdGVkOiBoeWRyYXRlLFxuICAgIGNhY2hlOiB0YWdcbiAgfTtcbiAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGlzU3RyaWN0TW9kZSk7XG4gIHJldHVybiBjb250YWluZXJJbmZvO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICBwYXJlbnRDb21wb25lbnQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHJldHVybiBwYXJlbnRDb21wb25lbnQ7XG59XG5mdW5jdGlvbiB1cGRhdGVDb250YWluZXJJbXBsKFxuICByb290RmliZXIsXG4gIGxhbmUsXG4gIGVsZW1lbnQsXG4gIGNvbnRhaW5lcixcbiAgcGFyZW50Q29tcG9uZW50LFxuICBjYWxsYmFja1xuKSB7XG4gIHBhcmVudENvbXBvbmVudCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gIG51bGwgPT09IGNvbnRhaW5lci5jb250ZXh0XG4gICAgPyAoY29udGFpbmVyLmNvbnRleHQgPSBwYXJlbnRDb21wb25lbnQpXG4gICAgOiAoY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gcGFyZW50Q29tcG9uZW50KTtcbiAgY29udGFpbmVyID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICBjb250YWluZXIucGF5bG9hZCA9IHsgZWxlbWVudDogZWxlbWVudCB9O1xuICBjYWxsYmFjayA9IHZvaWQgMCA9PT0gY2FsbGJhY2sgPyBudWxsIDogY2FsbGJhY2s7XG4gIG51bGwgIT09IGNhbGxiYWNrICYmIChjb250YWluZXIuY2FsbGJhY2sgPSBjYWxsYmFjayk7XG4gIGVsZW1lbnQgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgY29udGFpbmVyLCBsYW5lKTtcbiAgbnVsbCAhPT0gZWxlbWVudCAmJlxuICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZWxlbWVudCwgcm9vdEZpYmVyLCBsYW5lKSxcbiAgICBlbnRhbmdsZVRyYW5zaXRpb25zKGVsZW1lbnQsIHJvb3RGaWJlciwgbGFuZSkpO1xufVxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSkge1xuICBmaWJlciA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIGlmIChudWxsICE9PSBmaWJlciAmJiBudWxsICE9PSBmaWJlci5kZWh5ZHJhdGVkKSB7XG4gICAgdmFyIGEgPSBmaWJlci5yZXRyeUxhbmU7XG4gICAgZmliZXIucmV0cnlMYW5lID0gMCAhPT0gYSAmJiBhIDwgcmV0cnlMYW5lID8gYSA6IHJldHJ5TGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSkge1xuICBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgKGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlKSAmJiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGZpYmVyKSB7XG4gIGlmICgxMyA9PT0gZmliZXIudGFnKSB7XG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDY3MTA4ODY0KTtcbiAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgNjcxMDg4NjQpO1xuICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCA2NzEwODg2NCk7XG4gIH1cbn1cbnZhciBfZW5hYmxlZCA9ICEwO1xuZnVuY3Rpb24gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50KFxuICBkb21FdmVudE5hbWUsXG4gIGV2ZW50U3lzdGVtRmxhZ3MsXG4gIGNvbnRhaW5lcixcbiAgbmF0aXZlRXZlbnRcbikge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICB0cnkge1xuICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gMiksXG4gICAgICBkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG4gIH0gZmluYWxseSB7XG4gICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaENvbnRpbnVvdXNFdmVudChcbiAgZG9tRXZlbnROYW1lLFxuICBldmVudFN5c3RlbUZsYWdzLFxuICBjb250YWluZXIsXG4gIG5hdGl2ZUV2ZW50XG4pIHtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgdHJ5IHtcbiAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IDgpLFxuICAgICAgZGlzcGF0Y2hFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICB9IGZpbmFsbHkge1xuICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eSksXG4gICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChcbiAgZG9tRXZlbnROYW1lLFxuICBldmVudFN5c3RlbUZsYWdzLFxuICB0YXJnZXRDb250YWluZXIsXG4gIG5hdGl2ZUV2ZW50XG4pIHtcbiAgaWYgKF9lbmFibGVkKSB7XG4gICAgdmFyIGJsb2NrZWRPbiA9IGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChudWxsID09PSBibG9ja2VkT24pXG4gICAgICBkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oXG4gICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgIHJldHVybl90YXJnZXRJbnN0LFxuICAgICAgICB0YXJnZXRDb250YWluZXJcbiAgICAgICksXG4gICAgICAgIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gICAgZWxzZSBpZiAoXG4gICAgICBxdWV1ZUlmQ29udGludW91c0V2ZW50KFxuICAgICAgICBibG9ja2VkT24sXG4gICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgKVxuICAgIClcbiAgICAgIG5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGVsc2UgaWYgKFxuICAgICAgKGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCksXG4gICAgICBldmVudFN5c3RlbUZsYWdzICYgNCAmJlxuICAgICAgICAtMSA8IGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cy5pbmRleE9mKGRvbUV2ZW50TmFtZSkpXG4gICAgKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gYmxvY2tlZE9uOyApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO1xuICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIpXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgZmliZXIgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGlmIChmaWJlci5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMoZmliZXIucGVuZGluZ0xhbmVzKTtcbiAgICAgICAgICAgICAgICBpZiAoMCAhPT0gbGFuZXMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByb290ID0gZmliZXI7XG4gICAgICAgICAgICAgICAgICByb290LnBlbmRpbmdMYW5lcyB8PSAyO1xuICAgICAgICAgICAgICAgICAgZm9yIChyb290LmVudGFuZ2xlZExhbmVzIHw9IDI7IGxhbmVzOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSAxIDw8ICgzMSAtIGNsejMyKGxhbmVzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZW50YW5nbGVtZW50c1sxXSB8PSBsYW5lO1xuICAgICAgICAgICAgICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChmaWJlcik7XG4gICAgICAgICAgICAgICAgICAwID09PSAoZXhlY3V0aW9uQ29udGV4dCAmIDYpICYmXG4gICAgICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IG5vdygpICsgNTAwKSxcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAocm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKSxcbiAgICAgICAgICAgICAgICBmbHVzaFN5bmNXb3JrJDEoKSxcbiAgICAgICAgICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgMik7XG4gICAgICAgICAgfVxuICAgICAgICBmaWJlciA9IGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgICAgICBudWxsID09PSBmaWJlciAmJlxuICAgICAgICAgIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShcbiAgICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgIHJldHVybl90YXJnZXRJbnN0LFxuICAgICAgICAgICAgdGFyZ2V0Q29udGFpbmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKGZpYmVyID09PSBibG9ja2VkT24pIGJyZWFrO1xuICAgICAgICBibG9ja2VkT24gPSBmaWJlcjtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IGJsb2NrZWRPbiAmJiBuYXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2VcbiAgICAgIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShcbiAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdGFyZ2V0Q29udGFpbmVyXG4gICAgICApO1xuICB9XG59XG5mdW5jdGlvbiBmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIG5hdGl2ZUV2ZW50ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICByZXR1cm4gZmluZEluc3RhbmNlQmxvY2tpbmdUYXJnZXQobmF0aXZlRXZlbnQpO1xufVxudmFyIHJldHVybl90YXJnZXRJbnN0ID0gbnVsbDtcbmZ1bmN0aW9uIGZpbmRJbnN0YW5jZUJsb2NraW5nVGFyZ2V0KHRhcmdldE5vZGUpIHtcbiAgcmV0dXJuX3RhcmdldEluc3QgPSBudWxsO1xuICB0YXJnZXROb2RlID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0Tm9kZSk7XG4gIGlmIChudWxsICE9PSB0YXJnZXROb2RlKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXROb2RlKTtcbiAgICBpZiAobnVsbCA9PT0gbmVhcmVzdE1vdW50ZWQpIHRhcmdldE5vZGUgPSBudWxsO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIHRhZyA9IG5lYXJlc3RNb3VudGVkLnRhZztcbiAgICAgIGlmICgxMyA9PT0gdGFnKSB7XG4gICAgICAgIHRhcmdldE5vZGUgPSBnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTtcbiAgICAgICAgaWYgKG51bGwgIT09IHRhcmdldE5vZGUpIHJldHVybiB0YXJnZXROb2RlO1xuICAgICAgICB0YXJnZXROb2RlID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoMyA9PT0gdGFnKSB7XG4gICAgICAgIGlmIChuZWFyZXN0TW91bnRlZC5zdGF0ZU5vZGUuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZClcbiAgICAgICAgICByZXR1cm4gMyA9PT0gbmVhcmVzdE1vdW50ZWQudGFnXG4gICAgICAgICAgICA/IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHRhcmdldE5vZGUgPSBudWxsO1xuICAgICAgfSBlbHNlIG5lYXJlc3RNb3VudGVkICE9PSB0YXJnZXROb2RlICYmICh0YXJnZXROb2RlID0gbnVsbCk7XG4gICAgfVxuICB9XG4gIHJldHVybl90YXJnZXRJbnN0ID0gdGFyZ2V0Tm9kZTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5KGRvbUV2ZW50TmFtZSkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgXCJiZWZvcmV0b2dnbGVcIjpcbiAgICBjYXNlIFwiY2FuY2VsXCI6XG4gICAgY2FzZSBcImNsaWNrXCI6XG4gICAgY2FzZSBcImNsb3NlXCI6XG4gICAgY2FzZSBcImNvbnRleHRtZW51XCI6XG4gICAgY2FzZSBcImNvcHlcIjpcbiAgICBjYXNlIFwiY3V0XCI6XG4gICAgY2FzZSBcImF1eGNsaWNrXCI6XG4gICAgY2FzZSBcImRibGNsaWNrXCI6XG4gICAgY2FzZSBcImRyYWdlbmRcIjpcbiAgICBjYXNlIFwiZHJhZ3N0YXJ0XCI6XG4gICAgY2FzZSBcImRyb3BcIjpcbiAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgIGNhc2UgXCJmb2N1c291dFwiOlxuICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgIGNhc2UgXCJpbnZhbGlkXCI6XG4gICAgY2FzZSBcImtleWRvd25cIjpcbiAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICBjYXNlIFwia2V5dXBcIjpcbiAgICBjYXNlIFwibW91c2Vkb3duXCI6XG4gICAgY2FzZSBcIm1vdXNldXBcIjpcbiAgICBjYXNlIFwicGFzdGVcIjpcbiAgICBjYXNlIFwicGF1c2VcIjpcbiAgICBjYXNlIFwicGxheVwiOlxuICAgIGNhc2UgXCJwb2ludGVyY2FuY2VsXCI6XG4gICAgY2FzZSBcInBvaW50ZXJkb3duXCI6XG4gICAgY2FzZSBcInBvaW50ZXJ1cFwiOlxuICAgIGNhc2UgXCJyYXRlY2hhbmdlXCI6XG4gICAgY2FzZSBcInJlc2V0XCI6XG4gICAgY2FzZSBcInJlc2l6ZVwiOlxuICAgIGNhc2UgXCJzZWVrZWRcIjpcbiAgICBjYXNlIFwic3VibWl0XCI6XG4gICAgY2FzZSBcInRvZ2dsZVwiOlxuICAgIGNhc2UgXCJ0b3VjaGNhbmNlbFwiOlxuICAgIGNhc2UgXCJ0b3VjaGVuZFwiOlxuICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCI6XG4gICAgY2FzZSBcInZvbHVtZWNoYW5nZVwiOlxuICAgIGNhc2UgXCJjaGFuZ2VcIjpcbiAgICBjYXNlIFwic2VsZWN0aW9uY2hhbmdlXCI6XG4gICAgY2FzZSBcInRleHRJbnB1dFwiOlxuICAgIGNhc2UgXCJjb21wb3NpdGlvbnN0YXJ0XCI6XG4gICAgY2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6XG4gICAgY2FzZSBcImNvbXBvc2l0aW9udXBkYXRlXCI6XG4gICAgY2FzZSBcImJlZm9yZWJsdXJcIjpcbiAgICBjYXNlIFwiYWZ0ZXJibHVyXCI6XG4gICAgY2FzZSBcImJlZm9yZWlucHV0XCI6XG4gICAgY2FzZSBcImJsdXJcIjpcbiAgICBjYXNlIFwiZnVsbHNjcmVlbmNoYW5nZVwiOlxuICAgIGNhc2UgXCJmb2N1c1wiOlxuICAgIGNhc2UgXCJoYXNoY2hhbmdlXCI6XG4gICAgY2FzZSBcInBvcHN0YXRlXCI6XG4gICAgY2FzZSBcInNlbGVjdFwiOlxuICAgIGNhc2UgXCJzZWxlY3RzdGFydFwiOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSBcImRyYWdcIjpcbiAgICBjYXNlIFwiZHJhZ2VudGVyXCI6XG4gICAgY2FzZSBcImRyYWdleGl0XCI6XG4gICAgY2FzZSBcImRyYWdsZWF2ZVwiOlxuICAgIGNhc2UgXCJkcmFnb3ZlclwiOlxuICAgIGNhc2UgXCJtb3VzZW1vdmVcIjpcbiAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgY2FzZSBcInBvaW50ZXJtb3ZlXCI6XG4gICAgY2FzZSBcInBvaW50ZXJvdXRcIjpcbiAgICBjYXNlIFwicG9pbnRlcm92ZXJcIjpcbiAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgY2FzZSBcInRvdWNobW92ZVwiOlxuICAgIGNhc2UgXCJ3aGVlbFwiOlxuICAgIGNhc2UgXCJtb3VzZWVudGVyXCI6XG4gICAgY2FzZSBcIm1vdXNlbGVhdmVcIjpcbiAgICBjYXNlIFwicG9pbnRlcmVudGVyXCI6XG4gICAgY2FzZSBcInBvaW50ZXJsZWF2ZVwiOlxuICAgICAgcmV0dXJuIDg7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIHN3aXRjaCAoZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSkge1xuICAgICAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICBjYXNlIE5vcm1hbFByaW9yaXR5JDE6XG4gICAgICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgICAgICByZXR1cm4gMjY4NDM1NDU2O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDMyO1xuICB9XG59XG52YXIgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9ICExLFxuICBxdWV1ZWRGb2N1cyA9IG51bGwsXG4gIHF1ZXVlZERyYWcgPSBudWxsLFxuICBxdWV1ZWRNb3VzZSA9IG51bGwsXG4gIHF1ZXVlZFBvaW50ZXJzID0gbmV3IE1hcCgpLFxuICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMgPSBuZXcgTWFwKCksXG4gIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cyA9IFtdLFxuICBkaXNjcmV0ZVJlcGxheWFibGVFdmVudHMgPVxuICAgIFwibW91c2Vkb3duIG1vdXNldXAgdG91Y2hjYW5jZWwgdG91Y2hlbmQgdG91Y2hzdGFydCBhdXhjbGljayBkYmxjbGljayBwb2ludGVyY2FuY2VsIHBvaW50ZXJkb3duIHBvaW50ZXJ1cCBkcmFnZW5kIGRyYWdzdGFydCBkcm9wIGNvbXBvc2l0aW9uZW5kIGNvbXBvc2l0aW9uc3RhcnQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBpbnB1dCB0ZXh0SW5wdXQgY29weSBjdXQgcGFzdGUgY2xpY2sgY2hhbmdlIGNvbnRleHRtZW51IHJlc2V0XCIuc3BsaXQoXG4gICAgICBcIiBcIlxuICAgICk7XG5mdW5jdGlvbiBjbGVhcklmQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgIGNhc2UgXCJmb2N1c291dFwiOlxuICAgICAgcXVldWVkRm9jdXMgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRyYWdlbnRlclwiOlxuICAgIGNhc2UgXCJkcmFnbGVhdmVcIjpcbiAgICAgIHF1ZXVlZERyYWcgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgIGNhc2UgXCJtb3VzZW91dFwiOlxuICAgICAgcXVldWVkTW91c2UgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInBvaW50ZXJvdmVyXCI6XG4gICAgY2FzZSBcInBvaW50ZXJvdXRcIjpcbiAgICAgIHF1ZXVlZFBvaW50ZXJzLmRlbGV0ZShuYXRpdmVFdmVudC5wb2ludGVySWQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6XG4gICAgY2FzZSBcImxvc3Rwb2ludGVyY2FwdHVyZVwiOlxuICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmRlbGV0ZShuYXRpdmVFdmVudC5wb2ludGVySWQpO1xuICB9XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KFxuICBleGlzdGluZ1F1ZXVlZEV2ZW50LFxuICBibG9ja2VkT24sXG4gIGRvbUV2ZW50TmFtZSxcbiAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgdGFyZ2V0Q29udGFpbmVyLFxuICBuYXRpdmVFdmVudFxuKSB7XG4gIGlmIChcbiAgICBudWxsID09PSBleGlzdGluZ1F1ZXVlZEV2ZW50IHx8XG4gICAgZXhpc3RpbmdRdWV1ZWRFdmVudC5uYXRpdmVFdmVudCAhPT0gbmF0aXZlRXZlbnRcbiAgKVxuICAgIHJldHVybiAoXG4gICAgICAoZXhpc3RpbmdRdWV1ZWRFdmVudCA9IHtcbiAgICAgICAgYmxvY2tlZE9uOiBibG9ja2VkT24sXG4gICAgICAgIGRvbUV2ZW50TmFtZTogZG9tRXZlbnROYW1lLFxuICAgICAgICBldmVudFN5c3RlbUZsYWdzOiBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgICAgIHRhcmdldENvbnRhaW5lcnM6IFt0YXJnZXRDb250YWluZXJdXG4gICAgICB9KSxcbiAgICAgIG51bGwgIT09IGJsb2NrZWRPbiAmJlxuICAgICAgICAoKGJsb2NrZWRPbiA9IGdldEluc3RhbmNlRnJvbU5vZGUoYmxvY2tlZE9uKSksXG4gICAgICAgIG51bGwgIT09IGJsb2NrZWRPbiAmJiBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihibG9ja2VkT24pKSxcbiAgICAgIGV4aXN0aW5nUXVldWVkRXZlbnRcbiAgICApO1xuICBleGlzdGluZ1F1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MgfD0gZXZlbnRTeXN0ZW1GbGFncztcbiAgYmxvY2tlZE9uID0gZXhpc3RpbmdRdWV1ZWRFdmVudC50YXJnZXRDb250YWluZXJzO1xuICBudWxsICE9PSB0YXJnZXRDb250YWluZXIgJiZcbiAgICAtMSA9PT0gYmxvY2tlZE9uLmluZGV4T2YodGFyZ2V0Q29udGFpbmVyKSAmJlxuICAgIGJsb2NrZWRPbi5wdXNoKHRhcmdldENvbnRhaW5lcik7XG4gIHJldHVybiBleGlzdGluZ1F1ZXVlZEV2ZW50O1xufVxuZnVuY3Rpb24gcXVldWVJZkNvbnRpbnVvdXNFdmVudChcbiAgYmxvY2tlZE9uLFxuICBkb21FdmVudE5hbWUsXG4gIGV2ZW50U3lzdGVtRmxhZ3MsXG4gIHRhcmdldENvbnRhaW5lcixcbiAgbmF0aXZlRXZlbnRcbikge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAocXVldWVkRm9jdXMgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KFxuICAgICAgICAgIHF1ZXVlZEZvY3VzLFxuICAgICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgKSksXG4gICAgICAgICEwXG4gICAgICApO1xuICAgIGNhc2UgXCJkcmFnZW50ZXJcIjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChxdWV1ZWREcmFnID0gYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgICAgICBxdWV1ZWREcmFnLFxuICAgICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgKSksXG4gICAgICAgICEwXG4gICAgICApO1xuICAgIGNhc2UgXCJtb3VzZW92ZXJcIjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChxdWV1ZWRNb3VzZSA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoXG4gICAgICAgICAgcXVldWVkTW91c2UsXG4gICAgICAgICAgYmxvY2tlZE9uLFxuICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICApKSxcbiAgICAgICAgITBcbiAgICAgICk7XG4gICAgY2FzZSBcInBvaW50ZXJvdmVyXCI6XG4gICAgICB2YXIgcG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgICAgcXVldWVkUG9pbnRlcnMuc2V0KFxuICAgICAgICBwb2ludGVySWQsXG4gICAgICAgIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoXG4gICAgICAgICAgcXVldWVkUG9pbnRlcnMuZ2V0KHBvaW50ZXJJZCkgfHwgbnVsbCxcbiAgICAgICAgICBibG9ja2VkT24sXG4gICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByZXR1cm4gITA7XG4gICAgY2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAocG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkKSxcbiAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLnNldChcbiAgICAgICAgICBwb2ludGVySWQsXG4gICAgICAgICAgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgICAgICAgIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5nZXQocG9pbnRlcklkKSB8fCBudWxsLFxuICAgICAgICAgICAgYmxvY2tlZE9uLFxuICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICAhMFxuICAgICAgKTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBhdHRlbXB0RXhwbGljaXRIeWRyYXRpb25UYXJnZXQocXVldWVkVGFyZ2V0KSB7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocXVldWVkVGFyZ2V0LnRhcmdldCk7XG4gIGlmIChudWxsICE9PSB0YXJnZXRJbnN0KSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcbiAgICBpZiAobnVsbCAhPT0gbmVhcmVzdE1vdW50ZWQpXG4gICAgICBpZiAoKCh0YXJnZXRJbnN0ID0gbmVhcmVzdE1vdW50ZWQudGFnKSwgMTMgPT09IHRhcmdldEluc3QpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKHRhcmdldEluc3QgPSBnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKSksXG4gICAgICAgICAgbnVsbCAhPT0gdGFyZ2V0SW5zdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgcnVuV2l0aFByaW9yaXR5KHF1ZXVlZFRhcmdldC5wcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKDEzID09PSBuZWFyZXN0TW91bnRlZC50YWcpIHtcbiAgICAgICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZSgpLFxuICAgICAgICAgICAgICAgIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUobmVhcmVzdE1vdW50ZWQsIGxhbmUpO1xuICAgICAgICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIG5lYXJlc3RNb3VudGVkLCBsYW5lKTtcbiAgICAgICAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQobmVhcmVzdE1vdW50ZWQsIGxhbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgMyA9PT0gdGFyZ2V0SW5zdCAmJlxuICAgICAgICBuZWFyZXN0TW91bnRlZC5zdGF0ZU5vZGUuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZFxuICAgICAgKSB7XG4gICAgICAgIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPVxuICAgICAgICAgIDMgPT09IG5lYXJlc3RNb3VudGVkLnRhZ1xuICAgICAgICAgICAgPyBuZWFyZXN0TW91bnRlZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbiAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IG51bGw7XG59XG5mdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEV2ZW50KSB7XG4gIGlmIChudWxsICE9PSBxdWV1ZWRFdmVudC5ibG9ja2VkT24pIHJldHVybiAhMTtcbiAgZm9yIChcbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IHF1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG4gICAgMCA8IHRhcmdldENvbnRhaW5lcnMubGVuZ3RoO1xuXG4gICkge1xuICAgIHZhciBuZXh0QmxvY2tlZE9uID0gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChxdWV1ZWRFdmVudC5uYXRpdmVFdmVudCk7XG4gICAgaWYgKG51bGwgPT09IG5leHRCbG9ja2VkT24pIHtcbiAgICAgIG5leHRCbG9ja2VkT24gPSBxdWV1ZWRFdmVudC5uYXRpdmVFdmVudDtcbiAgICAgIHZhciBuYXRpdmVFdmVudENsb25lID0gbmV3IG5leHRCbG9ja2VkT24uY29uc3RydWN0b3IoXG4gICAgICAgIG5leHRCbG9ja2VkT24udHlwZSxcbiAgICAgICAgbmV4dEJsb2NrZWRPblxuICAgICAgKTtcbiAgICAgIGN1cnJlbnRSZXBsYXlpbmdFdmVudCA9IG5hdGl2ZUV2ZW50Q2xvbmU7XG4gICAgICBuZXh0QmxvY2tlZE9uLnRhcmdldC5kaXNwYXRjaEV2ZW50KG5hdGl2ZUV2ZW50Q2xvbmUpO1xuICAgICAgY3VycmVudFJlcGxheWluZ0V2ZW50ID0gbnVsbDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh0YXJnZXRDb250YWluZXJzID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0QmxvY2tlZE9uKSksXG4gICAgICAgIG51bGwgIT09IHRhcmdldENvbnRhaW5lcnMgJiZcbiAgICAgICAgICBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbih0YXJnZXRDb250YWluZXJzKSxcbiAgICAgICAgKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG5leHRCbG9ja2VkT24pLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICB0YXJnZXRDb250YWluZXJzLnNoaWZ0KCk7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKHF1ZXVlZEV2ZW50LCBrZXksIG1hcCkge1xuICBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEV2ZW50KSAmJiBtYXAuZGVsZXRlKGtleSk7XG59XG5mdW5jdGlvbiByZXBsYXlVbmJsb2NrZWRFdmVudHMoKSB7XG4gIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSAhMTtcbiAgbnVsbCAhPT0gcXVldWVkRm9jdXMgJiZcbiAgICBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEZvY3VzKSAmJlxuICAgIChxdWV1ZWRGb2N1cyA9IG51bGwpO1xuICBudWxsICE9PSBxdWV1ZWREcmFnICYmXG4gICAgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWREcmFnKSAmJlxuICAgIChxdWV1ZWREcmFnID0gbnVsbCk7XG4gIG51bGwgIT09IHF1ZXVlZE1vdXNlICYmXG4gICAgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRNb3VzZSkgJiZcbiAgICAocXVldWVkTW91c2UgPSBudWxsKTtcbiAgcXVldWVkUG9pbnRlcnMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO1xuICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEV2ZW50LCB1bmJsb2NrZWQpIHtcbiAgcXVldWVkRXZlbnQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQgJiZcbiAgICAoKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG51bGwpLFxuICAgIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgfHxcbiAgICAgICgoaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9ICEwKSxcbiAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKFxuICAgICAgICBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgICAgIHJlcGxheVVuYmxvY2tlZEV2ZW50c1xuICAgICAgKSkpO1xufVxudmFyIGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSA9IG51bGw7XG5mdW5jdGlvbiBzY2hlZHVsZVJlcGxheVF1ZXVlSWZOZWVkZWQoZm9ybVJlcGxheWluZ1F1ZXVlKSB7XG4gIGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSAhPT0gZm9ybVJlcGxheWluZ1F1ZXVlICYmXG4gICAgKChsYXN0U2NoZWR1bGVkUmVwbGF5UXVldWUgPSBmb3JtUmVwbGF5aW5nUXVldWUpLFxuICAgIFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKFxuICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBsYXN0U2NoZWR1bGVkUmVwbGF5UXVldWUgPT09IGZvcm1SZXBsYXlpbmdRdWV1ZSAmJlxuICAgICAgICAgIChsYXN0U2NoZWR1bGVkUmVwbGF5UXVldWUgPSBudWxsKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtUmVwbGF5aW5nUXVldWUubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICB2YXIgZm9ybSA9IGZvcm1SZXBsYXlpbmdRdWV1ZVtpXSxcbiAgICAgICAgICAgIHN1Ym1pdHRlck9yQWN0aW9uID0gZm9ybVJlcGxheWluZ1F1ZXVlW2kgKyAxXSxcbiAgICAgICAgICAgIGZvcm1EYXRhID0gZm9ybVJlcGxheWluZ1F1ZXVlW2kgKyAyXTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygc3VibWl0dGVyT3JBY3Rpb24pXG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gZmluZEluc3RhbmNlQmxvY2tpbmdUYXJnZXQoc3VibWl0dGVyT3JBY3Rpb24gfHwgZm9ybSkpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICB2YXIgZm9ybUluc3QgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGZvcm0pO1xuICAgICAgICAgIG51bGwgIT09IGZvcm1JbnN0ICYmXG4gICAgICAgICAgICAoZm9ybVJlcGxheWluZ1F1ZXVlLnNwbGljZShpLCAzKSxcbiAgICAgICAgICAgIChpIC09IDMpLFxuICAgICAgICAgICAgc3RhcnRIb3N0VHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgZm9ybUluc3QsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nOiAhMCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGZvcm0ubWV0aG9kLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogc3VibWl0dGVyT3JBY3Rpb25cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3VibWl0dGVyT3JBY3Rpb24sXG4gICAgICAgICAgICAgIGZvcm1EYXRhXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICkpO1xufVxuZnVuY3Rpb24gcmV0cnlJZkJsb2NrZWRPbih1bmJsb2NrZWQpIHtcbiAgZnVuY3Rpb24gdW5ibG9jayhxdWV1ZWRFdmVudCkge1xuICAgIHJldHVybiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRXZlbnQsIHVuYmxvY2tlZCk7XG4gIH1cbiAgbnVsbCAhPT0gcXVldWVkRm9jdXMgJiYgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEZvY3VzLCB1bmJsb2NrZWQpO1xuICBudWxsICE9PSBxdWV1ZWREcmFnICYmIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWREcmFnLCB1bmJsb2NrZWQpO1xuICBudWxsICE9PSBxdWV1ZWRNb3VzZSAmJiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkTW91c2UsIHVuYmxvY2tlZCk7XG4gIHF1ZXVlZFBvaW50ZXJzLmZvckVhY2godW5ibG9jayk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKHVuYmxvY2spO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBxdWV1ZWRUYXJnZXQgPSBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHNbaV07XG4gICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkICYmIChxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbCk7XG4gIH1cbiAgZm9yIChcbiAgICA7XG4gICAgMCA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGggJiZcbiAgICAoKGkgPSBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHNbMF0pLCBudWxsID09PSBpLmJsb2NrZWRPbik7XG5cbiAgKVxuICAgIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChpKSxcbiAgICAgIG51bGwgPT09IGkuYmxvY2tlZE9uICYmIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5zaGlmdCgpO1xuICBpID0gKHVuYmxvY2tlZC5vd25lckRvY3VtZW50IHx8IHVuYmxvY2tlZCkuJCRyZWFjdEZvcm1SZXBsYXk7XG4gIGlmIChudWxsICE9IGkpXG4gICAgZm9yIChxdWV1ZWRUYXJnZXQgPSAwOyBxdWV1ZWRUYXJnZXQgPCBpLmxlbmd0aDsgcXVldWVkVGFyZ2V0ICs9IDMpIHtcbiAgICAgIHZhciBmb3JtID0gaVtxdWV1ZWRUYXJnZXRdLFxuICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbiA9IGlbcXVldWVkVGFyZ2V0ICsgMV0sXG4gICAgICAgIGZvcm1Qcm9wcyA9IGZvcm1baW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBzdWJtaXR0ZXJPckFjdGlvbilcbiAgICAgICAgZm9ybVByb3BzIHx8IHNjaGVkdWxlUmVwbGF5UXVldWVJZk5lZWRlZChpKTtcbiAgICAgIGVsc2UgaWYgKGZvcm1Qcm9wcykge1xuICAgICAgICB2YXIgYWN0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHN1Ym1pdHRlck9yQWN0aW9uICYmIHN1Ym1pdHRlck9yQWN0aW9uLmhhc0F0dHJpYnV0ZShcImZvcm1BY3Rpb25cIikpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKChmb3JtID0gc3VibWl0dGVyT3JBY3Rpb24pLFxuICAgICAgICAgICAgKGZvcm1Qcm9wcyA9IHN1Ym1pdHRlck9yQWN0aW9uW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGwpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGFjdGlvbiA9IGZvcm1Qcm9wcy5mb3JtQWN0aW9uO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGZpbmRJbnN0YW5jZUJsb2NraW5nVGFyZ2V0KGZvcm0pKSBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgYWN0aW9uID0gZm9ybVByb3BzLmFjdGlvbjtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uXG4gICAgICAgICAgPyAoaVtxdWV1ZWRUYXJnZXQgKyAxXSA9IGFjdGlvbilcbiAgICAgICAgICA6IChpLnNwbGljZShxdWV1ZWRUYXJnZXQsIDMpLCAocXVldWVkVGFyZ2V0IC09IDMpKTtcbiAgICAgICAgc2NoZWR1bGVSZXBsYXlRdWV1ZUlmTmVlZGVkKGkpO1xuICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIFJlYWN0RE9NUm9vdChpbnRlcm5hbFJvb3QpIHtcbiAgdGhpcy5faW50ZXJuYWxSb290ID0gaW50ZXJuYWxSb290O1xufVxuUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS5yZW5kZXIgPSBSZWFjdERPTVJvb3QucHJvdG90eXBlLnJlbmRlciA9XG4gIGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICAgIGlmIChudWxsID09PSByb290KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQwOSkpO1xuICAgIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50LFxuICAgICAgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKCk7XG4gICAgdXBkYXRlQ29udGFpbmVySW1wbChjdXJyZW50LCBsYW5lLCBjaGlsZHJlbiwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gIH07XG5SZWFjdERPTUh5ZHJhdGlvblJvb3QucHJvdG90eXBlLnVubW91bnQgPSBSZWFjdERPTVJvb3QucHJvdG90eXBlLnVubW91bnQgPVxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLl9pbnRlcm5hbFJvb3Q7XG4gICAgaWYgKG51bGwgIT09IHJvb3QpIHtcbiAgICAgIHRoaXMuX2ludGVybmFsUm9vdCA9IG51bGw7XG4gICAgICB2YXIgY29udGFpbmVyID0gcm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgMCA9PT0gcm9vdC50YWcgJiYgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgdXBkYXRlQ29udGFpbmVySW1wbChyb290LmN1cnJlbnQsIDIsIG51bGwsIHJvb3QsIG51bGwsIG51bGwpO1xuICAgICAgZmx1c2hTeW5jV29yayQxKCk7XG4gICAgICBjb250YWluZXJbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBudWxsO1xuICAgIH1cbiAgfTtcbmZ1bmN0aW9uIFJlYWN0RE9NSHlkcmF0aW9uUm9vdChpbnRlcm5hbFJvb3QpIHtcbiAgdGhpcy5faW50ZXJuYWxSb290ID0gaW50ZXJuYWxSb290O1xufVxuUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS51bnN0YWJsZV9zY2hlZHVsZUh5ZHJhdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCkge1xuICAgIHZhciB1cGRhdGVQcmlvcml0eSA9IHJlc29sdmVVcGRhdGVQcmlvcml0eSgpO1xuICAgIHRhcmdldCA9IHsgYmxvY2tlZE9uOiBudWxsLCB0YXJnZXQ6IHRhcmdldCwgcHJpb3JpdHk6IHVwZGF0ZVByaW9yaXR5IH07XG4gICAgZm9yIChcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGkgPCBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoICYmXG4gICAgICAwICE9PSB1cGRhdGVQcmlvcml0eSAmJlxuICAgICAgdXBkYXRlUHJpb3JpdHkgPCBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHNbaV0ucHJpb3JpdHk7XG4gICAgICBpKytcbiAgICApO1xuICAgIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5zcGxpY2UoaSwgMCwgdGFyZ2V0KTtcbiAgICAwID09PSBpICYmIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldCh0YXJnZXQpO1xuICB9XG59O1xudmFyIGlzb21vcnBoaWNSZWFjdFBhY2thZ2VWZXJzaW9uJGpzY29tcCRpbmxpbmVfMTY4NiA9IFJlYWN0LnZlcnNpb247XG5pZiAoXG4gIFwiMTkuMC4wXCIgIT09XG4gIGlzb21vcnBoaWNSZWFjdFBhY2thZ2VWZXJzaW9uJGpzY29tcCRpbmxpbmVfMTY4NlxuKVxuICB0aHJvdyBFcnJvcihcbiAgICBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKFxuICAgICAgNTI3LFxuICAgICAgaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24kanNjb21wJGlubGluZV8xNjg2LFxuICAgICAgXCIxOS4wLjBcIlxuICAgIClcbiAgKTtcblJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmZpbmRET01Ob2RlID0gZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICB2YXIgZmliZXIgPSBjb21wb25lbnRPckVsZW1lbnQuX3JlYWN0SW50ZXJuYWxzO1xuICBpZiAodm9pZCAwID09PSBmaWJlcikge1xuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyKVxuICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxODgpKTtcbiAgICBjb21wb25lbnRPckVsZW1lbnQgPSBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpLmpvaW4oXCIsXCIpO1xuICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjY4LCBjb21wb25lbnRPckVsZW1lbnQpKTtcbiAgfVxuICBjb21wb25lbnRPckVsZW1lbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcik7XG4gIGNvbXBvbmVudE9yRWxlbWVudCA9XG4gICAgbnVsbCAhPT0gY29tcG9uZW50T3JFbGVtZW50XG4gICAgICA/IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChjb21wb25lbnRPckVsZW1lbnQpXG4gICAgICA6IG51bGw7XG4gIGNvbXBvbmVudE9yRWxlbWVudCA9XG4gICAgbnVsbCA9PT0gY29tcG9uZW50T3JFbGVtZW50ID8gbnVsbCA6IGNvbXBvbmVudE9yRWxlbWVudC5zdGF0ZU5vZGU7XG4gIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG59O1xudmFyIGludGVybmFscyRqc2NvbXAkaW5saW5lXzIxNjUgPSB7XG4gIGJ1bmRsZVR5cGU6IDAsXG4gIHZlcnNpb246IFwiMTkuMC4wXCIsXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6IFwicmVhY3QtZG9tXCIsXG4gIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdFNoYXJlZEludGVybmFscyxcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICByZWNvbmNpbGVyVmVyc2lvbjogXCIxOS4wLjBcIlxufTtcbmlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKSB7XG4gIHZhciBob29rJGpzY29tcCRpbmxpbmVfMjE2NiA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKFxuICAgICFob29rJGpzY29tcCRpbmxpbmVfMjE2Ni5pc0Rpc2FibGVkICYmXG4gICAgaG9vayRqc2NvbXAkaW5saW5lXzIxNjYuc3VwcG9ydHNGaWJlclxuICApXG4gICAgdHJ5IHtcbiAgICAgIChyZW5kZXJlcklEID0gaG9vayRqc2NvbXAkaW5saW5lXzIxNjYuaW5qZWN0KFxuICAgICAgICBpbnRlcm5hbHMkanNjb21wJGlubGluZV8yMTY1XG4gICAgICApKSxcbiAgICAgICAgKGluamVjdGVkSG9vayA9IGhvb2skanNjb21wJGlubGluZV8yMTY2KTtcbiAgICB9IGNhdGNoIChlcnIpIHt9XG59XG5leHBvcnRzLmNyZWF0ZVJvb3QgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5OSkpO1xuICB2YXIgaXNTdHJpY3RNb2RlID0gITEsXG4gICAgaWRlbnRpZmllclByZWZpeCA9IFwiXCIsXG4gICAgb25VbmNhdWdodEVycm9yID0gZGVmYXVsdE9uVW5jYXVnaHRFcnJvcixcbiAgICBvbkNhdWdodEVycm9yID0gZGVmYXVsdE9uQ2F1Z2h0RXJyb3IsXG4gICAgb25SZWNvdmVyYWJsZUVycm9yID0gZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzID0gbnVsbDtcbiAgbnVsbCAhPT0gb3B0aW9ucyAmJlxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucyAmJlxuICAgICghMCA9PT0gb3B0aW9ucy51bnN0YWJsZV9zdHJpY3RNb2RlICYmIChpc1N0cmljdE1vZGUgPSAhMCksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggJiZcbiAgICAgIChpZGVudGlmaWVyUHJlZml4ID0gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4KSxcbiAgICB2b2lkIDAgIT09IG9wdGlvbnMub25VbmNhdWdodEVycm9yICYmXG4gICAgICAob25VbmNhdWdodEVycm9yID0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vbkNhdWdodEVycm9yICYmIChvbkNhdWdodEVycm9yID0gb3B0aW9ucy5vbkNhdWdodEVycm9yKSxcbiAgICB2b2lkIDAgIT09IG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yICYmXG4gICAgICAob25SZWNvdmVyYWJsZUVycm9yID0gb3B0aW9ucy5vblJlY292ZXJhYmxlRXJyb3IpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy51bnN0YWJsZV90cmFuc2l0aW9uQ2FsbGJhY2tzICYmXG4gICAgICAodHJhbnNpdGlvbkNhbGxiYWNrcyA9IG9wdGlvbnMudW5zdGFibGVfdHJhbnNpdGlvbkNhbGxiYWNrcykpO1xuICBvcHRpb25zID0gY3JlYXRlRmliZXJSb290KFxuICAgIGNvbnRhaW5lcixcbiAgICAxLFxuICAgICExLFxuICAgIG51bGwsXG4gICAgbnVsbCxcbiAgICBpc1N0cmljdE1vZGUsXG4gICAgaWRlbnRpZmllclByZWZpeCxcbiAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgb25DYXVnaHRFcnJvcixcbiAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgdHJhbnNpdGlvbkNhbGxiYWNrcyxcbiAgICBudWxsXG4gICk7XG4gIGNvbnRhaW5lcltpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSA9IG9wdGlvbnMuY3VycmVudDtcbiAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMoXG4gICAgOCA9PT0gY29udGFpbmVyLm5vZGVUeXBlID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXJcbiAgKTtcbiAgcmV0dXJuIG5ldyBSZWFjdERPTVJvb3Qob3B0aW9ucyk7XG59O1xuZXhwb3J0cy5oeWRyYXRlUm9vdCA9IGZ1bmN0aW9uIChjb250YWluZXIsIGluaXRpYWxDaGlsZHJlbiwgb3B0aW9ucykge1xuICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOTkpKTtcbiAgdmFyIGlzU3RyaWN0TW9kZSA9ICExLFxuICAgIGlkZW50aWZpZXJQcmVmaXggPSBcIlwiLFxuICAgIG9uVW5jYXVnaHRFcnJvciA9IGRlZmF1bHRPblVuY2F1Z2h0RXJyb3IsXG4gICAgb25DYXVnaHRFcnJvciA9IGRlZmF1bHRPbkNhdWdodEVycm9yLFxuICAgIG9uUmVjb3ZlcmFibGVFcnJvciA9IGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IsXG4gICAgdHJhbnNpdGlvbkNhbGxiYWNrcyA9IG51bGwsXG4gICAgZm9ybVN0YXRlID0gbnVsbDtcbiAgbnVsbCAhPT0gb3B0aW9ucyAmJlxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucyAmJlxuICAgICghMCA9PT0gb3B0aW9ucy51bnN0YWJsZV9zdHJpY3RNb2RlICYmIChpc1N0cmljdE1vZGUgPSAhMCksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggJiZcbiAgICAgIChpZGVudGlmaWVyUHJlZml4ID0gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4KSxcbiAgICB2b2lkIDAgIT09IG9wdGlvbnMub25VbmNhdWdodEVycm9yICYmXG4gICAgICAob25VbmNhdWdodEVycm9yID0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vbkNhdWdodEVycm9yICYmIChvbkNhdWdodEVycm9yID0gb3B0aW9ucy5vbkNhdWdodEVycm9yKSxcbiAgICB2b2lkIDAgIT09IG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yICYmXG4gICAgICAob25SZWNvdmVyYWJsZUVycm9yID0gb3B0aW9ucy5vblJlY292ZXJhYmxlRXJyb3IpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy51bnN0YWJsZV90cmFuc2l0aW9uQ2FsbGJhY2tzICYmXG4gICAgICAodHJhbnNpdGlvbkNhbGxiYWNrcyA9IG9wdGlvbnMudW5zdGFibGVfdHJhbnNpdGlvbkNhbGxiYWNrcyksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLmZvcm1TdGF0ZSAmJiAoZm9ybVN0YXRlID0gb3B0aW9ucy5mb3JtU3RhdGUpKTtcbiAgaW5pdGlhbENoaWxkcmVuID0gY3JlYXRlRmliZXJSb290KFxuICAgIGNvbnRhaW5lcixcbiAgICAxLFxuICAgICEwLFxuICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICBudWxsICE9IG9wdGlvbnMgPyBvcHRpb25zIDogbnVsbCxcbiAgICBpc1N0cmljdE1vZGUsXG4gICAgaWRlbnRpZmllclByZWZpeCxcbiAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgb25DYXVnaHRFcnJvcixcbiAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgdHJhbnNpdGlvbkNhbGxiYWNrcyxcbiAgICBmb3JtU3RhdGVcbiAgKTtcbiAgaW5pdGlhbENoaWxkcmVuLmNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShudWxsKTtcbiAgb3B0aW9ucyA9IGluaXRpYWxDaGlsZHJlbi5jdXJyZW50O1xuICBpc1N0cmljdE1vZGUgPSByZXF1ZXN0VXBkYXRlTGFuZSgpO1xuICBpZGVudGlmaWVyUHJlZml4ID0gY3JlYXRlVXBkYXRlKGlzU3RyaWN0TW9kZSk7XG4gIGlkZW50aWZpZXJQcmVmaXguY2FsbGJhY2sgPSBudWxsO1xuICBlbnF1ZXVlVXBkYXRlKG9wdGlvbnMsIGlkZW50aWZpZXJQcmVmaXgsIGlzU3RyaWN0TW9kZSk7XG4gIGluaXRpYWxDaGlsZHJlbi5jdXJyZW50LmxhbmVzID0gaXNTdHJpY3RNb2RlO1xuICBtYXJrUm9vdFVwZGF0ZWQkMShpbml0aWFsQ2hpbGRyZW4sIGlzU3RyaWN0TW9kZSk7XG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChpbml0aWFsQ2hpbGRyZW4pO1xuICBjb250YWluZXJbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBpbml0aWFsQ2hpbGRyZW4uY3VycmVudDtcbiAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMoY29udGFpbmVyKTtcbiAgcmV0dXJuIG5ldyBSZWFjdERPTUh5ZHJhdGlvblJvb3QoaW5pdGlhbENoaWxkcmVuKTtcbn07XG5leHBvcnRzLnZlcnNpb24gPSBcIjE5LjAuMFwiO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHZhciB1cmwgPSBcImh0dHBzOi8vcmVhY3QuZGV2L2Vycm9ycy9cIiArIGNvZGU7XG4gIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHVybCArPSBcIj9hcmdzW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzWzFdKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIHVybCArPSBcIiZhcmdzW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2ldKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIFwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiICtcbiAgICBjb2RlICtcbiAgICBcIjsgdmlzaXQgXCIgK1xuICAgIHVybCArXG4gICAgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiXG4gICk7XG59XG5mdW5jdGlvbiBub29wKCkge31cbnZhciBJbnRlcm5hbHMgPSB7XG4gICAgZDoge1xuICAgICAgZjogbm9vcCxcbiAgICAgIHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1MjIpKTtcbiAgICAgIH0sXG4gICAgICBEOiBub29wLFxuICAgICAgQzogbm9vcCxcbiAgICAgIEw6IG5vb3AsXG4gICAgICBtOiBub29wLFxuICAgICAgWDogbm9vcCxcbiAgICAgIFM6IG5vb3AsXG4gICAgICBNOiBub29wXG4gICAgfSxcbiAgICBwOiAwLFxuICAgIGZpbmRET01Ob2RlOiBudWxsXG4gIH0sXG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLCBpbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID1cbiAgICAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXSA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleTogbnVsbCA9PSBrZXkgPyBudWxsIDogXCJcIiArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERTtcbmZ1bmN0aW9uIGdldENyb3NzT3JpZ2luU3RyaW5nQXMoYXMsIGlucHV0KSB7XG4gIGlmIChcImZvbnRcIiA9PT0gYXMpIHJldHVybiBcIlwiO1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0KVxuICAgIHJldHVybiBcInVzZS1jcmVkZW50aWFsc1wiID09PSBpbnB1dCA/IGlucHV0IDogXCJcIjtcbn1cbmV4cG9ydHMuX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID1cbiAgSW50ZXJuYWxzO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID1cbiAgICAyIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gIGlmIChcbiAgICAhY29udGFpbmVyIHx8XG4gICAgKDEgIT09IGNvbnRhaW5lci5ub2RlVHlwZSAmJlxuICAgICAgOSAhPT0gY29udGFpbmVyLm5vZGVUeXBlICYmXG4gICAgICAxMSAhPT0gY29udGFpbmVyLm5vZGVUeXBlKVxuICApXG4gICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOTkpKTtcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59O1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHByZXZpb3VzVHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgcHJldmlvdXNVcGRhdGVQcmlvcml0eSA9IEludGVybmFscy5wO1xuICB0cnkge1xuICAgIGlmICgoKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSwgKEludGVybmFscy5wID0gMiksIGZuKSkgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2aW91c1RyYW5zaXRpb24pLFxuICAgICAgKEludGVybmFscy5wID0gcHJldmlvdXNVcGRhdGVQcmlvcml0eSksXG4gICAgICBJbnRlcm5hbHMuZC5mKCk7XG4gIH1cbn07XG5leHBvcnRzLnByZWNvbm5lY3QgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgIChvcHRpb25zXG4gICAgICA/ICgob3B0aW9ucyA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4pLFxuICAgICAgICAob3B0aW9ucyA9XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gb3B0aW9uc1xuICAgICAgICAgICAgICA/IG9wdGlvbnNcbiAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICA6IHZvaWQgMCkpXG4gICAgICA6IChvcHRpb25zID0gbnVsbCksXG4gICAgSW50ZXJuYWxzLmQuQyhocmVmLCBvcHRpb25zKSk7XG59O1xuZXhwb3J0cy5wcmVmZXRjaEROUyA9IGZ1bmN0aW9uIChocmVmKSB7XG4gIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIEludGVybmFscy5kLkQoaHJlZik7XG59O1xuZXhwb3J0cy5wcmVpbml0ID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIG9wdGlvbnMgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMpIHtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzLFxuICAgICAgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKGFzLCBvcHRpb25zLmNyb3NzT3JpZ2luKSxcbiAgICAgIGludGVncml0eSA9XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA/IG9wdGlvbnMuaW50ZWdyaXR5IDogdm9pZCAwLFxuICAgICAgZmV0Y2hQcmlvcml0eSA9XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICA/IG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgIDogdm9pZCAwO1xuICAgIFwic3R5bGVcIiA9PT0gYXNcbiAgICAgID8gSW50ZXJuYWxzLmQuUyhcbiAgICAgICAgICBocmVmLFxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLnByZWNlZGVuY2UgPyBvcHRpb25zLnByZWNlZGVuY2UgOiB2b2lkIDAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgaW50ZWdyaXR5OiBpbnRlZ3JpdHksXG4gICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBmZXRjaFByaW9yaXR5XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICA6IFwic2NyaXB0XCIgPT09IGFzICYmXG4gICAgICAgIEludGVybmFscy5kLlgoaHJlZiwge1xuICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICAgICAgICBmZXRjaFByaW9yaXR5OiBmZXRjaFByaW9yaXR5LFxuICAgICAgICAgIG5vbmNlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gIH1cbn07XG5leHBvcnRzLnByZWluaXRNb2R1bGUgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYpXG4gICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBvcHRpb25zICYmIG51bGwgIT09IG9wdGlvbnMpIHtcbiAgICAgIGlmIChudWxsID09IG9wdGlvbnMuYXMgfHwgXCJzY3JpcHRcIiA9PT0gb3B0aW9ucy5hcykge1xuICAgICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKFxuICAgICAgICAgIG9wdGlvbnMuYXMsXG4gICAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICApO1xuICAgICAgICBJbnRlcm5hbHMuZC5NKGhyZWYsIHtcbiAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDAsXG4gICAgICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgbnVsbCA9PSBvcHRpb25zICYmIEludGVybmFscy5kLk0oaHJlZik7XG59O1xuZXhwb3J0cy5wcmVsb2FkID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgaWYgKFxuICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiZcbiAgICBudWxsICE9PSBvcHRpb25zICYmXG4gICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXNcbiAgKSB7XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcyxcbiAgICAgIGNyb3NzT3JpZ2luID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhhcywgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgSW50ZXJuYWxzLmQuTChocmVmLCBhcywge1xuICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgaW50ZWdyaXR5OlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPyBvcHRpb25zLmludGVncml0eSA6IHZvaWQgMCxcbiAgICAgIG5vbmNlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDAsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy50eXBlID8gb3B0aW9ucy50eXBlIDogdm9pZCAwLFxuICAgICAgZmV0Y2hQcmlvcml0eTpcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgID8gb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgOiB2b2lkIDAsXG4gICAgICByZWZlcnJlclBvbGljeTpcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICA/IG9wdGlvbnMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgIGltYWdlU3JjU2V0OlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNyY1NldCA/IG9wdGlvbnMuaW1hZ2VTcmNTZXQgOiB2b2lkIDAsXG4gICAgICBpbWFnZVNpemVzOlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNpemVzID8gb3B0aW9ucy5pbWFnZVNpemVzIDogdm9pZCAwLFxuICAgICAgbWVkaWE6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm1lZGlhID8gb3B0aW9ucy5tZWRpYSA6IHZvaWQgMFxuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0cy5wcmVsb2FkTW9kdWxlID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmKVxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKG9wdGlvbnMuYXMsIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgSW50ZXJuYWxzLmQubShocmVmLCB7XG4gICAgICAgIGFzOlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzICYmIFwic2NyaXB0XCIgIT09IG9wdGlvbnMuYXNcbiAgICAgICAgICAgID8gb3B0aW9ucy5hc1xuICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA/IG9wdGlvbnMuaW50ZWdyaXR5IDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2UgSW50ZXJuYWxzLmQubShocmVmKTtcbn07XG5leHBvcnRzLnJlcXVlc3RGb3JtUmVzZXQgPSBmdW5jdGlvbiAoZm9ybSkge1xuICBJbnRlcm5hbHMuZC5yKGZvcm0pO1xufTtcbmV4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoZm4sIGEpIHtcbiAgcmV0dXJuIGZuKGEpO1xufTtcbmV4cG9ydHMudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspO1xufTtcbmV4cG9ydHMudXNlRm9ybVN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMoKTtcbn07XG5leHBvcnRzLnZlcnNpb24gPSBcIjE5LjAuMFwiO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLWNsaWVudC5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1jbGllbnQuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpO1xuZnVuY3Rpb24ganN4UHJvZCh0eXBlLCBjb25maWcsIG1heWJlS2V5KSB7XG4gIHZhciBrZXkgPSBudWxsO1xuICB2b2lkIDAgIT09IG1heWJlS2V5ICYmIChrZXkgPSBcIlwiICsgbWF5YmVLZXkpO1xuICB2b2lkIDAgIT09IGNvbmZpZy5rZXkgJiYgKGtleSA9IFwiXCIgKyBjb25maWcua2V5KTtcbiAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgbWF5YmVLZXkgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgY29uZmlnID0gbWF5YmVLZXkucmVmO1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHZvaWQgMCAhPT0gY29uZmlnID8gY29uZmlnIDogbnVsbCxcbiAgICBwcm9wczogbWF5YmVLZXlcbiAgfTtcbn1cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3ggPSBqc3hQcm9kO1xuZXhwb3J0cy5qc3hzID0ganN4UHJvZDtcbiIsIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LnByb2R1Y3Rpb24uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG51bGwgPT09IG1heWJlSXRlcmFibGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG1heWJlSXRlcmFibGUpIHJldHVybiBudWxsO1xuICBtYXliZUl0ZXJhYmxlID1cbiAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICBtYXliZUl0ZXJhYmxlW1wiQEBpdGVyYXRvclwiXTtcbiAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlSXRlcmFibGUgPyBtYXliZUl0ZXJhYmxlIDogbnVsbDtcbn1cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoKSB7fVxuICB9LFxuICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICBlbXB0eU9iamVjdCA9IHt9O1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoXG4gICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSAmJlxuICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSAmJlxuICAgIG51bGwgIT0gcGFydGlhbFN0YXRlXG4gIClcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwidGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCJcbiAgICApO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIFwic2V0U3RhdGVcIik7XG59O1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCBcImZvcmNlVXBkYXRlXCIpO1xufTtcbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IChQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50O1xuYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9ICEwO1xudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7IEg6IG51bGwsIEE6IG51bGwsIFQ6IG51bGwsIFM6IG51bGwgfSxcbiAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgc2VsZiA9IHByb3BzLnJlZjtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiB2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbCxcbiAgICBwcm9wczogcHJvcHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICBvbGRFbGVtZW50LnR5cGUsXG4gICAgbmV3S2V5LFxuICAgIHZvaWQgMCxcbiAgICB2b2lkIDAsXG4gICAgdm9pZCAwLFxuICAgIG9sZEVsZW1lbnQucHJvcHNcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gKFxuICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvYmplY3QgJiZcbiAgICBudWxsICE9PSBvYmplY3QgJiZcbiAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHsgXCI9XCI6IFwiPTBcIiwgXCI6XCI6IFwiPTJcIiB9O1xuICByZXR1cm4gKFxuICAgIFwiJFwiICtcbiAgICBrZXkucmVwbGFjZSgvWz06XS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgICB9KVxuICApO1xufVxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgcmV0dXJuIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlbGVtZW50ICYmIG51bGwgIT09IGVsZW1lbnQgJiYgbnVsbCAhPSBlbGVtZW50LmtleVxuICAgID8gZXNjYXBlKFwiXCIgKyBlbGVtZW50LmtleSlcbiAgICA6IGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5mdW5jdGlvbiByZXNvbHZlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICB0aHJvdyB0aGVuYWJsZS5yZWFzb247XG4gICAgZGVmYXVsdDpcbiAgICAgIHN3aXRjaCAoXG4gICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgdGhlbmFibGUuc3RhdHVzXG4gICAgICAgICAgPyB0aGVuYWJsZS50aGVuKG5vb3AkMSwgbm9vcCQxKVxuICAgICAgICAgIDogKCh0aGVuYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIiksXG4gICAgICAgICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAoKHRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgKHRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWUpKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLCAodGhlbmFibGUucmVhc29uID0gZXJyb3IpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSksXG4gICAgICAgIHRoZW5hYmxlLnN0YXR1cylcbiAgICAgICkge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICB0aHJvdyB0aGVuYWJsZS5yZWFzb247XG4gICAgICB9XG4gIH1cbiAgdGhyb3cgdGhlbmFibGU7XG59XG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZSB8fCBcImJvb2xlYW5cIiA9PT0gdHlwZSkgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSAhMTtcbiAgaWYgKG51bGwgPT09IGNoaWxkcmVuKSBpbnZva2VDYWxsYmFjayA9ICEwO1xuICBlbHNlXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gITA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gITA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbnZva2VDYWxsYmFjayA9IGNoaWxkcmVuLl9pbml0KSxcbiAgICAgICAgICAgICAgbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKGNoaWxkcmVuLl9wYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBhcnJheSxcbiAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICBpZiAoaW52b2tlQ2FsbGJhY2spXG4gICAgcmV0dXJuIChcbiAgICAgIChjYWxsYmFjayA9IGNhbGxiYWNrKGNoaWxkcmVuKSksXG4gICAgICAoaW52b2tlQ2FsbGJhY2sgPVxuICAgICAgICBcIlwiID09PSBuYW1lU29GYXIgPyBcIi5cIiArIGdldEVsZW1lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKSxcbiAgICAgIGlzQXJyYXlJbXBsKGNhbGxiYWNrKVxuICAgICAgICA/ICgoZXNjYXBlZFByZWZpeCA9IFwiXCIpLFxuICAgICAgICAgIG51bGwgIT0gaW52b2tlQ2FsbGJhY2sgJiZcbiAgICAgICAgICAgIChlc2NhcGVkUHJlZml4ID1cbiAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgXCIkJi9cIikgKyBcIi9cIiksXG4gICAgICAgICAgbWFwSW50b0FycmF5KGNhbGxiYWNrLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgXCJcIiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgIH0pKVxuICAgICAgICA6IG51bGwgIT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAoaXNWYWxpZEVsZW1lbnQoY2FsbGJhY2spICYmXG4gICAgICAgICAgICAoY2FsbGJhY2sgPSBjbG9uZUFuZFJlcGxhY2VLZXkoXG4gICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4ICtcbiAgICAgICAgICAgICAgICAobnVsbCA9PSBjYWxsYmFjay5rZXkgfHxcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ua2V5ID09PSBjYWxsYmFjay5rZXkpXG4gICAgICAgICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgICAgICAgIDogKFwiXCIgKyBjYWxsYmFjay5rZXkpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsXG4gICAgICAgICAgICAgICAgICAgICAgXCIkJi9cIlxuICAgICAgICAgICAgICAgICAgICApICsgXCIvXCIpICtcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFja1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgYXJyYXkucHVzaChjYWxsYmFjaykpLFxuICAgICAgMVxuICAgICk7XG4gIGludm9rZUNhbGxiYWNrID0gMDtcbiAgdmFyIG5leHROYW1lUHJlZml4ID0gXCJcIiA9PT0gbmFtZVNvRmFyID8gXCIuXCIgOiBuYW1lU29GYXIgKyBcIjpcIjtcbiAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgKG5hbWVTb0ZhciA9IGNoaWxkcmVuW2ldKSxcbiAgICAgICAgKHR5cGUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKSksXG4gICAgICAgIChpbnZva2VDYWxsYmFjayArPSBtYXBJbnRvQXJyYXkoXG4gICAgICAgICAgbmFtZVNvRmFyLFxuICAgICAgICAgIGFycmF5LFxuICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBjYWxsYmFja1xuICAgICAgICApKTtcbiAgZWxzZSBpZiAoKChpID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbikpLCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpKSlcbiAgICBmb3IgKFxuICAgICAgY2hpbGRyZW4gPSBpLmNhbGwoY2hpbGRyZW4pLCBpID0gMDtcbiAgICAgICEobmFtZVNvRmFyID0gY2hpbGRyZW4ubmV4dCgpKS5kb25lO1xuXG4gICAgKVxuICAgICAgKG5hbWVTb0ZhciA9IG5hbWVTb0Zhci52YWx1ZSksXG4gICAgICAgICh0eXBlID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KG5hbWVTb0ZhciwgaSsrKSksXG4gICAgICAgIChpbnZva2VDYWxsYmFjayArPSBtYXBJbnRvQXJyYXkoXG4gICAgICAgICAgbmFtZVNvRmFyLFxuICAgICAgICAgIGFycmF5LFxuICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBjYWxsYmFja1xuICAgICAgICApKTtcbiAgZWxzZSBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZSkge1xuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZHJlbi50aGVuKVxuICAgICAgcmV0dXJuIG1hcEludG9BcnJheShcbiAgICAgICAgcmVzb2x2ZVRoZW5hYmxlKGNoaWxkcmVuKSxcbiAgICAgICAgYXJyYXksXG4gICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgYXJyYXkgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgIHRocm93IEVycm9yKFxuICAgICAgXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICtcbiAgICAgICAgKFwiW29iamVjdCBPYmplY3RdXCIgPT09IGFycmF5XG4gICAgICAgICAgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgOiBhcnJheSkgK1xuICAgICAgICBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGludm9rZUNhbGxiYWNrO1xufVxuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKG51bGwgPT0gY2hpbGRyZW4pIHJldHVybiBjaGlsZHJlbjtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsIFwiXCIsIFwiXCIsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmICgtMSA9PT0gcGF5bG9hZC5fc3RhdHVzKSB7XG4gICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgY3RvciA9IGN0b3IoKTtcbiAgICBjdG9yLnRoZW4oXG4gICAgICBmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICAgIGlmICgwID09PSBwYXlsb2FkLl9zdGF0dXMgfHwgLTEgPT09IHBheWxvYWQuX3N0YXR1cylcbiAgICAgICAgICAocGF5bG9hZC5fc3RhdHVzID0gMSksIChwYXlsb2FkLl9yZXN1bHQgPSBtb2R1bGVPYmplY3QpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAoMCA9PT0gcGF5bG9hZC5fc3RhdHVzIHx8IC0xID09PSBwYXlsb2FkLl9zdGF0dXMpXG4gICAgICAgICAgKHBheWxvYWQuX3N0YXR1cyA9IDIpLCAocGF5bG9hZC5fcmVzdWx0ID0gZXJyb3IpO1xuICAgICAgfVxuICAgICk7XG4gICAgLTEgPT09IHBheWxvYWQuX3N0YXR1cyAmJiAoKHBheWxvYWQuX3N0YXR1cyA9IDApLCAocGF5bG9hZC5fcmVzdWx0ID0gY3RvcikpO1xuICB9XG4gIGlmICgxID09PSBwYXlsb2FkLl9zdGF0dXMpIHJldHVybiBwYXlsb2FkLl9yZXN1bHQuZGVmYXVsdDtcbiAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xufVxudmFyIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICA/IHJlcG9ydEVycm9yXG4gICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9O1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5leHBvcnRzLkNoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmdW5jdGlvbiAoY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICAgIG1hcENoaWxkcmVuKFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgZm9yRWFjaENvbnRleHRcbiAgICApO1xuICB9LFxuICBjb3VudDogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgdmFyIG4gPSAwO1xuICAgIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgICBuKys7XG4gICAgfSk7XG4gICAgcmV0dXJuIG47XG4gIH0sXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIHJldHVybiAoXG4gICAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0pIHx8IFtdXG4gICAgKTtcbiAgfSxcbiAgb25seTogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpXG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIlxuICAgICAgKTtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbn07XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5Qcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG5leHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuZXhwb3J0cy5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgPVxuICBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuYWN0ID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBFcnJvcihcImFjdCguLi4pIGlzIG5vdCBzdXBwb3J0ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMgb2YgUmVhY3QuXCIpO1xufTtcbmV4cG9ydHMuY2FjaGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmIChudWxsID09PSBlbGVtZW50IHx8IHZvaWQgMCA9PT0gZWxlbWVudClcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwiVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIlxuICAgICk7XG4gIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyksXG4gICAga2V5ID0gZWxlbWVudC5rZXksXG4gICAgb3duZXIgPSB2b2lkIDA7XG4gIGlmIChudWxsICE9IGNvbmZpZylcbiAgICBmb3IgKHByb3BOYW1lIGluICh2b2lkIDAgIT09IGNvbmZpZy5yZWYgJiYgKG93bmVyID0gdm9pZCAwKSxcbiAgICB2b2lkIDAgIT09IGNvbmZpZy5rZXkgJiYgKGtleSA9IFwiXCIgKyBjb25maWcua2V5KSxcbiAgICBjb25maWcpKVxuICAgICAgIWhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgfHxcbiAgICAgICAgXCJrZXlcIiA9PT0gcHJvcE5hbWUgfHxcbiAgICAgICAgXCJfX3NlbGZcIiA9PT0gcHJvcE5hbWUgfHxcbiAgICAgICAgXCJfX3NvdXJjZVwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAoXCJyZWZcIiA9PT0gcHJvcE5hbWUgJiYgdm9pZCAwID09PSBjb25maWcucmVmKSB8fFxuICAgICAgICAocHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gIHZhciBwcm9wTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoMSA9PT0gcHJvcE5hbWUpIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIGVsc2UgaWYgKDEgPCBwcm9wTmFtZSkge1xuICAgIGZvciAodmFyIGNoaWxkQXJyYXkgPSBBcnJheShwcm9wTmFtZSksIGkgPSAwOyBpIDwgcHJvcE5hbWU7IGkrKylcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCB2b2lkIDAsIHZvaWQgMCwgb3duZXIsIHByb3BzKTtcbn07XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoZGVmYXVsdFZhbHVlKSB7XG4gIGRlZmF1bHRWYWx1ZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBkZWZhdWx0VmFsdWUuUHJvdmlkZXIgPSBkZWZhdWx0VmFsdWU7XG4gIGRlZmF1bHRWYWx1ZS5Db25zdW1lciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OU1VNRVJfVFlQRSxcbiAgICBfY29udGV4dDogZGVmYXVsdFZhbHVlXG4gIH07XG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lLFxuICAgIHByb3BzID0ge30sXG4gICAga2V5ID0gbnVsbDtcbiAgaWYgKG51bGwgIT0gY29uZmlnKVxuICAgIGZvciAocHJvcE5hbWUgaW4gKHZvaWQgMCAhPT0gY29uZmlnLmtleSAmJiAoa2V5ID0gXCJcIiArIGNvbmZpZy5rZXkpLCBjb25maWcpKVxuICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJlxuICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICBcIl9fc2VsZlwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICBcIl9fc291cmNlXCIgIT09IHByb3BOYW1lICYmXG4gICAgICAgIChwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmICgxID09PSBjaGlsZHJlbkxlbmd0aCkgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgZWxzZSBpZiAoMSA8IGNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKSwgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKVxuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKVxuICAgIGZvciAocHJvcE5hbWUgaW4gKChjaGlsZHJlbkxlbmd0aCA9IHR5cGUuZGVmYXVsdFByb3BzKSwgY2hpbGRyZW5MZW5ndGgpKVxuICAgICAgdm9pZCAwID09PSBwcm9wc1twcm9wTmFtZV0gJiZcbiAgICAgICAgKHByb3BzW3Byb3BOYW1lXSA9IGNoaWxkcmVuTGVuZ3RoW3Byb3BOYW1lXSk7XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCB2b2lkIDAsIHZvaWQgMCwgbnVsbCwgcHJvcHMpO1xufTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4geyBjdXJyZW50OiBudWxsIH07XG59O1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZnVuY3Rpb24gKHJlbmRlcikge1xuICByZXR1cm4geyAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSwgcmVuZGVyOiByZW5kZXIgfTtcbn07XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBmdW5jdGlvbiAoY3Rvcikge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHsgX3N0YXR1czogLTEsIF9yZXN1bHQ6IGN0b3IgfSxcbiAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gIH07XG59O1xuZXhwb3J0cy5tZW1vID0gZnVuY3Rpb24gKHR5cGUsIGNvbXBhcmUpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogdm9pZCAwID09PSBjb21wYXJlID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcbn07XG5leHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChzY29wZSkge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgdHJ5IHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBzY29wZSgpLFxuICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gJiZcbiAgICAgIHJldHVyblZhbHVlLnRoZW4obm9vcCwgcmVwb3J0R2xvYmFsRXJyb3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG4gIH1cbn07XG5leHBvcnRzLnVuc3RhYmxlX3VzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlQ2FjaGVSZWZyZXNoKCk7XG59O1xuZXhwb3J0cy51c2UgPSBmdW5jdGlvbiAodXNhYmxlKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZSh1c2FibGUpO1xufTtcbmV4cG9ydHMudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKTtcbn07XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn07XG5leHBvcnRzLnVzZUNvbnRleHQgPSBmdW5jdGlvbiAoQ29udGV4dCkge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VDb250ZXh0KENvbnRleHQpO1xufTtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy51c2VEZWZlcnJlZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbn07XG5leHBvcnRzLnVzZUVmZmVjdCA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59O1xuZXhwb3J0cy51c2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlSWQoKTtcbn07XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59O1xuZXhwb3J0cy51c2VJbnNlcnRpb25FZmZlY3QgPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xufTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn07XG5leHBvcnRzLnVzZU1lbW8gPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn07XG5leHBvcnRzLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG59O1xuZXhwb3J0cy51c2VSZWR1Y2VyID0gZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn07XG5leHBvcnRzLnVzZVJlZiA9IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59O1xuZXhwb3J0cy51c2VTdGF0ZSA9IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn07XG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gZnVuY3Rpb24gKFxuICBzdWJzY3JpYmUsXG4gIGdldFNuYXBzaG90LFxuICBnZXRTZXJ2ZXJTbmFwc2hvdFxuKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTbmFwc2hvdCxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICApO1xufTtcbmV4cG9ydHMudXNlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlVHJhbnNpdGlvbigpO1xufTtcbmV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMC4wXCI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHNjaGVkdWxlci5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHB1c2goaGVhcCwgbm9kZSkge1xuICB2YXIgaW5kZXggPSBoZWFwLmxlbmd0aDtcbiAgaGVhcC5wdXNoKG5vZGUpO1xuICBhOiBmb3IgKDsgMCA8IGluZGV4OyApIHtcbiAgICB2YXIgcGFyZW50SW5kZXggPSAoaW5kZXggLSAxKSA+Pj4gMSxcbiAgICAgIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuICAgIGlmICgwIDwgY29tcGFyZShwYXJlbnQsIG5vZGUpKVxuICAgICAgKGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZSksIChoZWFwW2luZGV4XSA9IHBhcmVudCksIChpbmRleCA9IHBhcmVudEluZGV4KTtcbiAgICBlbHNlIGJyZWFrIGE7XG4gIH1cbn1cbmZ1bmN0aW9uIHBlZWsoaGVhcCkge1xuICByZXR1cm4gMCA9PT0gaGVhcC5sZW5ndGggPyBudWxsIDogaGVhcFswXTtcbn1cbmZ1bmN0aW9uIHBvcChoZWFwKSB7XG4gIGlmICgwID09PSBoZWFwLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gIHZhciBmaXJzdCA9IGhlYXBbMF0sXG4gICAgbGFzdCA9IGhlYXAucG9wKCk7XG4gIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuICAgIGhlYXBbMF0gPSBsYXN0O1xuICAgIGE6IGZvciAoXG4gICAgICB2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBoZWFwLmxlbmd0aCwgaGFsZkxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgICAgIGluZGV4IDwgaGFsZkxlbmd0aDtcblxuICAgICkge1xuICAgICAgdmFyIGxlZnRJbmRleCA9IDIgKiAoaW5kZXggKyAxKSAtIDEsXG4gICAgICAgIGxlZnQgPSBoZWFwW2xlZnRJbmRleF0sXG4gICAgICAgIHJpZ2h0SW5kZXggPSBsZWZ0SW5kZXggKyAxLFxuICAgICAgICByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07XG4gICAgICBpZiAoMCA+IGNvbXBhcmUobGVmdCwgbGFzdCkpXG4gICAgICAgIHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgMCA+IGNvbXBhcmUocmlnaHQsIGxlZnQpXG4gICAgICAgICAgPyAoKGhlYXBbaW5kZXhdID0gcmlnaHQpLFxuICAgICAgICAgICAgKGhlYXBbcmlnaHRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgIChpbmRleCA9IHJpZ2h0SW5kZXgpKVxuICAgICAgICAgIDogKChoZWFwW2luZGV4XSA9IGxlZnQpLFxuICAgICAgICAgICAgKGhlYXBbbGVmdEluZGV4XSA9IGxhc3QpLFxuICAgICAgICAgICAgKGluZGV4ID0gbGVmdEluZGV4KSk7XG4gICAgICBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIDAgPiBjb21wYXJlKHJpZ2h0LCBsYXN0KSlcbiAgICAgICAgKGhlYXBbaW5kZXhdID0gcmlnaHQpLCAoaGVhcFtyaWdodEluZGV4XSA9IGxhc3QpLCAoaW5kZXggPSByaWdodEluZGV4KTtcbiAgICAgIGVsc2UgYnJlYWsgYTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpcnN0O1xufVxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIHZhciBkaWZmID0gYS5zb3J0SW5kZXggLSBiLnNvcnRJbmRleDtcbiAgcmV0dXJuIDAgIT09IGRpZmYgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG59XG5leHBvcnRzLnVuc3RhYmxlX25vdyA9IHZvaWQgMDtcbmlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2UgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2Uubm93KSB7XG4gIHZhciBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGxvY2FsRGF0ZSA9IERhdGUsXG4gICAgaW5pdGlhbFRpbWUgPSBsb2NhbERhdGUubm93KCk7XG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgfTtcbn1cbnZhciB0YXNrUXVldWUgPSBbXSxcbiAgdGltZXJRdWV1ZSA9IFtdLFxuICB0YXNrSWRDb3VudGVyID0gMSxcbiAgY3VycmVudFRhc2sgPSBudWxsLFxuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IDMsXG4gIGlzUGVyZm9ybWluZ1dvcmsgPSAhMSxcbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMSxcbiAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICExLFxuICBsb2NhbFNldFRpbWVvdXQgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBzZXRUaW1lb3V0ID8gc2V0VGltZW91dCA6IG51bGwsXG4gIGxvY2FsQ2xlYXJUaW1lb3V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogbnVsbCxcbiAgbG9jYWxTZXRJbW1lZGlhdGUgPSBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2Ygc2V0SW1tZWRpYXRlID8gc2V0SW1tZWRpYXRlIDogbnVsbDtcbmZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcbiAgZm9yICh2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpOyBudWxsICE9PSB0aW1lcjsgKSB7XG4gICAgaWYgKG51bGwgPT09IHRpbWVyLmNhbGxiYWNrKSBwb3AodGltZXJRdWV1ZSk7XG4gICAgZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKVxuICAgICAgcG9wKHRpbWVyUXVldWUpLFxuICAgICAgICAodGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWUpLFxuICAgICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgIGVsc2UgYnJlYWs7XG4gICAgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVUaW1lb3V0KGN1cnJlbnRUaW1lKSB7XG4gIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpXG4gICAgaWYgKG51bGwgIT09IHBlZWsodGFza1F1ZXVlKSlcbiAgICAgIChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgbnVsbCAhPT0gZmlyc3RUaW1lciAmJlxuICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxufVxudmFyIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITEsXG4gIHRhc2tUaW1lb3V0SUQgPSAtMSxcbiAgZnJhbWVJbnRlcnZhbCA9IDUsXG4gIHN0YXJ0VGltZSA9IC0xO1xuZnVuY3Rpb24gc2hvdWxkWWllbGRUb0hvc3QoKSB7XG4gIHJldHVybiBleHBvcnRzLnVuc3RhYmxlX25vdygpIC0gc3RhcnRUaW1lIDwgZnJhbWVJbnRlcnZhbCA/ICExIDogITA7XG59XG5mdW5jdGlvbiBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKSB7XG4gIGlmIChpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdmFyIGhhc01vcmVXb3JrID0gITA7XG4gICAgdHJ5IHtcbiAgICAgIGE6IHtcbiAgICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMTtcbiAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCAmJlxuICAgICAgICAgICgoaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICExKSxcbiAgICAgICAgICBsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKSxcbiAgICAgICAgICAodGFza1RpbWVvdXRJRCA9IC0xKSk7XG4gICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgPSAhMDtcbiAgICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGI6IHtcbiAgICAgICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRUYXNrICYmXG4gICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPiBjdXJyZW50VGltZSAmJiBzaG91bGRZaWVsZFRvSG9zdCgpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBjdXJyZW50VGFzay5jYWxsYmFjaztcbiAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgY29udGludWF0aW9uQ2FsbGJhY2sgPSBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSAmJiBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50VGFzaykgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICAgICAgICAgIG51bGwgIT09IGZpcnN0VGltZXIgJiZcbiAgICAgICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICBoYW5kbGVUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGhhc01vcmVXb3JrID0gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgKGN1cnJlbnRUYXNrID0gbnVsbCksXG4gICAgICAgICAgICAoY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWwpLFxuICAgICAgICAgICAgKGlzUGVyZm9ybWluZ1dvcmsgPSAhMSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzTW9yZVdvcmsgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGhhc01vcmVXb3JrXG4gICAgICAgID8gc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKVxuICAgICAgICA6IChpc01lc3NhZ2VMb29wUnVubmluZyA9ICExKTtcbiAgICB9XG4gIH1cbn1cbnZhciBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbmlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsb2NhbFNldEltbWVkaWF0ZSlcbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYWxTZXRJbW1lZGlhdGUocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKTtcbiAgfTtcbmVsc2UgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpLFxuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgfTtcbn0gZWxzZVxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhbFNldFRpbWVvdXQocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lLCAwKTtcbiAgfTtcbmZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soKSB7XG4gIGlzTWVzc2FnZUxvb3BSdW5uaW5nIHx8XG4gICAgKChpc01lc3NhZ2VMb29wUnVubmluZyA9ICEwKSwgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKSk7XG59XG5mdW5jdGlvbiByZXF1ZXN0SG9zdFRpbWVvdXQoY2FsbGJhY2ssIG1zKSB7XG4gIHRhc2tUaW1lb3V0SUQgPSBsb2NhbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICB9LCBtcyk7XG59XG5leHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IDU7XG5leHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5ID0gMTtcbmV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSA0O1xuZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IDM7XG5leHBvcnRzLnVuc3RhYmxlX1Byb2ZpbGluZyA9IG51bGw7XG5leHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbmV4cG9ydHMudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sgPSBmdW5jdGlvbiAodGFzaykge1xuICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbn07XG5leHBvcnRzLnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uID0gZnVuY3Rpb24gKCkge1xuICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCB8fFxuICAgIGlzUGVyZm9ybWluZ1dvcmsgfHxcbiAgICAoKGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITApLCByZXF1ZXN0SG9zdENhbGxiYWNrKCkpO1xufTtcbmV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoZnBzKSB7XG4gIDAgPiBmcHMgfHwgMTI1IDwgZnBzXG4gICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICBcImZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCBmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZFwiXG4gICAgICApXG4gICAgOiAoZnJhbWVJbnRlcnZhbCA9IDAgPCBmcHMgPyBNYXRoLmZsb29yKDFlMyAvIGZwcykgOiA1KTtcbn07XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY3VycmVudFByaW9yaXR5TGV2ZWw7XG59O1xuZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHBlZWsodGFza1F1ZXVlKTtcbn07XG5leHBvcnRzLnVuc3RhYmxlX25leHQgPSBmdW5jdGlvbiAoZXZlbnRIYW5kbGVyKSB7XG4gIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAyOlxuICAgIGNhc2UgMzpcbiAgICAgIHZhciBwcmlvcml0eUxldmVsID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIH1cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59O1xuZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAyOlxuICAgIGNhc2UgMzpcbiAgICBjYXNlIDQ6XG4gICAgY2FzZSA1OlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSAzO1xuICB9XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufTtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IGZ1bmN0aW9uIChcbiAgcHJpb3JpdHlMZXZlbCxcbiAgY2FsbGJhY2ssXG4gIG9wdGlvbnNcbikge1xuICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJiBudWxsICE9PSBvcHRpb25zXG4gICAgPyAoKG9wdGlvbnMgPSBvcHRpb25zLmRlbGF5KSxcbiAgICAgIChvcHRpb25zID1cbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgMCA8IG9wdGlvbnNcbiAgICAgICAgICA/IGN1cnJlbnRUaW1lICsgb3B0aW9uc1xuICAgICAgICAgIDogY3VycmVudFRpbWUpKVxuICAgIDogKG9wdGlvbnMgPSBjdXJyZW50VGltZSk7XG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHZhciB0aW1lb3V0ID0gLTE7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICB0aW1lb3V0ID0gMjUwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgdGltZW91dCA9IDEwNzM3NDE4MjM7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICB0aW1lb3V0ID0gMWU0O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRpbWVvdXQgPSA1ZTM7XG4gIH1cbiAgdGltZW91dCA9IG9wdGlvbnMgKyB0aW1lb3V0O1xuICBwcmlvcml0eUxldmVsID0ge1xuICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgc3RhcnRUaW1lOiBvcHRpb25zLFxuICAgIGV4cGlyYXRpb25UaW1lOiB0aW1lb3V0LFxuICAgIHNvcnRJbmRleDogLTFcbiAgfTtcbiAgb3B0aW9ucyA+IGN1cnJlbnRUaW1lXG4gICAgPyAoKHByaW9yaXR5TGV2ZWwuc29ydEluZGV4ID0gb3B0aW9ucyksXG4gICAgICBwdXNoKHRpbWVyUXVldWUsIHByaW9yaXR5TGV2ZWwpLFxuICAgICAgbnVsbCA9PT0gcGVlayh0YXNrUXVldWUpICYmXG4gICAgICAgIHByaW9yaXR5TGV2ZWwgPT09IHBlZWsodGltZXJRdWV1ZSkgJiZcbiAgICAgICAgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWRcbiAgICAgICAgICA/IChsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKSwgKHRhc2tUaW1lb3V0SUQgPSAtMSkpXG4gICAgICAgICAgOiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIG9wdGlvbnMgLSBjdXJyZW50VGltZSkpKVxuICAgIDogKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IHRpbWVvdXQpLFxuICAgICAgcHVzaCh0YXNrUXVldWUsIHByaW9yaXR5TGV2ZWwpLFxuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgfHxcbiAgICAgICAgaXNQZXJmb3JtaW5nV29yayB8fFxuICAgICAgICAoKGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITApLCByZXF1ZXN0SG9zdENhbGxiYWNrKCkpKTtcbiAgcmV0dXJuIHByaW9yaXR5TGV2ZWw7XG59O1xuZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCA9IHNob3VsZFlpZWxkVG9Ib3N0O1xuZXhwb3J0cy51bnN0YWJsZV93cmFwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgfVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbn1cbnZhciBvYmplY3RJcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IGlzLFxuICB1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlLFxuICB1c2VFZmZlY3QgPSBSZWFjdC51c2VFZmZlY3QsXG4gIHVzZUxheW91dEVmZmVjdCA9IFJlYWN0LnVzZUxheW91dEVmZmVjdCxcbiAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpIHtcbiAgdmFyIHZhbHVlID0gZ2V0U25hcHNob3QoKSxcbiAgICBfdXNlU3RhdGUgPSB1c2VTdGF0ZSh7IGluc3Q6IHsgdmFsdWU6IHZhbHVlLCBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QgfSB9KSxcbiAgICBpbnN0ID0gX3VzZVN0YXRlWzBdLmluc3QsXG4gICAgZm9yY2VVcGRhdGUgPSBfdXNlU3RhdGVbMV07XG4gIHVzZUxheW91dEVmZmVjdChcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gICAgICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7XG4gICAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlVXBkYXRlKHsgaW5zdDogaW5zdCB9KTtcbiAgICB9LFxuICAgIFtzdWJzY3JpYmUsIHZhbHVlLCBnZXRTbmFwc2hvdF1cbiAgKTtcbiAgdXNlRWZmZWN0KFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VVcGRhdGUoeyBpbnN0OiBpbnN0IH0pO1xuICAgICAgcmV0dXJuIHN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VVcGRhdGUoeyBpbnN0OiBpbnN0IH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbc3Vic2NyaWJlXVxuICApO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gIGluc3QgPSBpbnN0LnZhbHVlO1xuICB0cnkge1xuICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgIHJldHVybiAhb2JqZWN0SXMoaW5zdCwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCkge1xuICByZXR1cm4gZ2V0U25hcHNob3QoKTtcbn1cbnZhciBzaGltID1cbiAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHdpbmRvdyB8fFxuICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93LmRvY3VtZW50IHx8XG4gIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudFxuICAgID8gdXNlU3luY0V4dGVybmFsU3RvcmUkMVxuICAgIDogdXNlU3luY0V4dGVybmFsU3RvcmUkMjtcbmV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmUgPVxuICB2b2lkIDAgIT09IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NDUklQVCcpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkge1xuXHRcdFx0dmFyIGkgPSBzY3JpcHRzLmxlbmd0aCAtIDE7XG5cdFx0XHR3aGlsZSAoaSA+IC0xICYmICghc2NyaXB0VXJsIHx8ICEvXmh0dHAocz8pOi8udGVzdChzY3JpcHRVcmwpKSkgc2NyaXB0VXJsID0gc2NyaXB0c1tpLS1dLnNyYztcblx0XHR9XG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxudmFyIF8xID0gXCJ2MjJVN21NWGkxZnRLQ05DM0hoUFwiO1xudmFyIF8yID0gXCJfUnJOT3FKY2R6QjEwYnB1cjlqNVwiO1xudmFyIF8zID0gXCJibW04OW42WV9WUU1Wd0g3MDI3R1wiO1xuZXhwb3J0IHsgXzEgYXMgXCJjb250YWluZXJcIiwgXzIgYXMgXCJsb2dvXCIsIF8zIGFzIFwibmF2aWdhdGlvblwiIH1cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxudmFyIF8xID0gXCJLUmI4MXA1YW44ZldhM2k5RG5LV1wiO1xudmFyIF8yID0gXCJocGFsVlFoX2k3MmFyMk84bWFkNVwiO1xudmFyIF8zID0gXCJnR3NFYlNuZ0c2aldXOTVFeUlwVlwiO1xudmFyIF80ID0gXCJGYkt1cEdpYmV0T2hrNGVfZEdUV1wiO1xuZXhwb3J0IHsgXzEgYXMgXCJmYWRlX291dFwiLCBfMiBhcyBcIm1vdXNlX292ZXJfY29udGFpbmVyXCIsIF8zIGFzIFwic2hvd1wiLCBfNCBhcyBcInRvb2x0aXBcIiB9XG4iLCJpbXBvcnQgKiBhcyBzIGZyb20gJy4vVG9vbHRpcC5jc3MnXG5pbXBvcnQge1Byb3BzV2l0aENoaWxkcmVuLCB1c2VSZWYsIHVzZVN0YXRlfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7Y3JlYXRlUG9ydGFsfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5cbnR5cGUgUHJvcHMgPSB7XG4gICAgdGl0bGU6IHN0cmluZ1xufVxuXG50eXBlIENvb3JkaW5hdGVzID0ge1xuICAgIGxlZnQ6IG51bWJlcixcbiAgICB0b3A6IG51bWJlclxufVxuXG5leHBvcnQgY29uc3QgVG9vbHRpcCA9IChwOiBQcm9wc1dpdGhDaGlsZHJlbjxQcm9wcz4pID0+IHtcbiAgICBjb25zdCBbbW91c2VPdmVyLCBzZXRNb3VzZU92ZXJdID0gdXNlU3RhdGUoZmFsc2UpXG4gICAgY29uc3QgW2xlYXZlZCwgc2V0TGVhdmVkXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IGJvdW5kcyA9IHVzZVJlZjxDb29yZGluYXRlcz4oe1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgfSlcblxuICAgIGNvbnN0IGNhbGxiYWNrUmVmID0gKG5vZGU6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgY29uc3Qge2xlZnQsIGJvdHRvbX0gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICBib3VuZHMuY3VycmVudC50b3AgPSBib3R0b21cbiAgICAgICAgICAgIGJvdW5kcy5jdXJyZW50LmxlZnQgPSBsZWZ0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZUxlYXZlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lQ2FsbCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIHNldExlYXZlZCh0cnVlKVxuICAgICAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gdGltZUNhbGwgPj0gMjAwKSB7XG4gICAgICAgICAgICAgICAgc2V0TW91c2VPdmVyKGZhbHNlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e3MubW91c2Vfb3Zlcl9jb250YWluZXJ9XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI9eygpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRNb3VzZU92ZXIodHJ1ZSlcbiAgICAgICAgICAgICAgICBzZXRMZWF2ZWQoZmFsc2UpXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtoYW5kbGVNb3VzZUxlYXZlfVxuICAgICAgICAgICAgcmVmPXtjYWxsYmFja1JlZn1cbiAgICAgICAgPlxuICAgICAgICAgICAge3AuY2hpbGRyZW59XG4gICAgICAgICAgICB7bW91c2VPdmVyICYmIGNyZWF0ZVBvcnRhbChcbiAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cy50b29sdGlwfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1sZWF2ZWQ9e2xlYXZlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYm91bmRzLmN1cnJlbnQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGJvdW5kcy5jdXJyZW50LnRvcFxuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgPntwLnRpdGxlfTwvZGl2PlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rvb2x0aXAtcG9ydGFsJykhXG4gICAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTsiLCJleHBvcnQge1Rvb2x0aXB9IGZyb20gJy4vVG9vbHRpcCciLCJpbXBvcnQgKiBhcyBzIGZyb20gJy4vU2lkZWJhck5hdmlnYXRpb24uY3NzJ1xuaW1wb3J0IExvZ29JbWFnZSBmcm9tICdAc3JjL3NoYXJlZC91aS9hc3NldHMvaW1hZ2VzL2xvZ28ucG5nJ1xuaW1wb3J0IEhvbWVJY29uIGZyb20gJ0BzcmMvc2hhcmVkL3VpL2Fzc2V0cy9pbWFnZXMvbmF2aWdhdGlvbi9ob21lLnN2ZydcbmltcG9ydCBQcm9maWxlSWNvbiBmcm9tICdAc3JjL3NoYXJlZC91aS9hc3NldHMvaW1hZ2VzL25hdmlnYXRpb24vcHJvZmlsZS5zdmcnXG5pbXBvcnQgUHJvamVjdEljb24gZnJvbSAnQHNyYy9zaGFyZWQvdWkvYXNzZXRzL2ltYWdlcy9uYXZpZ2F0aW9uL3Byb2plY3Quc3ZnJ1xuaW1wb3J0IFNldHRpbmdJY29uIGZyb20gJ0BzcmMvc2hhcmVkL3VpL2Fzc2V0cy9pbWFnZXMvbmF2aWdhdGlvbi9zZXR0aW5ncy5zdmcnXG5pbXBvcnQgVGFza0ljb24gZnJvbSAnQHNyYy9zaGFyZWQvdWkvYXNzZXRzL2ltYWdlcy9uYXZpZ2F0aW9uL3Rhc2suc3ZnJ1xuaW1wb3J0IEJlbGxJY29uIGZyb20gJ0BzcmMvc2hhcmVkL3VpL2Fzc2V0cy9pbWFnZXMvbmF2aWdhdGlvbi9iZWxsLnN2ZydcbmltcG9ydCB7VG9vbHRpcH0gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL3Rvb2x0aXBcIjtcblxuZXhwb3J0IGNvbnN0IFNpZGViYXJOYXZpZ2F0aW9uID0gKCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLmNvbnRhaW5lcn0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cy5sb2dvfT5cbiAgICAgICAgICAgICAgICA8aW1nIHNyYz17TG9nb0ltYWdlfSBhbHQ9XCJcIi8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLm5hdmlnYXRpb259PlxuICAgICAgICAgICAgICAgIDxUb29sdGlwIHRpdGxlPVwi0JTQvtC80LDRiNC90Y/RjyDRgdGC0YDQsNC90LjRhtCwICjQsiDRgNCw0LfRgNCw0LHQvtGC0LrQtSlcIj5cbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9e0hvbWVJY29ufSBhbHQ9XCJcIi8+XG4gICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxuXG4gICAgICAgICAgICAgICAgPFRvb2x0aXAgdGl0bGU9XCLQn9GA0L7RhNC40LvRjCAo0LIg0YDQsNC30YDQsNCx0L7RgtC60LUpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtQcm9maWxlSWNvbn0gYWx0PVwiXCIvPlxuICAgICAgICAgICAgICAgIDwvVG9vbHRpcD5cblxuICAgICAgICAgICAgICAgIDxUb29sdGlwIHRpdGxlPVwi0JfQsNC00LDRh9C4ICjQsiDRgNCw0LfRgNCw0LHQvtGC0LrQtSlcIj5cbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9e1Rhc2tJY29ufSBhbHQ9XCJcIi8+XG4gICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxuXG4gICAgICAgICAgICAgICAgPFRvb2x0aXAgdGl0bGU9XCLQn9GA0L7QtdC60YLRiyAo0LIg0YDQsNC30YDQsNCx0L7RgtC60LUpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtQcm9qZWN0SWNvbn0gYWx0PVwiXCIvPlxuICAgICAgICAgICAgICAgIDwvVG9vbHRpcD5cblxuICAgICAgICAgICAgICAgIDxUb29sdGlwIHRpdGxlPVwi0J3QsNGB0YLRgNC+0LnQutC4ICjQsiDRgNCw0LfRgNCw0LHQvtGC0LrQtSlcIj5cbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9e1NldHRpbmdJY29ufSBhbHQ9XCJcIi8+XG4gICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxuXG4gICAgICAgICAgICAgICAgPFRvb2x0aXAgdGl0bGU9XCLQo9Cy0LXQtNC+0LzQu9C10L3QuNGPICjQsiDRgNCw0LfRgNCw0LHQvtGC0LrQtSlcIj5cbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9e0JlbGxJY29ufSBhbHQ9XCJcIi8+XG4gICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59OyIsImV4cG9ydCB7U2lkZWJhck5hdmlnYXRpb259IGZyb20gJy4vU2lkZWJhck5hdmlnYXRpb24nIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG52YXIgXzEgPSBcIldkQkp0bmhfdXdsbnAzbHNlZ29hXCI7XG52YXIgXzIgPSBcIlFvbXJ5WEI1XzZzbEF1ZkpLeW5mXCI7XG52YXIgXzMgPSBcIkltdkF2dGlWNlpncm9Ea01pSFJYXCI7XG52YXIgXzQgPSBcInBvTmp1NllhRGc5WFpVNkxIU19nXCI7XG52YXIgXzUgPSBcInBWYk1TcEM2QzY3V2hqQ0JWOHQ2XCI7XG52YXIgXzYgPSBcIm9JZWtIczV0ZDhqeF9YOHN6amtLXCI7XG5leHBvcnQgeyBfMSBhcyBcImJ1dHRvblwiLCBfMiBhcyBcImNvbnRhaW5lclwiLCBfMyBhcyBcIm92ZXJmbG93X2Jsb2NrXCIsIF80IGFzIFwicHJvamVjdF90aXRsZVwiLCBfNSBhcyBcInNpZGViYXJfaGVhZGluZ1wiLCBfNiBhcyBcInRvcF9ibG9ja1wiIH1cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxudmFyIF8xID0gXCJkc1ZJRDNqSDFEUGhWb1ZIeUpEd1wiO1xudmFyIF8yID0gXCJoYXRVeldzTjdEVmo3TnVoQmgzZ1wiO1xuZXhwb3J0IHsgXzEgYXMgXCJoZWFkaW5nXCIsIF8yIGFzIFwidGV4dFwiIH1cbiIsImltcG9ydCB7SFRNTEF0dHJpYnV0ZXMsIFJlYWN0Tm9kZX0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBzIGZyb20gJy4vVHlwb2dyYXBoeS5jc3MnXG5cbnR5cGUgSGVhZGluZ1Byb3BzID0ge1xuICAgIGFzPzogXCJoMVwiIHwgXCJoMlwiIHwgXCJoM1wiIHwgXCJoNFwiIHwgXCJoNVwiIHwgXCJoNlwiO1xufVxuXG50eXBlIFRleHRQcm9wcyA9IHtcbiAgICBhcz86IFwiZGl2XCIgfCBcInNwYW5cIlxufVxuXG5jb25zdCBIZWFkaW5nID0gKHA6IEhlYWRpbmdQcm9wcyAmIEhUTUxBdHRyaWJ1dGVzPEhUTUxIZWFkaW5nRWxlbWVudD4pID0+IHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IHMuaGVhZGluZ1xuICAgIGlmIChwLmNsYXNzTmFtZSkge1xuICAgICAgICBjbGFzc05hbWVzICs9ICcgJyArIHAuY2xhc3NOYW1lXG4gICAgfVxuXG4gICAgY29uc3QgZWxlbXM6IFJlY29yZDxOb25OdWxsYWJsZTxIZWFkaW5nUHJvcHNbXCJhc1wiXT4sIFJlYWN0Tm9kZT4gPSAge1xuICAgICAgICAnaDEnOiA8aDEgey4uLnB9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30+e3AuY2hpbGRyZW59PC9oMT4sXG4gICAgICAgICdoMic6IDxoMiB7Li4ucH0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfT57cC5jaGlsZHJlbn08L2gyPixcbiAgICAgICAgJ2gzJzogPGgzIHsuLi5wfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9PntwLmNoaWxkcmVufTwvaDM+LFxuICAgICAgICAnaDQnOiA8aDQgey4uLnB9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30+e3AuY2hpbGRyZW59PC9oND4sXG4gICAgICAgICdoNSc6IDxoNSB7Li4ucH0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfT57cC5jaGlsZHJlbn08L2g1PixcbiAgICAgICAgJ2g2JzogPGg2IHsuLi5wfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9PntwLmNoaWxkcmVufTwvaDY+LFxuICAgIH1cbiAgICByZXR1cm4gZWxlbXNbcC5hcyB8fCAnaDInXVxufVxuXG5jb25zdCBQYXJhZ3JhcGggPSAocDogSFRNTEF0dHJpYnV0ZXM8SFRNTFBhcmFncmFwaEVsZW1lbnQ+KSA9PiB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBzLnRleHRcbiAgICBpZiAocC5jbGFzc05hbWUpIHtcbiAgICAgICAgY2xhc3NOYW1lcyArPSAnICcgKyBwLmNsYXNzTmFtZVxuICAgIH1cblxuICAgIHJldHVybiA8cCB7Li4ucH0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfT57cC5jaGlsZHJlbn08L3A+XG59XG5cbmNvbnN0IFRleHQgPSAocDogVGV4dFByb3BzICYgSFRNTEF0dHJpYnV0ZXM8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBzLnRleHRcbiAgICBpZiAocC5jbGFzc05hbWUpIHtcbiAgICAgICAgY2xhc3NOYW1lcyArPSAnICcgKyBwLmNsYXNzTmFtZVxuICAgIH1cblxuICAgIGNvbnN0IGVsZW1zOiBSZWNvcmQ8Tm9uTnVsbGFibGU8VGV4dFByb3BzW1wiYXNcIl0+LCBSZWFjdE5vZGU+ID0gIHtcbiAgICAgICAgJ2Rpdic6IDxkaXYgey4uLnB9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30+e3AuY2hpbGRyZW59PC9kaXY+LFxuICAgICAgICAnc3Bhbic6IDxzcGFuIHsuLi5wfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9PntwLmNoaWxkcmVufTwvc3Bhbj4sXG4gICAgfVxuICAgIHJldHVybiBlbGVtc1twLmFzIHx8ICdkaXYnXVxufVxuXG5jb25zdCBMaW5rID0gKHA6IEhUTUxBdHRyaWJ1dGVzPEhUTUxBbmNob3JFbGVtZW50PikgPT4ge1xuICAgIGxldCBjbGFzc05hbWVzID0gcy50ZXh0XG4gICAgaWYgKHAuY2xhc3NOYW1lKSB7XG4gICAgICAgIGNsYXNzTmFtZXMgKz0gJyAnICsgcC5jbGFzc05hbWVcbiAgICB9XG5cbiAgICByZXR1cm4gPGEgey4uLnB9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30+e3AuY2hpbGRyZW59PC9hPlxufVxuXG5leHBvcnQgY29uc3QgVHlwb2dyYXBoeSA9IHtIZWFkaW5nLCBUZXh0LCBQYXJhZ3JhcGgsIExpbmt9IiwiZXhwb3J0IHtUeXBvZ3JhcGh5fSBmcm9tICcuL1R5cG9ncmFwaHknIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG52YXIgXzEgPSBcIlIybUxuVncwTjdDUUp1Q3FxUG13XCI7XG52YXIgXzIgPSBcIkdSeE9GdFpRNGYwRmlCRGQ3MVlGXCI7XG5leHBvcnQgeyBfMSBhcyBcImNvbnRhaW5lclwiLCBfMiBhcyBcImRpYWdyYW1cIiB9XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbnZhciBfMSA9IFwicFBfWDNDUlRyS0ZnWGJuVzVKRVFcIjtcbnZhciBfMiA9IFwicVFOMHRkenF6RHZhSFdYSUJyWGZcIjtcbmV4cG9ydCB7IF8xIGFzIFwiY2lyY2xlXCIsIF8yIGFzIFwic3ZnXCIgfVxuIiwiaW1wb3J0ICogYXMgcyBmcm9tICcuL0RpYWdyYW0uY3NzJ1xuXG50eXBlIFByb3BzID0ge1xuICAgIHZhbHVlOiBudW1iZXJcbn07XG5cbmV4cG9ydCBjb25zdCBEaWFncmFtID0gKHA6IFByb3BzKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPHN2Z1xuICAgICAgICAgICAgY2xhc3NOYW1lPXtzLnN2Z31cbiAgICAgICAgICAgIHdpZHRoPVwiNDBcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiNDBcIlxuICAgICAgICAgICAgdmlld0JveD1cIjAgMCA0MCA0MFwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgICAgIGN4PXsyMH1cbiAgICAgICAgICAgICAgICBjeT17MjB9XG4gICAgICAgICAgICAgICAgcj17MTV9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzLmNpcmNsZX1cbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9e2Ake3AudmFsdWUgKiA0NyAvIDUwfSwgMTAwYH1cbiAgICAgICAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0PXswfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgKTtcbn07IiwiZXhwb3J0IHtEaWFncmFtfSBmcm9tICcuL0RpYWdyYW0nIiwiaW1wb3J0ICogYXMgcyBmcm9tICcuL1NpZGViYXJUYXNrLmNzcydcbmltcG9ydCB7VHlwb2dyYXBoeX0gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL3R5cG9ncmFwaHlcIjtcbmltcG9ydCB7RGlhZ3JhbX0gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL2RpYWdyYW1cIjtcblxudHlwZSBQcm9wcyA9IHtcbiAgICB0YXNrTmFtZTogc3RyaW5nLFxuICAgIHBlcmNlbnQ6IG51bWJlclxufVxuZXhwb3J0IGNvbnN0IFNpZGViYXJUYXNrID0gKHA6IFByb3BzKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3MuY29udGFpbmVyfT5cbiAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQ+e3AudGFza05hbWV9PC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cy5kaWFncmFtfT5cbiAgICAgICAgICAgICAgICA8RGlhZ3JhbSB2YWx1ZT17cC5wZXJjZW50fS8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQ+e3AucGVyY2VudH0lPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59OyIsImV4cG9ydCB7U2lkZWJhclRhc2t9IGZyb20gJy4vU2lkZWJhclRhc2snIiwidmFyIG5pY2VFcnJvcnMgPSB7XG4gIDA6IFwiSW52YWxpZCB2YWx1ZSBmb3IgY29uZmlndXJhdGlvbiAnZW5mb3JjZUFjdGlvbnMnLCBleHBlY3RlZCAnbmV2ZXInLCAnYWx3YXlzJyBvciAnb2JzZXJ2ZWQnXCIsXG4gIDE6IGZ1bmN0aW9uIF8oYW5ub3RhdGlvblR5cGUsIGtleSkge1xuICAgIHJldHVybiBcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZSArIFwiJyB0byAnXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzogRmllbGQgbm90IGZvdW5kLlwiO1xuICB9LFxuICAvKlxuICAyKHByb3ApIHtcbiAgICAgIHJldHVybiBgaW52YWxpZCBkZWNvcmF0b3IgZm9yICcke3Byb3AudG9TdHJpbmcoKX0nYFxuICB9LFxuICAzKHByb3ApIHtcbiAgICAgIHJldHVybiBgQ2Fubm90IGRlY29yYXRlICcke3Byb3AudG9TdHJpbmcoKX0nOiBhY3Rpb24gY2FuIG9ubHkgYmUgdXNlZCBvbiBwcm9wZXJ0aWVzIHdpdGggYSBmdW5jdGlvbiB2YWx1ZS5gXG4gIH0sXG4gIDQocHJvcCkge1xuICAgICAgcmV0dXJuIGBDYW5ub3QgZGVjb3JhdGUgJyR7cHJvcC50b1N0cmluZygpfSc6IGNvbXB1dGVkIGNhbiBvbmx5IGJlIHVzZWQgb24gZ2V0dGVyIHByb3BlcnRpZXMuYFxuICB9LFxuICAqL1xuICA1OiBcIidrZXlzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMsIHNldHMgYW5kIG1hcHNcIixcbiAgNjogXCIndmFsdWVzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMsIHNldHMgYW5kIG1hcHNcIixcbiAgNzogXCInZW50cmllcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDg6IFwiJ3NldCgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDk6IFwiJ3JlbW92ZSgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDEwOiBcIidoYXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICAxMTogXCInZ2V0KCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgMTI6IFwiSW52YWxpZCBhbm5vdGF0aW9uXCIsXG4gIDEzOiBcIkR5bmFtaWMgb2JzZXJ2YWJsZSBvYmplY3RzIGNhbm5vdCBiZSBmcm96ZW4uIElmIHlvdSdyZSBwYXNzaW5nIG9ic2VydmFibGVzIHRvIDNyZCBwYXJ0eSBjb21wb25lbnQvZnVuY3Rpb24gdGhhdCBjYWxscyBPYmplY3QuZnJlZXplLCBwYXNzIGNvcHkgaW5zdGVhZDogdG9KUyhvYnNlcnZhYmxlKVwiLFxuICAxNDogXCJJbnRlcmNlcHQgaGFuZGxlcnMgc2hvdWxkIHJldHVybiBub3RoaW5nIG9yIGEgY2hhbmdlIG9iamVjdFwiLFxuICAxNTogXCJPYnNlcnZhYmxlIGFycmF5cyBjYW5ub3QgYmUgZnJvemVuLiBJZiB5b3UncmUgcGFzc2luZyBvYnNlcnZhYmxlcyB0byAzcmQgcGFydHkgY29tcG9uZW50L2Z1bmN0aW9uIHRoYXQgY2FsbHMgT2JqZWN0LmZyZWV6ZSwgcGFzcyBjb3B5IGluc3RlYWQ6IHRvSlMob2JzZXJ2YWJsZSlcIixcbiAgMTY6IFwiTW9kaWZpY2F0aW9uIGV4Y2VwdGlvbjogdGhlIGludGVybmFsIHN0cnVjdHVyZSBvZiBhbiBvYnNlcnZhYmxlIGFycmF5IHdhcyBjaGFuZ2VkLlwiLFxuICAxNzogZnVuY3Rpb24gXyhpbmRleCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFwiW21vYnguYXJyYXldIEluZGV4IG91dCBvZiBib3VuZHMsIFwiICsgaW5kZXggKyBcIiBpcyBsYXJnZXIgdGhhbiBcIiArIGxlbmd0aDtcbiAgfSxcbiAgMTg6IFwibW9ieC5tYXAgcmVxdWlyZXMgTWFwIHBvbHlmaWxsIGZvciB0aGUgY3VycmVudCBicm93c2VyLiBDaGVjayBiYWJlbC1wb2x5ZmlsbCBvciBjb3JlLWpzL2VzNi9tYXAuanNcIixcbiAgMTk6IGZ1bmN0aW9uIF8ob3RoZXIpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgaW5pdGlhbGl6ZSBmcm9tIGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gTWFwOiBcIiArIG90aGVyLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH0sXG4gIDIwOiBmdW5jdGlvbiBfKG90aGVyKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGluaXRpYWxpemUgbWFwIGZyb20gXCIgKyBvdGhlcjtcbiAgfSxcbiAgMjE6IGZ1bmN0aW9uIF8oZGF0YVN0cnVjdHVyZSkge1xuICAgIHJldHVybiBcIkNhbm5vdCBjb252ZXJ0IHRvIG1hcCBmcm9tICdcIiArIGRhdGFTdHJ1Y3R1cmUgKyBcIidcIjtcbiAgfSxcbiAgMjI6IFwibW9ieC5zZXQgcmVxdWlyZXMgU2V0IHBvbHlmaWxsIGZvciB0aGUgY3VycmVudCBicm93c2VyLiBDaGVjayBiYWJlbC1wb2x5ZmlsbCBvciBjb3JlLWpzL2VzNi9zZXQuanNcIixcbiAgMjM6IFwiSXQgaXMgbm90IHBvc3NpYmxlIHRvIGdldCBpbmRleCBhdG9tcyBmcm9tIGFycmF5c1wiLFxuICAyNDogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcIkNhbm5vdCBvYnRhaW4gYWRtaW5pc3RyYXRpb24gZnJvbSBcIiArIHRoaW5nO1xuICB9LFxuICAyNTogZnVuY3Rpb24gXyhwcm9wZXJ0eSwgbmFtZSkge1xuICAgIHJldHVybiBcInRoZSBlbnRyeSAnXCIgKyBwcm9wZXJ0eSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgb2JzZXJ2YWJsZSBtYXAgJ1wiICsgbmFtZSArIFwiJ1wiO1xuICB9LFxuICAyNjogXCJwbGVhc2Ugc3BlY2lmeSBhIHByb3BlcnR5XCIsXG4gIDI3OiBmdW5jdGlvbiBfKHByb3BlcnR5LCBuYW1lKSB7XG4gICAgcmV0dXJuIFwibm8gb2JzZXJ2YWJsZSBwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eS50b1N0cmluZygpICsgXCInIGZvdW5kIG9uIHRoZSBvYnNlcnZhYmxlIG9iamVjdCAnXCIgKyBuYW1lICsgXCInXCI7XG4gIH0sXG4gIDI4OiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IG9idGFpbiBhdG9tIGZyb20gXCIgKyB0aGluZztcbiAgfSxcbiAgMjk6IFwiRXhwZWN0aW5nIHNvbWUgb2JqZWN0XCIsXG4gIDMwOiBcImludmFsaWQgYWN0aW9uIHN0YWNrLiBkaWQgeW91IGZvcmdldCB0byBmaW5pc2ggYW4gYWN0aW9uP1wiLFxuICAzMTogXCJtaXNzaW5nIG9wdGlvbiBmb3IgY29tcHV0ZWQ6IGdldFwiLFxuICAzMjogZnVuY3Rpb24gXyhuYW1lLCBkZXJpdmF0aW9uKSB7XG4gICAgcmV0dXJuIFwiQ3ljbGUgZGV0ZWN0ZWQgaW4gY29tcHV0YXRpb24gXCIgKyBuYW1lICsgXCI6IFwiICsgZGVyaXZhdGlvbjtcbiAgfSxcbiAgMzM6IGZ1bmN0aW9uIF8obmFtZSkge1xuICAgIHJldHVybiBcIlRoZSBzZXR0ZXIgb2YgY29tcHV0ZWQgdmFsdWUgJ1wiICsgbmFtZSArIFwiJyBpcyB0cnlpbmcgdG8gdXBkYXRlIGl0c2VsZi4gRGlkIHlvdSBpbnRlbmQgdG8gdXBkYXRlIGFuIF9vYnNlcnZhYmxlXyB2YWx1ZSwgaW5zdGVhZCBvZiB0aGUgY29tcHV0ZWQgcHJvcGVydHk/XCI7XG4gIH0sXG4gIDM0OiBmdW5jdGlvbiBfKG5hbWUpIHtcbiAgICByZXR1cm4gXCJbQ29tcHV0ZWRWYWx1ZSAnXCIgKyBuYW1lICsgXCInXSBJdCBpcyBub3QgcG9zc2libGUgdG8gYXNzaWduIGEgbmV3IHZhbHVlIHRvIGEgY29tcHV0ZWQgdmFsdWUuXCI7XG4gIH0sXG4gIDM1OiBcIlRoZXJlIGFyZSBtdWx0aXBsZSwgZGlmZmVyZW50IHZlcnNpb25zIG9mIE1vYlggYWN0aXZlLiBNYWtlIHN1cmUgTW9iWCBpcyBsb2FkZWQgb25seSBvbmNlIG9yIHVzZSBgY29uZmlndXJlKHsgaXNvbGF0ZUdsb2JhbFN0YXRlOiB0cnVlIH0pYFwiLFxuICAzNjogXCJpc29sYXRlR2xvYmFsU3RhdGUgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgTW9iWCBpcyBydW5uaW5nIGFueSByZWFjdGlvbnNcIixcbiAgMzc6IGZ1bmN0aW9uIF8obWV0aG9kKSB7XG4gICAgcmV0dXJuIFwiW21vYnhdIGBvYnNlcnZhYmxlQXJyYXkuXCIgKyBtZXRob2QgKyBcIigpYCBtdXRhdGVzIHRoZSBhcnJheSBpbi1wbGFjZSwgd2hpY2ggaXMgbm90IGFsbG93ZWQgaW5zaWRlIGEgZGVyaXZhdGlvbi4gVXNlIGBhcnJheS5zbGljZSgpLlwiICsgbWV0aG9kICsgXCIoKWAgaW5zdGVhZFwiO1xuICB9LFxuICAzODogXCInb3duS2V5cygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0c1wiLFxuICAzOTogXCInZGVmaW5lUHJvcGVydHkoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHNcIlxufTtcbnZhciBlcnJvcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBuaWNlRXJyb3JzIDoge307XG5mdW5jdGlvbiBkaWUoZXJyb3IpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgZSA9IHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVycm9yIDogZXJyb3JzW2Vycm9yXTtcbiAgICBpZiAodHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIikgZSA9IGUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW01vYlhdIFwiICsgZSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKHR5cGVvZiBlcnJvciA9PT0gXCJudW1iZXJcIiA/IFwiW01vYlhdIG1pbmlmaWVkIGVycm9yIG5yOiBcIiArIGVycm9yICsgKGFyZ3MubGVuZ3RoID8gXCIgXCIgKyBhcmdzLm1hcChTdHJpbmcpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIi4gRmluZCB0aGUgZnVsbCBlcnJvciBhdDogaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2Jsb2IvbWFpbi9wYWNrYWdlcy9tb2J4L3NyYy9lcnJvcnMudHNcIiA6IFwiW01vYlhdIFwiICsgZXJyb3IpO1xufVxuXG52YXIgbW9ja0dsb2JhbCA9IHt9O1xuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHJldHVybiBtb2NrR2xvYmFsO1xufVxuXG4vLyBXZSBzaG9ydGVuIGFueXRoaW5nIHVzZWQgPiA1IHRpbWVzXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbnZhciBnZXREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEVNUFRZX0FSUkFZID0gW107XG5PYmplY3QuZnJlZXplKEVNUFRZX0FSUkFZKTtcbnZhciBFTVBUWV9PQkpFQ1QgPSB7fTtcbk9iamVjdC5mcmVlemUoRU1QVFlfT0JKRUNUKTtcbnZhciBoYXNQcm94eSA9IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBwbGFpbk9iamVjdFN0cmluZyA9IC8qI19fUFVSRV9fKi9PYmplY3QudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGFzc2VydFByb3hpZXMoKSB7XG4gIGlmICghaGFzUHJveHkpIHtcbiAgICBkaWUocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJgUHJveHlgIG9iamVjdHMgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIFBsZWFzZSBjb25maWd1cmUgTW9iWCB0byBlbmFibGUgYSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbi5gXCIgOiBcIlByb3h5IG5vdCBhdmFpbGFibGVcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQobXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZ2xvYmFsU3RhdGUudmVyaWZ5UHJveGllcykge1xuICAgIGRpZShcIk1vYlggaXMgY3VycmVudGx5IGNvbmZpZ3VyZWQgdG8gYmUgYWJsZSB0byBydW4gaW4gRVM1IG1vZGUsIGJ1dCBpbiBFUzUgTW9iWCB3b24ndCBiZSBhYmxlIHRvIFwiICsgbXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xuICByZXR1cm4gKytnbG9iYWxTdGF0ZS5tb2J4R3VpZDtcbn1cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBpbnZva2VkIGF0IG1vc3Qgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gIHZhciBpbnZva2VkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGludm9rZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52b2tlZCA9IHRydWU7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmbikge1xuICByZXR1cm4gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc1N0cmluZ2lzaCh2YWx1ZSkge1xuICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwcm90b0NvbnN0cnVjdG9yID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgcHJvdG9Db25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHByb3RvQ29uc3RydWN0b3IudG9TdHJpbmcoKSA9PT0gcGxhaW5PYmplY3RTdHJpbmc7XG59XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc4NjUxNzBcbmZ1bmN0aW9uIGlzR2VuZXJhdG9yKG9iaikge1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9iai5jb25zdHJ1Y3RvcjtcbiAgaWYgKCFjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSBjb25zdHJ1Y3Rvci5uYW1lIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRIaWRkZW5Qcm9wKG9iamVjdCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkSGlkZGVuRmluYWxQcm9wKG9iamVjdCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUobmFtZSwgdGhlQ2xhc3MpIHtcbiAgdmFyIHByb3BOYW1lID0gXCJpc01vYlhcIiArIG5hbWU7XG4gIHRoZUNsYXNzLnByb3RvdHlwZVtwcm9wTmFtZV0gPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgeFtwcm9wTmFtZV0gPT09IHRydWU7XG4gIH07XG59XG4vKipcbiAqIFlpZWxkcyB0cnVlIGZvciBib3RoIG5hdGl2ZSBhbmQgb2JzZXJ2YWJsZSBNYXAsIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCB3aW5kb3dzLlxuICovXG5mdW5jdGlvbiBpc0VTNk1hcCh0aGluZykge1xuICByZXR1cm4gdGhpbmcgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpbmcpID09PSBcIltvYmplY3QgTWFwXVwiO1xufVxuLyoqXG4gKiBNYWtlcyBzdXJlIGEgTWFwIGlzIGFuIGluc3RhbmNlIG9mIG5vbi1pbmhlcml0ZWQgbmF0aXZlIG9yIG9ic2VydmFibGUgTWFwLlxuICovXG5mdW5jdGlvbiBpc1BsYWluRVM2TWFwKHRoaW5nKSB7XG4gIHZhciBtYXBQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGluZyk7XG4gIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtYXBQcm90byk7XG4gIHZhciBudWxsUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0UHJvdG8pO1xuICByZXR1cm4gbnVsbFByb3RvID09PSBudWxsO1xufVxuLyoqXG4gKiBZaWVsZHMgdHJ1ZSBmb3IgYm90aCBuYXRpdmUgYW5kIG9ic2VydmFibGUgU2V0LCBldmVuIGFjcm9zcyBkaWZmZXJlbnQgd2luZG93cy5cbiAqL1xuZnVuY3Rpb24gaXNFUzZTZXQodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaW5nKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbn1cbnZhciBoYXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgZm9sbG93aW5nOiBvd24gZW51bWVyYWJsZSBrZXlzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRQbGFpbk9iamVjdEtleXMob2JqZWN0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgLy8gTm90IHN1cHBvcnRlZCBpbiBJRSwgc28gdGhlcmUgYXJlIG5vdCBnb2luZyB0byBiZSBzeW1ib2wgcHJvcHMgYW55d2F5Li4uXG4gIGlmICghaGFzR2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbiAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gIGlmICghc3ltYm9scy5sZW5ndGgpIHtcbiAgICByZXR1cm4ga2V5cztcbiAgfVxuICByZXR1cm4gW10uY29uY2F0KGtleXMsIHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgcyk7XG4gIH0pKTtcbn1cbi8vIEZyb20gSW1tZXIgdXRpbHNcbi8vIFJldHVybnMgYWxsIG93biBrZXlzLCBpbmNsdWRpbmcgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbGljXG52YXIgb3duS2V5cyA9IHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Qub3duS2V5cyA/IFJlZmxlY3Qub3duS2V5cyA6IGhhc0dldE93blByb3BlcnR5U3ltYm9scyA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG59IDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbmZ1bmN0aW9uIHN0cmluZ2lmeUtleShrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiKSB7XG4gICAgcmV0dXJuIGtleS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBuZXcgU3RyaW5nKGtleSkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyBcIlwiICsgdmFsdWUgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3AodGFyZ2V0LCBwcm9wKSB7XG4gIHJldHVybiBvYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApO1xufVxuLy8gRnJvbSBJbW1lciB1dGlsc1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRhcmdldCkge1xuICAvLyBQb2x5ZmlsbCBuZWVkZWQgZm9yIEhlcm1lcyBhbmQgSUUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svaGVybWVzL2lzc3Vlcy8yNzRcbiAgdmFyIHJlcyA9IHt9O1xuICAvLyBOb3RlOiB3aXRob3V0IHBvbHlmaWxsIGZvciBvd25LZXlzLCBzeW1ib2xzIHdvbid0IGJlIHBpY2tlZCB1cFxuICBvd25LZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmVzW2tleV0gPSBnZXREZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gZ2V0RmxhZyhmbGFncywgbWFzaykge1xuICByZXR1cm4gISEoZmxhZ3MgJiBtYXNrKTtcbn1cbmZ1bmN0aW9uIHNldEZsYWcoZmxhZ3MsIG1hc2ssIG5ld1ZhbHVlKSB7XG4gIGlmIChuZXdWYWx1ZSkge1xuICAgIGZsYWdzIHw9IG1hc2s7XG4gIH0gZWxzZSB7XG4gICAgZmxhZ3MgJj0gfm1hc2s7XG4gIH1cbiAgcmV0dXJuIGZsYWdzO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikge1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbyA9IHJbdF07XG4gICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHIsIGUpIHtcbiAgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAodCkgcmV0dXJuICh0ID0gdC5jYWxsKHIpKS5uZXh0LmJpbmQodCk7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpKSB8fCBlICYmIHIgJiYgXCJudW1iZXJcIiA9PSB0eXBlb2Ygci5sZW5ndGgpIHtcbiAgICB0ICYmIChyID0gdCk7XG4gICAgdmFyIG8gPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbyA+PSByLmxlbmd0aCA/IHtcbiAgICAgICAgZG9uZTogITBcbiAgICAgIH0gOiB7XG4gICAgICAgIGRvbmU6ICExLFxuICAgICAgICB2YWx1ZTogcltvKytdXG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgciBpbiB0KSAoe30pLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgJiYgKG5bcl0gPSB0W3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZSh0LCBvKSB7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShvLnByb3RvdHlwZSksIHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdCwgX3NldFByb3RvdHlwZU9mKHQsIG8pO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gIH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJtb2J4LXN0b3JlZC1hbm5vdGF0aW9uc1wiKTtcbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWN0cyBhc1xuICogLSBkZWNvcmF0b3JcbiAqIC0gYW5ub3RhdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgaWYgKGlzMjAyMjNEZWNvcmF0b3IocHJvcGVydHkpKSB7XG4gICAgICByZXR1cm4gYW5ub3RhdGlvbi5kZWNvcmF0ZV8yMDIyM18odGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JlQW5ub3RhdGlvbih0YXJnZXQsIHByb3BlcnR5LCBhbm5vdGF0aW9uKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVjb3JhdG9yLCBhbm5vdGF0aW9uKTtcbn1cbi8qKlxuICogU3RvcmVzIGFubm90YXRpb24gdG8gcHJvdG90eXBlLFxuICogc28gaXQgY2FuIGJlIGluc3BlY3RlZCBsYXRlciBieSBgbWFrZU9ic2VydmFibGVgIGNhbGxlZCBmcm9tIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHN0b3JlQW5ub3RhdGlvbihwcm90b3R5cGUsIGtleSwgYW5ub3RhdGlvbikge1xuICBpZiAoIWhhc1Byb3AocHJvdG90eXBlLCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCkpIHtcbiAgICBhZGRIaWRkZW5Qcm9wKHByb3RvdHlwZSwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wsIF9leHRlbmRzKHt9LCBwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSk7XG4gIH1cbiAgLy8gQG92ZXJyaWRlIG11c3Qgb3ZlcnJpZGUgc29tZXRoaW5nXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiAhaGFzUHJvcChwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lICsgXCIucHJvdG90eXBlLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgZGllKFwiJ1wiICsgZmllbGROYW1lICsgXCInIGlzIGRlY29yYXRlZCB3aXRoICdvdmVycmlkZScsIFwiICsgXCJidXQgbm8gc3VjaCBkZWNvcmF0ZWQgbWVtYmVyIHdhcyBmb3VuZCBvbiBwcm90b3R5cGUuXCIpO1xuICB9XG4gIC8vIENhbm5vdCByZS1kZWNvcmF0ZVxuICBhc3NlcnROb3REZWNvcmF0ZWQocHJvdG90eXBlLCBhbm5vdGF0aW9uLCBrZXkpO1xuICAvLyBJZ25vcmUgb3ZlcnJpZGVcbiAgaWYgKCFpc092ZXJyaWRlKGFubm90YXRpb24pKSB7XG4gICAgcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXVtrZXldID0gYW5ub3RhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Tm90RGVjb3JhdGVkKHByb3RvdHlwZSwgYW5ub3RhdGlvbiwga2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzT3ZlcnJpZGUoYW5ub3RhdGlvbikgJiYgaGFzUHJvcChwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lICsgXCIucHJvdG90eXBlLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgdmFyIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSA9IHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF1ba2V5XS5hbm5vdGF0aW9uVHlwZV87XG4gICAgdmFyIHJlcXVlc3RlZEFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV87XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdAXCIgKyByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSArIFwiJyB0byAnXCIgKyBmaWVsZE5hbWUgKyBcIic6XCIgKyAoXCJcXG5UaGUgZmllbGQgaXMgYWxyZWFkeSBkZWNvcmF0ZWQgd2l0aCAnQFwiICsgY3VycmVudEFubm90YXRpb25UeXBlICsgXCInLlwiKSArIFwiXFxuUmUtZGVjb3JhdGluZyBmaWVsZHMgaXMgbm90IGFsbG93ZWQuXCIgKyBcIlxcblVzZSAnQG92ZXJyaWRlJyBkZWNvcmF0b3IgZm9yIG1ldGhvZHMgb3ZlcnJpZGRlbiBieSBzdWJjbGFzcy5cIik7XG4gIH1cbn1cbi8qKlxuICogQ29sbGVjdHMgYW5ub3RhdGlvbnMgZnJvbSBwcm90b3R5cGVzIGFuZCBzdG9yZXMgdGhlbSBvbiB0YXJnZXQgKGluc3RhbmNlKVxuICovXG5mdW5jdGlvbiBjb2xsZWN0U3RvcmVkQW5ub3RhdGlvbnModGFyZ2V0KSB7XG4gIGlmICghaGFzUHJvcCh0YXJnZXQsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sKSkge1xuICAgIC8vIGlmIChfX0RFVl9fICYmICF0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSB7XG4gICAgLy8gICAgIGRpZShcbiAgICAvLyAgICAgICAgIGBObyBhbm5vdGF0aW9ucyB3ZXJlIHBhc3NlZCB0byBtYWtlT2JzZXJ2YWJsZSwgYnV0IG5vIGRlY29yYXRlZCBtZW1iZXJzIGhhdmUgYmVlbiBmb3VuZCBlaXRoZXJgXG4gICAgLy8gICAgIClcbiAgICAvLyB9XG4gICAgLy8gV2UgbmVlZCBhIGNvcHkgYXMgd2Ugd2lsbCByZW1vdmUgYW5ub3RhdGlvbiBmcm9tIHRoZSBsaXN0IG9uY2UgaXQncyBhcHBsaWVkLlxuICAgIGFkZEhpZGRlblByb3AodGFyZ2V0LCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCwgX2V4dGVuZHMoe30sIHRhcmdldFtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0W3N0b3JlZEFubm90YXRpb25zU3ltYm9sXTtcbn1cbmZ1bmN0aW9uIGlzMjAyMjNEZWNvcmF0b3IoY29udGV4dCkge1xuICByZXR1cm4gdHlwZW9mIGNvbnRleHQgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY29udGV4dFtcImtpbmRcIl0gPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydDIwMjIzRGVjb3JhdG9yVHlwZShjb250ZXh0LCB0eXBlcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICF0eXBlcy5pbmNsdWRlcyhjb250ZXh0LmtpbmQpKSB7XG4gICAgZGllKFwiVGhlIGRlY29yYXRvciBhcHBsaWVkIHRvICdcIiArIFN0cmluZyhjb250ZXh0Lm5hbWUpICsgXCInIGNhbm5vdCBiZSB1c2VkIG9uIGEgXCIgKyBjb250ZXh0LmtpbmQgKyBcIiBlbGVtZW50XCIpO1xuICB9XG59XG5cbnZhciAkbW9ieCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJtb2J4IGFkbWluaXN0cmF0aW9uXCIpO1xudmFyIEF0b20gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGF0b20uIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgaXQgaXMgcmVjb21tZW5kZWQgdG8gZ2l2ZSBpdCBhIG5hbWUuXG4gICAqIFRoZSBvbkJlY29tZU9ic2VydmVkIGFuZCBvbkJlY29tZVVub2JzZXJ2ZWQgY2FsbGJhY2tzIGNhbiBiZSB1c2VkIGZvciByZXNvdXJjZSBtYW5hZ2VtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gQXRvbShuYW1lXykge1xuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiQXRvbUBcIiArIGdldE5leHRJZCgpIDogXCJBdG9tXCI7XG4gICAgfVxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5mbGFnc18gPSAwO1xuICAgIHRoaXMub2JzZXJ2ZXJzXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmxhc3RBY2Nlc3NlZEJ5XyA9IDA7XG4gICAgdGhpcy5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgLy8gb25CZWNvbWVPYnNlcnZlZExpc3RlbmVyc1xuICAgIHRoaXMub25CT0wgPSB2b2lkIDA7XG4gICAgLy8gb25CZWNvbWVVbm9ic2VydmVkTGlzdGVuZXJzXG4gICAgdGhpcy5vbkJVT0wgPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICB9XG4gIC8vIGZvciBlZmZlY3RpdmUgdW5vYnNlcnZpbmcuIEJhc2VBdG9tIGhhcyB0cnVlLCBmb3IgZXh0cmEgb3B0aW1pemF0aW9uLCBzbyBpdHMgb25CZWNvbWVVbm9ic2VydmVkIG5ldmVyIGdldHMgY2FsbGVkLCBiZWNhdXNlIGl0J3Mgbm90IG5lZWRlZFxuICB2YXIgX3Byb3RvID0gQXRvbS5wcm90b3R5cGU7XG4gIF9wcm90by5vbkJPID0gZnVuY3Rpb24gb25CTygpIHtcbiAgICBpZiAodGhpcy5vbkJPTCkge1xuICAgICAgdGhpcy5vbkJPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uQlVPID0gZnVuY3Rpb24gb25CVU8oKSB7XG4gICAgaWYgKHRoaXMub25CVU9MKSB7XG4gICAgICB0aGlzLm9uQlVPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW52b2tlIHRoaXMgbWV0aG9kIHRvIG5vdGlmeSBtb2J4IHRoYXQgeW91ciBhdG9tIGhhcyBiZWVuIHVzZWQgc29tZWhvdy5cbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGN1cnJlbnRseSBhIHJlYWN0aXZlIGNvbnRleHQuXG4gICAqLztcbiAgX3Byb3RvLnJlcG9ydE9ic2VydmVkID0gZnVuY3Rpb24gcmVwb3J0T2JzZXJ2ZWQkMSgpIHtcbiAgICByZXR1cm4gcmVwb3J0T2JzZXJ2ZWQodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEludm9rZSB0aGlzIG1ldGhvZCBfYWZ0ZXJfIHRoaXMgbWV0aG9kIGhhcyBjaGFuZ2VkIHRvIHNpZ25hbCBtb2J4IHRoYXQgYWxsIGl0cyBvYnNlcnZlcnMgc2hvdWxkIGludmFsaWRhdGUuXG4gICAqLztcbiAgX3Byb3RvLnJlcG9ydENoYW5nZWQgPSBmdW5jdGlvbiByZXBvcnRDaGFuZ2VkKCkge1xuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICBwcm9wYWdhdGVDaGFuZ2VkKHRoaXMpO1xuICAgIGVuZEJhdGNoKCk7XG4gIH07XG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICB9O1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF0b20sIFt7XG4gICAga2V5OiBcImlzQmVpbmdPYnNlcnZlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIEF0b20uaXNCZWluZ09ic2VydmVkTWFza18pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZmxhZ3NfID0gc2V0RmxhZyh0aGlzLmZsYWdzXywgQXRvbS5pc0JlaW5nT2JzZXJ2ZWRNYXNrXywgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1BlbmRpbmdVbm9ic2VydmF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0RmxhZyh0aGlzLmZsYWdzXywgQXRvbS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uTWFza18pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZmxhZ3NfID0gc2V0RmxhZyh0aGlzLmZsYWdzXywgQXRvbS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uTWFza18sIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlmZlZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0RmxhZyh0aGlzLmZsYWdzXywgQXRvbS5kaWZmVmFsdWVNYXNrXykgPyAxIDogMDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLmZsYWdzXyA9IHNldEZsYWcodGhpcy5mbGFnc18sIEF0b20uZGlmZlZhbHVlTWFza18sIG5ld1ZhbHVlID09PSAxID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbkF0b20uaXNCZWluZ09ic2VydmVkTWFza18gPSAxO1xuQXRvbS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uTWFza18gPSAyO1xuQXRvbS5kaWZmVmFsdWVNYXNrXyA9IDQ7XG52YXIgaXNBdG9tID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJBdG9tXCIsIEF0b20pO1xuZnVuY3Rpb24gY3JlYXRlQXRvbShuYW1lLCBvbkJlY29tZU9ic2VydmVkSGFuZGxlciwgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlcikge1xuICBpZiAob25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgPT09IHZvaWQgMCkge1xuICAgIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyID0gbm9vcDtcbiAgfVxuICBpZiAob25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciA9PT0gdm9pZCAwKSB7XG4gICAgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciA9IG5vb3A7XG4gIH1cbiAgdmFyIGF0b20gPSBuZXcgQXRvbShuYW1lKTtcbiAgLy8gZGVmYXVsdCBgbm9vcGAgbGlzdGVuZXIgd2lsbCBub3QgaW5pdGlhbGl6ZSB0aGUgaG9vayBTZXRcbiAgaWYgKG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyICE9PSBub29wKSB7XG4gICAgb25CZWNvbWVPYnNlcnZlZChhdG9tLCBvbkJlY29tZU9ic2VydmVkSGFuZGxlcik7XG4gIH1cbiAgaWYgKG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIgIT09IG5vb3ApIHtcbiAgICBvbkJlY29tZVVub2JzZXJ2ZWQoYXRvbSwgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlcik7XG4gIH1cbiAgcmV0dXJuIGF0b207XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5Q29tcGFyZXIoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbmZ1bmN0aW9uIHN0cnVjdHVyYWxDb21wYXJlcihhLCBiKSB7XG4gIHJldHVybiBkZWVwRXF1YWwoYSwgYik7XG59XG5mdW5jdGlvbiBzaGFsbG93Q29tcGFyZXIoYSwgYikge1xuICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIDEpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmVyKGEsIGIpIHtcbiAgaWYgKE9iamVjdC5pcykge1xuICAgIHJldHVybiBPYmplY3QuaXMoYSwgYik7XG4gIH1cbiAgcmV0dXJuIGEgPT09IGIgPyBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYiA6IGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cbnZhciBjb21wYXJlciA9IHtcbiAgaWRlbnRpdHk6IGlkZW50aXR5Q29tcGFyZXIsXG4gIHN0cnVjdHVyYWw6IHN0cnVjdHVyYWxDb21wYXJlcixcbiAgXCJkZWZhdWx0XCI6IGRlZmF1bHRDb21wYXJlcixcbiAgc2hhbGxvdzogc2hhbGxvd0NvbXBhcmVyXG59O1xuXG5mdW5jdGlvbiBkZWVwRW5oYW5jZXIodiwgXywgbmFtZSkge1xuICAvLyBpdCBpcyBhbiBvYnNlcnZhYmxlIGFscmVhZHksIGRvbmVcbiAgaWYgKGlzT2JzZXJ2YWJsZSh2KSkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIC8vIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgYW5kIG11dGF0ZWQ/XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkodiwge1xuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUub2JqZWN0KHYsIHVuZGVmaW5lZCwge1xuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9XG4gIGlmIChpc0VTNk1hcCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCB7XG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzRVM2U2V0KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUuc2V0KHYsIHtcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIiAmJiAhaXNBY3Rpb24odikgJiYgIWlzRmxvdyh2KSkge1xuICAgIGlmIChpc0dlbmVyYXRvcih2KSkge1xuICAgICAgcmV0dXJuIGZsb3codik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhdXRvQWN0aW9uKG5hbWUsIHYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFbmhhbmNlcih2LCBfLCBuYW1lKSB7XG4gIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGlmIChpc09ic2VydmFibGVPYmplY3QodikgfHwgaXNPYnNlcnZhYmxlQXJyYXkodikgfHwgaXNPYnNlcnZhYmxlTWFwKHYpIHx8IGlzT2JzZXJ2YWJsZVNldCh2KSkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkodiwge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRlZXA6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5vYmplY3QodiwgdW5kZWZpbmVkLCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGVlcDogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNFUzZNYXAodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5tYXAodiwge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRlZXA6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzRVM2U2V0KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUuc2V0KHYsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkZWVwOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBkaWUoXCJUaGUgc2hhbGxvdyBtb2RpZmllciAvIGRlY29yYXRvciBjYW4gb25seSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYXJyYXlzLCBvYmplY3RzLCBtYXBzIGFuZCBzZXRzXCIpO1xuICB9XG59XG5mdW5jdGlvbiByZWZlcmVuY2VFbmhhbmNlcihuZXdWYWx1ZSkge1xuICAvLyBuZXZlciB0dXJuIGludG8gYW4gb2JzZXJ2YWJsZVxuICByZXR1cm4gbmV3VmFsdWU7XG59XG5mdW5jdGlvbiByZWZTdHJ1Y3RFbmhhbmNlcih2LCBvbGRWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzT2JzZXJ2YWJsZSh2KSkge1xuICAgIGRpZShcIm9ic2VydmFibGUuc3RydWN0IHNob3VsZCBub3QgYmUgdXNlZCB3aXRoIG9ic2VydmFibGUgdmFsdWVzXCIpO1xuICB9XG4gIGlmIChkZWVwRXF1YWwodiwgb2xkVmFsdWUpKSB7XG4gICAgcmV0dXJuIG9sZFZhbHVlO1xuICB9XG4gIHJldHVybiB2O1xufVxuXG52YXIgT1ZFUlJJREUgPSBcIm92ZXJyaWRlXCI7XG52YXIgb3ZlcnJpZGUgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbih7XG4gIGFubm90YXRpb25UeXBlXzogT1ZFUlJJREUsXG4gIG1ha2VfOiBtYWtlXyxcbiAgZXh0ZW5kXzogZXh0ZW5kXyxcbiAgZGVjb3JhdGVfMjAyMjNfOiBkZWNvcmF0ZV8yMDIyM19cbn0pO1xuZnVuY3Rpb24gaXNPdmVycmlkZShhbm5vdGF0aW9uKSB7XG4gIHJldHVybiBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlXyA9PT0gT1ZFUlJJREU7XG59XG5mdW5jdGlvbiBtYWtlXyhhZG0sIGtleSkge1xuICAvLyBNdXN0IG5vdCBiZSBwbGFpbiBvYmplY3RcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBhZG0uaXNQbGFpbk9iamVjdF8pIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbm5vdCBiZSB1c2VkIG9uIHBsYWluIG9iamVjdHMuXCIpKTtcbiAgfVxuICAvLyBNdXN0IG92ZXJyaWRlIHNvbWV0aGluZ1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFoYXNQcm9wKGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfLCBrZXkpKSB7XG4gICAgZGllKFwiJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJyBpcyBhbm5vdGF0ZWQgd2l0aCAnXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJywgXCIgKyBcImJ1dCBubyBzdWNoIGFubm90YXRlZCBtZW1iZXIgd2FzIGZvdW5kIG9uIHByb3RvdHlwZS5cIik7XG4gIH1cbiAgcmV0dXJuIDAgLyogTWFrZVJlc3VsdC5DYW5jZWwgKi87XG59XG5mdW5jdGlvbiBleHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgZGllKFwiJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCB3aXRoICdtYWtlT2JzZXJ2YWJsZSdcIik7XG59XG5mdW5jdGlvbiBkZWNvcmF0ZV8yMDIyM18oZGVzYywgY29udGV4dCkge1xuICBjb25zb2xlLndhcm4oXCInXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJyBjYW5ub3QgYmUgdXNlZCB3aXRoIGRlY29yYXRvcnMgLSB0aGlzIGlzIGEgbm8tb3BcIik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkFubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kMSxcbiAgICBleHRlbmRfOiBleHRlbmRfJDEsXG4gICAgZGVjb3JhdGVfMjAyMjNfOiBkZWNvcmF0ZV8yMDIyM18kMVxuICB9O1xufVxuZnVuY3Rpb24gbWFrZV8kMShhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXztcbiAgLy8gYm91bmRcbiAgaWYgKChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pICE9IG51bGwgJiYgX3RoaXMkb3B0aW9uc18uYm91bmQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwIC8qIE1ha2VSZXN1bHQuQ2FuY2VsICovIDogMSAvKiBNYWtlUmVzdWx0LkJyZWFrICovO1xuICB9XG4gIC8vIG93blxuICBpZiAoc291cmNlID09PSBhZG0udGFyZ2V0Xykge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDAgLyogTWFrZVJlc3VsdC5DYW5jZWwgKi8gOiAyIC8qIE1ha2VSZXN1bHQuQ29udGludWUgKi87XG4gIH1cbiAgLy8gcHJvdG90eXBlXG4gIGlmIChpc0FjdGlvbihkZXNjcmlwdG9yLnZhbHVlKSkge1xuICAgIC8vIEEgcHJvdG90eXBlIGNvdWxkIGhhdmUgYmVlbiBhbm5vdGF0ZWQgYWxyZWFkeSBieSBvdGhlciBjb25zdHJ1Y3RvcixcbiAgICAvLyByZXN0IG9mIHRoZSBwcm90byBjaGFpbiBtdXN0IGJlIGFubm90YXRlZCBhbHJlYWR5XG4gICAgcmV0dXJuIDEgLyogTWFrZVJlc3VsdC5CcmVhayAqLztcbiAgfVxuICB2YXIgYWN0aW9uRGVzY3JpcHRvciA9IGNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKTtcbiAgZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIGFjdGlvbkRlc2NyaXB0b3IpO1xuICByZXR1cm4gMiAvKiBNYWtlUmVzdWx0LkNvbnRpbnVlICovO1xufVxuZnVuY3Rpb24gZXh0ZW5kXyQxKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIGFjdGlvbkRlc2NyaXB0b3IgPSBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBhY3Rpb25EZXNjcmlwdG9yLCBwcm94eVRyYXApO1xufVxuZnVuY3Rpb24gZGVjb3JhdGVfMjAyMjNfJDEobXRoZCwgY29udGV4dCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgYXNzZXJ0MjAyMjNEZWNvcmF0b3JUeXBlKGNvbnRleHQsIFtcIm1ldGhvZFwiLCBcImZpZWxkXCJdKTtcbiAgfVxuICB2YXIga2luZCA9IGNvbnRleHQua2luZCxcbiAgICBuYW1lID0gY29udGV4dC5uYW1lLFxuICAgIGFkZEluaXRpYWxpemVyID0gY29udGV4dC5hZGRJbml0aWFsaXplcjtcbiAgdmFyIGFubiA9IHRoaXM7XG4gIHZhciBfY3JlYXRlQWN0aW9uID0gZnVuY3Rpb24gX2NyZWF0ZUFjdGlvbihtKSB7XG4gICAgdmFyIF9hbm4kb3B0aW9uc18kbmFtZSwgX2FubiRvcHRpb25zXywgX2FubiRvcHRpb25zXyRhdXRvQWN0LCBfYW5uJG9wdGlvbnNfMjtcbiAgICByZXR1cm4gY3JlYXRlQWN0aW9uKChfYW5uJG9wdGlvbnNfJG5hbWUgPSAoX2FubiRvcHRpb25zXyA9IGFubi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm4kb3B0aW9uc18ubmFtZSkgIT0gbnVsbCA/IF9hbm4kb3B0aW9uc18kbmFtZSA6IG5hbWUudG9TdHJpbmcoKSwgbSwgKF9hbm4kb3B0aW9uc18kYXV0b0FjdCA9IChfYW5uJG9wdGlvbnNfMiA9IGFubi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm4kb3B0aW9uc18yLmF1dG9BY3Rpb24pICE9IG51bGwgPyBfYW5uJG9wdGlvbnNfJGF1dG9BY3QgOiBmYWxzZSk7XG4gIH07XG4gIGlmIChraW5kID09IFwiZmllbGRcIikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5pdE10aGQpIHtcbiAgICAgIHZhciBfYW5uJG9wdGlvbnNfMztcbiAgICAgIHZhciBtdGhkID0gaW5pdE10aGQ7XG4gICAgICBpZiAoIWlzQWN0aW9uKG10aGQpKSB7XG4gICAgICAgIG10aGQgPSBfY3JlYXRlQWN0aW9uKG10aGQpO1xuICAgICAgfVxuICAgICAgaWYgKChfYW5uJG9wdGlvbnNfMyA9IGFubi5vcHRpb25zXykgIT0gbnVsbCAmJiBfYW5uJG9wdGlvbnNfMy5ib3VuZCkge1xuICAgICAgICBtdGhkID0gbXRoZC5iaW5kKHRoaXMpO1xuICAgICAgICBtdGhkLmlzTW9ieEFjdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXRoZDtcbiAgICB9O1xuICB9XG4gIGlmIChraW5kID09IFwibWV0aG9kXCIpIHtcbiAgICB2YXIgX3RoaXMkb3B0aW9uc18yO1xuICAgIGlmICghaXNBY3Rpb24obXRoZCkpIHtcbiAgICAgIG10aGQgPSBfY3JlYXRlQWN0aW9uKG10aGQpO1xuICAgIH1cbiAgICBpZiAoKF90aGlzJG9wdGlvbnNfMiA9IHRoaXMub3B0aW9uc18pICE9IG51bGwgJiYgX3RoaXMkb3B0aW9uc18yLmJvdW5kKSB7XG4gICAgICBhZGRJbml0aWFsaXplcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGJvdW5kID0gc2VsZltuYW1lXS5iaW5kKHNlbGYpO1xuICAgICAgICBib3VuZC5pc01vYnhBY3Rpb24gPSB0cnVlO1xuICAgICAgICBzZWxmW25hbWVdID0gYm91bmQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG10aGQ7XG4gIH1cbiAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubi5hbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgU3RyaW5nKG5hbWUpICsgXCInIChraW5kOiBcIiArIGtpbmQgKyBcIik6XCIgKyAoXCJcXG4nXCIgKyBhbm4uYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgb24gcHJvcGVydGllcyB3aXRoIGEgZnVuY3Rpb24gdmFsdWUuXCIpKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFjdGlvbkRlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIF9yZWYyKSB7XG4gIHZhciBhbm5vdGF0aW9uVHlwZV8gPSBfcmVmLmFubm90YXRpb25UeXBlXztcbiAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgb24gcHJvcGVydGllcyB3aXRoIGEgZnVuY3Rpb24gdmFsdWUuXCIpKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uRGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvcixcbi8vIHByb3ZpZGVzIGFiaWxpdHkgdG8gZGlzYWJsZSBzYWZlRGVzY3JpcHRvcnMgZm9yIHByb3RvdHlwZXNcbnNhZmVEZXNjcmlwdG9ycykge1xuICB2YXIgX2Fubm90YXRpb24kb3B0aW9uc18sIF9hbm5vdGF0aW9uJG9wdGlvbnNfJCwgX2Fubm90YXRpb24kb3B0aW9uc18yLCBfYW5ub3RhdGlvbiRvcHRpb25zXyQyLCBfYW5ub3RhdGlvbiRvcHRpb25zXzMsIF9hbm5vdGF0aW9uJG9wdGlvbnNfNCwgX2FkbSRwcm94eV8yO1xuICBpZiAoc2FmZURlc2NyaXB0b3JzID09PSB2b2lkIDApIHtcbiAgICBzYWZlRGVzY3JpcHRvcnMgPSBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnM7XG4gIH1cbiAgYXNzZXJ0QWN0aW9uRGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvcik7XG4gIHZhciB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gIGlmICgoX2Fubm90YXRpb24kb3B0aW9uc18gPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSAhPSBudWxsICYmIF9hbm5vdGF0aW9uJG9wdGlvbnNfLmJvdW5kKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfO1xuICAgIHZhbHVlID0gdmFsdWUuYmluZCgoX2FkbSRwcm94eV8gPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8gOiBhZG0udGFyZ2V0Xyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogY3JlYXRlQWN0aW9uKChfYW5ub3RhdGlvbiRvcHRpb25zXyQgPSAoX2Fubm90YXRpb24kb3B0aW9uc18yID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfMi5uYW1lKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kIDoga2V5LnRvU3RyaW5nKCksIHZhbHVlLCAoX2Fubm90YXRpb24kb3B0aW9uc18kMiA9IChfYW5ub3RhdGlvbiRvcHRpb25zXzMgPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX2Fubm90YXRpb24kb3B0aW9uc18zLmF1dG9BY3Rpb24pICE9IG51bGwgPyBfYW5ub3RhdGlvbiRvcHRpb25zXyQyIDogZmFsc2UsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2Rpc2N1c3Npb25zLzMxNDBcbiAgICAoX2Fubm90YXRpb24kb3B0aW9uc180ID0gYW5ub3RhdGlvbi5vcHRpb25zXykgIT0gbnVsbCAmJiBfYW5ub3RhdGlvbiRvcHRpb25zXzQuYm91bmQgPyAoX2FkbSRwcm94eV8yID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfMiA6IGFkbS50YXJnZXRfIDogdW5kZWZpbmVkKSxcbiAgICAvLyBOb24tY29uZmlndXJhYmxlIGZvciBjbGFzc2VzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbCBmaWVsZCByZWRlZmluaXRpb24gaW4gc3ViY2xhc3NcbiAgICBjb25maWd1cmFibGU6IHNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L3B1bGwvMjY0MSNpc3N1ZWNvbW1lbnQtNzM3MjkyMDU4XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgLy8gTm9uLW9ic2V2YWJsZSwgdGhlcmVmb3JlIG5vbi13cml0YWJsZVxuICAgIC8vIEFsc28gcHJldmVudHMgcmV3cml0aW5nIGluIHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gICAgd3JpdGFibGU6IHNhZmVEZXNjcmlwdG9ycyA/IGZhbHNlIDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGbG93QW5ub3RhdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBuYW1lLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQyLFxuICAgIGV4dGVuZF86IGV4dGVuZF8kMixcbiAgICBkZWNvcmF0ZV8yMDIyM186IGRlY29yYXRlXzIwMjIzXyQyXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlXyQyKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfO1xuICAvLyBvd25cbiAgaWYgKHNvdXJjZSA9PT0gYWRtLnRhcmdldF8pIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwIC8qIE1ha2VSZXN1bHQuQ2FuY2VsICovIDogMiAvKiBNYWtlUmVzdWx0LkNvbnRpbnVlICovO1xuICB9XG4gIC8vIHByb3RvdHlwZVxuICAvLyBib3VuZCAtIG11c3QgYW5ub3RhdGUgcHJvdG9zIHRvIHN1cHBvcnQgc3VwZXIuZmxvdygpXG4gIGlmICgoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSAhPSBudWxsICYmIF90aGlzJG9wdGlvbnNfLmJvdW5kICYmICghaGFzUHJvcChhZG0udGFyZ2V0Xywga2V5KSB8fCAhaXNGbG93KGFkbS50YXJnZXRfW2tleV0pKSkge1xuICAgIGlmICh0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDAgLyogTWFrZVJlc3VsdC5DYW5jZWwgKi87XG4gICAgfVxuICB9XG4gIGlmIChpc0Zsb3coZGVzY3JpcHRvci52YWx1ZSkpIHtcbiAgICAvLyBBIHByb3RvdHlwZSBjb3VsZCBoYXZlIGJlZW4gYW5ub3RhdGVkIGFscmVhZHkgYnkgb3RoZXIgY29uc3RydWN0b3IsXG4gICAgLy8gcmVzdCBvZiB0aGUgcHJvdG8gY2hhaW4gbXVzdCBiZSBhbm5vdGF0ZWQgYWxyZWFkeVxuICAgIHJldHVybiAxIC8qIE1ha2VSZXN1bHQuQnJlYWsgKi87XG4gIH1cbiAgdmFyIGZsb3dEZXNjcmlwdG9yID0gY3JlYXRlRmxvd0Rlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlLCBmYWxzZSk7XG4gIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBmbG93RGVzY3JpcHRvcik7XG4gIHJldHVybiAyIC8qIE1ha2VSZXN1bHQuQ29udGludWUgKi87XG59XG5mdW5jdGlvbiBleHRlbmRfJDIoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgX3RoaXMkb3B0aW9uc18yO1xuICB2YXIgZmxvd0Rlc2NyaXB0b3IgPSBjcmVhdGVGbG93RGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvciwgKF90aGlzJG9wdGlvbnNfMiA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzIuYm91bmQpO1xuICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIGZsb3dEZXNjcmlwdG9yLCBwcm94eVRyYXApO1xufVxuZnVuY3Rpb24gZGVjb3JhdGVfMjAyMjNfJDIobXRoZCwgY29udGV4dCkge1xuICB2YXIgX3RoaXMkb3B0aW9uc18zO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgYXNzZXJ0MjAyMjNEZWNvcmF0b3JUeXBlKGNvbnRleHQsIFtcIm1ldGhvZFwiXSk7XG4gIH1cbiAgdmFyIG5hbWUgPSBjb250ZXh0Lm5hbWUsXG4gICAgYWRkSW5pdGlhbGl6ZXIgPSBjb250ZXh0LmFkZEluaXRpYWxpemVyO1xuICBpZiAoIWlzRmxvdyhtdGhkKSkge1xuICAgIG10aGQgPSBmbG93KG10aGQpO1xuICB9XG4gIGlmICgoX3RoaXMkb3B0aW9uc18zID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXzMuYm91bmQpIHtcbiAgICBhZGRJbml0aWFsaXplcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYm91bmQgPSBzZWxmW25hbWVdLmJpbmQoc2VsZik7XG4gICAgICBib3VuZC5pc01vYlhGbG93ID0gdHJ1ZTtcbiAgICAgIHNlbGZbbmFtZV0gPSBib3VuZDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbXRoZDtcbn1cbmZ1bmN0aW9uIGFzc2VydEZsb3dEZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBfcmVmMikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIG9uIHByb3BlcnRpZXMgd2l0aCBhIGdlbmVyYXRvciBmdW5jdGlvbiB2YWx1ZS5cIikpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVGbG93RGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvciwgYm91bmQsXG4vLyBwcm92aWRlcyBhYmlsaXR5IHRvIGRpc2FibGUgc2FmZURlc2NyaXB0b3JzIGZvciBwcm90b3R5cGVzXG5zYWZlRGVzY3JpcHRvcnMpIHtcbiAgaWYgKHNhZmVEZXNjcmlwdG9ycyA9PT0gdm9pZCAwKSB7XG4gICAgc2FmZURlc2NyaXB0b3JzID0gZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzO1xuICB9XG4gIGFzc2VydEZsb3dEZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgdmFyIHZhbHVlID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgLy8gSW4gY2FzZSBvZiBmbG93LmJvdW5kLCB0aGUgZGVzY3JpcHRvciBjYW4gYmUgZnJvbSBhbHJlYWR5IGFubm90YXRlZCBwcm90b3R5cGVcbiAgaWYgKCFpc0Zsb3codmFsdWUpKSB7XG4gICAgdmFsdWUgPSBmbG93KHZhbHVlKTtcbiAgfVxuICBpZiAoYm91bmQpIHtcbiAgICB2YXIgX2FkbSRwcm94eV87XG4gICAgLy8gV2UgZG8gbm90IGtlZXAgb3JpZ2luYWwgZnVuY3Rpb24gYXJvdW5kLCBzbyB3ZSBiaW5kIHRoZSBleGlzdGluZyBmbG93XG4gICAgdmFsdWUgPSB2YWx1ZS5iaW5kKChfYWRtJHByb3h5XyA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XyA6IGFkbS50YXJnZXRfKTtcbiAgICAvLyBUaGlzIGlzIG5vcm1hbGx5IHNldCBieSBgZmxvd2AsIGJ1dCBgYmluZGAgcmV0dXJucyBuZXcgZnVuY3Rpb24uLi5cbiAgICB2YWx1ZS5pc01vYlhGbG93ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAvLyBOb24tY29uZmlndXJhYmxlIGZvciBjbGFzc2VzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbCBmaWVsZCByZWRlZmluaXRpb24gaW4gc3ViY2xhc3NcbiAgICBjb25maWd1cmFibGU6IHNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L3B1bGwvMjY0MSNpc3N1ZWNvbW1lbnQtNzM3MjkyMDU4XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgLy8gTm9uLW9ic2V2YWJsZSwgdGhlcmVmb3JlIG5vbi13cml0YWJsZVxuICAgIC8vIEFsc28gcHJldmVudHMgcmV3cml0aW5nIGluIHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gICAgd3JpdGFibGU6IHNhZmVEZXNjcmlwdG9ycyA/IGZhbHNlIDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEFubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kMyxcbiAgICBleHRlbmRfOiBleHRlbmRfJDMsXG4gICAgZGVjb3JhdGVfMjAyMjNfOiBkZWNvcmF0ZV8yMDIyM18kM1xuICB9O1xufVxuZnVuY3Rpb24gbWFrZV8kMyhhZG0sIGtleSwgZGVzY3JpcHRvcikge1xuICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwIC8qIE1ha2VSZXN1bHQuQ2FuY2VsICovIDogMSAvKiBNYWtlUmVzdWx0LkJyZWFrICovO1xufVxuZnVuY3Rpb24gZXh0ZW5kXyQzKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgYXNzZXJ0Q29tcHV0ZWREZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVDb21wdXRlZFByb3BlcnR5XyhrZXksIF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnNfLCB7XG4gICAgZ2V0OiBkZXNjcmlwdG9yLmdldCxcbiAgICBzZXQ6IGRlc2NyaXB0b3Iuc2V0XG4gIH0pLCBwcm94eVRyYXApO1xufVxuZnVuY3Rpb24gZGVjb3JhdGVfMjAyMjNfJDMoZ2V0LCBjb250ZXh0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBhc3NlcnQyMDIyM0RlY29yYXRvclR5cGUoY29udGV4dCwgW1wiZ2V0dGVyXCJdKTtcbiAgfVxuICB2YXIgYW5uID0gdGhpcztcbiAgdmFyIGtleSA9IGNvbnRleHQubmFtZSxcbiAgICBhZGRJbml0aWFsaXplciA9IGNvbnRleHQuYWRkSW5pdGlhbGl6ZXI7XG4gIGFkZEluaXRpYWxpemVyKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWRtID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRoaXMpWyRtb2J4XTtcbiAgICB2YXIgb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBhbm4ub3B0aW9uc18sIHtcbiAgICAgIGdldDogZ2V0LFxuICAgICAgY29udGV4dDogdGhpc1xuICAgIH0pO1xuICAgIG9wdGlvbnMubmFtZSB8fCAob3B0aW9ucy5uYW1lID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSA6IFwiT2JzZXJ2YWJsZU9iamVjdC5cIiArIGtleS50b1N0cmluZygpKTtcbiAgICBhZG0udmFsdWVzXy5zZXQoa2V5LCBuZXcgQ29tcHV0ZWRWYWx1ZShvcHRpb25zKSk7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzWyRtb2J4XS5nZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXkpO1xuICB9O1xufVxuZnVuY3Rpb24gYXNzZXJ0Q29tcHV0ZWREZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBfcmVmMikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIHZhciBnZXQgPSBfcmVmMi5nZXQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWdldCkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIG9uIGdldHRlcigrc2V0dGVyKSBwcm9wZXJ0aWVzLlwiKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kNCxcbiAgICBleHRlbmRfOiBleHRlbmRfJDQsXG4gICAgZGVjb3JhdGVfMjAyMjNfOiBkZWNvcmF0ZV8yMDIyM18kNFxuICB9O1xufVxuZnVuY3Rpb24gbWFrZV8kNChhZG0sIGtleSwgZGVzY3JpcHRvcikge1xuICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwIC8qIE1ha2VSZXN1bHQuQ2FuY2VsICovIDogMSAvKiBNYWtlUmVzdWx0LkJyZWFrICovO1xufVxuZnVuY3Rpb24gZXh0ZW5kXyQ0KGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfJGVuaGFuYywgX3RoaXMkb3B0aW9uc187XG4gIGFzc2VydE9ic2VydmFibGVEZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvci52YWx1ZSwgKF90aGlzJG9wdGlvbnNfJGVuaGFuYyA9IChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXy5lbmhhbmNlcikgIT0gbnVsbCA/IF90aGlzJG9wdGlvbnNfJGVuaGFuYyA6IGRlZXBFbmhhbmNlciwgcHJveHlUcmFwKTtcbn1cbmZ1bmN0aW9uIGRlY29yYXRlXzIwMjIzXyQ0KGRlc2MsIGNvbnRleHQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb250ZXh0LmtpbmQgPT09IFwiZmllbGRcIikge1xuICAgICAgdGhyb3cgZGllKFwiUGxlYXNlIHVzZSBgQG9ic2VydmFibGUgYWNjZXNzb3IgXCIgKyBTdHJpbmcoY29udGV4dC5uYW1lKSArIFwiYCBpbnN0ZWFkIG9mIGBAb2JzZXJ2YWJsZSBcIiArIFN0cmluZyhjb250ZXh0Lm5hbWUpICsgXCJgXCIpO1xuICAgIH1cbiAgICBhc3NlcnQyMDIyM0RlY29yYXRvclR5cGUoY29udGV4dCwgW1wiYWNjZXNzb3JcIl0pO1xuICB9XG4gIHZhciBhbm4gPSB0aGlzO1xuICB2YXIga2luZCA9IGNvbnRleHQua2luZCxcbiAgICBuYW1lID0gY29udGV4dC5uYW1lO1xuICAvLyBUaGUgbGF6aW5lc3MgaGVyZSBpcyBub3QgaWRlYWwuLi4gSXQncyBhIHdvcmthcm91bmQgdG8gaG93IDIwMjIuMyBEZWNvcmF0b3JzIGFyZSBpbXBsZW1lbnRlZDpcbiAgLy8gICBgYWRkSW5pdGlhbGl6ZXJgIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWQgX2JlZm9yZV8gYW55IGFjY2Vzc29ycyBhcmUgZGVmaW5lZCAoaW5zdGVhZCBvZiB0aGUgaWRlYWwtZm9yLXVzIHJpZ2h0IGFmdGVyIGVhY2gpLlxuICAvLyAgIFRoaXMgbWVhbnMgdGhhdCwgaWYgd2Ugd2VyZSB0byBkbyBvdXIgc3R1ZmYgaW4gYW4gYGFkZEluaXRpYWxpemVyYCwgd2UnZCBhdHRlbXB0IHRvIHJlYWQgYSBwcml2YXRlIHNsb3RcbiAgLy8gICBiZWZvcmUgaXQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuIFRoZSBydW50aW1lIGRvZXNuJ3QgbGlrZSB0aGF0IGFuZCB0aHJvd3MgYSBgQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXJcbiAgLy8gICBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRgIGVycm9yLlxuICAvLyBUT0RPOiBpdCBzZWVtcyB0aGF0IHRoaXMgd2lsbCBub3QgYmUgcmVxdWlyZWQgYW55bW9yZSBpbiB0aGUgZmluYWwgdmVyc2lvbiBvZiB0aGUgc3BlY1xuICAvLyBTZWUgVE9ETzogbGlua1xuICB2YXIgaW5pdGlhbGl6ZWRPYmplY3RzID0gbmV3IFdlYWtTZXQoKTtcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZU9ic2VydmFibGUodGFyZ2V0LCB2YWx1ZSkge1xuICAgIHZhciBfYW5uJG9wdGlvbnNfJGVuaGFuY2UsIF9hbm4kb3B0aW9uc187XG4gICAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQpWyRtb2J4XTtcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUodmFsdWUsIChfYW5uJG9wdGlvbnNfJGVuaGFuY2UgPSAoX2FubiRvcHRpb25zXyA9IGFubi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm4kb3B0aW9uc18uZW5oYW5jZXIpICE9IG51bGwgPyBfYW5uJG9wdGlvbnNfJGVuaGFuY2UgOiBkZWVwRW5oYW5jZXIsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGFkbS5uYW1lXyArIFwiLlwiICsgbmFtZS50b1N0cmluZygpIDogXCJPYnNlcnZhYmxlT2JqZWN0LlwiICsgbmFtZS50b1N0cmluZygpLCBmYWxzZSk7XG4gICAgYWRtLnZhbHVlc18uc2V0KG5hbWUsIG9ic2VydmFibGUpO1xuICAgIGluaXRpYWxpemVkT2JqZWN0cy5hZGQodGFyZ2V0KTtcbiAgfVxuICBpZiAoa2luZCA9PSBcImFjY2Vzc29yXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghaW5pdGlhbGl6ZWRPYmplY3RzLmhhcyh0aGlzKSkge1xuICAgICAgICAgIGluaXRpYWxpemVPYnNlcnZhYmxlKHRoaXMsIGRlc2MuZ2V0LmNhbGwodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzWyRtb2J4XS5nZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhuYW1lKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoIWluaXRpYWxpemVkT2JqZWN0cy5oYXModGhpcykpIHtcbiAgICAgICAgICBpbml0aWFsaXplT2JzZXJ2YWJsZSh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLnNldE9ic2VydmFibGVQcm9wVmFsdWVfKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KHZhbHVlKSB7XG4gICAgICAgIGlmICghaW5pdGlhbGl6ZWRPYmplY3RzLmhhcyh0aGlzKSkge1xuICAgICAgICAgIGluaXRpYWxpemVPYnNlcnZhYmxlKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm47XG59XG5mdW5jdGlvbiBhc3NlcnRPYnNlcnZhYmxlRGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgZGVzY3JpcHRvcikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2Fubm90IGJlIHVzZWQgb24gZ2V0dGVyL3NldHRlciBwcm9wZXJ0aWVzXCIpKTtcbiAgfVxufVxuXG52YXIgQVVUTyA9IFwidHJ1ZVwiO1xudmFyIGF1dG9Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUF1dG9Bbm5vdGF0aW9uKCk7XG5mdW5jdGlvbiBjcmVhdGVBdXRvQW5ub3RhdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBBVVRPLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQ1LFxuICAgIGV4dGVuZF86IGV4dGVuZF8kNSxcbiAgICBkZWNvcmF0ZV8yMDIyM186IGRlY29yYXRlXzIwMjIzXyQ1XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlXyQ1KGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfMywgX3RoaXMkb3B0aW9uc180O1xuICAvLyBnZXR0ZXIgLT4gY29tcHV0ZWRcbiAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkLm1ha2VfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpO1xuICB9XG4gIC8vIGxvbmUgc2V0dGVyIC0+IGFjdGlvbiBzZXR0ZXJcbiAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgLy8gVE9ETyBtYWtlIGFjdGlvbiBhcHBsaWNhYmxlIHRvIHNldHRlciBhbmQgZGVsZWdhdGUgdG8gYWN0aW9uLm1ha2VfXG4gICAgdmFyIHNldCA9IGNyZWF0ZUFjdGlvbihrZXkudG9TdHJpbmcoKSwgZGVzY3JpcHRvci5zZXQpO1xuICAgIC8vIG93blxuICAgIGlmIChzb3VyY2UgPT09IGFkbS50YXJnZXRfKSB7XG4gICAgICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgICBzZXQ6IHNldFxuICAgICAgfSkgPT09IG51bGwgPyAwIC8qIE1ha2VSZXN1bHQuQ2FuY2VsICovIDogMiAvKiBNYWtlUmVzdWx0LkNvbnRpbnVlICovO1xuICAgIH1cbiAgICAvLyBwcm90b1xuICAgIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IHNldFxuICAgIH0pO1xuICAgIHJldHVybiAyIC8qIE1ha2VSZXN1bHQuQ29udGludWUgKi87XG4gIH1cbiAgLy8gZnVuY3Rpb24gb24gcHJvdG8gLT4gYXV0b0FjdGlvbi9mbG93XG4gIGlmIChzb3VyY2UgIT09IGFkbS50YXJnZXRfICYmIHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgX3RoaXMkb3B0aW9uc18yO1xuICAgIGlmIChpc0dlbmVyYXRvcihkZXNjcmlwdG9yLnZhbHVlKSkge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnNfO1xuICAgICAgdmFyIGZsb3dBbm5vdGF0aW9uID0gKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXy5hdXRvQmluZCA/IGZsb3cuYm91bmQgOiBmbG93O1xuICAgICAgcmV0dXJuIGZsb3dBbm5vdGF0aW9uLm1ha2VfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpO1xuICAgIH1cbiAgICB2YXIgYWN0aW9uQW5ub3RhdGlvbiA9IChfdGhpcyRvcHRpb25zXzIgPSB0aGlzLm9wdGlvbnNfKSAhPSBudWxsICYmIF90aGlzJG9wdGlvbnNfMi5hdXRvQmluZCA/IGF1dG9BY3Rpb24uYm91bmQgOiBhdXRvQWN0aW9uO1xuICAgIHJldHVybiBhY3Rpb25Bbm5vdGF0aW9uLm1ha2VfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpO1xuICB9XG4gIC8vIG90aGVyIC0+IG9ic2VydmFibGVcbiAgLy8gQ29weSBwcm9wcyBmcm9tIHByb3RvIGFzIHdlbGwsIHNlZSB0ZXN0OlxuICAvLyBcImRlY29yYXRlIHNob3VsZCB3b3JrIHdpdGggT2JqZWN0LmNyZWF0ZVwiXG4gIHZhciBvYnNlcnZhYmxlQW5ub3RhdGlvbiA9ICgoX3RoaXMkb3B0aW9uc18zID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfMy5kZWVwKSA9PT0gZmFsc2UgPyBvYnNlcnZhYmxlLnJlZiA6IG9ic2VydmFibGU7XG4gIC8vIGlmIGZ1bmN0aW9uIHJlc3BlY3QgYXV0b0JpbmQgb3B0aW9uXG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIChfdGhpcyRvcHRpb25zXzQgPSB0aGlzLm9wdGlvbnNfKSAhPSBudWxsICYmIF90aGlzJG9wdGlvbnNfNC5hdXRvQmluZCkge1xuICAgIHZhciBfYWRtJHByb3h5XztcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZGVzY3JpcHRvci52YWx1ZS5iaW5kKChfYWRtJHByb3h5XyA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XyA6IGFkbS50YXJnZXRfKTtcbiAgfVxuICByZXR1cm4gb2JzZXJ2YWJsZUFubm90YXRpb24ubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG59XG5mdW5jdGlvbiBleHRlbmRfJDUoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgX3RoaXMkb3B0aW9uc181LCBfdGhpcyRvcHRpb25zXzY7XG4gIC8vIGdldHRlciAtPiBjb21wdXRlZFxuICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbiAgfVxuICAvLyBsb25lIHNldHRlciAtPiBhY3Rpb24gc2V0dGVyXG4gIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgIC8vIFRPRE8gbWFrZSBhY3Rpb24gYXBwbGljYWJsZSB0byBzZXR0ZXIgYW5kIGRlbGVnYXRlIHRvIGFjdGlvbi5leHRlbmRfXG4gICAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICBzZXQ6IGNyZWF0ZUFjdGlvbihrZXkudG9TdHJpbmcoKSwgZGVzY3JpcHRvci5zZXQpXG4gICAgfSwgcHJveHlUcmFwKTtcbiAgfVxuICAvLyBvdGhlciAtPiBvYnNlcnZhYmxlXG4gIC8vIGlmIGZ1bmN0aW9uIHJlc3BlY3QgYXV0b0JpbmQgb3B0aW9uXG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIChfdGhpcyRvcHRpb25zXzUgPSB0aGlzLm9wdGlvbnNfKSAhPSBudWxsICYmIF90aGlzJG9wdGlvbnNfNS5hdXRvQmluZCkge1xuICAgIHZhciBfYWRtJHByb3h5XzI7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWUuYmluZCgoX2FkbSRwcm94eV8yID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfMiA6IGFkbS50YXJnZXRfKTtcbiAgfVxuICB2YXIgb2JzZXJ2YWJsZUFubm90YXRpb24gPSAoKF90aGlzJG9wdGlvbnNfNiA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzYuZGVlcCkgPT09IGZhbHNlID8gb2JzZXJ2YWJsZS5yZWYgOiBvYnNlcnZhYmxlO1xuICByZXR1cm4gb2JzZXJ2YWJsZUFubm90YXRpb24uZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbn1cbmZ1bmN0aW9uIGRlY29yYXRlXzIwMjIzXyQ1KGRlc2MsIGNvbnRleHQpIHtcbiAgZGllKFwiJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicgY2Fubm90IGJlIHVzZWQgYXMgYSBkZWNvcmF0b3JcIik7XG59XG5cbnZhciBPQlNFUlZBQkxFID0gXCJvYnNlcnZhYmxlXCI7XG52YXIgT0JTRVJWQUJMRV9SRUYgPSBcIm9ic2VydmFibGUucmVmXCI7XG52YXIgT0JTRVJWQUJMRV9TSEFMTE9XID0gXCJvYnNlcnZhYmxlLnNoYWxsb3dcIjtcbnZhciBPQlNFUlZBQkxFX1NUUlVDVCA9IFwib2JzZXJ2YWJsZS5zdHJ1Y3RcIjtcbi8vIFByZWRlZmluZWQgYmFncyBvZiBjcmVhdGUgb2JzZXJ2YWJsZSBvcHRpb25zLCB0byBhdm9pZCBhbGxvY2F0aW5nIHRlbXBvcmFyaWx5IG9wdGlvbiBvYmplY3RzXG4vLyBpbiB0aGUgbWFqb3JpdHkgb2YgY2FzZXNcbnZhciBkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMgPSB7XG4gIGRlZXA6IHRydWUsXG4gIG5hbWU6IHVuZGVmaW5lZCxcbiAgZGVmYXVsdERlY29yYXRvcjogdW5kZWZpbmVkLFxuICBwcm94eTogdHJ1ZVxufTtcbk9iamVjdC5mcmVlemUoZGVmYXVsdENyZWF0ZU9ic2VydmFibGVPcHRpb25zKTtcbmZ1bmN0aW9uIGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnModGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nIHx8IGRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucztcbn1cbnZhciBvYnNlcnZhYmxlQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFKTtcbnZhciBvYnNlcnZhYmxlUmVmQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFX1JFRiwge1xuICBlbmhhbmNlcjogcmVmZXJlbmNlRW5oYW5jZXJcbn0pO1xudmFyIG9ic2VydmFibGVTaGFsbG93QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFX1NIQUxMT1csIHtcbiAgZW5oYW5jZXI6IHNoYWxsb3dFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZVN0cnVjdEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRV9TVFJVQ1QsIHtcbiAgZW5oYW5jZXI6IHJlZlN0cnVjdEVuaGFuY2VyXG59KTtcbnZhciBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKG9ic2VydmFibGVBbm5vdGF0aW9uKTtcbmZ1bmN0aW9uIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kZWVwID09PSB0cnVlID8gZGVlcEVuaGFuY2VyIDogb3B0aW9ucy5kZWVwID09PSBmYWxzZSA/IHJlZmVyZW5jZUVuaGFuY2VyIDogZ2V0RW5oYW5jZXJGcm9tQW5ub3RhdGlvbihvcHRpb25zLmRlZmF1bHREZWNvcmF0b3IpO1xufVxuZnVuY3Rpb24gZ2V0QW5ub3RhdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGRlZmF1bHREZWNvcjtcbiAgcmV0dXJuIG9wdGlvbnMgPyAoX29wdGlvbnMkZGVmYXVsdERlY29yID0gb3B0aW9ucy5kZWZhdWx0RGVjb3JhdG9yKSAhPSBudWxsID8gX29wdGlvbnMkZGVmYXVsdERlY29yIDogY3JlYXRlQXV0b0Fubm90YXRpb24ob3B0aW9ucykgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRFbmhhbmNlckZyb21Bbm5vdGF0aW9uKGFubm90YXRpb24pIHtcbiAgdmFyIF9hbm5vdGF0aW9uJG9wdGlvbnNfJCwgX2Fubm90YXRpb24kb3B0aW9uc187XG4gIHJldHVybiAhYW5ub3RhdGlvbiA/IGRlZXBFbmhhbmNlciA6IChfYW5ub3RhdGlvbiRvcHRpb25zXyQgPSAoX2Fubm90YXRpb24kb3B0aW9uc18gPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX2Fubm90YXRpb24kb3B0aW9uc18uZW5oYW5jZXIpICE9IG51bGwgPyBfYW5ub3RhdGlvbiRvcHRpb25zXyQgOiBkZWVwRW5oYW5jZXI7XG59XG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCwgYXJyYXkgb3IgZnVuY3Rpb24gaW50byBhIHJlYWN0aXZlIHN0cnVjdHVyZS5cbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB3aGljaCBzaG91bGQgYmVjb21lIG9ic2VydmFibGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGUodiwgYXJnMiwgYXJnMykge1xuICAvLyBAb2JzZXJ2YWJsZSBzb21lUHJvcDsgKDIwMjIuMyBEZWNvcmF0b3JzKVxuICBpZiAoaXMyMDIyM0RlY29yYXRvcihhcmcyKSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlQW5ub3RhdGlvbi5kZWNvcmF0ZV8yMDIyM18odiwgYXJnMik7XG4gIH1cbiAgLy8gQG9ic2VydmFibGUgc29tZVByb3A7XG4gIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgIHN0b3JlQW5ub3RhdGlvbih2LCBhcmcyLCBvYnNlcnZhYmxlQW5ub3RhdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGFscmVhZHkgb2JzZXJ2YWJsZSAtIGlnbm9yZVxuICBpZiAoaXNPYnNlcnZhYmxlKHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgLy8gcGxhaW4gb2JqZWN0XG4gIGlmIChpc1BsYWluT2JqZWN0KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUub2JqZWN0KHYsIGFyZzIsIGFyZzMpO1xuICB9XG4gIC8vIEFycmF5XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkodiwgYXJnMik7XG4gIH1cbiAgLy8gTWFwXG4gIGlmIChpc0VTNk1hcCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCBhcmcyKTtcbiAgfVxuICAvLyBTZXRcbiAgaWYgKGlzRVM2U2V0KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUuc2V0KHYsIGFyZzIpO1xuICB9XG4gIC8vIG90aGVyIG9iamVjdCAtIGlnbm9yZVxuICBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPT0gbnVsbCkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIC8vIGFueXRoaW5nIGVsc2VcbiAgcmV0dXJuIG9ic2VydmFibGUuYm94KHYsIGFyZzIpO1xufVxuYXNzaWduKGNyZWF0ZU9ic2VydmFibGUsIG9ic2VydmFibGVEZWNvcmF0b3JBbm5vdGF0aW9uKTtcbnZhciBvYnNlcnZhYmxlRmFjdG9yaWVzID0ge1xuICBib3g6IGZ1bmN0aW9uIGJveCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lLCB0cnVlLCBvLmVxdWFscyk7XG4gIH0sXG4gIGFycmF5OiBmdW5jdGlvbiBhcnJheShpbml0aWFsVmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiAoZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9PT0gZmFsc2UgfHwgby5wcm94eSA9PT0gZmFsc2UgPyBjcmVhdGVMZWdhY3lBcnJheSA6IGNyZWF0ZU9ic2VydmFibGVBcnJheSkoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVNYXAoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTZXQoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QocHJvcHMsIGRlY29yYXRvcnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5pdE9ic2VydmFibGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZE9ic2VydmFibGUoZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9PT0gZmFsc2UgfHwgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucHJveHkpID09PSBmYWxzZSA/IGFzT2JzZXJ2YWJsZU9iamVjdCh7fSwgb3B0aW9ucykgOiBhc0R5bmFtaWNPYnNlcnZhYmxlT2JqZWN0KHt9LCBvcHRpb25zKSwgcHJvcHMsIGRlY29yYXRvcnMpO1xuICAgIH0pO1xuICB9LFxuICByZWY6IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKG9ic2VydmFibGVSZWZBbm5vdGF0aW9uKSxcbiAgc2hhbGxvdzogLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24ob2JzZXJ2YWJsZVNoYWxsb3dBbm5vdGF0aW9uKSxcbiAgZGVlcDogb2JzZXJ2YWJsZURlY29yYXRvckFubm90YXRpb24sXG4gIHN0cnVjdDogLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24ob2JzZXJ2YWJsZVN0cnVjdEFubm90YXRpb24pXG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgb2JzZXJ2YWJsZSA9IC8qI19fUFVSRV9fKi9hc3NpZ24oY3JlYXRlT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZUZhY3Rvcmllcyk7XG5cbnZhciBDT01QVVRFRCA9IFwiY29tcHV0ZWRcIjtcbnZhciBDT01QVVRFRF9TVFJVQ1QgPSBcImNvbXB1dGVkLnN0cnVjdFwiO1xudmFyIGNvbXB1dGVkQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURUQpO1xudmFyIGNvbXB1dGVkU3RydWN0QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURURfU1RSVUNULCB7XG4gIGVxdWFsczogY29tcGFyZXIuc3RydWN0dXJhbFxufSk7XG4vKipcbiAqIERlY29yYXRvciBmb3IgY2xhc3MgcHJvcGVydGllczogQGNvbXB1dGVkIGdldCB2YWx1ZSgpIHsgcmV0dXJuIGV4cHI7IH0uXG4gKiBGb3IgbGVnYWN5IHB1cnBvc2VzIGFsc28gaW52b2thYmxlIGFzIEVTNSBvYnNlcnZhYmxlIGNyZWF0ZWQ6IGBjb21wdXRlZCgoKSA9PiBleHByKWA7XG4gKi9cbnZhciBjb21wdXRlZCA9IGZ1bmN0aW9uIGNvbXB1dGVkKGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzMjAyMjNEZWNvcmF0b3IoYXJnMikpIHtcbiAgICAvLyBAY29tcHV0ZWQgKDIwMjIuMyBEZWNvcmF0b3JzKVxuICAgIHJldHVybiBjb21wdXRlZEFubm90YXRpb24uZGVjb3JhdGVfMjAyMjNfKGFyZzEsIGFyZzIpO1xuICB9XG4gIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgIC8vIEBjb21wdXRlZFxuICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgY29tcHV0ZWRBbm5vdGF0aW9uKTtcbiAgfVxuICBpZiAoaXNQbGFpbk9iamVjdChhcmcxKSkge1xuICAgIC8vIEBjb21wdXRlZCh7IG9wdGlvbnMgfSlcbiAgICByZXR1cm4gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihjcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURUQsIGFyZzEpKTtcbiAgfVxuICAvLyBjb21wdXRlZChleHByLCBvcHRpb25zPylcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNGdW5jdGlvbihhcmcxKSkge1xuICAgICAgZGllKFwiRmlyc3QgYXJndW1lbnQgdG8gYGNvbXB1dGVkYCBzaG91bGQgYmUgYW4gZXhwcmVzc2lvbi5cIik7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSB7XG4gICAgICBkaWUoXCJBIHNldHRlciBhcyBzZWNvbmQgYXJndW1lbnQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgdXNlIGB7IHNldDogZm4gfWAgb3B0aW9uIGluc3RlYWRcIik7XG4gICAgfVxuICB9XG4gIHZhciBvcHRzID0gaXNQbGFpbk9iamVjdChhcmcyKSA/IGFyZzIgOiB7fTtcbiAgb3B0cy5nZXQgPSBhcmcxO1xuICBvcHRzLm5hbWUgfHwgKG9wdHMubmFtZSA9IGFyZzEubmFtZSB8fCBcIlwiKTsgLyogZm9yIGdlbmVyYXRlZCBuYW1lICovXG4gIHJldHVybiBuZXcgQ29tcHV0ZWRWYWx1ZShvcHRzKTtcbn07XG5PYmplY3QuYXNzaWduKGNvbXB1dGVkLCBjb21wdXRlZEFubm90YXRpb24pO1xuY29tcHV0ZWQuc3RydWN0ID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oY29tcHV0ZWRTdHJ1Y3RBbm5vdGF0aW9uKTtcblxudmFyIF9nZXREZXNjcmlwdG9yJGNvbmZpZywgX2dldERlc2NyaXB0b3I7XG4vLyB3ZSBkb24ndCB1c2UgZ2xvYmFsU3RhdGUgZm9yIHRoZXNlIGluIG9yZGVyIHRvIGF2b2lkIHBvc3NpYmxlIGlzc3VlcyB3aXRoIG11bHRpcGxlXG4vLyBtb2J4IHZlcnNpb25zXG52YXIgY3VycmVudEFjdGlvbklkID0gMDtcbnZhciBuZXh0QWN0aW9uSWQgPSAxO1xudmFyIGlzRnVuY3Rpb25OYW1lQ29uZmlndXJhYmxlID0gKF9nZXREZXNjcmlwdG9yJGNvbmZpZyA9IChfZ2V0RGVzY3JpcHRvciA9IC8qI19fUFVSRV9fKi9nZXREZXNjcmlwdG9yKGZ1bmN0aW9uICgpIHt9LCBcIm5hbWVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0RGVzY3JpcHRvci5jb25maWd1cmFibGUpICE9IG51bGwgPyBfZ2V0RGVzY3JpcHRvciRjb25maWcgOiBmYWxzZTtcbi8vIHdlIGNhbiBzYWZlbHkgcmVjeWNsZSB0aGlzIG9iamVjdFxudmFyIHRtcE5hbWVEZXNjcmlwdG9yID0ge1xuICB2YWx1ZTogXCJhY3Rpb25cIixcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlXG59O1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKGFjdGlvbk5hbWUsIGZuLCBhdXRvQWN0aW9uLCByZWYpIHtcbiAgaWYgKGF1dG9BY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIGF1dG9BY3Rpb24gPSBmYWxzZTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgZGllKFwiYGFjdGlvbmAgY2FuIG9ubHkgYmUgaW52b2tlZCBvbiBmdW5jdGlvbnNcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWN0aW9uTmFtZSAhPT0gXCJzdHJpbmdcIiB8fCAhYWN0aW9uTmFtZSkge1xuICAgICAgZGllKFwiYWN0aW9ucyBzaG91bGQgaGF2ZSB2YWxpZCBuYW1lcywgZ290OiAnXCIgKyBhY3Rpb25OYW1lICsgXCInXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXMoKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGVBY3Rpb24oYWN0aW9uTmFtZSwgYXV0b0FjdGlvbiwgZm4sIHJlZiB8fCB0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHJlcy5pc01vYnhBY3Rpb24gPSB0cnVlO1xuICByZXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLnRvU3RyaW5nKCk7XG4gIH07XG4gIGlmIChpc0Z1bmN0aW9uTmFtZUNvbmZpZ3VyYWJsZSkge1xuICAgIHRtcE5hbWVEZXNjcmlwdG9yLnZhbHVlID0gYWN0aW9uTmFtZTtcbiAgICBkZWZpbmVQcm9wZXJ0eShyZXMsIFwibmFtZVwiLCB0bXBOYW1lRGVzY3JpcHRvcik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLCBmbiwgc2NvcGUsIGFyZ3MpIHtcbiAgdmFyIHJ1bkluZm8gPSBfc3RhcnRBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLCBzY29wZSwgYXJncyk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHNjb3BlLCBhcmdzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcnVuSW5mby5lcnJvcl8gPSBlcnI7XG4gICAgdGhyb3cgZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIF9lbmRBY3Rpb24ocnVuSW5mbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9zdGFydEFjdGlvbihhY3Rpb25OYW1lLCBjYW5SdW5Bc0Rlcml2YXRpb24sXG4vLyB0cnVlIGZvciBhdXRvQWN0aW9uXG5zY29wZSwgYXJncykge1xuICB2YXIgbm90aWZ5U3B5XyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKSAmJiAhIWFjdGlvbk5hbWU7XG4gIHZhciBzdGFydFRpbWVfID0gMDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHlfKSB7XG4gICAgc3RhcnRUaW1lXyA9IERhdGUubm93KCk7XG4gICAgdmFyIGZsYXR0ZW5lZEFyZ3MgPSBhcmdzID8gQXJyYXkuZnJvbShhcmdzKSA6IEVNUFRZX0FSUkFZO1xuICAgIHNweVJlcG9ydFN0YXJ0KHtcbiAgICAgIHR5cGU6IEFDVElPTixcbiAgICAgIG5hbWU6IGFjdGlvbk5hbWUsXG4gICAgICBvYmplY3Q6IHNjb3BlLFxuICAgICAgYXJndW1lbnRzOiBmbGF0dGVuZWRBcmdzXG4gICAgfSk7XG4gIH1cbiAgdmFyIHByZXZEZXJpdmF0aW9uXyA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgdmFyIHJ1bkFzQWN0aW9uID0gIWNhblJ1bkFzRGVyaXZhdGlvbiB8fCAhcHJldkRlcml2YXRpb25fO1xuICBzdGFydEJhdGNoKCk7XG4gIHZhciBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfID0gZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXM7IC8vIGJ5IGRlZmF1bHQgcHJlc2VydmUgcHJldmlvdXMgYWxsb3dcbiAgaWYgKHJ1bkFzQWN0aW9uKSB7XG4gICAgdW50cmFja2VkU3RhcnQoKTtcbiAgICBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydCh0cnVlKTtcbiAgfVxuICB2YXIgcHJldkFsbG93U3RhdGVSZWFkc18gPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTtcbiAgdmFyIHJ1bkluZm8gPSB7XG4gICAgcnVuQXNBY3Rpb25fOiBydW5Bc0FjdGlvbixcbiAgICBwcmV2RGVyaXZhdGlvbl86IHByZXZEZXJpdmF0aW9uXyxcbiAgICBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfOiBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfLFxuICAgIHByZXZBbGxvd1N0YXRlUmVhZHNfOiBwcmV2QWxsb3dTdGF0ZVJlYWRzXyxcbiAgICBub3RpZnlTcHlfOiBub3RpZnlTcHlfLFxuICAgIHN0YXJ0VGltZV86IHN0YXJ0VGltZV8sXG4gICAgYWN0aW9uSWRfOiBuZXh0QWN0aW9uSWQrKyxcbiAgICBwYXJlbnRBY3Rpb25JZF86IGN1cnJlbnRBY3Rpb25JZFxuICB9O1xuICBjdXJyZW50QWN0aW9uSWQgPSBydW5JbmZvLmFjdGlvbklkXztcbiAgcmV0dXJuIHJ1bkluZm87XG59XG5mdW5jdGlvbiBfZW5kQWN0aW9uKHJ1bkluZm8pIHtcbiAgaWYgKGN1cnJlbnRBY3Rpb25JZCAhPT0gcnVuSW5mby5hY3Rpb25JZF8pIHtcbiAgICBkaWUoMzApO1xuICB9XG4gIGN1cnJlbnRBY3Rpb25JZCA9IHJ1bkluZm8ucGFyZW50QWN0aW9uSWRfO1xuICBpZiAocnVuSW5mby5lcnJvcl8gIT09IHVuZGVmaW5lZCkge1xuICAgIGdsb2JhbFN0YXRlLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMgPSB0cnVlO1xuICB9XG4gIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHJ1bkluZm8ucHJldkFsbG93U3RhdGVDaGFuZ2VzXyk7XG4gIGFsbG93U3RhdGVSZWFkc0VuZChydW5JbmZvLnByZXZBbGxvd1N0YXRlUmVhZHNfKTtcbiAgZW5kQmF0Y2goKTtcbiAgaWYgKHJ1bkluZm8ucnVuQXNBY3Rpb25fKSB7XG4gICAgdW50cmFja2VkRW5kKHJ1bkluZm8ucHJldkRlcml2YXRpb25fKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHJ1bkluZm8ubm90aWZ5U3B5Xykge1xuICAgIHNweVJlcG9ydEVuZCh7XG4gICAgICB0aW1lOiBEYXRlLm5vdygpIC0gcnVuSW5mby5zdGFydFRpbWVfXG4gICAgfSk7XG4gIH1cbiAgZ2xvYmFsU3RhdGUuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXMoYWxsb3dTdGF0ZUNoYW5nZXMsIGZ1bmMpIHtcbiAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KGFsbG93U3RhdGVDaGFuZ2VzKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYygpO1xuICB9IGZpbmFsbHkge1xuICAgIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpO1xuICB9XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KGFsbG93U3RhdGVDaGFuZ2VzKSB7XG4gIHZhciBwcmV2ID0gZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXM7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gYWxsb3dTdGF0ZUNoYW5nZXM7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldikge1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9IHByZXY7XG59XG5cbnZhciBDUkVBVEUgPSBcImNyZWF0ZVwiO1xudmFyIE9ic2VydmFibGVWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F0b20pIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCBlbmhhbmNlciwgbmFtZV8sIG5vdGlmeVNweSwgZXF1YWxzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiT2JzZXJ2YWJsZVZhbHVlQFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVWYWx1ZVwiO1xuICAgIH1cbiAgICBpZiAobm90aWZ5U3B5ID09PSB2b2lkIDApIHtcbiAgICAgIG5vdGlmeVNweSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChlcXVhbHMgPT09IHZvaWQgMCkge1xuICAgICAgZXF1YWxzID0gY29tcGFyZXJbXCJkZWZhdWx0XCJdO1xuICAgIH1cbiAgICBfdGhpcyA9IF9BdG9tLmNhbGwodGhpcywgbmFtZV8pIHx8IHRoaXM7XG4gICAgX3RoaXMuZW5oYW5jZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgX3RoaXMuZXF1YWxzID0gdm9pZCAwO1xuICAgIF90aGlzLmhhc1VucmVwb3J0ZWRDaGFuZ2VfID0gZmFsc2U7XG4gICAgX3RoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICBfdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIF90aGlzLnZhbHVlXyA9IHZvaWQgMDtcbiAgICBfdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICBfdGhpcy5lbmhhbmNlciA9IGVuaGFuY2VyO1xuICAgIF90aGlzLm5hbWVfID0gbmFtZV87XG4gICAgX3RoaXMuZXF1YWxzID0gZXF1YWxzO1xuICAgIF90aGlzLnZhbHVlXyA9IGVuaGFuY2VyKHZhbHVlLCB1bmRlZmluZWQsIG5hbWVfKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgLy8gb25seSBub3RpZnkgc3B5IGlmIHRoaXMgaXMgYSBzdGFuZC1hbG9uZSBvYnNlcnZhYmxlXG4gICAgICBzcHlSZXBvcnQoe1xuICAgICAgICB0eXBlOiBDUkVBVEUsXG4gICAgICAgIG9iamVjdDogX3RoaXMsXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInZhbHVlXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogX3RoaXMubmFtZV8sXG4gICAgICAgIG5ld1ZhbHVlOiBcIlwiICsgX3RoaXMudmFsdWVfXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0c0xvb3NlKE9ic2VydmFibGVWYWx1ZSwgX0F0b20pO1xuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZTtcbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZSA9IGZ1bmN0aW9uIGRlaGFuY2VWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgbmV3VmFsdWUgPSB0aGlzLnByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEKSB7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJ2YWx1ZVwiLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8ucHJlcGFyZU5ld1ZhbHVlXyA9IGZ1bmN0aW9uIHByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpIHtcbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzKTtcbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEO1xuICAgICAgfVxuICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfVxuICAgIC8vIGFwcGx5IG1vZGlmaWVyXG4gICAgbmV3VmFsdWUgPSB0aGlzLmVuaGFuY2VyKG5ld1ZhbHVlLCB0aGlzLnZhbHVlXywgdGhpcy5uYW1lXyk7XG4gICAgcmV0dXJuIHRoaXMuZXF1YWxzKHRoaXMudmFsdWVfLCBuZXdWYWx1ZSkgPyBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQgOiBuZXdWYWx1ZTtcbiAgfTtcbiAgX3Byb3RvLnNldE5ld1ZhbHVlXyA9IGZ1bmN0aW9uIHNldE5ld1ZhbHVlXyhuZXdWYWx1ZSkge1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgIHRoaXMudmFsdWVfID0gbmV3VmFsdWU7XG4gICAgdGhpcy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgaWYgKGhhc0xpc3RlbmVycyh0aGlzKSkge1xuICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIHtcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdGhpcy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZSh0aGlzLnZhbHVlXyk7XG4gIH07XG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgICBsaXN0ZW5lcih7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInZhbHVlXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG5ld1ZhbHVlOiB0aGlzLnZhbHVlXyxcbiAgICAgICAgb2xkVmFsdWU6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcbiAgX3Byb3RvLnJhdyA9IGZ1bmN0aW9uIHJhdygpIHtcbiAgICAvLyB1c2VkIGJ5IE1TVCBvdCBnZXQgdW5kZWhhbmNlZCB2YWx1ZVxuICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgfTtcbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoKTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV8gKyBcIltcIiArIHRoaXMudmFsdWVfICsgXCJdXCI7XG4gIH07XG4gIF9wcm90by52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdG9QcmltaXRpdmUodGhpcy5nZXQoKSk7XG4gIH07XG4gIF9wcm90b1tTeW1ib2wudG9QcmltaXRpdmVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgfTtcbiAgcmV0dXJuIE9ic2VydmFibGVWYWx1ZTtcbn0oQXRvbSk7XG52YXIgaXNPYnNlcnZhYmxlVmFsdWUgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVWYWx1ZVwiLCBPYnNlcnZhYmxlVmFsdWUpO1xuXG4vKipcbiAqIEEgbm9kZSBpbiB0aGUgc3RhdGUgZGVwZW5kZW5jeSByb290IHRoYXQgb2JzZXJ2ZXMgb3RoZXIgbm9kZXMsIGFuZCBjYW4gYmUgb2JzZXJ2ZWQgaXRzZWxmLlxuICpcbiAqIENvbXB1dGVkVmFsdWUgd2lsbCByZW1lbWJlciB0aGUgcmVzdWx0IG9mIHRoZSBjb21wdXRhdGlvbiBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBiYXRjaCwgb3JcbiAqIHdoaWxlIGJlaW5nIG9ic2VydmVkLlxuICpcbiAqIER1cmluZyB0aGlzIHRpbWUgaXQgd2lsbCByZWNvbXB1dGUgb25seSB3aGVuIG9uZSBvZiBpdHMgZGlyZWN0IGRlcGVuZGVuY2llcyBjaGFuZ2VkLFxuICogYnV0IG9ubHkgd2hlbiBpdCBpcyBiZWluZyBhY2Nlc3NlZCB3aXRoIGBDb21wdXRlZFZhbHVlLmdldCgpYC5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBkZXNjcmlwdGlvbjpcbiAqIDEuIEZpcnN0IHRpbWUgaXQncyBiZWluZyBhY2Nlc3NlZCBpdCB3aWxsIGNvbXB1dGUgYW5kIHJlbWVtYmVyIHJlc3VsdFxuICogICAgZ2l2ZSBiYWNrIHJlbWVtYmVyZWQgcmVzdWx0IHVudGlsIDIuIGhhcHBlbnNcbiAqIDIuIEZpcnN0IHRpbWUgYW55IGRlZXAgZGVwZW5kZW5jeSBjaGFuZ2UsIHByb3BhZ2F0ZSBQT1NTSUJMWV9TVEFMRSB0byBhbGwgb2JzZXJ2ZXJzLCB3YWl0IGZvciAzLlxuICogMy4gV2hlbiBpdCdzIGJlaW5nIGFjY2Vzc2VkLCByZWNvbXB1dGUgaWYgYW55IHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkLlxuICogICAgaWYgcmVzdWx0IGNoYW5nZWQ6IHByb3BhZ2F0ZSBTVEFMRSB0byBhbGwgb2JzZXJ2ZXJzLCB0aGF0IHdlcmUgUE9TU0lCTFlfU1RBTEUgZnJvbSB0aGUgbGFzdCBzdGVwLlxuICogICAgZ28gdG8gc3RlcCAyLiBlaXRoZXIgd2F5XG4gKlxuICogSWYgYXQgYW55IHBvaW50IGl0J3Mgb3V0c2lkZSBiYXRjaCBhbmQgaXQgaXNuJ3Qgb2JzZXJ2ZWQ6IHJlc2V0IGV2ZXJ5dGhpbmcgYW5kIGdvIHRvIDEuXG4gKi9cbnZhciBDb21wdXRlZFZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjb21wdXRlZCB2YWx1ZSBiYXNlZCBvbiBhIGZ1bmN0aW9uIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIFRoZSBgbmFtZWAgcHJvcGVydHkgaXMgZm9yIGRlYnVnIHB1cnBvc2VzIG9ubHkuXG4gICAqXG4gICAqIFRoZSBgZXF1YWxzYCBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIGNvbXBhcmVyIGZ1bmN0aW9uIHRvIHVzZSB0byBkZXRlcm1pbmUgaWYgYSBuZXdseSBwcm9kdWNlZFxuICAgKiB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIHZhbHVlLiBUd28gY29tcGFyZXJzIGFyZSBwcm92aWRlZCBpbiB0aGUgbGlicmFyeTsgYGRlZmF1bHRDb21wYXJlcmBcbiAgICogY29tcGFyZXMgYmFzZWQgb24gaWRlbnRpdHkgY29tcGFyaXNvbiAoPT09KSwgYW5kIGBzdHJ1Y3R1cmFsQ29tcGFyZXJgIGRlZXBseSBjb21wYXJlcyB0aGUgc3RydWN0dXJlLlxuICAgKiBTdHJ1Y3R1cmFsIGNvbXBhcmlzb24gY2FuIGJlIGNvbnZlbmllbnQgaWYgeW91IGFsd2F5cyBwcm9kdWNlIGEgbmV3IGFnZ3JlZ2F0ZWQgb2JqZWN0IGFuZFxuICAgKiBkb24ndCB3YW50IHRvIG5vdGlmeSBvYnNlcnZlcnMgaWYgaXQgaXMgc3RydWN0dXJhbGx5IHRoZSBzYW1lLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3Igd29ya2luZyB3aXRoIHZlY3RvcnMsIG1vdXNlIGNvb3JkaW5hdGVzIGV0Yy5cbiAgICovXG4gIGZ1bmN0aW9uIENvbXB1dGVkVmFsdWUob3B0aW9ucykge1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLm9ic2VydmluZ18gPSBbXTtcbiAgICAvLyBub2RlcyB3ZSBhcmUgbG9va2luZyBhdC4gT3VyIHZhbHVlIGRlcGVuZHMgb24gdGhlc2Ugbm9kZXNcbiAgICB0aGlzLm5ld09ic2VydmluZ18gPSBudWxsO1xuICAgIC8vIGR1cmluZyB0cmFja2luZyBpdCdzIGFuIGFycmF5IHdpdGggbmV3IG9ic2VydmVkIG9ic2VydmVyc1xuICAgIHRoaXMub2JzZXJ2ZXJzXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnJ1bklkXyA9IDA7XG4gICAgdGhpcy5sYXN0QWNjZXNzZWRCeV8gPSAwO1xuICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgICB0aGlzLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgICB0aGlzLnZhbHVlXyA9IG5ldyBDYXVnaHRFeGNlcHRpb24obnVsbCk7XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyaWdnZXJlZEJ5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmZsYWdzXyA9IDA7XG4gICAgdGhpcy5kZXJpdmF0aW9uID0gdm9pZCAwO1xuICAgIC8vIE4uQjogdW5taW5pZmllZCBhcyBpdCBpcyB1c2VkIGJ5IE1TVFxuICAgIHRoaXMuc2V0dGVyXyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzVHJhY2luZ18gPSBUcmFjZU1vZGUuTk9ORTtcbiAgICB0aGlzLnNjb3BlXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVxdWFsc18gPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1aXJlc1JlYWN0aW9uXyA9IHZvaWQgMDtcbiAgICB0aGlzLmtlZXBBbGl2ZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5vbkJPTCA9IHZvaWQgMDtcbiAgICB0aGlzLm9uQlVPTCA9IHZvaWQgMDtcbiAgICBpZiAoIW9wdGlvbnMuZ2V0KSB7XG4gICAgICBkaWUoMzEpO1xuICAgIH1cbiAgICB0aGlzLmRlcml2YXRpb24gPSBvcHRpb25zLmdldDtcbiAgICB0aGlzLm5hbWVfID0gb3B0aW9ucy5uYW1lIHx8IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIkNvbXB1dGVkVmFsdWVAXCIgKyBnZXROZXh0SWQoKSA6IFwiQ29tcHV0ZWRWYWx1ZVwiKTtcbiAgICBpZiAob3B0aW9ucy5zZXQpIHtcbiAgICAgIHRoaXMuc2V0dGVyXyA9IGNyZWF0ZUFjdGlvbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB0aGlzLm5hbWVfICsgXCItc2V0dGVyXCIgOiBcIkNvbXB1dGVkVmFsdWUtc2V0dGVyXCIsIG9wdGlvbnMuc2V0KTtcbiAgICB9XG4gICAgdGhpcy5lcXVhbHNfID0gb3B0aW9ucy5lcXVhbHMgfHwgKG9wdGlvbnMuY29tcGFyZVN0cnVjdHVyYWwgfHwgb3B0aW9ucy5zdHJ1Y3QgPyBjb21wYXJlci5zdHJ1Y3R1cmFsIDogY29tcGFyZXJbXCJkZWZhdWx0XCJdKTtcbiAgICB0aGlzLnNjb3BlXyA9IG9wdGlvbnMuY29udGV4dDtcbiAgICB0aGlzLnJlcXVpcmVzUmVhY3Rpb25fID0gb3B0aW9ucy5yZXF1aXJlc1JlYWN0aW9uO1xuICAgIHRoaXMua2VlcEFsaXZlXyA9ICEhb3B0aW9ucy5rZWVwQWxpdmU7XG4gIH1cbiAgdmFyIF9wcm90byA9IENvbXB1dGVkVmFsdWUucHJvdG90eXBlO1xuICBfcHJvdG8ub25CZWNvbWVTdGFsZV8gPSBmdW5jdGlvbiBvbkJlY29tZVN0YWxlXygpIHtcbiAgICBwcm9wYWdhdGVNYXliZUNoYW5nZWQodGhpcyk7XG4gIH07XG4gIF9wcm90by5vbkJPID0gZnVuY3Rpb24gb25CTygpIHtcbiAgICBpZiAodGhpcy5vbkJPTCkge1xuICAgICAgdGhpcy5vbkJPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9uQlVPID0gZnVuY3Rpb24gb25CVU8oKSB7XG4gICAgaWYgKHRoaXMub25CVU9MKSB7XG4gICAgICB0aGlzLm9uQlVPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvLyB0byBjaGVjayBmb3IgY3ljbGVzXG4gIDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBjb21wdXRlZCB2YWx1ZS5cbiAgICogV2lsbCBldmFsdWF0ZSBpdHMgY29tcHV0YXRpb24gZmlyc3QgaWYgbmVlZGVkLlxuICAgKi9cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5pc0NvbXB1dGluZykge1xuICAgICAgZGllKDMyLCB0aGlzLm5hbWVfLCB0aGlzLmRlcml2YXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA9PT0gMCAmJlxuICAgIC8vICFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRwaW9uICYmXG4gICAgdGhpcy5vYnNlcnZlcnNfLnNpemUgPT09IDAgJiYgIXRoaXMua2VlcEFsaXZlXykge1xuICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcbiAgICAgICAgdGhpcy53YXJuQWJvdXRVbnRyYWNrZWRSZWFkXygpO1xuICAgICAgICBzdGFydEJhdGNoKCk7IC8vIFNlZSBwZXJmIHRlc3QgJ2NvbXB1dGVkIG1lbW9pemF0aW9uJ1xuICAgICAgICB0aGlzLnZhbHVlXyA9IHRoaXMuY29tcHV0ZVZhbHVlXyhmYWxzZSk7XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcG9ydE9ic2VydmVkKHRoaXMpO1xuICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcbiAgICAgICAgdmFyIHByZXZUcmFja2luZ0NvbnRleHQgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQ7XG4gICAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZV8gJiYgIXByZXZUcmFja2luZ0NvbnRleHQpIHtcbiAgICAgICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNrQW5kQ29tcHV0ZSgpKSB7XG4gICAgICAgICAgcHJvcGFnYXRlQ2hhbmdlQ29uZmlybWVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHByZXZUcmFja2luZ0NvbnRleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLnZhbHVlXztcbiAgICBpZiAoaXNDYXVnaHRFeGNlcHRpb24ocmVzdWx0KSkge1xuICAgICAgdGhyb3cgcmVzdWx0LmNhdXNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2V0dGVyXykge1xuICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nU2V0dGVyKSB7XG4gICAgICAgIGRpZSgzMywgdGhpcy5uYW1lXyk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzUnVubmluZ1NldHRlciA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNldHRlcl8uY2FsbCh0aGlzLnNjb3BlXywgdmFsdWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmdTZXR0ZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGllKDM0LCB0aGlzLm5hbWVfKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by50cmFja0FuZENvbXB1dGUgPSBmdW5jdGlvbiB0cmFja0FuZENvbXB1dGUoKSB7XG4gICAgLy8gTi5COiB1bm1pbmlmaWVkIGFzIGl0IGlzIHVzZWQgYnkgTVNUXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgdmFyIHdhc1N1c3BlbmRlZCA9IC8qIHNlZSAjMTIwOCAqL3RoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY29tcHV0ZVZhbHVlXyh0cnVlKTtcbiAgICB2YXIgY2hhbmdlZCA9IHdhc1N1c3BlbmRlZCB8fCBpc0NhdWdodEV4Y2VwdGlvbihvbGRWYWx1ZSkgfHwgaXNDYXVnaHRFeGNlcHRpb24obmV3VmFsdWUpIHx8ICF0aGlzLmVxdWFsc18ob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy52YWx1ZV8gPSBuZXdWYWx1ZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJjb21wdXRlZFwiLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMuc2NvcGVfLFxuICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG4gIF9wcm90by5jb21wdXRlVmFsdWVfID0gZnVuY3Rpb24gY29tcHV0ZVZhbHVlXyh0cmFjaykge1xuICAgIHRoaXMuaXNDb21wdXRpbmcgPSB0cnVlO1xuICAgIC8vIGRvbid0IGFsbG93IHN0YXRlIGNoYW5nZXMgZHVyaW5nIGNvbXB1dGF0aW9uXG4gICAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KGZhbHNlKTtcbiAgICB2YXIgcmVzO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmVzID0gdHJhY2tEZXJpdmVkRnVuY3Rpb24odGhpcywgdGhpcy5kZXJpdmF0aW9uLCB0aGlzLnNjb3BlXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XG4gICAgICAgIHJlcyA9IHRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuc2NvcGVfKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5kZXJpdmF0aW9uLmNhbGwodGhpcy5zY29wZV8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVzID0gbmV3IENhdWdodEV4Y2VwdGlvbihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgICB0aGlzLmlzQ29tcHV0aW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgX3Byb3RvLnN1c3BlbmRfID0gZnVuY3Rpb24gc3VzcGVuZF8oKSB7XG4gICAgaWYgKCF0aGlzLmtlZXBBbGl2ZV8pIHtcbiAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgICAgdGhpcy52YWx1ZV8gPSB1bmRlZmluZWQ7IC8vIGRvbid0IGhvbGQgb24gdG8gY29tcHV0ZWQgdmFsdWUhXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMuaXNUcmFjaW5nXyAhPT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gQ29tcHV0ZWQgdmFsdWUgJ1wiICsgdGhpcy5uYW1lXyArIFwiJyB3YXMgc3VzcGVuZGVkIGFuZCBpdCB3aWxsIHJlY29tcHV0ZSBvbiB0aGUgbmV4dCBhY2Nlc3MuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG4gICAgdmFyIHByZXZWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gYXV0b3J1bihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPOiB3aHkgaXMgdGhpcyBpbiBhIGRpZmZlcmVudCBwbGFjZSB0aGFuIHRoZSBzcHlSZXBvcnQoKSBmdW5jdGlvbj8gaW4gYWxsIG90aGVyIG9ic2VydmFibGVzIGl0J3MgY2FsbGVkIGluIHRoZSBzYW1lIHBsYWNlXG4gICAgICB2YXIgbmV3VmFsdWUgPSBfdGhpcy5nZXQoKTtcbiAgICAgIGlmICghZmlyc3RUaW1lIHx8IGZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuICAgICAgICBsaXN0ZW5lcih7XG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiY29tcHV0ZWRcIixcbiAgICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IF90aGlzLm5hbWVfLFxuICAgICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgICBvYmplY3Q6IF90aGlzLFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZTogcHJldlZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB1bnRyYWNrZWRFbmQocHJldlUpO1xuICAgICAgfVxuICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICBwcmV2VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLndhcm5BYm91dFVudHJhY2tlZFJlYWRfID0gZnVuY3Rpb24gd2FybkFib3V0VW50cmFja2VkUmVhZF8oKSB7XG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gQ29tcHV0ZWQgdmFsdWUgJ1wiICsgdGhpcy5uYW1lXyArIFwiJyBpcyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LiBEb2luZyBhIGZ1bGwgcmVjb21wdXRlLlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnJlcXVpcmVzUmVhY3Rpb25fID09PSBcImJvb2xlYW5cIiA/IHRoaXMucmVxdWlyZXNSZWFjdGlvbl8gOiBnbG9iYWxTdGF0ZS5jb21wdXRlZFJlcXVpcmVzUmVhY3Rpb24pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBDb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzLm5hbWVfICsgXCInIGlzIGJlaW5nIHJlYWQgb3V0c2lkZSBhIHJlYWN0aXZlIGNvbnRleHQuIERvaW5nIGEgZnVsbCByZWNvbXB1dGUuXCIpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV8gKyBcIltcIiArIHRoaXMuZGVyaXZhdGlvbi50b1N0cmluZygpICsgXCJdXCI7XG4gIH07XG4gIF9wcm90by52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdG9QcmltaXRpdmUodGhpcy5nZXQoKSk7XG4gIH07XG4gIF9wcm90b1tTeW1ib2wudG9QcmltaXRpdmVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgfTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDb21wdXRlZFZhbHVlLCBbe1xuICAgIGtleTogXCJpc0NvbXB1dGluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIENvbXB1dGVkVmFsdWUuaXNDb21wdXRpbmdNYXNrXyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5mbGFnc18gPSBzZXRGbGFnKHRoaXMuZmxhZ3NfLCBDb21wdXRlZFZhbHVlLmlzQ29tcHV0aW5nTWFza18sIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNSdW5uaW5nU2V0dGVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0RmxhZyh0aGlzLmZsYWdzXywgQ29tcHV0ZWRWYWx1ZS5pc1J1bm5pbmdTZXR0ZXJNYXNrXyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5mbGFnc18gPSBzZXRGbGFnKHRoaXMuZmxhZ3NfLCBDb21wdXRlZFZhbHVlLmlzUnVubmluZ1NldHRlck1hc2tfLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQmVpbmdPYnNlcnZlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIENvbXB1dGVkVmFsdWUuaXNCZWluZ09ic2VydmVkTWFza18pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZmxhZ3NfID0gc2V0RmxhZyh0aGlzLmZsYWdzXywgQ29tcHV0ZWRWYWx1ZS5pc0JlaW5nT2JzZXJ2ZWRNYXNrXywgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1BlbmRpbmdVbm9ic2VydmF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0RmxhZyh0aGlzLmZsYWdzXywgQ29tcHV0ZWRWYWx1ZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uTWFza18pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZmxhZ3NfID0gc2V0RmxhZyh0aGlzLmZsYWdzXywgQ29tcHV0ZWRWYWx1ZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uTWFza18sIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlmZlZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0RmxhZyh0aGlzLmZsYWdzXywgQ29tcHV0ZWRWYWx1ZS5kaWZmVmFsdWVNYXNrXykgPyAxIDogMDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLmZsYWdzXyA9IHNldEZsYWcodGhpcy5mbGFnc18sIENvbXB1dGVkVmFsdWUuZGlmZlZhbHVlTWFza18sIG5ld1ZhbHVlID09PSAxID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbkNvbXB1dGVkVmFsdWUuaXNDb21wdXRpbmdNYXNrXyA9IDE7XG5Db21wdXRlZFZhbHVlLmlzUnVubmluZ1NldHRlck1hc2tfID0gMjtcbkNvbXB1dGVkVmFsdWUuaXNCZWluZ09ic2VydmVkTWFza18gPSA0O1xuQ29tcHV0ZWRWYWx1ZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uTWFza18gPSA4O1xuQ29tcHV0ZWRWYWx1ZS5kaWZmVmFsdWVNYXNrXyA9IDE2O1xudmFyIGlzQ29tcHV0ZWRWYWx1ZSA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiQ29tcHV0ZWRWYWx1ZVwiLCBDb21wdXRlZFZhbHVlKTtcblxudmFyIElEZXJpdmF0aW9uU3RhdGVfO1xuKGZ1bmN0aW9uIChJRGVyaXZhdGlvblN0YXRlXykge1xuICAvLyBiZWZvcmUgYmVpbmcgcnVuIG9yIChvdXRzaWRlIGJhdGNoIGFuZCBub3QgYmVpbmcgb2JzZXJ2ZWQpXG4gIC8vIGF0IHRoaXMgcG9pbnQgZGVyaXZhdGlvbiBpcyBub3QgaG9sZGluZyBhbnkgZGF0YSBhYm91dCBkZXBlbmRlbmN5IHRyZWVcbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJOT1RfVFJBQ0tJTkdfXCJdID0gLTFdID0gXCJOT1RfVFJBQ0tJTkdfXCI7XG4gIC8vIG5vIHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkIHNpbmNlIGxhc3QgY29tcHV0YXRpb25cbiAgLy8gd29uJ3QgcmVjYWxjdWxhdGUgZGVyaXZhdGlvblxuICAvLyB0aGlzIGlzIHdoYXQgbWFrZXMgbW9ieCBmYXN0XG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiVVBfVE9fREFURV9cIl0gPSAwXSA9IFwiVVBfVE9fREFURV9cIjtcbiAgLy8gc29tZSBkZWVwIGRlcGVuZGVuY3kgY2hhbmdlZCwgYnV0IGRvbid0IGtub3cgaWYgc2hhbGxvdyBkZXBlbmRlbmN5IGNoYW5nZWRcbiAgLy8gd2lsbCByZXF1aXJlIHRvIGNoZWNrIGZpcnN0IGlmIFVQX1RPX0RBVEUgb3IgUE9TU0lCTFlfU1RBTEVcbiAgLy8gY3VycmVudGx5IG9ubHkgQ29tcHV0ZWRWYWx1ZSB3aWxsIHByb3BhZ2F0ZSBQT1NTSUJMWV9TVEFMRVxuICAvL1xuICAvLyBoYXZpbmcgdGhpcyBzdGF0ZSBpcyBzZWNvbmQgYmlnIG9wdGltaXphdGlvbjpcbiAgLy8gZG9uJ3QgaGF2ZSB0byByZWNvbXB1dGUgb24gZXZlcnkgZGVwZW5kZW5jeSBjaGFuZ2UsIGJ1dCBvbmx5IHdoZW4gaXQncyBuZWVkZWRcbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJQT1NTSUJMWV9TVEFMRV9cIl0gPSAxXSA9IFwiUE9TU0lCTFlfU1RBTEVfXCI7XG4gIC8vIEEgc2hhbGxvdyBkZXBlbmRlbmN5IGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgY29tcHV0YXRpb24gYW5kIHRoZSBkZXJpdmF0aW9uXG4gIC8vIHdpbGwgbmVlZCB0byByZWNvbXB1dGUgd2hlbiBpdCdzIG5lZWRlZCBuZXh0LlxuICBJRGVyaXZhdGlvblN0YXRlX1tJRGVyaXZhdGlvblN0YXRlX1tcIlNUQUxFX1wiXSA9IDJdID0gXCJTVEFMRV9cIjtcbn0pKElEZXJpdmF0aW9uU3RhdGVfIHx8IChJRGVyaXZhdGlvblN0YXRlXyA9IHt9KSk7XG52YXIgVHJhY2VNb2RlO1xuKGZ1bmN0aW9uIChUcmFjZU1vZGUpIHtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICBUcmFjZU1vZGVbVHJhY2VNb2RlW1wiTE9HXCJdID0gMV0gPSBcIkxPR1wiO1xuICBUcmFjZU1vZGVbVHJhY2VNb2RlW1wiQlJFQUtcIl0gPSAyXSA9IFwiQlJFQUtcIjtcbn0pKFRyYWNlTW9kZSB8fCAoVHJhY2VNb2RlID0ge30pKTtcbnZhciBDYXVnaHRFeGNlcHRpb24gPSBmdW5jdGlvbiBDYXVnaHRFeGNlcHRpb24oY2F1c2UpIHtcbiAgdGhpcy5jYXVzZSA9IHZvaWQgMDtcbiAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAvLyBFbXB0eVxufTtcbmZ1bmN0aW9uIGlzQ2F1Z2h0RXhjZXB0aW9uKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDYXVnaHRFeGNlcHRpb247XG59XG4vKipcbiAqIEZpbmRzIG91dCB3aGV0aGVyIGFueSBkZXBlbmRlbmN5IG9mIHRoZSBkZXJpdmF0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICogSWYgZGVwZW5kZW5jaWVzU3RhdGUgaXMgMSB0aGVuIGl0IHdpbGwgcmVjYWxjdWxhdGUgZGVwZW5kZW5jaWVzLFxuICogaWYgYW55IGRlcGVuZGVuY3kgY2hhbmdlZCBpdCB3aWxsIHByb3BhZ2F0ZSBpdCBieSBjaGFuZ2luZyBkZXBlbmRlbmNpZXNTdGF0ZSB0byAyLlxuICpcbiAqIEJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBkZXBlbmRlbmNpZXMgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IHdlcmUgcmVwb3J0ZWQgYW5kXG4gKiBzdG9wcGluZyBvbiB0aGUgZmlyc3QgY2hhbmdlLCBhbGwgdGhlIHJlY2FsY3VsYXRpb25zIGFyZSBvbmx5IGNhbGxlZCBmb3IgQ29tcHV0ZWRWYWx1ZXNcbiAqIHRoYXQgd2lsbCBiZSB0cmFja2VkIGJ5IGRlcml2YXRpb24uIFRoYXQgaXMgYmVjYXVzZSB3ZSBhc3N1bWUgdGhhdCBpZiB0aGUgZmlyc3QgeFxuICogZGVwZW5kZW5jaWVzIG9mIHRoZSBkZXJpdmF0aW9uIGRvZXNuJ3QgY2hhbmdlIHRoZW4gdGhlIGRlcml2YXRpb24gc2hvdWxkIHJ1biB0aGUgc2FtZSB3YXlcbiAqIHVwIHVudGlsIGFjY2Vzc2luZyB4LXRoIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZENvbXB1dGUoZGVyaXZhdGlvbikge1xuICBzd2l0Y2ggKGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfKSB7XG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR186XG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV86XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXzpcbiAgICAgIHtcbiAgICAgICAgLy8gc3RhdGUgcHJvcGFnYXRpb24gY2FuIG9jY3VyIG91dHNpZGUgb2YgYWN0aW9uL3JlYWN0aXZlIGNvbnRleHQgIzIxOTVcbiAgICAgICAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTtcbiAgICAgICAgdmFyIHByZXZVbnRyYWNrZWQgPSB1bnRyYWNrZWRTdGFydCgpOyAvLyBubyBuZWVkIGZvciB0aG9zZSBjb21wdXRlZHMgdG8gYmUgcmVwb3J0ZWQsIHRoZXkgd2lsbCBiZSBwaWNrZWQgdXAgaW4gdHJhY2tEZXJpdmVkRnVuY3Rpb24uXG4gICAgICAgIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZ18sXG4gICAgICAgICAgbCA9IG9icy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IG9ic1tpXTtcbiAgICAgICAgICBpZiAoaXNDb21wdXRlZFZhbHVlKG9iaikpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKSB7XG4gICAgICAgICAgICAgIG9iai5nZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2JqLmdldCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIHRoZSB2YWx1ZSAqb3IqIGV4Y2VwdGlvbiBhdCB0aGlzIG1vbWVudCwgYnV0IGlmIHRoZXJlIGlzIG9uZSwgbm90aWZ5IGFsbFxuICAgICAgICAgICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcbiAgICAgICAgICAgICAgICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIENvbXB1dGVkVmFsdWUgYG9iamAgYWN0dWFsbHkgY2hhbmdlZCBpdCB3aWxsIGJlIGNvbXB1dGVkIGFuZCBwcm9wYWdhdGVkIHRvIGl0cyBvYnNlcnZlcnMuXG4gICAgICAgICAgICAvLyBhbmQgYGRlcml2YXRpb25gIGlzIGFuIG9ic2VydmVyIG9mIGBvYmpgXG4gICAgICAgICAgICAvLyBpbnZhcmlhbnRTaG91bGRDb21wdXRlKGRlcml2YXRpb24pXG4gICAgICAgICAgICBpZiAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXykge1xuICAgICAgICAgICAgICB1bnRyYWNrZWRFbmQocHJldlVudHJhY2tlZCk7XG4gICAgICAgICAgICAgIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pO1xuICAgICAgICB1bnRyYWNrZWRFbmQocHJldlVudHJhY2tlZCk7XG4gICAgICAgIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0NvbXB1dGluZ0Rlcml2YXRpb24oKSB7XG4gIHJldHVybiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gIT09IG51bGw7IC8vIGZpbHRlciBvdXQgYWN0aW9ucyBpbnNpZGUgY29tcHV0YXRpb25zXG59XG5mdW5jdGlvbiBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZChhdG9tKSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGhhc09ic2VydmVycyA9IGF0b20ub2JzZXJ2ZXJzXy5zaXplID4gMDtcbiAgLy8gU2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBjaGFuZ2Ugb2JzZXJ2ZWQgc3RhdGUgb3V0c2lkZSBzdHJpY3QgbW9kZSwgZXhjZXB0IGR1cmluZyBpbml0aWFsaXphdGlvbiwgc2VlICM1NjNcbiAgaWYgKCFnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyAmJiAoaGFzT2JzZXJ2ZXJzIHx8IGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID09PSBcImFsd2F5c1wiKSkge1xuICAgIGNvbnNvbGUud2FybihcIltNb2JYXSBcIiArIChnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9ucyA/IFwiU2luY2Ugc3RyaWN0LW1vZGUgaXMgZW5hYmxlZCwgY2hhbmdpbmcgKG9ic2VydmVkKSBvYnNlcnZhYmxlIHZhbHVlcyB3aXRob3V0IHVzaW5nIGFuIGFjdGlvbiBpcyBub3QgYWxsb3dlZC4gVHJpZWQgdG8gbW9kaWZ5OiBcIiA6IFwiU2lkZSBlZmZlY3RzIGxpa2UgY2hhbmdpbmcgc3RhdGUgYXJlIG5vdCBhbGxvd2VkIGF0IHRoaXMgcG9pbnQuIEFyZSB5b3UgdHJ5aW5nIHRvIG1vZGlmeSBzdGF0ZSBmcm9tLCBmb3IgZXhhbXBsZSwgYSBjb21wdXRlZCB2YWx1ZSBvciB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9mIGEgUmVhY3QgY29tcG9uZW50PyBZb3UgY2FuIHdyYXAgc2lkZSBlZmZlY3RzIGluICdydW5JbkFjdGlvbicgKG9yIGRlY29yYXRlIGZ1bmN0aW9ucyB3aXRoICdhY3Rpb24nKSBpZiBuZWVkZWQuIFRyaWVkIHRvIG1vZGlmeTogXCIpICsgYXRvbS5uYW1lXyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSWZTdGF0ZVJlYWRzQXJlQWxsb3dlZChvYnNlcnZhYmxlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyAmJiBnbG9iYWxTdGF0ZS5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBPYnNlcnZhYmxlICdcIiArIG9ic2VydmFibGUubmFtZV8gKyBcIicgYmVpbmcgcmVhZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dC5cIik7XG4gIH1cbn1cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGBmYCBhbmQgdHJhY2tzIHdoaWNoIG9ic2VydmFibGVzIGFyZSBiZWluZyBhY2Nlc3NlZC5cbiAqIFRoZSB0cmFja2luZyBpbmZvcm1hdGlvbiBpcyBzdG9yZWQgb24gdGhlIGBkZXJpdmF0aW9uYCBvYmplY3QgYW5kIHRoZSBkZXJpdmF0aW9uIGlzIHJlZ2lzdGVyZWRcbiAqIGFzIG9ic2VydmVyIG9mIGFueSBvZiB0aGUgYWNjZXNzZWQgb2JzZXJ2YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyYWNrRGVyaXZlZEZ1bmN0aW9uKGRlcml2YXRpb24sIGYsIGNvbnRleHQpIHtcbiAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTtcbiAgY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbik7XG4gIC8vIFByZWFsbG9jYXRlIGFycmF5OyB3aWxsIGJlIHRyaW1tZWQgYnkgYmluZERlcGVuZGVuY2llcy5cbiAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfID0gbmV3IEFycmF5KFxuICAvLyBSZXNlcnZlIGNvbnN0YW50IHNwYWNlIGZvciBpbml0aWFsIGRlcGVuZGVuY2llcywgZHluYW1pYyBzcGFjZSBvdGhlcndpc2UuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvcHVsbC8zODMzXG4gIGRlcml2YXRpb24ucnVuSWRfID09PSAwID8gMTAwIDogZGVyaXZhdGlvbi5vYnNlcnZpbmdfLmxlbmd0aCk7XG4gIGRlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF8gPSAwO1xuICBkZXJpdmF0aW9uLnJ1bklkXyA9ICsrZ2xvYmFsU3RhdGUucnVuSWQ7XG4gIHZhciBwcmV2VHJhY2tpbmcgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IGRlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLmluQmF0Y2grKztcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPT09IHRydWUpIHtcbiAgICByZXN1bHQgPSBmLmNhbGwoY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGYuY2FsbChjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXN1bHQgPSBuZXcgQ2F1Z2h0RXhjZXB0aW9uKGUpO1xuICAgIH1cbiAgfVxuICBnbG9iYWxTdGF0ZS5pbkJhdGNoLS07XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IHByZXZUcmFja2luZztcbiAgYmluZERlcGVuZGVuY2llcyhkZXJpdmF0aW9uKTtcbiAgd2FybkFib3V0RGVyaXZhdGlvbldpdGhvdXREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XG4gIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzKGRlcml2YXRpb24pIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZGVyaXZhdGlvbi5vYnNlcnZpbmdfLmxlbmd0aCAhPT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRlcml2YXRpb24ucmVxdWlyZXNPYnNlcnZhYmxlXyA9PT0gXCJib29sZWFuXCIgPyBkZXJpdmF0aW9uLnJlcXVpcmVzT2JzZXJ2YWJsZV8gOiBnbG9iYWxTdGF0ZS5yZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZSkge1xuICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBEZXJpdmF0aW9uICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgaXMgY3JlYXRlZC91cGRhdGVkIHdpdGhvdXQgcmVhZGluZyBhbnkgb2JzZXJ2YWJsZSB2YWx1ZS5cIik7XG4gIH1cbn1cbi8qKlxuICogZGlmZnMgbmV3T2JzZXJ2aW5nIHdpdGggb2JzZXJ2aW5nLlxuICogdXBkYXRlIG9ic2VydmluZyB0byBiZSBuZXdPYnNlcnZpbmcgd2l0aCB1bmlxdWUgb2JzZXJ2YWJsZXNcbiAqIG5vdGlmeSBvYnNlcnZlcnMgdGhhdCBiZWNvbWUgb2JzZXJ2ZWQvdW5vYnNlcnZlZFxuICovXG5mdW5jdGlvbiBiaW5kRGVwZW5kZW5jaWVzKGRlcml2YXRpb24pIHtcbiAgLy8gaW52YXJpYW50KGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGUgIT09IElEZXJpdmF0aW9uU3RhdGUuTk9UX1RSQUNLSU5HLCBcIklOVEVSTkFMIEVSUk9SIGJpbmREZXBlbmRlbmNpZXMgZXhwZWN0cyBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcbiAgdmFyIHByZXZPYnNlcnZpbmcgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIHZhciBvYnNlcnZpbmcgPSBkZXJpdmF0aW9uLm9ic2VydmluZ18gPSBkZXJpdmF0aW9uLm5ld09ic2VydmluZ187XG4gIHZhciBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6ICh0aGlzIGxpc3QgY2FuIGNvbnRhaW4gZHVwbGljYXRlcyk6XG4gIC8vICAgMDogZmlyc3Qgb2NjdXJyZW5jZSwgY2hhbmdlIHRvIDEgYW5kIGtlZXAgaXRcbiAgLy8gICAxOiBleHRyYSBvY2N1cnJlbmNlLCBkcm9wIGl0XG4gIHZhciBpMCA9IDAsXG4gICAgbCA9IGRlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF87XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGRlcCA9IG9ic2VydmluZ1tpXTtcbiAgICBpZiAoZGVwLmRpZmZWYWx1ZSA9PT0gMCkge1xuICAgICAgZGVwLmRpZmZWYWx1ZSA9IDE7XG4gICAgICBpZiAoaTAgIT09IGkpIHtcbiAgICAgICAgb2JzZXJ2aW5nW2kwXSA9IGRlcDtcbiAgICAgIH1cbiAgICAgIGkwKys7XG4gICAgfVxuICAgIC8vIFVwY2FzdCBpcyAnc2FmZScgaGVyZSwgYmVjYXVzZSBpZiBkZXAgaXMgSU9ic2VydmFibGUsIGBkZXBlbmRlbmNpZXNTdGF0ZWAgd2lsbCBiZSB1bmRlZmluZWQsXG4gICAgLy8gbm90IGhpdHRpbmcgdGhlIGNvbmRpdGlvblxuICAgIGlmIChkZXAuZGVwZW5kZW5jaWVzU3RhdGVfID4gbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlKSB7XG4gICAgICBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgPSBkZXAuZGVwZW5kZW5jaWVzU3RhdGVfO1xuICAgIH1cbiAgfVxuICBvYnNlcnZpbmcubGVuZ3RoID0gaTA7XG4gIGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nXyA9IG51bGw7IC8vIG5ld09ic2VydmluZyBzaG91bGRuJ3QgYmUgbmVlZGVkIG91dHNpZGUgdHJhY2tpbmcgKHN0YXRlbWVudCBtb3ZlZCBkb3duIHRvIHdvcmsgYXJvdW5kIEZGIGJ1Zywgc2VlICM2MTQpXG4gIC8vIEdvIHRocm91Z2ggYWxsIG9sZCBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAoaXQgaXMgdW5pcXVlIGFmdGVyIGxhc3QgYmluZERlcGVuZGVuY2llcylcbiAgLy8gICAwOiBpdCdzIG5vdCBpbiBuZXcgb2JzZXJ2YWJsZXMsIHVub2JzZXJ2ZSBpdFxuICAvLyAgIDE6IGl0IGtlZXBzIGJlaW5nIG9ic2VydmVkLCBkb24ndCB3YW50IHRvIG5vdGlmeSBpdC4gY2hhbmdlIHRvIDBcbiAgbCA9IHByZXZPYnNlcnZpbmcubGVuZ3RoO1xuICB3aGlsZSAobC0tKSB7XG4gICAgdmFyIF9kZXAgPSBwcmV2T2JzZXJ2aW5nW2xdO1xuICAgIGlmIChfZGVwLmRpZmZWYWx1ZSA9PT0gMCkge1xuICAgICAgcmVtb3ZlT2JzZXJ2ZXIoX2RlcCwgZGVyaXZhdGlvbik7XG4gICAgfVxuICAgIF9kZXAuZGlmZlZhbHVlID0gMDtcbiAgfVxuICAvLyBHbyB0aHJvdWdoIGFsbCBuZXcgb2JzZXJ2YWJsZXMgYW5kIGNoZWNrIGRpZmZWYWx1ZTogKG5vdyBpdCBzaG91bGQgYmUgdW5pcXVlKVxuICAvLyAgIDA6IGl0IHdhcyBzZXQgdG8gMCBpbiBsYXN0IGxvb3AuIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gIC8vICAgMTogaXQgd2Fzbid0IG9ic2VydmVkLCBsZXQncyBvYnNlcnZlIGl0LiBzZXQgYmFjayB0byAwXG4gIHdoaWxlIChpMC0tKSB7XG4gICAgdmFyIF9kZXAyID0gb2JzZXJ2aW5nW2kwXTtcbiAgICBpZiAoX2RlcDIuZGlmZlZhbHVlID09PSAxKSB7XG4gICAgICBfZGVwMi5kaWZmVmFsdWUgPSAwO1xuICAgICAgYWRkT2JzZXJ2ZXIoX2RlcDIsIGRlcml2YXRpb24pO1xuICAgIH1cbiAgfVxuICAvLyBTb21lIG5ldyBvYnNlcnZlZCBkZXJpdmF0aW9ucyBtYXkgYmVjb21lIHN0YWxlIGR1cmluZyB0aGlzIGRlcml2YXRpb24gY29tcHV0YXRpb25cbiAgLy8gc28gdGhleSBoYXZlIGhhZCBubyBjaGFuY2UgdG8gcHJvcGFnYXRlIHN0YWxlbmVzcyAoIzkxNilcbiAgaWYgKGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSAhPT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9IGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZTtcbiAgICBkZXJpdmF0aW9uLm9uQmVjb21lU3RhbGVfKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFyT2JzZXJ2aW5nKGRlcml2YXRpb24pIHtcbiAgLy8gaW52YXJpYW50KGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwLCBcIklOVEVSTkFMIEVSUk9SIGNsZWFyT2JzZXJ2aW5nIHNob3VsZCBiZSBjYWxsZWQgb25seSBpbnNpZGUgYmF0Y2hcIik7XG4gIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIGRlcml2YXRpb24ub2JzZXJ2aW5nXyA9IFtdO1xuICB2YXIgaSA9IG9icy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZW1vdmVPYnNlcnZlcihvYnNbaV0sIGRlcml2YXRpb24pO1xuICB9XG4gIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbn1cbmZ1bmN0aW9uIHVudHJhY2tlZChhY3Rpb24pIHtcbiAgdmFyIHByZXYgPSB1bnRyYWNrZWRTdGFydCgpO1xuICB0cnkge1xuICAgIHJldHVybiBhY3Rpb24oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1bnRyYWNrZWRFbmQocHJldik7XG4gIH1cbn1cbmZ1bmN0aW9uIHVudHJhY2tlZFN0YXJ0KCkge1xuICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gbnVsbDtcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiB1bnRyYWNrZWRFbmQocHJldikge1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBwcmV2O1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZVJlYWRzU3RhcnQoYWxsb3dTdGF0ZVJlYWRzKSB7XG4gIHZhciBwcmV2ID0gZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzO1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHM7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXYpIHtcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzID0gcHJldjtcbn1cbi8qKlxuICogbmVlZGVkIHRvIGtlZXAgYGxvd2VzdE9ic2VydmVyU3RhdGVgIGNvcnJlY3QuIHdoZW4gY2hhbmdpbmcgZnJvbSAoMiBvciAxKSB0byAwXG4gKlxuICovXG5mdW5jdGlvbiBjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMChkZXJpdmF0aW9uKSB7XG4gIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgdmFyIG9icyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXztcbiAgdmFyIGkgPSBvYnMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb2JzW2ldLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gIH1cbn1cblxuLyoqXG4gKiBUaGVzZSB2YWx1ZXMgd2lsbCBwZXJzaXN0IGlmIGdsb2JhbCBzdGF0ZSBpcyByZXNldFxuICovXG52YXIgcGVyc2lzdGVudEtleXMgPSBbXCJtb2J4R3VpZFwiLCBcInNweUxpc3RlbmVyc1wiLCBcImVuZm9yY2VBY3Rpb25zXCIsIFwiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uXCIsIFwicmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGVcIiwgXCJvYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvblwiLCBcImFsbG93U3RhdGVSZWFkc1wiLCBcImRpc2FibGVFcnJvckJvdW5kYXJpZXNcIiwgXCJydW5JZFwiLCBcIlVOQ0hBTkdFRFwiLCBcInVzZVByb3hpZXNcIl07XG52YXIgTW9iWEdsb2JhbHMgPSBmdW5jdGlvbiBNb2JYR2xvYmFscygpIHtcbiAgLyoqXG4gICAqIE1vYlhHbG9iYWxzIHZlcnNpb24uXG4gICAqIE1vYlggY29tcGF0aWJsaXR5IHdpdGggb3RoZXIgdmVyc2lvbnMgbG9hZGVkIGluIG1lbW9yeSBhcyBsb25nIGFzIHRoaXMgdmVyc2lvbiBtYXRjaGVzLlxuICAgKiBJdCBpbmRpY2F0ZXMgdGhhdCB0aGUgZ2xvYmFsIHN0YXRlIHN0aWxsIHN0b3JlcyBzaW1pbGFyIGluZm9ybWF0aW9uXG4gICAqXG4gICAqIE4uQjogdGhpcyB2ZXJzaW9uIGlzIHVucmVsYXRlZCB0byB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIE1vYlgsIGFuZCBpcyBvbmx5IHRoZSB2ZXJzaW9uIG9mIHRoZVxuICAgKiBpbnRlcm5hbCBzdGF0ZSBzdG9yYWdlIG9mIE1vYlgsIGFuZCBjYW4gYmUgdGhlIHNhbWUgYWNyb3NzIG1hbnkgZGlmZmVyZW50IHBhY2thZ2UgdmVyc2lvbnNcbiAgICovXG4gIHRoaXMudmVyc2lvbiA9IDY7XG4gIC8qKlxuICAgKiBnbG9iYWxseSB1bmlxdWUgdG9rZW4gdG8gc2lnbmFsIHVuY2hhbmdlZFxuICAgKi9cbiAgdGhpcy5VTkNIQU5HRUQgPSB7fTtcbiAgLyoqXG4gICAqIEN1cnJlbnRseSBydW5uaW5nIGRlcml2YXRpb25cbiAgICovXG4gIHRoaXMudHJhY2tpbmdEZXJpdmF0aW9uID0gbnVsbDtcbiAgLyoqXG4gICAqIEN1cnJlbnRseSBydW5uaW5nIHJlYWN0aW9uLiBUaGlzIGRldGVybWluZXMgaWYgd2UgY3VycmVudGx5IGhhdmUgYSByZWFjdGl2ZSBjb250ZXh0LlxuICAgKiAoVHJhY2tpbmcgZGVyaXZhdGlvbiBpcyBhbHNvIHNldCBmb3IgdGVtcG9yYWwgdHJhY2tpbmcgb2YgY29tcHV0ZWQgdmFsdWVzIGluc2lkZSBhY3Rpb25zLFxuICAgKiBidXQgdHJhY2tpbmdSZWFjdGlvbiBjYW4gb25seSBiZSBzZXQgYnkgYSBmb3JtIG9mIFJlYWN0aW9uKVxuICAgKi9cbiAgdGhpcy50cmFja2luZ0NvbnRleHQgPSBudWxsO1xuICAvKipcbiAgICogRWFjaCB0aW1lIGEgZGVyaXZhdGlvbiBpcyB0cmFja2VkLCBpdCBpcyBhc3NpZ25lZCBhIHVuaXF1ZSBydW4taWRcbiAgICovXG4gIHRoaXMucnVuSWQgPSAwO1xuICAvKipcbiAgICogJ2d1aWQnIGZvciBnZW5lcmFsIHB1cnBvc2UuIFdpbGwgYmUgcGVyc2lzdGVkIGFtb25nc3QgcmVzZXRzLlxuICAgKi9cbiAgdGhpcy5tb2J4R3VpZCA9IDA7XG4gIC8qKlxuICAgKiBBcmUgd2UgaW4gYSBiYXRjaCBibG9jaz8gKGFuZCBob3cgbWFueSBvZiB0aGVtKVxuICAgKi9cbiAgdGhpcy5pbkJhdGNoID0gMDtcbiAgLyoqXG4gICAqIE9ic2VydmFibGVzIHRoYXQgZG9uJ3QgaGF2ZSBvYnNlcnZlcnMgYW55bW9yZSwgYW5kIGFyZSBhYm91dCB0byBiZVxuICAgKiBzdXNwZW5kZWQsIHVubGVzcyBzb21lYm9keSBlbHNlIGFjY2Vzc2VzIGl0IGluIHRoZSBzYW1lIGJhdGNoXG4gICAqXG4gICAqIEB0eXBlIHtJT2JzZXJ2YWJsZVtdfVxuICAgKi9cbiAgdGhpcy5wZW5kaW5nVW5vYnNlcnZhdGlvbnMgPSBbXTtcbiAgLyoqXG4gICAqIExpc3Qgb2Ygc2NoZWR1bGVkLCBub3QgeWV0IGV4ZWN1dGVkLCByZWFjdGlvbnMuXG4gICAqL1xuICB0aGlzLnBlbmRpbmdSZWFjdGlvbnMgPSBbXTtcbiAgLyoqXG4gICAqIEFyZSB3ZSBjdXJyZW50bHkgcHJvY2Vzc2luZyByZWFjdGlvbnM/XG4gICAqL1xuICB0aGlzLmlzUnVubmluZ1JlYWN0aW9ucyA9IGZhbHNlO1xuICAvKipcbiAgICogSXMgaXQgYWxsb3dlZCB0byBjaGFuZ2Ugb2JzZXJ2YWJsZXMgYXQgdGhpcyBwb2ludD9cbiAgICogSW4gZ2VuZXJhbCwgTW9iWCBkb2Vzbid0IGFsbG93IHRoYXQgd2hlbiBydW5uaW5nIGNvbXB1dGF0aW9ucyBhbmQgUmVhY3QucmVuZGVyLlxuICAgKiBUbyBlbnN1cmUgdGhhdCB0aG9zZSBmdW5jdGlvbnMgc3RheSBwdXJlLlxuICAgKi9cbiAgdGhpcy5hbGxvd1N0YXRlQ2hhbmdlcyA9IGZhbHNlO1xuICAvKipcbiAgICogSXMgaXQgYWxsb3dlZCB0byByZWFkIG9ic2VydmFibGVzIGF0IHRoaXMgcG9pbnQ/XG4gICAqIFVzZWQgdG8gaG9sZCB0aGUgc3RhdGUgbmVlZGVkIGZvciBgb2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25gXG4gICAqL1xuICB0aGlzLmFsbG93U3RhdGVSZWFkcyA9IHRydWU7XG4gIC8qKlxuICAgKiBJZiBzdHJpY3QgbW9kZSBpcyBlbmFibGVkLCBzdGF0ZSBjaGFuZ2VzIGFyZSBieSBkZWZhdWx0IG5vdCBhbGxvd2VkXG4gICAqL1xuICB0aGlzLmVuZm9yY2VBY3Rpb25zID0gdHJ1ZTtcbiAgLyoqXG4gICAqIFNweSBjYWxsYmFja3NcbiAgICovXG4gIHRoaXMuc3B5TGlzdGVuZXJzID0gW107XG4gIC8qKlxuICAgKiBHbG9iYWxseSBhdHRhY2hlZCBlcnJvciBoYW5kbGVycyB0aGF0IHJlYWN0IHNwZWNpZmljYWxseSB0byBlcnJvcnMgaW4gcmVhY3Rpb25zXG4gICAqL1xuICB0aGlzLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycyA9IFtdO1xuICAvKipcbiAgICogV2FybiBpZiBjb21wdXRlZCB2YWx1ZXMgYXJlIGFjY2Vzc2VkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0XG4gICAqL1xuICB0aGlzLmNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvbiA9IGZhbHNlO1xuICAvKipcbiAgICogKEV4cGVyaW1lbnRhbClcbiAgICogV2FybiBpZiB5b3UgdHJ5IHRvIGNyZWF0ZSB0byBkZXJpdmF0aW9uIC8gcmVhY3RpdmUgY29udGV4dCB3aXRob3V0IGFjY2Vzc2luZyBhbnkgb2JzZXJ2YWJsZS5cbiAgICovXG4gIHRoaXMucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUgPSBmYWxzZTtcbiAgLyoqXG4gICAqIChFeHBlcmltZW50YWwpXG4gICAqIFdhcm4gaWYgb2JzZXJ2YWJsZXMgYXJlIGFjY2Vzc2VkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0XG4gICAqL1xuICB0aGlzLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uID0gZmFsc2U7XG4gIC8qXG4gICAqIERvbid0IGNhdGNoIGFuZCByZXRocm93IGV4Y2VwdGlvbnMuIFRoaXMgaXMgdXNlZnVsIGZvciBpbnNwZWN0aW5nIHRoZSBzdGF0ZSBvZlxuICAgKiB0aGUgc3RhY2sgd2hlbiBhbiBleGNlcHRpb24gb2NjdXJzIHdoaWxlIGRlYnVnZ2luZy5cbiAgICovXG4gIHRoaXMuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9IGZhbHNlO1xuICAvKlxuICAgKiBJZiB0cnVlLCB3ZSBhcmUgYWxyZWFkeSBoYW5kbGluZyBhbiBleGNlcHRpb24gaW4gYW4gYWN0aW9uLiBBbnkgZXJyb3JzIGluIHJlYWN0aW9ucyBzaG91bGQgYmUgc3VwcHJlc3NlZCwgYXNcbiAgICogdGhleSBhcmUgbm90IHRoZSBjYXVzZSwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvaXNzdWVzLzE4MzZcbiAgICovXG4gIHRoaXMuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IGZhbHNlO1xuICB0aGlzLnVzZVByb3hpZXMgPSB0cnVlO1xuICAvKlxuICAgKiBwcmludCB3YXJuaW5ncyBhYm91dCBjb2RlIHRoYXQgd291bGQgZmFpbCBpZiBwcm94aWVzIHdlcmVuJ3QgYXZhaWxhYmxlXG4gICAqL1xuICB0aGlzLnZlcmlmeVByb3hpZXMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEZhbHNlIGZvcmNlcyBhbGwgb2JqZWN0J3MgZGVzY3JpcHRvcnMgdG9cbiAgICogd3JpdGFibGU6IHRydWVcbiAgICogY29uZmlndXJhYmxlOiB0cnVlXG4gICAqL1xuICB0aGlzLnNhZmVEZXNjcmlwdG9ycyA9IHRydWU7XG59O1xudmFyIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSB0cnVlO1xudmFyIGlzb2xhdGVDYWxsZWQgPSBmYWxzZTtcbnZhciBnbG9iYWxTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBnbG9iYWwgPSAvKiNfX1BVUkVfXyovZ2V0R2xvYmFsKCk7XG4gIGlmIChnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA+IDAgJiYgIWdsb2JhbC5fX21vYnhHbG9iYWxzKSB7XG4gICAgY2FuTWVyZ2VHbG9iYWxTdGF0ZSA9IGZhbHNlO1xuICB9XG4gIGlmIChnbG9iYWwuX19tb2J4R2xvYmFscyAmJiBnbG9iYWwuX19tb2J4R2xvYmFscy52ZXJzaW9uICE9PSBuZXcgTW9iWEdsb2JhbHMoKS52ZXJzaW9uKSB7XG4gICAgY2FuTWVyZ2VHbG9iYWxTdGF0ZSA9IGZhbHNlO1xuICB9XG4gIGlmICghY2FuTWVyZ2VHbG9iYWxTdGF0ZSkge1xuICAgIC8vIEJlY2F1c2UgdGhpcyBpcyBhIElJRkUgd2UgbmVlZCB0byBsZXQgaXNvbGF0ZUNhbGxlZCBhIGNoYW5jZSB0byBjaGFuZ2VcbiAgICAvLyBzbyB3ZSBydW4gaXQgYWZ0ZXIgdGhlIGV2ZW50IGxvb3AgY29tcGxldGVkIGF0IGxlYXN0IDEgaXRlcmF0aW9uXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzb2xhdGVDYWxsZWQpIHtcbiAgICAgICAgZGllKDM1KTtcbiAgICAgIH1cbiAgICB9LCAxKTtcbiAgICByZXR1cm4gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMpIHtcbiAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCArPSAxO1xuICAgIGlmICghZ2xvYmFsLl9fbW9ieEdsb2JhbHMuVU5DSEFOR0VEKSB7XG4gICAgICBnbG9iYWwuX19tb2J4R2xvYmFscy5VTkNIQU5HRUQgPSB7fTtcbiAgICB9IC8vIG1ha2UgbWVyZ2UgYmFja3dhcmQgY29tcGF0aWJsZVxuICAgIHJldHVybiBnbG9iYWwuX19tb2J4R2xvYmFscztcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA9IDE7XG4gICAgcmV0dXJuIGdsb2JhbC5fX21vYnhHbG9iYWxzID0gLyojX19QVVJFX18qL25ldyBNb2JYR2xvYmFscygpO1xuICB9XG59KCk7XG5mdW5jdGlvbiBpc29sYXRlR2xvYmFsU3RhdGUoKSB7XG4gIGlmIChnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLmxlbmd0aCB8fCBnbG9iYWxTdGF0ZS5pbkJhdGNoIHx8IGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucykge1xuICAgIGRpZSgzNik7XG4gIH1cbiAgaXNvbGF0ZUNhbGxlZCA9IHRydWU7XG4gIGlmIChjYW5NZXJnZUdsb2JhbFN0YXRlKSB7XG4gICAgdmFyIGdsb2JhbCA9IGdldEdsb2JhbCgpO1xuICAgIGlmICgtLWdsb2JhbC5fX21vYnhJbnN0YW5jZUNvdW50ID09PSAwKSB7XG4gICAgICBnbG9iYWwuX19tb2J4R2xvYmFscyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2xvYmFsU3RhdGUgPSBuZXcgTW9iWEdsb2JhbHMoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0R2xvYmFsU3RhdGUoKSB7XG4gIHJldHVybiBnbG9iYWxTdGF0ZTtcbn1cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seTsgdGhpcyB3aWxsIGJyZWFrIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBleGlzdGluZyBvYnNlcnZhYmxlcyxcbiAqIGJ1dCBjYW4gYmUgdXNlZCB0byBnZXQgYmFjayBhdCBhIHN0YWJsZSBzdGF0ZSBhZnRlciB0aHJvd2luZyBlcnJvcnNcbiAqL1xuZnVuY3Rpb24gcmVzZXRHbG9iYWxTdGF0ZSgpIHtcbiAgdmFyIGRlZmF1bHRHbG9iYWxzID0gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0R2xvYmFscykge1xuICAgIGlmIChwZXJzaXN0ZW50S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICBnbG9iYWxTdGF0ZVtrZXldID0gZGVmYXVsdEdsb2JhbHNba2V5XTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSAhZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGhhc09ic2VydmVycyhvYnNlcnZhYmxlKSB7XG4gIHJldHVybiBvYnNlcnZhYmxlLm9ic2VydmVyc18gJiYgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPiAwO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpIHtcbiAgcmV0dXJuIG9ic2VydmFibGUub2JzZXJ2ZXJzXztcbn1cbi8vIGZ1bmN0aW9uIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlOiBJT2JzZXJ2YWJsZSkge1xuLy8gICAgIGNvbnN0IGxpc3QgPSBvYnNlcnZhYmxlLm9ic2VydmVyc1xuLy8gICAgIGNvbnN0IG1hcCA9IG9ic2VydmFibGUub2JzZXJ2ZXJzSW5kZXhlc1xuLy8gICAgIGNvbnN0IGwgPSBsaXN0Lmxlbmd0aFxuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4vLyAgICAgICAgIGNvbnN0IGlkID0gbGlzdFtpXS5fX21hcGlkXG4vLyAgICAgICAgIGlmIChpKSB7XG4vLyAgICAgICAgICAgICBpbnZhcmlhbnQobWFwW2lkXSA9PT0gaSwgXCJJTlRFUk5BTCBFUlJPUiBtYXBzIGRlcml2YXRpb24uX19tYXBpZCB0byBpbmRleCBpbiBsaXN0XCIpIC8vIGZvciBwZXJmb3JtYW5jZVxuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgaW52YXJpYW50KCEoaWQgaW4gbWFwKSwgXCJJTlRFUk5BTCBFUlJPUiBvYnNlcnZlciBvbiBpbmRleCAwIHNob3VsZG4ndCBiZSBoZWxkIGluIG1hcC5cIikgLy8gZm9yIHBlcmZvcm1hbmNlXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyAgICAgaW52YXJpYW50KFxuLy8gICAgICAgICBsaXN0Lmxlbmd0aCA9PT0gMCB8fCBPYmplY3Qua2V5cyhtYXApLmxlbmd0aCA9PT0gbGlzdC5sZW5ndGggLSAxLFxuLy8gICAgICAgICBcIklOVEVSTkFMIEVSUk9SIHRoZXJlIGlzIG5vIGp1bmsgaW4gbWFwXCJcbi8vICAgICApXG4vLyB9XG5mdW5jdGlvbiBhZGRPYnNlcnZlcihvYnNlcnZhYmxlLCBub2RlKSB7XG4gIC8vIGludmFyaWFudChub2RlLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiwgY2FuIGFkZCBvbmx5IGRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpID09PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiBhZGQgYWxyZWFkeSBhZGRlZCBub2RlXCIpO1xuICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5hZGQobm9kZSk7XG4gIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID4gbm9kZS5kZXBlbmRlbmNpZXNTdGF0ZV8pIHtcbiAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gbm9kZS5kZXBlbmRlbmNpZXNTdGF0ZV87XG4gIH1cbiAgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgIT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIGRpZG4ndCBhZGQgbm9kZVwiKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9ic2VydmVyKG9ic2VydmFibGUsIG5vZGUpIHtcbiAgLy8gaW52YXJpYW50KGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwLCBcIklOVEVSTkFMIEVSUk9SLCByZW1vdmUgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IGluc2lkZSBiYXRjaFwiKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiByZW1vdmUgYWxyZWFkeSByZW1vdmVkIG5vZGVcIik7XG4gIC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfW1wiZGVsZXRlXCJdKG5vZGUpO1xuICBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPT09IDApIHtcbiAgICAvLyBkZWxldGluZyBsYXN0IG9ic2VydmVyXG4gICAgcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpO1xuICB9XG4gIC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpID09PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiByZW1vdmUgYWxyZWFkeSByZW1vdmVkIG5vZGUyXCIpO1xufVxuZnVuY3Rpb24gcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpIHtcbiAgaWYgKG9ic2VydmFibGUuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCwgXCJJTlRFUk5BTCBFUlJPUiwgc2hvdWxkIG9ubHkgcXVldWUgZm9yIHVub2JzZXJ2YXRpb24gdW5vYnNlcnZlZCBvYnNlcnZhYmxlc1wiKTtcbiAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb24gPSB0cnVlO1xuICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucy5wdXNoKG9ic2VydmFibGUpO1xuICB9XG59XG4vKipcbiAqIEJhdGNoIHN0YXJ0cyBhIHRyYW5zYWN0aW9uLCBhdCBsZWFzdCBmb3IgcHVycG9zZXMgb2YgbWVtb2l6aW5nIENvbXB1dGVkVmFsdWVzIHdoZW4gbm90aGluZyBlbHNlIGRvZXMuXG4gKiBEdXJpbmcgYSBiYXRjaCBgb25CZWNvbWVVbm9ic2VydmVkYCB3aWxsIGJlIGNhbGxlZCBhdCBtb3N0IG9uY2UgcGVyIG9ic2VydmFibGUuXG4gKiBBdm9pZHMgdW5uZWNlc3NhcnkgcmVjYWxjdWxhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gIGdsb2JhbFN0YXRlLmluQmF0Y2grKztcbn1cbmZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICBpZiAoLS1nbG9iYWxTdGF0ZS5pbkJhdGNoID09PSAwKSB7XG4gICAgcnVuUmVhY3Rpb25zKCk7XG4gICAgLy8gdGhlIGJhdGNoIGlzIGFjdHVhbGx5IGFib3V0IHRvIGZpbmlzaCwgYWxsIHVub2JzZXJ2aW5nIHNob3VsZCBoYXBwZW4gaGVyZS5cbiAgICB2YXIgbGlzdCA9IGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbGlzdFtpXTtcbiAgICAgIG9ic2VydmFibGUuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbiA9IGZhbHNlO1xuICAgICAgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID09PSAwKSB7XG4gICAgICAgIGlmIChvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZCkge1xuICAgICAgICAgIC8vIGlmIHRoaXMgb2JzZXJ2YWJsZSBoYWQgcmVhY3RpdmUgb2JzZXJ2ZXJzLCB0cmlnZ2VyIHRoZSBob29rc1xuICAgICAgICAgIG9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkID0gZmFsc2U7XG4gICAgICAgICAgb2JzZXJ2YWJsZS5vbkJVTygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZhYmxlIGluc3RhbmNlb2YgQ29tcHV0ZWRWYWx1ZSkge1xuICAgICAgICAgIC8vIGNvbXB1dGVkIHZhbHVlcyBhcmUgYXV0b21hdGljYWxseSB0ZWFyZWQgZG93biB3aGVuIHRoZSBsYXN0IG9ic2VydmVyIGxlYXZlc1xuICAgICAgICAgIC8vIHRoaXMgcHJvY2VzcyBoYXBwZW5zIHJlY3Vyc2l2ZWx5LCB0aGlzIGNvbXB1dGVkIG1pZ2h0IGJlIHRoZSBsYXN0IG9ic2VydmFiZSBvZiBhbm90aGVyLCBldGMuLlxuICAgICAgICAgIG9ic2VydmFibGUuc3VzcGVuZF8oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnMgPSBbXTtcbiAgfVxufVxuZnVuY3Rpb24gcmVwb3J0T2JzZXJ2ZWQob2JzZXJ2YWJsZSkge1xuICBjaGVja0lmU3RhdGVSZWFkc0FyZUFsbG93ZWQob2JzZXJ2YWJsZSk7XG4gIHZhciBkZXJpdmF0aW9uID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuICBpZiAoZGVyaXZhdGlvbiAhPT0gbnVsbCkge1xuICAgIC8qKlxuICAgICAqIFNpbXBsZSBvcHRpbWl6YXRpb24sIGdpdmUgZWFjaCBkZXJpdmF0aW9uIHJ1biBhbiB1bmlxdWUgaWQgKHJ1bklkKVxuICAgICAqIENoZWNrIGlmIGxhc3QgdGltZSB0aGlzIG9ic2VydmFibGUgd2FzIGFjY2Vzc2VkIHRoZSBzYW1lIHJ1bklkIGlzIHVzZWRcbiAgICAgKiBpZiB0aGlzIGlzIHRoZSBjYXNlLCB0aGUgcmVsYXRpb24gaXMgYWxyZWFkeSBrbm93blxuICAgICAqL1xuICAgIGlmIChkZXJpdmF0aW9uLnJ1bklkXyAhPT0gb2JzZXJ2YWJsZS5sYXN0QWNjZXNzZWRCeV8pIHtcbiAgICAgIG9ic2VydmFibGUubGFzdEFjY2Vzc2VkQnlfID0gZGVyaXZhdGlvbi5ydW5JZF87XG4gICAgICAvLyBUcmllZCBzdG9yaW5nIG5ld09ic2VydmluZywgb3Igb2JzZXJ2aW5nLCBvciBib3RoIGFzIFNldCwgYnV0IHBlcmZvcm1hbmNlIGRpZG4ndCBjb21lIGNsb3NlLi4uXG4gICAgICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ19bZGVyaXZhdGlvbi51bmJvdW5kRGVwc0NvdW50XysrXSA9IG9ic2VydmFibGU7XG4gICAgICBpZiAoIW9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkICYmIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCkge1xuICAgICAgICBvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZCA9IHRydWU7XG4gICAgICAgIG9ic2VydmFibGUub25CTygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWQ7XG4gIH0gZWxzZSBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPT09IDAgJiYgZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDApIHtcbiAgICBxdWV1ZUZvclVub2JzZXJ2YXRpb24ob2JzZXJ2YWJsZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gZnVuY3Rpb24gaW52YXJpYW50TE9TKG9ic2VydmFibGU6IElPYnNlcnZhYmxlLCBtc2c6IHN0cmluZykge1xuLy8gICAgIC8vIGl0J3MgZXhwZW5zaXZlIHNvIGJldHRlciBub3QgcnVuIGl0IGluIHByb2R1Y2l0b24uIGJ1dCB0ZW1wb3JhcmlseSBoZWxwZnVsIGZvciB0ZXN0aW5nXG4vLyAgICAgY29uc3QgbWluID0gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5taW4oYSwgYi5kZXBlbmRlbmNpZXNTdGF0ZSksIDIpXG4vLyAgICAgaWYgKG1pbiA+PSBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUpIHJldHVybiAvLyA8LSB0aGUgb25seSBhc3N1bXB0aW9uIGFib3V0IGBsb3dlc3RPYnNlcnZlclN0YXRlYFxuLy8gICAgIHRocm93IG5ldyBFcnJvcihcbi8vICAgICAgICAgXCJsb3dlc3RPYnNlcnZlclN0YXRlIGlzIHdyb25nIGZvciBcIiArXG4vLyAgICAgICAgICAgICBtc2cgK1xuLy8gICAgICAgICAgICAgXCIgYmVjYXVzZSBcIiArXG4vLyAgICAgICAgICAgICBtaW4gK1xuLy8gICAgICAgICAgICAgXCIgPCBcIiArXG4vLyAgICAgICAgICAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVcbi8vICAgICApXG4vLyB9XG4vKipcbiAqIE5PVEU6IGN1cnJlbnQgcHJvcGFnYXRpb24gbWVjaGFuaXNtIHdpbGwgaW4gY2FzZSBvZiBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGJlaGF2ZSB1bmV4cGVjdGVkbHlcbiAqIEl0IHdpbGwgcHJvcGFnYXRlIGNoYW5nZXMgdG8gb2JzZXJ2ZXJzIGZyb20gcHJldmlvdXMgcnVuXG4gKiBJdCdzIGhhcmQgb3IgbWF5YmUgaW1wb3NzaWJsZSAod2l0aCByZWFzb25hYmxlIHBlcmYpIHRvIGdldCBpdCByaWdodCB3aXRoIGN1cnJlbnQgYXBwcm9hY2hcbiAqIEhvcGVmdWxseSBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGFyZW4ndCBhIGZlYXR1cmUgcGVvcGxlIHNob3VsZCBkZXBlbmQgb25cbiAqIEFsc28gbW9zdCBiYXNpYyB1c2UgY2FzZXMgc2hvdWxkIGJlIG9rXG4gKi9cbi8vIENhbGxlZCBieSBBdG9tIHdoZW4gaXRzIHZhbHVlIGNoYW5nZXNcbmZ1bmN0aW9uIHByb3BhZ2F0ZUNoYW5nZWQob2JzZXJ2YWJsZSkge1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjaGFuZ2VkIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87XG4gIC8vIElkZWFsbHkgd2UgdXNlIGZvci4ub2YgaGVyZSwgYnV0IHRoZSBkb3duY29tcGlsZWQgdmVyc2lvbiBpcyByZWFsbHkgc2xvdy4uLlxuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZC5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBsb2dUcmFjZUluZm8oZCwgb2JzZXJ2YWJsZSk7XG4gICAgICB9XG4gICAgICBkLm9uQmVjb21lU3RhbGVfKCk7XG4gICAgfVxuICAgIGQuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO1xuICB9KTtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY2hhbmdlZCBlbmRcIik7XG59XG4vLyBDYWxsZWQgYnkgQ29tcHV0ZWRWYWx1ZSB3aGVuIGl0IHJlY2FsY3VsYXRlIGFuZCBpdHMgdmFsdWUgY2hhbmdlZFxuZnVuY3Rpb24gcHJvcGFnYXRlQ2hhbmdlQ29uZmlybWVkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY29uZmlybWVkIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5QT1NTSUJMWV9TVEFMRV8pIHtcbiAgICAgIGQuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBkLmlzVHJhY2luZ18gIT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgICAgIGxvZ1RyYWNlSW5mbyhkLCBvYnNlcnZhYmxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXyAvLyB0aGlzIGhhcHBlbnMgZHVyaW5nIGNvbXB1dGluZyBvZiBgZGAsIGp1c3Qga2VlcCBsb3dlc3RPYnNlcnZlclN0YXRlIHVwIHRvIGRhdGUuXG4gICAgKSB7XG4gICAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gICAgfVxuICB9KTtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY29uZmlybWVkIGVuZFwiKTtcbn1cbi8vIFVzZWQgYnkgY29tcHV0ZWQgd2hlbiBpdHMgZGVwZW5kZW5jeSBjaGFuZ2VkLCBidXQgd2UgZG9uJ3Qgd2FuJ3QgdG8gaW1tZWRpYXRlbHkgcmVjb21wdXRlLlxuZnVuY3Rpb24gcHJvcGFnYXRlTWF5YmVDaGFuZ2VkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwibWF5YmUgc3RhcnRcIik7XG4gIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfICE9PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykge1xuICAgIHJldHVybjtcbiAgfVxuICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICAgIGQuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfO1xuICAgICAgZC5vbkJlY29tZVN0YWxlXygpO1xuICAgIH1cbiAgfSk7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcIm1heWJlIGVuZFwiKTtcbn1cbmZ1bmN0aW9uIGxvZ1RyYWNlSW5mbyhkZXJpdmF0aW9uLCBvYnNlcnZhYmxlKSB7XG4gIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgaXMgaW52YWxpZGF0ZWQgZHVlIHRvIGEgY2hhbmdlIGluOiAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInXCIpO1xuICBpZiAoZGVyaXZhdGlvbi5pc1RyYWNpbmdfID09PSBUcmFjZU1vZGUuQlJFQUspIHtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICBwcmludERlcFRyZWUoZ2V0RGVwZW5kZW5jeVRyZWUoZGVyaXZhdGlvbiksIGxpbmVzLCAxKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBuZXcgRnVuY3Rpb24oXCJkZWJ1Z2dlcjtcXG4vKlxcblRyYWNpbmcgJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJ1xcblxcbllvdSBhcmUgZW50ZXJpbmcgdGhpcyBicmVhayBwb2ludCBiZWNhdXNlIGRlcml2YXRpb24gJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJyBpcyBiZWluZyB0cmFjZWQgYW5kICdcIiArIG9ic2VydmFibGUubmFtZV8gKyBcIicgaXMgbm93IGZvcmNpbmcgaXQgdG8gdXBkYXRlLlxcbkp1c3QgZm9sbG93IHRoZSBzdGFja3RyYWNlIHlvdSBzaG91bGQgbm93IHNlZSBpbiB0aGUgZGV2dG9vbHMgdG8gc2VlIHByZWNpc2VseSB3aGF0IHBpZWNlIG9mIHlvdXIgY29kZSBpcyBjYXVzaW5nIHRoaXMgdXBkYXRlXFxuVGhlIHN0YWNrZnJhbWUgeW91IGFyZSBsb29raW5nIGZvciBpcyBhdCBsZWFzdCB+Ni04IHN0YWNrLWZyYW1lcyB1cC5cXG5cXG5cIiArIChkZXJpdmF0aW9uIGluc3RhbmNlb2YgQ29tcHV0ZWRWYWx1ZSA/IGRlcml2YXRpb24uZGVyaXZhdGlvbi50b1N0cmluZygpLnJlcGxhY2UoL1sqXVxcLy9nLCBcIi9cIikgOiBcIlwiKSArIFwiXFxuXFxuVGhlIGRlcGVuZGVuY2llcyBmb3IgdGhpcyBkZXJpdmF0aW9uIGFyZTpcXG5cXG5cIiArIGxpbmVzLmpvaW4oXCJcXG5cIikgKyBcIlxcbiovXFxuICAgIFwiKSgpO1xuICB9XG59XG5mdW5jdGlvbiBwcmludERlcFRyZWUodHJlZSwgbGluZXMsIGRlcHRoKSB7XG4gIGlmIChsaW5lcy5sZW5ndGggPj0gMTAwMCkge1xuICAgIGxpbmVzLnB1c2goXCIoYW5kIG1hbnkgbW9yZSlcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxpbmVzLnB1c2goXCJcIiArIFwiXFx0XCIucmVwZWF0KGRlcHRoIC0gMSkgKyB0cmVlLm5hbWUpO1xuICBpZiAodHJlZS5kZXBlbmRlbmNpZXMpIHtcbiAgICB0cmVlLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIHByaW50RGVwVHJlZShjaGlsZCwgbGluZXMsIGRlcHRoICsgMSk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIFJlYWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVhY3Rpb24obmFtZV8sIG9uSW52YWxpZGF0ZV8sIGVycm9ySGFuZGxlcl8sIHJlcXVpcmVzT2JzZXJ2YWJsZV8pIHtcbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIlJlYWN0aW9uQFwiICsgZ2V0TmV4dElkKCkgOiBcIlJlYWN0aW9uXCI7XG4gICAgfVxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5vbkludmFsaWRhdGVfID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyXyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVpcmVzT2JzZXJ2YWJsZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZpbmdfID0gW107XG4gICAgLy8gbm9kZXMgd2UgYXJlIGxvb2tpbmcgYXQuIE91ciB2YWx1ZSBkZXBlbmRzIG9uIHRoZXNlIG5vZGVzXG4gICAgdGhpcy5uZXdPYnNlcnZpbmdfID0gW107XG4gICAgdGhpcy5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIHRoaXMucnVuSWRfID0gMDtcbiAgICB0aGlzLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgICB0aGlzLmZsYWdzXyA9IDA7XG4gICAgdGhpcy5pc1RyYWNpbmdfID0gVHJhY2VNb2RlLk5PTkU7XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIHRoaXMub25JbnZhbGlkYXRlXyA9IG9uSW52YWxpZGF0ZV87XG4gICAgdGhpcy5lcnJvckhhbmRsZXJfID0gZXJyb3JIYW5kbGVyXztcbiAgICB0aGlzLnJlcXVpcmVzT2JzZXJ2YWJsZV8gPSByZXF1aXJlc09ic2VydmFibGVfO1xuICB9XG4gIHZhciBfcHJvdG8gPSBSZWFjdGlvbi5wcm90b3R5cGU7XG4gIF9wcm90by5vbkJlY29tZVN0YWxlXyA9IGZ1bmN0aW9uIG9uQmVjb21lU3RhbGVfKCkge1xuICAgIHRoaXMuc2NoZWR1bGVfKCk7XG4gIH07XG4gIF9wcm90by5zY2hlZHVsZV8gPSBmdW5jdGlvbiBzY2hlZHVsZV8oKSB7XG4gICAgaWYgKCF0aGlzLmlzU2NoZWR1bGVkKSB7XG4gICAgICB0aGlzLmlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdSZWFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgIHJ1blJlYWN0aW9ucygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogaW50ZXJuYWwsIHVzZSBzY2hlZHVsZSgpIGlmIHlvdSBpbnRlbmQgdG8ga2ljayBvZmYgYSByZWFjdGlvblxuICAgKi87XG4gIF9wcm90by5ydW5SZWFjdGlvbl8gPSBmdW5jdGlvbiBydW5SZWFjdGlvbl8oKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgIHRoaXMuaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIHZhciBwcmV2ID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0O1xuICAgICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gdGhpcztcbiAgICAgIGlmIChzaG91bGRDb21wdXRlKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuaXNUcmFja1BlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMub25JbnZhbGlkYXRlXygpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5pc1RyYWNrUGVuZGluZyAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgLy8gb25JbnZhbGlkYXRlIGRpZG4ndCB0cmlnZ2VyIHRyYWNrIHJpZ2h0IGF3YXkuLlxuICAgICAgICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICAgICAgdHlwZTogXCJzY2hlZHVsZWQtcmVhY3Rpb25cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2O1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by50cmFjayA9IGZ1bmN0aW9uIHRyYWNrKGZuKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgICAgLy8gY29uc29sZS53YXJuKFwiUmVhY3Rpb24gYWxyZWFkeSBkaXNwb3NlZFwiKSAvLyBOb3RlOiBOb3QgYSB3YXJuaW5nIC8gZXJyb3IgaW4gbW9ieCA0IGVpdGhlclxuICAgIH1cbiAgICBzdGFydEJhdGNoKCk7XG4gICAgdmFyIG5vdGlmeSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBzdGFydFRpbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnkpIHtcbiAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IFwicmVhY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICB2YXIgcHJldlJlYWN0aW9uID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0OyAvLyByZWFjdGlvbnMgY291bGQgY3JlYXRlIHJlYWN0aW9ucy4uLlxuICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdCA9IHRyYWNrRGVyaXZlZEZ1bmN0aW9uKHRoaXMsIGZuLCB1bmRlZmluZWQpO1xuICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHByZXZSZWFjdGlvbjtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNUcmFja1BlbmRpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAvLyBkaXNwb3NlZCBkdXJpbmcgbGFzdCBydW4uIENsZWFuIHVwIGV2ZXJ5dGhpbmcgdGhhdCB3YXMgYm91bmQgYWZ0ZXIgdGhlIGRpc3Bvc2UgY2FsbC5cbiAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoaXNDYXVnaHRFeGNlcHRpb24ocmVzdWx0KSkge1xuICAgICAgdGhpcy5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKHJlc3VsdC5jYXVzZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5KSB7XG4gICAgICBzcHlSZXBvcnRFbmQoe1xuICAgICAgICB0aW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgZW5kQmF0Y2goKTtcbiAgfTtcbiAgX3Byb3RvLnJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbl8gPSBmdW5jdGlvbiByZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKGVycm9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5lcnJvckhhbmRsZXJfKSB7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcl8oZXJyb3IsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcykge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHZhciBtZXNzYWdlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJbbW9ieF0gRW5jb3VudGVyZWQgYW4gdW5jYXVnaHQgZXhjZXB0aW9uIHRoYXQgd2FzIHRocm93biBieSBhIHJlYWN0aW9uIG9yIG9ic2VydmVyIGNvbXBvbmVudCwgaW46ICdcIiArIHRoaXMgKyBcIidcIiA6IFwiW21vYnhdIHVuY2F1Z2h0IGVycm9yIGluICdcIiArIHRoaXMgKyBcIidcIjtcbiAgICBpZiAoIWdsb2JhbFN0YXRlLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICAgICAgLyoqIElmIGRlYnVnZ2luZyBicm91Z2h0IHlvdSBoZXJlLCBwbGVhc2UsIHJlYWQgdGhlIGFib3ZlIG1lc3NhZ2UgOi0pLiBUbnghICovXG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlttb2J4XSAoZXJyb3IgaW4gcmVhY3Rpb24gJ1wiICsgdGhpcy5uYW1lXyArIFwiJyBzdXBwcmVzc2VkLCBmaXggZXJyb3Igb2YgY2F1c2luZyBhY3Rpb24gYmVsb3cpXCIpO1xuICAgIH0gLy8gcHJldHRpZXItaWdub3JlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBlcnJvcjogXCJcIiArIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmKGVycm9yLCBfdGhpcyk7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgICAgLy8gaWYgZGlzcG9zZWQgd2hpbGUgcnVubmluZywgY2xlYW4gdXAgbGF0ZXIuIE1heWJlIG5vdCBvcHRpbWFsLCBidXQgcmFyZSBjYXNlXG4gICAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgICAgY2xlYXJPYnNlcnZpbmcodGhpcyk7XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZ2V0RGlzcG9zZXJfID0gZnVuY3Rpb24gZ2V0RGlzcG9zZXJfKGFib3J0U2lnbmFsKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgdmFyIGRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgX3RoaXMyLmRpc3Bvc2UoKTtcbiAgICAgIGFib3J0U2lnbmFsID09IG51bGwgfHwgYWJvcnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PSBudWxsIHx8IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBkaXNwb3NlKTtcbiAgICB9O1xuICAgIGFib3J0U2lnbmFsID09IG51bGwgfHwgYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lciA9PSBudWxsIHx8IGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBkaXNwb3NlKTtcbiAgICBkaXNwb3NlWyRtb2J4XSA9IHRoaXM7XG4gICAgcmV0dXJuIGRpc3Bvc2U7XG4gIH07XG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlJlYWN0aW9uW1wiICsgdGhpcy5uYW1lXyArIFwiXVwiO1xuICB9O1xuICBfcHJvdG8udHJhY2UgPSBmdW5jdGlvbiB0cmFjZSQxKGVudGVyQnJlYWtQb2ludCkge1xuICAgIGlmIChlbnRlckJyZWFrUG9pbnQgPT09IHZvaWQgMCkge1xuICAgICAgZW50ZXJCcmVha1BvaW50ID0gZmFsc2U7XG4gICAgfVxuICAgIHRyYWNlKHRoaXMsIGVudGVyQnJlYWtQb2ludCk7XG4gIH07XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVhY3Rpb24sIFt7XG4gICAga2V5OiBcImlzRGlzcG9zZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRGbGFnKHRoaXMuZmxhZ3NfLCBSZWFjdGlvbi5pc0Rpc3Bvc2VkTWFza18pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZmxhZ3NfID0gc2V0RmxhZyh0aGlzLmZsYWdzXywgUmVhY3Rpb24uaXNEaXNwb3NlZE1hc2tfLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU2NoZWR1bGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0RmxhZyh0aGlzLmZsYWdzXywgUmVhY3Rpb24uaXNTY2hlZHVsZWRNYXNrXyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5mbGFnc18gPSBzZXRGbGFnKHRoaXMuZmxhZ3NfLCBSZWFjdGlvbi5pc1NjaGVkdWxlZE1hc2tfLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVHJhY2tQZW5kaW5nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0RmxhZyh0aGlzLmZsYWdzXywgUmVhY3Rpb24uaXNUcmFja1BlbmRpbmdNYXNrXyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5mbGFnc18gPSBzZXRGbGFnKHRoaXMuZmxhZ3NfLCBSZWFjdGlvbi5pc1RyYWNrUGVuZGluZ01hc2tfLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUnVubmluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIFJlYWN0aW9uLmlzUnVubmluZ01hc2tfKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLmZsYWdzXyA9IHNldEZsYWcodGhpcy5mbGFnc18sIFJlYWN0aW9uLmlzUnVubmluZ01hc2tfLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpZmZWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIFJlYWN0aW9uLmRpZmZWYWx1ZU1hc2tfKSA/IDEgOiAwO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZmxhZ3NfID0gc2V0RmxhZyh0aGlzLmZsYWdzXywgUmVhY3Rpb24uZGlmZlZhbHVlTWFza18sIG5ld1ZhbHVlID09PSAxID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblJlYWN0aW9uLmlzRGlzcG9zZWRNYXNrXyA9IDE7XG5SZWFjdGlvbi5pc1NjaGVkdWxlZE1hc2tfID0gMjtcblJlYWN0aW9uLmlzVHJhY2tQZW5kaW5nTWFza18gPSA0O1xuUmVhY3Rpb24uaXNSdW5uaW5nTWFza18gPSA4O1xuUmVhY3Rpb24uZGlmZlZhbHVlTWFza18gPSAxNjtcbmZ1bmN0aW9uIG9uUmVhY3Rpb25FcnJvcihoYW5kbGVyKSB7XG4gIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIE1hZ2ljIG51bWJlciBhbGVydCFcbiAqIERlZmluZXMgd2l0aGluIGhvdyBtYW55IHRpbWVzIGEgcmVhY3Rpb24gaXMgYWxsb3dlZCB0byByZS10cmlnZ2VyIGl0c2VsZlxuICogdW50aWwgaXQgaXMgYXNzdW1lZCB0aGF0IHRoaXMgaXMgZ29ubmEgYmUgYSBuZXZlciBlbmRpbmcgbG9vcC4uLlxuICovXG52YXIgTUFYX1JFQUNUSU9OX0lURVJBVElPTlMgPSAxMDA7XG52YXIgcmVhY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbiByZWFjdGlvblNjaGVkdWxlcihmKSB7XG4gIHJldHVybiBmKCk7XG59O1xuZnVuY3Rpb24gcnVuUmVhY3Rpb25zKCkge1xuICAvLyBUcmFtcG9saW5pbmcsIGlmIHJ1blJlYWN0aW9ucyBhcmUgYWxyZWFkeSBydW5uaW5nLCBuZXcgcmVhY3Rpb25zIHdpbGwgYmUgcGlja2VkIHVwXG4gIGlmIChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCB8fCBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVhY3Rpb25TY2hlZHVsZXIocnVuUmVhY3Rpb25zSGVscGVyKTtcbn1cbmZ1bmN0aW9uIHJ1blJlYWN0aW9uc0hlbHBlcigpIHtcbiAgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zID0gdHJ1ZTtcbiAgdmFyIGFsbFJlYWN0aW9ucyA9IGdsb2JhbFN0YXRlLnBlbmRpbmdSZWFjdGlvbnM7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgLy8gV2hpbGUgcnVubmluZyByZWFjdGlvbnMsIG5ldyByZWFjdGlvbnMgbWlnaHQgYmUgdHJpZ2dlcmVkLlxuICAvLyBIZW5jZSB3ZSB3b3JrIHdpdGggdHdvIHZhcmlhYmxlcyBhbmQgY2hlY2sgd2hldGhlclxuICAvLyB3ZSBjb252ZXJnZSB0byBubyByZW1haW5pbmcgcmVhY3Rpb25zIGFmdGVyIGEgd2hpbGUuXG4gIHdoaWxlIChhbGxSZWFjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIGlmICgrK2l0ZXJhdGlvbnMgPT09IE1BWF9SRUFDVElPTl9JVEVSQVRJT05TKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiUmVhY3Rpb24gZG9lc24ndCBjb252ZXJnZSB0byBhIHN0YWJsZSBzdGF0ZSBhZnRlciBcIiArIE1BWF9SRUFDVElPTl9JVEVSQVRJT05TICsgXCIgaXRlcmF0aW9ucy5cIiArIChcIiBQcm9iYWJseSB0aGVyZSBpcyBhIGN5Y2xlIGluIHRoZSByZWFjdGl2ZSBmdW5jdGlvbjogXCIgKyBhbGxSZWFjdGlvbnNbMF0pIDogXCJbbW9ieF0gY3ljbGUgaW4gcmVhY3Rpb246IFwiICsgYWxsUmVhY3Rpb25zWzBdKTtcbiAgICAgIGFsbFJlYWN0aW9ucy5zcGxpY2UoMCk7IC8vIGNsZWFyIHJlYWN0aW9uc1xuICAgIH1cbiAgICB2YXIgcmVtYWluaW5nUmVhY3Rpb25zID0gYWxsUmVhY3Rpb25zLnNwbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlbWFpbmluZ1JlYWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlbWFpbmluZ1JlYWN0aW9uc1tpXS5ydW5SZWFjdGlvbl8oKTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zID0gZmFsc2U7XG59XG52YXIgaXNSZWFjdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiUmVhY3Rpb25cIiwgUmVhY3Rpb24pO1xuZnVuY3Rpb24gc2V0UmVhY3Rpb25TY2hlZHVsZXIoZm4pIHtcbiAgdmFyIGJhc2VTY2hlZHVsZXIgPSByZWFjdGlvblNjaGVkdWxlcjtcbiAgcmVhY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbiByZWFjdGlvblNjaGVkdWxlcihmKSB7XG4gICAgcmV0dXJuIGZuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiYXNlU2NoZWR1bGVyKGYpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc1NweUVuYWJsZWQoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgISFnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMubGVuZ3RoO1xufVxuZnVuY3Rpb24gc3B5UmVwb3J0KGV2ZW50KSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gZGVhZCBjb2RlIGVsaW1pbmF0aW9uIGNhbiBkbyB0aGUgcmVzdFxuICBpZiAoIWdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGxpc3RlbmVycyA9IGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycztcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldKGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gc3B5UmVwb3J0U3RhcnQoZXZlbnQpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hhbmdlID0gX2V4dGVuZHMoe30sIGV2ZW50LCB7XG4gICAgc3B5UmVwb3J0U3RhcnQ6IHRydWVcbiAgfSk7XG4gIHNweVJlcG9ydChjaGFuZ2UpO1xufVxudmFyIEVORF9FVkVOVCA9IHtcbiAgdHlwZTogXCJyZXBvcnQtZW5kXCIsXG4gIHNweVJlcG9ydEVuZDogdHJ1ZVxufTtcbmZ1bmN0aW9uIHNweVJlcG9ydEVuZChjaGFuZ2UpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY2hhbmdlKSB7XG4gICAgc3B5UmVwb3J0KF9leHRlbmRzKHt9LCBjaGFuZ2UsIHtcbiAgICAgIHR5cGU6IFwicmVwb3J0LWVuZFwiLFxuICAgICAgc3B5UmVwb3J0RW5kOiB0cnVlXG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIHNweVJlcG9ydChFTkRfRVZFTlQpO1xuICB9XG59XG5mdW5jdGlvbiBzcHkobGlzdGVuZXIpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnNvbGUud2FybihcIlttb2J4LnNweV0gSXMgYSBuby1vcCBpbiBwcm9kdWN0aW9uIGJ1aWxkc1wiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycyA9IGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcmV0dXJuIGwgIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIEFDVElPTiA9IFwiYWN0aW9uXCI7XG52YXIgQUNUSU9OX0JPVU5EID0gXCJhY3Rpb24uYm91bmRcIjtcbnZhciBBVVRPQUNUSU9OID0gXCJhdXRvQWN0aW9uXCI7XG52YXIgQVVUT0FDVElPTl9CT1VORCA9IFwiYXV0b0FjdGlvbi5ib3VuZFwiO1xudmFyIERFRkFVTFRfQUNUSU9OX05BTUUgPSBcIjx1bm5hbWVkIGFjdGlvbj5cIjtcbnZhciBhY3Rpb25Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQUNUSU9OKTtcbnZhciBhY3Rpb25Cb3VuZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihBQ1RJT05fQk9VTkQsIHtcbiAgYm91bmQ6IHRydWVcbn0pO1xudmFyIGF1dG9BY3Rpb25Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQVVUT0FDVElPTiwge1xuICBhdXRvQWN0aW9uOiB0cnVlXG59KTtcbnZhciBhdXRvQWN0aW9uQm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQVVUT0FDVElPTl9CT1VORCwge1xuICBhdXRvQWN0aW9uOiB0cnVlLFxuICBib3VuZDogdHJ1ZVxufSk7XG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25GYWN0b3J5KGF1dG9BY3Rpb24pIHtcbiAgdmFyIHJlcyA9IGZ1bmN0aW9uIGFjdGlvbihhcmcxLCBhcmcyKSB7XG4gICAgLy8gYWN0aW9uKGZuKCkge30pXG4gICAgaWYgKGlzRnVuY3Rpb24oYXJnMSkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVBY3Rpb24oYXJnMS5uYW1lIHx8IERFRkFVTFRfQUNUSU9OX05BTUUsIGFyZzEsIGF1dG9BY3Rpb24pO1xuICAgIH1cbiAgICAvLyBhY3Rpb24oXCJuYW1lXCIsIGZuKCkge30pXG4gICAgaWYgKGlzRnVuY3Rpb24oYXJnMikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVBY3Rpb24oYXJnMSwgYXJnMiwgYXV0b0FjdGlvbik7XG4gICAgfVxuICAgIC8vIEBhY3Rpb24gKDIwMjIuMyBEZWNvcmF0b3JzKVxuICAgIGlmIChpczIwMjIzRGVjb3JhdG9yKGFyZzIpKSB7XG4gICAgICByZXR1cm4gKGF1dG9BY3Rpb24gPyBhdXRvQWN0aW9uQW5ub3RhdGlvbiA6IGFjdGlvbkFubm90YXRpb24pLmRlY29yYXRlXzIwMjIzXyhhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgLy8gQGFjdGlvblxuICAgIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgICAgcmV0dXJuIHN0b3JlQW5ub3RhdGlvbihhcmcxLCBhcmcyLCBhdXRvQWN0aW9uID8gYXV0b0FjdGlvbkFubm90YXRpb24gOiBhY3Rpb25Bbm5vdGF0aW9uKTtcbiAgICB9XG4gICAgLy8gYWN0aW9uKFwibmFtZVwiKSAmIEBhY3Rpb24oXCJuYW1lXCIpXG4gICAgaWYgKGlzU3RyaW5naXNoKGFyZzEpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihjcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKGF1dG9BY3Rpb24gPyBBVVRPQUNUSU9OIDogQUNUSU9OLCB7XG4gICAgICAgIG5hbWU6IGFyZzEsXG4gICAgICAgIGF1dG9BY3Rpb246IGF1dG9BY3Rpb25cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZGllKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGBhY3Rpb25gXCIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlcztcbn1cbnZhciBhY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uRmFjdG9yeShmYWxzZSk7XG5PYmplY3QuYXNzaWduKGFjdGlvbiwgYWN0aW9uQW5ub3RhdGlvbik7XG52YXIgYXV0b0FjdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25GYWN0b3J5KHRydWUpO1xuT2JqZWN0LmFzc2lnbihhdXRvQWN0aW9uLCBhdXRvQWN0aW9uQW5ub3RhdGlvbik7XG5hY3Rpb24uYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhY3Rpb25Cb3VuZEFubm90YXRpb24pO1xuYXV0b0FjdGlvbi5ib3VuZCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGF1dG9BY3Rpb25Cb3VuZEFubm90YXRpb24pO1xuZnVuY3Rpb24gcnVuSW5BY3Rpb24oZm4pIHtcbiAgcmV0dXJuIGV4ZWN1dGVBY3Rpb24oZm4ubmFtZSB8fCBERUZBVUxUX0FDVElPTl9OQU1FLCBmYWxzZSwgZm4sIHRoaXMsIHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBpc0FjdGlvbih0aGluZykge1xuICByZXR1cm4gaXNGdW5jdGlvbih0aGluZykgJiYgdGhpbmcuaXNNb2J4QWN0aW9uID09PSB0cnVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuYW1lZCByZWFjdGl2ZSB2aWV3IGFuZCBrZWVwcyBpdCBhbGl2ZSwgc28gdGhhdCB0aGUgdmlldyBpcyBhbHdheXNcbiAqIHVwZGF0ZWQgaWYgb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcywgZXZlbiB3aGVuIHRoZSB2aWV3IGlzIG5vdCBmdXJ0aGVyIHVzZWQgYnkgc29tZXRoaW5nIGVsc2UuXG4gKiBAcGFyYW0gdmlldyBUaGUgcmVhY3RpdmUgdmlld1xuICogQHJldHVybnMgZGlzcG9zZXIgZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHN0b3AgdGhlIHZpZXcgZnJvbSBiZWluZyB1cGRhdGVkIGluIHRoZSBmdXR1cmUuXG4gKi9cbmZ1bmN0aW9uIGF1dG9ydW4odmlldywgb3B0cykge1xuICB2YXIgX29wdHMkbmFtZSwgX29wdHMsIF9vcHRzMiwgX29wdHMzO1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IEVNUFRZX09CSkVDVDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZpZXcpKSB7XG4gICAgICBkaWUoXCJBdXRvcnVuIGV4cGVjdHMgYSBmdW5jdGlvbiBhcyBmaXJzdCBhcmd1bWVudFwiKTtcbiAgICB9XG4gICAgaWYgKGlzQWN0aW9uKHZpZXcpKSB7XG4gICAgICBkaWUoXCJBdXRvcnVuIGRvZXMgbm90IGFjY2VwdCBhY3Rpb25zIHNpbmNlIGFjdGlvbnMgYXJlIHVudHJhY2thYmxlXCIpO1xuICAgIH1cbiAgfVxuICB2YXIgbmFtZSA9IChfb3B0cyRuYW1lID0gKF9vcHRzID0gb3B0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRzLm5hbWUpICE9IG51bGwgPyBfb3B0cyRuYW1lIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdmlldy5uYW1lIHx8IFwiQXV0b3J1bkBcIiArIGdldE5leHRJZCgpIDogXCJBdXRvcnVuXCI7XG4gIHZhciBydW5TeW5jID0gIW9wdHMuc2NoZWR1bGVyICYmICFvcHRzLmRlbGF5O1xuICB2YXIgcmVhY3Rpb247XG4gIGlmIChydW5TeW5jKSB7XG4gICAgLy8gbm9ybWFsIGF1dG9ydW5cbiAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyYWNrKHJlYWN0aW9uUnVubmVyKTtcbiAgICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyID0gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cyk7XG4gICAgLy8gZGVib3VuY2VkIGF1dG9ydW5cbiAgICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgc2NoZWR1bGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghcmVhY3Rpb24uaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmVhY3Rpb24udHJhY2socmVhY3Rpb25SdW5uZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVhY3Rpb25SdW5uZXIoKSB7XG4gICAgdmlldyhyZWFjdGlvbik7XG4gIH1cbiAgaWYgKCEoKF9vcHRzMiA9IG9wdHMpICE9IG51bGwgJiYgKF9vcHRzMiA9IF9vcHRzMi5zaWduYWwpICE9IG51bGwgJiYgX29wdHMyLmFib3J0ZWQpKSB7XG4gICAgcmVhY3Rpb24uc2NoZWR1bGVfKCk7XG4gIH1cbiAgcmV0dXJuIHJlYWN0aW9uLmdldERpc3Bvc2VyXygoX29wdHMzID0gb3B0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRzMy5zaWduYWwpO1xufVxudmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bihmKSB7XG4gIHJldHVybiBmKCk7XG59O1xuZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cykge1xuICByZXR1cm4gb3B0cy5zY2hlZHVsZXIgPyBvcHRzLnNjaGVkdWxlciA6IG9wdHMuZGVsYXkgPyBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIG9wdHMuZGVsYXkpO1xuICB9IDogcnVuO1xufVxuZnVuY3Rpb24gcmVhY3Rpb24oZXhwcmVzc2lvbiwgZWZmZWN0LCBvcHRzKSB7XG4gIHZhciBfb3B0cyRuYW1lMiwgX29wdHM0LCBfb3B0czU7XG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gRU1QVFlfT0JKRUNUO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oZXhwcmVzc2lvbikgfHwgIWlzRnVuY3Rpb24oZWZmZWN0KSkge1xuICAgICAgZGllKFwiRmlyc3QgYW5kIHNlY29uZCBhcmd1bWVudCB0byByZWFjdGlvbiBzaG91bGQgYmUgZnVuY3Rpb25zXCIpO1xuICAgIH1cbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qob3B0cykpIHtcbiAgICAgIGRpZShcIlRoaXJkIGFyZ3VtZW50IG9mIHJlYWN0aW9ucyBzaG91bGQgYmUgYW4gb2JqZWN0XCIpO1xuICAgIH1cbiAgfVxuICB2YXIgbmFtZSA9IChfb3B0cyRuYW1lMiA9IG9wdHMubmFtZSkgIT0gbnVsbCA/IF9vcHRzJG5hbWUyIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJSZWFjdGlvbkBcIiArIGdldE5leHRJZCgpIDogXCJSZWFjdGlvblwiO1xuICB2YXIgZWZmZWN0QWN0aW9uID0gYWN0aW9uKG5hbWUsIG9wdHMub25FcnJvciA/IHdyYXBFcnJvckhhbmRsZXIob3B0cy5vbkVycm9yLCBlZmZlY3QpIDogZWZmZWN0KTtcbiAgdmFyIHJ1blN5bmMgPSAhb3B0cy5zY2hlZHVsZXIgJiYgIW9wdHMuZGVsYXk7XG4gIHZhciBzY2hlZHVsZXIgPSBjcmVhdGVTY2hlZHVsZXJGcm9tT3B0aW9ucyhvcHRzKTtcbiAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG4gIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdmFsdWU7XG4gIHZhciBlcXVhbHMgPSBvcHRzLmNvbXBhcmVTdHJ1Y3R1cmFsID8gY29tcGFyZXIuc3RydWN0dXJhbCA6IG9wdHMuZXF1YWxzIHx8IGNvbXBhcmVyW1wiZGVmYXVsdFwiXTtcbiAgdmFyIHIgPSBuZXcgUmVhY3Rpb24obmFtZSwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChmaXJzdFRpbWUgfHwgcnVuU3luYykge1xuICAgICAgcmVhY3Rpb25SdW5uZXIoKTtcbiAgICB9IGVsc2UgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2NoZWR1bGVyKHJlYWN0aW9uUnVubmVyKTtcbiAgICB9XG4gIH0sIG9wdHMub25FcnJvciwgb3B0cy5yZXF1aXJlc09ic2VydmFibGUpO1xuICBmdW5jdGlvbiByZWFjdGlvblJ1bm5lcigpIHtcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmIChyLmlzRGlzcG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICByLnRyYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBhbGxvd1N0YXRlQ2hhbmdlcyhmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbihyKTtcbiAgICAgIH0pO1xuICAgICAgY2hhbmdlZCA9IGZpcnN0VGltZSB8fCAhZXF1YWxzKHZhbHVlLCBuZXh0VmFsdWUpO1xuICAgICAgdmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKGZpcnN0VGltZSAmJiBvcHRzLmZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgZWZmZWN0QWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSwgcik7XG4gICAgfSBlbHNlIGlmICghZmlyc3RUaW1lICYmIGNoYW5nZWQpIHtcbiAgICAgIGVmZmVjdEFjdGlvbih2YWx1ZSwgb2xkVmFsdWUsIHIpO1xuICAgIH1cbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfVxuICBpZiAoISgoX29wdHM0ID0gb3B0cykgIT0gbnVsbCAmJiAoX29wdHM0ID0gX29wdHM0LnNpZ25hbCkgIT0gbnVsbCAmJiBfb3B0czQuYWJvcnRlZCkpIHtcbiAgICByLnNjaGVkdWxlXygpO1xuICB9XG4gIHJldHVybiByLmdldERpc3Bvc2VyXygoX29wdHM1ID0gb3B0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRzNS5zaWduYWwpO1xufVxuZnVuY3Rpb24gd3JhcEVycm9ySGFuZGxlcihlcnJvckhhbmRsZXIsIGJhc2VGbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYmFzZUZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JIYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgT05fQkVDT01FX09CU0VSVkVEID0gXCJvbkJPXCI7XG52YXIgT05fQkVDT01FX1VOT0JTRVJWRUQgPSBcIm9uQlVPXCI7XG5mdW5jdGlvbiBvbkJlY29tZU9ic2VydmVkKHRoaW5nLCBhcmcyLCBhcmczKSB7XG4gIHJldHVybiBpbnRlcmNlcHRIb29rKE9OX0JFQ09NRV9PQlNFUlZFRCwgdGhpbmcsIGFyZzIsIGFyZzMpO1xufVxuZnVuY3Rpb24gb25CZWNvbWVVbm9ic2VydmVkKHRoaW5nLCBhcmcyLCBhcmczKSB7XG4gIHJldHVybiBpbnRlcmNlcHRIb29rKE9OX0JFQ09NRV9VTk9CU0VSVkVELCB0aGluZywgYXJnMiwgYXJnMyk7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRIb29rKGhvb2ssIHRoaW5nLCBhcmcyLCBhcmczKSB7XG4gIHZhciBhdG9tID0gdHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIiA/IGdldEF0b20odGhpbmcsIGFyZzIpIDogZ2V0QXRvbSh0aGluZyk7XG4gIHZhciBjYiA9IGlzRnVuY3Rpb24oYXJnMykgPyBhcmczIDogYXJnMjtcbiAgdmFyIGxpc3RlbmVyc0tleSA9IGhvb2sgKyBcIkxcIjtcbiAgaWYgKGF0b21bbGlzdGVuZXJzS2V5XSkge1xuICAgIGF0b21bbGlzdGVuZXJzS2V5XS5hZGQoY2IpO1xuICB9IGVsc2Uge1xuICAgIGF0b21bbGlzdGVuZXJzS2V5XSA9IG5ldyBTZXQoW2NiXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9va0xpc3RlbmVycyA9IGF0b21bbGlzdGVuZXJzS2V5XTtcbiAgICBpZiAoaG9va0xpc3RlbmVycykge1xuICAgICAgaG9va0xpc3RlbmVyc1tcImRlbGV0ZVwiXShjYik7XG4gICAgICBpZiAoaG9va0xpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBhdG9tW2xpc3RlbmVyc0tleV07XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgTkVWRVIgPSBcIm5ldmVyXCI7XG52YXIgQUxXQVlTID0gXCJhbHdheXNcIjtcbnZhciBPQlNFUlZFRCA9IFwib2JzZXJ2ZWRcIjtcbi8vIGNvbnN0IElGX0FWQUlMQUJMRSA9IFwiaWZhdmFpbGFibGVcIlxuZnVuY3Rpb24gY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuaXNvbGF0ZUdsb2JhbFN0YXRlID09PSB0cnVlKSB7XG4gICAgaXNvbGF0ZUdsb2JhbFN0YXRlKCk7XG4gIH1cbiAgdmFyIHVzZVByb3hpZXMgPSBvcHRpb25zLnVzZVByb3hpZXMsXG4gICAgZW5mb3JjZUFjdGlvbnMgPSBvcHRpb25zLmVuZm9yY2VBY3Rpb25zO1xuICBpZiAodXNlUHJveGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9IHVzZVByb3hpZXMgPT09IEFMV0FZUyA/IHRydWUgOiB1c2VQcm94aWVzID09PSBORVZFUiA/IGZhbHNlIDogdHlwZW9mIFByb3h5ICE9PSBcInVuZGVmaW5lZFwiO1xuICB9XG4gIGlmICh1c2VQcm94aWVzID09PSBcImlmYXZhaWxhYmxlXCIpIHtcbiAgICBnbG9iYWxTdGF0ZS52ZXJpZnlQcm94aWVzID0gdHJ1ZTtcbiAgfVxuICBpZiAoZW5mb3JjZUFjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlYSA9IGVuZm9yY2VBY3Rpb25zID09PSBBTFdBWVMgPyBBTFdBWVMgOiBlbmZvcmNlQWN0aW9ucyA9PT0gT0JTRVJWRUQ7XG4gICAgZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPSBlYTtcbiAgICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9IGVhID09PSB0cnVlIHx8IGVhID09PSBBTFdBWVMgPyBmYWxzZSA6IHRydWU7XG4gIH1cbiAgW1wiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uXCIsIFwicmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGVcIiwgXCJvYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvblwiLCBcImRpc2FibGVFcnJvckJvdW5kYXJpZXNcIiwgXCJzYWZlRGVzY3JpcHRvcnNcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICBnbG9iYWxTdGF0ZVtrZXldID0gISFvcHRpb25zW2tleV07XG4gICAgfVxuICB9KTtcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzID0gIWdsb2JhbFN0YXRlLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPT09IHRydWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBEZWJ1ZyBmZWF0dXJlIG9ubHkuIE1vYlggd2lsbCBOT1QgcmVjb3ZlciBmcm9tIGVycm9ycyB3aGVuIGBkaXNhYmxlRXJyb3JCb3VuZGFyaWVzYCBpcyBlbmFibGVkLlwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZWFjdGlvblNjaGVkdWxlcikge1xuICAgIHNldFJlYWN0aW9uU2NoZWR1bGVyKG9wdGlvbnMucmVhY3Rpb25TY2hlZHVsZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZE9ic2VydmFibGUodGFyZ2V0LCBwcm9wZXJ0aWVzLCBhbm5vdGF0aW9ucywgb3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiA0KSB7XG4gICAgICBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgZXhwZWN0ZWQgMi00IGFyZ3VtZW50c1wiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGRpZShcIidleHRlbmRPYnNlcnZhYmxlJyBleHBlY3RzIGFuIG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudFwiKTtcbiAgICB9XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0YXJnZXQpKSB7XG4gICAgICBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgc2hvdWxkIG5vdCBiZSB1c2VkIG9uIG1hcHMsIHVzZSBtYXAubWVyZ2UgaW5zdGVhZFwiKTtcbiAgICB9XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHByb3BlcnRpZXMpKSB7XG4gICAgICBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgb25seSBhY2NlcHRzIHBsYWluIG9iamVjdHMgYXMgc2Vjb25kIGFyZ3VtZW50XCIpO1xuICAgIH1cbiAgICBpZiAoaXNPYnNlcnZhYmxlKHByb3BlcnRpZXMpIHx8IGlzT2JzZXJ2YWJsZShhbm5vdGF0aW9ucykpIHtcbiAgICAgIGRpZShcIkV4dGVuZGluZyBhbiBvYmplY3Qgd2l0aCBhbm90aGVyIG9ic2VydmFibGUgKG9iamVjdCkgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gIH1cbiAgLy8gUHVsbCBkZXNjcmlwdG9ycyBmaXJzdCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBkZWFsIHdpdGggcHJvcHMgYWRkZWQgYnkgYWRtaW5pc3RyYXRpb24gKCRtb2J4KVxuICB2YXIgZGVzY3JpcHRvcnMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHByb3BlcnRpZXMpO1xuICBpbml0T2JzZXJ2YWJsZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTtcbiAgICBvd25LZXlzKGRlc2NyaXB0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGFkbS5leHRlbmRfKGtleSwgZGVzY3JpcHRvcnNba2V5XSxcbiAgICAgIC8vIG11c3QgcGFzcyBcInVuZGVmaW5lZFwiIGZvciB7IGtleTogdW5kZWZpbmVkIH1cbiAgICAgICFhbm5vdGF0aW9ucyA/IHRydWUgOiBrZXkgaW4gYW5ub3RhdGlvbnMgPyBhbm5vdGF0aW9uc1trZXldIDogdHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmN5VHJlZSh0aGluZywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIG5vZGVUb0RlcGVuZGVuY3lUcmVlKGdldEF0b20odGhpbmcsIHByb3BlcnR5KSk7XG59XG5mdW5jdGlvbiBub2RlVG9EZXBlbmRlbmN5VHJlZShub2RlKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgbmFtZTogbm9kZS5uYW1lX1xuICB9O1xuICBpZiAobm9kZS5vYnNlcnZpbmdfICYmIG5vZGUub2JzZXJ2aW5nXy5sZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0LmRlcGVuZGVuY2llcyA9IHVuaXF1ZShub2RlLm9ic2VydmluZ18pLm1hcChub2RlVG9EZXBlbmRlbmN5VHJlZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVyVHJlZSh0aGluZywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIG5vZGVUb09ic2VydmVyVHJlZShnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xufVxuZnVuY3Rpb24gbm9kZVRvT2JzZXJ2ZXJUcmVlKG5vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBuYW1lOiBub2RlLm5hbWVfXG4gIH07XG4gIGlmIChoYXNPYnNlcnZlcnMobm9kZSkpIHtcbiAgICByZXN1bHQub2JzZXJ2ZXJzID0gQXJyYXkuZnJvbShnZXRPYnNlcnZlcnMobm9kZSkpLm1hcChub2RlVG9PYnNlcnZlclRyZWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmlxdWUobGlzdCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGxpc3QpKTtcbn1cblxudmFyIGdlbmVyYXRvcklkID0gMDtcbmZ1bmN0aW9uIEZsb3dDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgdGhpcy5tZXNzYWdlID0gXCJGTE9XX0NBTkNFTExFRFwiO1xufVxuRmxvd0NhbmNlbGxhdGlvbkVycm9yLnByb3RvdHlwZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5mdW5jdGlvbiBpc0Zsb3dDYW5jZWxsYXRpb25FcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBGbG93Q2FuY2VsbGF0aW9uRXJyb3I7XG59XG52YXIgZmxvd0Fubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlRmxvd0Fubm90YXRpb24oXCJmbG93XCIpO1xudmFyIGZsb3dCb3VuZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlRmxvd0Fubm90YXRpb24oXCJmbG93LmJvdW5kXCIsIHtcbiAgYm91bmQ6IHRydWVcbn0pO1xudmFyIGZsb3cgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBmbG93KGFyZzEsIGFyZzIpIHtcbiAgLy8gQGZsb3cgKDIwMjIuMyBEZWNvcmF0b3JzKVxuICBpZiAoaXMyMDIyM0RlY29yYXRvcihhcmcyKSkge1xuICAgIHJldHVybiBmbG93QW5ub3RhdGlvbi5kZWNvcmF0ZV8yMDIyM18oYXJnMSwgYXJnMik7XG4gIH1cbiAgLy8gQGZsb3dcbiAgaWYgKGlzU3RyaW5naXNoKGFyZzIpKSB7XG4gICAgcmV0dXJuIHN0b3JlQW5ub3RhdGlvbihhcmcxLCBhcmcyLCBmbG93QW5ub3RhdGlvbik7XG4gIH1cbiAgLy8gZmxvdyhmbilcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgZGllKFwiRmxvdyBleHBlY3RzIHNpbmdsZSBhcmd1bWVudCB3aXRoIGdlbmVyYXRvciBmdW5jdGlvblwiKTtcbiAgfVxuICB2YXIgZ2VuZXJhdG9yID0gYXJnMTtcbiAgdmFyIG5hbWUgPSBnZW5lcmF0b3IubmFtZSB8fCBcIjx1bm5hbWVkIGZsb3c+XCI7XG4gIC8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS90ai9jby9ibG9iL21hc3Rlci9pbmRleC5qc1xuICB2YXIgcmVzID0gZnVuY3Rpb24gcmVzKCkge1xuICAgIHZhciBjdHggPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBydW5JZCA9ICsrZ2VuZXJhdG9ySWQ7XG4gICAgdmFyIGdlbiA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0gaW5pdFwiLCBnZW5lcmF0b3IpLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgdmFyIHJlamVjdG9yO1xuICAgIHZhciBwZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBzdGVwSWQgPSAwO1xuICAgICAgcmVqZWN0b3IgPSByZWplY3Q7XG4gICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZChyZXMpIHtcbiAgICAgICAgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0ID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSB5aWVsZCBcIiArIHN0ZXBJZCsrLCBnZW4ubmV4dCkuY2FsbChnZW4sIHJlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQocmV0KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0ZWQoZXJyKSB7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0geWllbGQgXCIgKyBzdGVwSWQrKywgZ2VuW1widGhyb3dcIl0pLmNhbGwoZ2VuLCBlcnIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KHJldCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBuZXh0KHJldCkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHJldC50aGVuKSkge1xuICAgICAgICAgIC8vIGFuIGFzeW5jIGl0ZXJhdG9yXG4gICAgICAgICAgcmV0LnRoZW4obmV4dCwgcmVqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUocmV0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShyZXQudmFsdWUpO1xuICAgICAgICByZXR1cm4gcGVuZGluZ1Byb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICB9XG4gICAgICBvbkZ1bGZpbGxlZCh1bmRlZmluZWQpOyAvLyBraWNrIG9mZiB0aGUgcHJvY2Vzc1xuICAgIH0pO1xuICAgIHByb21pc2UuY2FuY2VsID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSBjYW5jZWxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHBlbmRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgY2FuY2VsUHJvbWlzZShwZW5kaW5nUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxseSBibG9jayBjYW4gcmV0dXJuIChvciB5aWVsZCkgc3R1ZmYuLlxuICAgICAgICB2YXIgX3JlcyA9IGdlbltcInJldHVyblwiXSh1bmRlZmluZWQpO1xuICAgICAgICAvLyBlYXQgYW55dGhpbmcgdGhhdCBwcm9taXNlIHdvdWxkIGRvLCBpdCdzIGNhbmNlbGxlZCFcbiAgICAgICAgdmFyIHlpZWxkZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKF9yZXMudmFsdWUpO1xuICAgICAgICB5aWVsZGVkUHJvbWlzZS50aGVuKG5vb3AsIG5vb3ApO1xuICAgICAgICBjYW5jZWxQcm9taXNlKHlpZWxkZWRQcm9taXNlKTsgLy8gbWF5YmUgaXQgY2FuIGJlIGNhbmNlbGxlZCA6KVxuICAgICAgICAvLyByZWplY3Qgb3VyIG9yaWdpbmFsIHByb21pc2VcbiAgICAgICAgcmVqZWN0b3IobmV3IEZsb3dDYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0b3IoZSk7IC8vIHRoZXJlIGNvdWxkIGJlIGEgdGhyb3dpbmcgZmluYWxseSBibG9ja1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuICByZXMuaXNNb2JYRmxvdyA9IHRydWU7XG4gIHJldHVybiByZXM7XG59LCBmbG93QW5ub3RhdGlvbik7XG5mbG93LmJvdW5kID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oZmxvd0JvdW5kQW5ub3RhdGlvbik7XG5mdW5jdGlvbiBjYW5jZWxQcm9taXNlKHByb21pc2UpIHtcbiAgaWYgKGlzRnVuY3Rpb24ocHJvbWlzZS5jYW5jZWwpKSB7XG4gICAgcHJvbWlzZS5jYW5jZWwoKTtcbiAgfVxufVxuZnVuY3Rpb24gZmxvd1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdDsgLy8ganVzdCB0cmlja2luZyBUeXBlU2NyaXB0IDopXG59XG5mdW5jdGlvbiBpc0Zsb3coZm4pIHtcbiAgcmV0dXJuIChmbiA9PSBudWxsID8gdm9pZCAwIDogZm4uaXNNb2JYRmxvdykgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdFJlYWRzKHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIHZhciB0YXJnZXQ7XG4gIGlmIChpc09ic2VydmFibGVNYXAodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHRoaW5nKSB8fCBpc09ic2VydmFibGVWYWx1ZSh0aGluZykpIHtcbiAgICB0YXJnZXQgPSBnZXRBZG1pbmlzdHJhdGlvbih0aGluZyk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzU3RyaW5naXNoKHByb3BPckhhbmRsZXIpKSB7XG4gICAgICByZXR1cm4gZGllKFwiSW50ZXJjZXB0UmVhZHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGEgc3BlY2lmaWMgcHJvcGVydHksIG5vdCB3aXRoIGFuIG9iamVjdCBpbiBnZW5lcmFsXCIpO1xuICAgIH1cbiAgICB0YXJnZXQgPSBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcE9ySGFuZGxlcik7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIGRpZShcIkV4cGVjdGVkIG9ic2VydmFibGUgbWFwLCBvYmplY3Qgb3IgYXJyYXkgYXMgZmlyc3QgYXJyYXlcIik7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0YXJnZXQuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBkaWUoXCJBbiBpbnRlcmNlcHQgcmVhZGVyIHdhcyBhbHJlYWR5IGVzdGFibGlzaGVkXCIpO1xuICB9XG4gIHRhcmdldC5kZWhhbmNlciA9IHR5cGVvZiBwcm9wT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyBwcm9wT3JIYW5kbGVyIDogaGFuZGxlcjtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0YXJnZXQuZGVoYW5jZXIgPSB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdCh0aGluZywgcHJvcE9ySGFuZGxlciwgaGFuZGxlcikge1xuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHJldHVybiBpbnRlcmNlcHRQcm9wZXJ0eSh0aGluZywgcHJvcE9ySGFuZGxlciwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGVyY2VwdEludGVyY2VwdGFibGUodGhpbmcsIHByb3BPckhhbmRsZXIpO1xuICB9XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRJbnRlcmNlcHRhYmxlKHRoaW5nLCBoYW5kbGVyKSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZykuaW50ZXJjZXB0XyhoYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIGludGVyY2VwdFByb3BlcnR5KHRoaW5nLCBwcm9wZXJ0eSwgaGFuZGxlcikge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BlcnR5KS5pbnRlcmNlcHRfKGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBfaXNDb21wdXRlZCh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKHZhbHVlKTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCF2YWx1ZVskbW9ieF0udmFsdWVzXy5oYXMocHJvcGVydHkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBhdG9tID0gZ2V0QXRvbSh2YWx1ZSwgcHJvcGVydHkpO1xuICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKGF0b20pO1xufVxuZnVuY3Rpb24gaXNDb21wdXRlZCh2YWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGRpZShcImlzQ29tcHV0ZWQgZXhwZWN0cyBvbmx5IDEgYXJndW1lbnQuIFVzZSBpc0NvbXB1dGVkUHJvcCB0byBpbnNwZWN0IHRoZSBvYnNlcnZhYmlsaXR5IG9mIGEgcHJvcGVydHlcIik7XG4gIH1cbiAgcmV0dXJuIF9pc0NvbXB1dGVkKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzQ29tcHV0ZWRQcm9wKHZhbHVlLCBwcm9wTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc1N0cmluZ2lzaChwcm9wTmFtZSkpIHtcbiAgICByZXR1cm4gZGllKFwiaXNDb21wdXRlZCBleHBlY3RlZCBhIHByb3BlcnR5IG5hbWUgYXMgc2Vjb25kIGFyZ3VtZW50XCIpO1xuICB9XG4gIHJldHVybiBfaXNDb21wdXRlZCh2YWx1ZSwgcHJvcE5hbWUpO1xufVxuXG5mdW5jdGlvbiBfaXNPYnNlcnZhYmxlKHZhbHVlLCBwcm9wZXJ0eSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoaXNPYnNlcnZhYmxlTWFwKHZhbHVlKSB8fCBpc09ic2VydmFibGVBcnJheSh2YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gZGllKFwiaXNPYnNlcnZhYmxlKG9iamVjdCwgcHJvcGVydHlOYW1lKSBpcyBub3Qgc3VwcG9ydGVkIGZvciBhcnJheXMgYW5kIG1hcHMuIFVzZSBtYXAuaGFzIG9yIGFycmF5Lmxlbmd0aCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZVskbW9ieF0udmFsdWVzXy5oYXMocHJvcGVydHkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gRm9yIGZpcnN0IGNoZWNrLCBzZWUgIzcwMVxuICByZXR1cm4gaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSB8fCAhIXZhbHVlWyRtb2J4XSB8fCBpc0F0b20odmFsdWUpIHx8IGlzUmVhY3Rpb24odmFsdWUpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc09ic2VydmFibGUodmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgZGllKFwiaXNPYnNlcnZhYmxlIGV4cGVjdHMgb25seSAxIGFyZ3VtZW50LiBVc2UgaXNPYnNlcnZhYmxlUHJvcCB0byBpbnNwZWN0IHRoZSBvYnNlcnZhYmlsaXR5IG9mIGEgcHJvcGVydHlcIik7XG4gIH1cbiAgcmV0dXJuIF9pc09ic2VydmFibGUodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlUHJvcCh2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNTdHJpbmdpc2gocHJvcE5hbWUpKSB7XG4gICAgcmV0dXJuIGRpZShcImV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZSBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gIH1cbiAgcmV0dXJuIF9pc09ic2VydmFibGUodmFsdWUsIHByb3BOYW1lKTtcbn1cblxuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0ua2V5c18oKTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikgfHwgaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvYmoua2V5cygpKTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0pO1xuICB9XG4gIGRpZSg1KTtcbn1cbmZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH0pO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBvYmouZ2V0KGtleSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLnZhbHVlcygpKTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfVxuICBkaWUoNik7XG59XG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqW2tleV1dO1xuICAgIH0pO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmouZ2V0KGtleSldO1xuICAgIH0pO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKG9iai5lbnRyaWVzKCkpO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBbaW5kZXgsIGtleV07XG4gICAgfSk7XG4gIH1cbiAgZGllKDcpO1xufVxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgdmFyIF92YWx1ZXMgPSBrZXk7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9rZXkgaW4gX3ZhbHVlcykge1xuICAgICAgICBzZXQob2JqLCBfa2V5LCBfdmFsdWVzW19rZXldKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIG9ialskbW9ieF0uc2V0XyhrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIG9iai5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICBvYmouYWRkKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBrZXkgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICB9XG4gICAgaWYgKGtleSA8IDApIHtcbiAgICAgIGRpZShcIkludmFsaWQgaW5kZXg6ICdcIiArIGtleSArIFwiJ1wiKTtcbiAgICB9XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIGlmIChrZXkgPj0gb2JqLmxlbmd0aCkge1xuICAgICAgb2JqLmxlbmd0aCA9IGtleSArIDE7XG4gICAgfVxuICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgZW5kQmF0Y2goKTtcbiAgfSBlbHNlIHtcbiAgICBkaWUoOCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZShvYmosIGtleSkge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICBvYmpbJG1vYnhdLmRlbGV0ZV8oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIG9ialtcImRlbGV0ZVwiXShrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgb2JqW1wiZGVsZXRlXCJdKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBrZXkgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICB9XG4gICAgb2JqLnNwbGljZShrZXksIDEpO1xuICB9IGVsc2Uge1xuICAgIGRpZSg5KTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLmhhc18oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBvYmouaGFzKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmhhcyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4ga2V5ID49IDAgJiYga2V5IDwgb2JqLmxlbmd0aDtcbiAgfVxuICBkaWUoMTApO1xufVxuZnVuY3Rpb24gZ2V0KG9iaiwga2V5KSB7XG4gIGlmICghaGFzKG9iaiwga2V5KSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0uZ2V0XyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgcmV0dXJuIG9iai5nZXQoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIGRpZSgxMSk7XG59XG5mdW5jdGlvbiBhcGlEZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgZGVzY3JpcHRvcikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxuICBkaWUoMzkpO1xufVxuZnVuY3Rpb24gYXBpT3duS2V5cyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0ub3duS2V5c18oKTtcbiAgfVxuICBkaWUoMzgpO1xufVxuXG5mdW5jdGlvbiBvYnNlcnZlKHRoaW5nLCBwcm9wT3JDYiwgY2JPckZpcmUsIGZpcmVJbW1lZGlhdGVseSkge1xuICBpZiAoaXNGdW5jdGlvbihjYk9yRmlyZSkpIHtcbiAgICByZXR1cm4gb2JzZXJ2ZU9ic2VydmFibGVQcm9wZXJ0eSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlLCBmaXJlSW1tZWRpYXRlbHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYnNlcnZlT2JzZXJ2YWJsZSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlKTtcbiAgfVxufVxuZnVuY3Rpb24gb2JzZXJ2ZU9ic2VydmFibGUodGhpbmcsIGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKS5vYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVPYnNlcnZhYmxlUHJvcGVydHkodGhpbmcsIHByb3BlcnR5LCBsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpLm9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpO1xufVxuXG5mdW5jdGlvbiBjYWNoZShtYXAsIGtleSwgdmFsdWUpIHtcbiAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdG9KU0hlbHBlcihzb3VyY2UsIF9fYWxyZWFkeVNlZW4pIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsIHx8IHR5cGVvZiBzb3VyY2UgIT09IFwib2JqZWN0XCIgfHwgc291cmNlIGluc3RhbmNlb2YgRGF0ZSB8fCAhaXNPYnNlcnZhYmxlKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVWYWx1ZShzb3VyY2UpIHx8IGlzQ29tcHV0ZWRWYWx1ZShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHRvSlNIZWxwZXIoc291cmNlLmdldCgpLCBfX2FscmVhZHlTZWVuKTtcbiAgfVxuICBpZiAoX19hbHJlYWR5U2Vlbi5oYXMoc291cmNlKSkge1xuICAgIHJldHVybiBfX2FscmVhZHlTZWVuLmdldChzb3VyY2UpO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVBcnJheShzb3VyY2UpKSB7XG4gICAgdmFyIHJlcyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwgbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpKTtcbiAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgcmVzW2lkeF0gPSB0b0pTSGVscGVyKHZhbHVlLCBfX2FscmVhZHlTZWVuKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVTZXQoc291cmNlKSkge1xuICAgIHZhciBfcmVzID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgU2V0KCkpO1xuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgX3Jlcy5hZGQodG9KU0hlbHBlcih2YWx1ZSwgX19hbHJlYWR5U2VlbikpO1xuICAgIH0pO1xuICAgIHJldHVybiBfcmVzO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVNYXAoc291cmNlKSkge1xuICAgIHZhciBfcmVzMiA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwgbmV3IE1hcCgpKTtcbiAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgX3JlczIuc2V0KGtleSwgdG9KU0hlbHBlcih2YWx1ZSwgX19hbHJlYWR5U2VlbikpO1xuICAgIH0pO1xuICAgIHJldHVybiBfcmVzMjtcbiAgfSBlbHNlIHtcbiAgICAvLyBtdXN0IGJlIG9ic2VydmFibGUgb2JqZWN0XG4gICAgdmFyIF9yZXMzID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCB7fSk7XG4gICAgYXBpT3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKG9iamVjdFByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICBfcmVzM1trZXldID0gdG9KU0hlbHBlcihzb3VyY2Vba2V5XSwgX19hbHJlYWR5U2Vlbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZXMzO1xuICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNvbnZlcnRzIGFuIG9ic2VydmFibGUgdG8gaXQncyBub24tb2JzZXJ2YWJsZSBuYXRpdmUgY291bnRlcnBhcnQuXG4gKiBJdCBkb2VzIE5PVCByZWN1cnNlIGludG8gbm9uLW9ic2VydmFibGVzLCB0aGVzZSBhcmUgbGVmdCBhcyB0aGV5IGFyZSwgZXZlbiBpZiB0aGV5IGNvbnRhaW4gb2JzZXJ2YWJsZXMuXG4gKiBDb21wdXRlZCBhbmQgb3RoZXIgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29tcGxldGVseSBpZ25vcmVkLlxuICogQ29tcGxleCBzY2VuYXJpb3MgcmVxdWlyZSBjdXN0b20gc29sdXRpb24sIGVnIGltcGxlbWVudGluZyBgdG9KU09OYCBvciB1c2luZyBgc2VyaWFsaXpyYCBsaWIuXG4gKi9cbmZ1bmN0aW9uIHRvSlMoc291cmNlLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgb3B0aW9ucykge1xuICAgIGRpZShcInRvSlMgbm8gbG9uZ2VyIHN1cHBvcnRzIG9wdGlvbnNcIik7XG4gIH1cbiAgcmV0dXJuIHRvSlNIZWxwZXIoc291cmNlLCBuZXcgTWFwKCkpO1xufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZW50ZXJCcmVha1BvaW50ID0gZmFsc2U7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgZW50ZXJCcmVha1BvaW50ID0gYXJncy5wb3AoKTtcbiAgfVxuICB2YXIgZGVyaXZhdGlvbiA9IGdldEF0b21Gcm9tQXJncyhhcmdzKTtcbiAgaWYgKCFkZXJpdmF0aW9uKSB7XG4gICAgcmV0dXJuIGRpZShcIid0cmFjZShicmVhaz8pJyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhIHRyYWNrZWQgY29tcHV0ZWQgdmFsdWUgb3IgYSBSZWFjdGlvbi4gQ29uc2lkZXIgcGFzc2luZyBpbiB0aGUgY29tcHV0ZWQgdmFsdWUgb3IgcmVhY3Rpb24gZXhwbGljaXRseVwiKTtcbiAgfVxuICBpZiAoZGVyaXZhdGlvbi5pc1RyYWNpbmdfID09PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgdHJhY2luZyBlbmFibGVkXCIpO1xuICB9XG4gIGRlcml2YXRpb24uaXNUcmFjaW5nXyA9IGVudGVyQnJlYWtQb2ludCA/IFRyYWNlTW9kZS5CUkVBSyA6IFRyYWNlTW9kZS5MT0c7XG59XG5mdW5jdGlvbiBnZXRBdG9tRnJvbUFyZ3MoYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZ2V0QXRvbShhcmdzWzBdKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZ2V0QXRvbShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIER1cmluZyBhIHRyYW5zYWN0aW9uIG5vIHZpZXdzIGFyZSB1cGRhdGVkIHVudGlsIHRoZSBlbmQgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICogVGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcnVuIHN5bmNocm9ub3VzbHkgbm9uZXRoZWxlc3MuXG4gKlxuICogQHBhcmFtIGFjdGlvbiBhIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyBzb21lIHJlYWN0aXZlIHN0YXRlXG4gKiBAcmV0dXJucyBhbnkgdmFsdWUgdGhhdCB3YXMgcmV0dXJuZWQgYnkgdGhlICdhY3Rpb24nIHBhcmFtZXRlci5cbiAqL1xuZnVuY3Rpb24gdHJhbnNhY3Rpb24oYWN0aW9uLCB0aGlzQXJnKSB7XG4gIGlmICh0aGlzQXJnID09PSB2b2lkIDApIHtcbiAgICB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICB9XG4gIHN0YXJ0QmF0Y2goKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYWN0aW9uLmFwcGx5KHRoaXNBcmcpO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgYXJnMSAmJiB0eXBlb2YgYXJnMSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiB3aGVuUHJvbWlzZShwcmVkaWNhdGUsIGFyZzEpO1xuICB9XG4gIHJldHVybiBfd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIgfHwge30pO1xufVxuZnVuY3Rpb24gX3doZW4ocHJlZGljYXRlLCBlZmZlY3QsIG9wdHMpIHtcbiAgdmFyIHRpbWVvdXRIYW5kbGU7XG4gIGlmICh0eXBlb2Ygb3B0cy50aW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiV0hFTl9USU1FT1VUXCIpO1xuICAgIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZGlzcG9zZXJbJG1vYnhdLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgZGlzcG9zZXIoKTtcbiAgICAgICAgaWYgKG9wdHMub25FcnJvcikge1xuICAgICAgICAgIG9wdHMub25FcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBvcHRzLnRpbWVvdXQpO1xuICB9XG4gIG9wdHMubmFtZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IG9wdHMubmFtZSB8fCBcIldoZW5AXCIgKyBnZXROZXh0SWQoKSA6IFwiV2hlblwiO1xuICB2YXIgZWZmZWN0QWN0aW9uID0gY3JlYXRlQWN0aW9uKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IG9wdHMubmFtZSArIFwiLWVmZmVjdFwiIDogXCJXaGVuLWVmZmVjdFwiLCBlZmZlY3QpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgdmFyIGRpc3Bvc2VyID0gYXV0b3J1bihmdW5jdGlvbiAocikge1xuICAgIC8vIHByZWRpY2F0ZSBzaG91bGQgbm90IGNoYW5nZSBzdGF0ZVxuICAgIHZhciBjb25kID0gYWxsb3dTdGF0ZUNoYW5nZXMoZmFsc2UsIHByZWRpY2F0ZSk7XG4gICAgaWYgKGNvbmQpIHtcbiAgICAgIHIuZGlzcG9zZSgpO1xuICAgICAgaWYgKHRpbWVvdXRIYW5kbGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgfVxuICAgICAgZWZmZWN0QWN0aW9uKCk7XG4gICAgfVxuICB9LCBvcHRzKTtcbiAgcmV0dXJuIGRpc3Bvc2VyO1xufVxuZnVuY3Rpb24gd2hlblByb21pc2UocHJlZGljYXRlLCBvcHRzKSB7XG4gIHZhciBfb3B0cyRzaWduYWw7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgb3B0cyAmJiBvcHRzLm9uRXJyb3IpIHtcbiAgICByZXR1cm4gZGllKFwidGhlIG9wdGlvbnMgJ29uRXJyb3InIGFuZCAncHJvbWlzZScgY2Fubm90IGJlIGNvbWJpbmVkXCIpO1xuICB9XG4gIGlmIChvcHRzICE9IG51bGwgJiYgKF9vcHRzJHNpZ25hbCA9IG9wdHMuc2lnbmFsKSAhPSBudWxsICYmIF9vcHRzJHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV0hFTl9BQk9SVEVEXCIpKSwge1xuICAgICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHZhciBjYW5jZWw7XG4gIHZhciBhYm9ydDtcbiAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgX29wdHMkc2lnbmFsMjtcbiAgICB2YXIgZGlzcG9zZXIgPSBfd2hlbihwcmVkaWNhdGUsIHJlc29sdmUsIF9leHRlbmRzKHt9LCBvcHRzLCB7XG4gICAgICBvbkVycm9yOiByZWplY3RcbiAgICB9KSk7XG4gICAgY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgZGlzcG9zZXIoKTtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJXSEVOX0NBTkNFTExFRFwiKSk7XG4gICAgfTtcbiAgICBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgZGlzcG9zZXIoKTtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJXSEVOX0FCT1JURURcIikpO1xuICAgIH07XG4gICAgb3B0cyA9PSBudWxsIHx8IChfb3B0cyRzaWduYWwyID0gb3B0cy5zaWduYWwpID09IG51bGwgfHwgX29wdHMkc2lnbmFsMi5hZGRFdmVudExpc3RlbmVyID09IG51bGwgfHwgX29wdHMkc2lnbmFsMi5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpO1xuICB9KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgIHZhciBfb3B0cyRzaWduYWwzO1xuICAgIHJldHVybiBvcHRzID09IG51bGwgfHwgKF9vcHRzJHNpZ25hbDMgPSBvcHRzLnNpZ25hbCkgPT0gbnVsbCB8fCBfb3B0cyRzaWduYWwzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRzJHNpZ25hbDMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KTtcbiAgfSk7XG4gIHJlcy5jYW5jZWwgPSBjYW5jZWw7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFkbSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFskbW9ieF07XG59XG4vLyBPcHRpbWl6YXRpb246IHdlIGRvbid0IG5lZWQgdGhlIGludGVybWVkaWF0ZSBvYmplY3RzIGFuZCBjb3VsZCBoYXZlIGEgY29tcGxldGVseSBjdXN0b20gYWRtaW5pc3RyYXRpb24gZm9yIER5bmFtaWNPYmplY3RzLFxuLy8gYW5kIHNraXAgZWl0aGVyIHRoZSBpbnRlcm5hbCB2YWx1ZXMgbWFwLCBvciB0aGUgYmFzZSBvYmplY3Qgd2l0aCBpdHMgcHJvcGVydHkgZGVzY3JpcHRvcnMhXG52YXIgb2JqZWN0UHJveHlUcmFwcyA9IHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBuYW1lKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJkZXRlY3QgbmV3IHByb3BlcnRpZXMgdXNpbmcgdGhlICdpbicgb3BlcmF0b3IuIFVzZSAnaGFzJyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkbSh0YXJnZXQpLmhhc18obmFtZSk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgIHJldHVybiBnZXRBZG0odGFyZ2V0KS5nZXRfKG5hbWUpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF9nZXRBZG0kc2V0XztcbiAgICBpZiAoIWlzU3RyaW5naXNoKG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWdldEFkbSh0YXJnZXQpLnZhbHVlc18uaGFzKG5hbWUpKSB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiYWRkIGEgbmV3IG9ic2VydmFibGUgcHJvcGVydHkgdGhyb3VnaCBkaXJlY3QgYXNzaWdubWVudC4gVXNlICdzZXQnIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICAvLyBudWxsIChpbnRlcmNlcHRlZCkgLT4gdHJ1ZSAoc3VjY2VzcylcbiAgICByZXR1cm4gKF9nZXRBZG0kc2V0XyA9IGdldEFkbSh0YXJnZXQpLnNldF8obmFtZSwgdmFsdWUsIHRydWUpKSAhPSBudWxsID8gX2dldEFkbSRzZXRfIDogdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgbmFtZSkge1xuICAgIHZhciBfZ2V0QWRtJGRlbGV0ZV87XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImRlbGV0ZSBwcm9wZXJ0aWVzIGZyb20gYW4gb2JzZXJ2YWJsZSBvYmplY3QuIFVzZSAncmVtb3ZlJyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZ2lzaChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBudWxsIChpbnRlcmNlcHRlZCkgLT4gdHJ1ZSAoc3VjY2VzcylcbiAgICByZXR1cm4gKF9nZXRBZG0kZGVsZXRlXyA9IGdldEFkbSh0YXJnZXQpLmRlbGV0ZV8obmFtZSwgdHJ1ZSkpICE9IG51bGwgPyBfZ2V0QWRtJGRlbGV0ZV8gOiB0cnVlO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgdmFyIF9nZXRBZG0kZGVmaW5lUHJvcGVydDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiZGVmaW5lIHByb3BlcnR5IG9uIGFuIG9ic2VydmFibGUgb2JqZWN0LiBVc2UgJ2RlZmluZVByb3BlcnR5JyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgLy8gbnVsbCAoaW50ZXJjZXB0ZWQpIC0+IHRydWUgKHN1Y2Nlc3MpXG4gICAgcmV0dXJuIChfZ2V0QWRtJGRlZmluZVByb3BlcnQgPSBnZXRBZG0odGFyZ2V0KS5kZWZpbmVQcm9wZXJ0eV8obmFtZSwgZGVzY3JpcHRvcikpICE9IG51bGwgPyBfZ2V0QWRtJGRlZmluZVByb3BlcnQgOiB0cnVlO1xuICB9LFxuICBvd25LZXlzOiBmdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiaXRlcmF0ZSBrZXlzIHRvIGRldGVjdCBhZGRlZCAvIHJlbW92ZWQgcHJvcGVydGllcy4gVXNlICdrZXlzJyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkbSh0YXJnZXQpLm93bktleXNfKCk7XG4gIH0sXG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpIHtcbiAgICBkaWUoMTMpO1xuICB9XG59O1xuZnVuY3Rpb24gYXNEeW5hbWljT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIF90YXJnZXQkJG1vYngsIF90YXJnZXQkJG1vYngkcHJveHlfO1xuICBhc3NlcnRQcm94aWVzKCk7XG4gIHRhcmdldCA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpO1xuICByZXR1cm4gKF90YXJnZXQkJG1vYngkcHJveHlfID0gKF90YXJnZXQkJG1vYnggPSB0YXJnZXRbJG1vYnhdKS5wcm94eV8pICE9IG51bGwgPyBfdGFyZ2V0JCRtb2J4JHByb3h5XyA6IF90YXJnZXQkJG1vYngucHJveHlfID0gbmV3IFByb3h5KHRhcmdldCwgb2JqZWN0UHJveHlUcmFwcyk7XG59XG5cbmZ1bmN0aW9uIGhhc0ludGVyY2VwdG9ycyhpbnRlcmNlcHRhYmxlKSB7XG4gIHJldHVybiBpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18gIT09IHVuZGVmaW5lZCAmJiBpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18ubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVySW50ZXJjZXB0b3IoaW50ZXJjZXB0YWJsZSwgaGFuZGxlcikge1xuICB2YXIgaW50ZXJjZXB0b3JzID0gaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfIHx8IChpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18gPSBbXSk7XG4gIGludGVyY2VwdG9ycy5wdXNoKGhhbmRsZXIpO1xuICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IGludGVyY2VwdG9ycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICBpbnRlcmNlcHRvcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGludGVyY2VwdENoYW5nZShpbnRlcmNlcHRhYmxlLCBjaGFuZ2UpIHtcbiAgdmFyIHByZXZVID0gdW50cmFja2VkU3RhcnQoKTtcbiAgdHJ5IHtcbiAgICAvLyBJbnRlcmNlcHRvciBjYW4gbW9kaWZ5IHRoZSBhcnJheSwgY29weSBpdCB0byBhdm9pZCBjb25jdXJyZW50IG1vZGlmaWNhdGlvbiwgc2VlICMxOTUwXG4gICAgdmFyIGludGVyY2VwdG9ycyA9IFtdLmNvbmNhdChpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18gfHwgW10pO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW50ZXJjZXB0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2hhbmdlID0gaW50ZXJjZXB0b3JzW2ldKGNoYW5nZSk7XG4gICAgICBpZiAoY2hhbmdlICYmICFjaGFuZ2UudHlwZSkge1xuICAgICAgICBkaWUoMTQpO1xuICAgICAgfVxuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2U7XG4gIH0gZmluYWxseSB7XG4gICAgdW50cmFja2VkRW5kKHByZXZVKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNMaXN0ZW5lcnMobGlzdGVuYWJsZSkge1xuICByZXR1cm4gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyKGxpc3RlbmFibGUsIGhhbmRsZXIpIHtcbiAgdmFyIGxpc3RlbmVycyA9IGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXyB8fCAobGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfID0gW10pO1xuICBsaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbiAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBsaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgbGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMobGlzdGVuYWJsZSwgY2hhbmdlKSB7XG4gIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG4gIHZhciBsaXN0ZW5lcnMgPSBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc187XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0oY2hhbmdlKTtcbiAgfVxuICB1bnRyYWNrZWRFbmQocHJldlUpO1xufVxuXG5mdW5jdGlvbiBtYWtlT2JzZXJ2YWJsZSh0YXJnZXQsIGFubm90YXRpb25zLCBvcHRpb25zKSB7XG4gIGluaXRPYnNlcnZhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2Fubm90YXRpb25zO1xuICAgIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKVskbW9ieF07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBhbm5vdGF0aW9ucyAmJiB0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSB7XG4gICAgICBkaWUoXCJtYWtlT2JzZXJ2YWJsZSBzZWNvbmQgYXJnIG11c3QgYmUgbnVsbGlzaCB3aGVuIHVzaW5nIGRlY29yYXRvcnMuIE1peGluZyBAZGVjb3JhdG9yIHN5bnRheCB3aXRoIGFubm90YXRpb25zIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICAvLyBEZWZhdWx0IHRvIGRlY29yYXRvcnNcbiAgICAoX2Fubm90YXRpb25zID0gYW5ub3RhdGlvbnMpICE9IG51bGwgPyBfYW5ub3RhdGlvbnMgOiBhbm5vdGF0aW9ucyA9IGNvbGxlY3RTdG9yZWRBbm5vdGF0aW9ucyh0YXJnZXQpO1xuICAgIC8vIEFubm90YXRlXG4gICAgb3duS2V5cyhhbm5vdGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gYWRtLm1ha2VfKGtleSwgYW5ub3RhdGlvbnNba2V5XSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuLy8gcHJvdG9ba2V5c1N5bWJvbF0gPSBuZXcgU2V0PFByb3BlcnR5S2V5PigpXG52YXIga2V5c1N5bWJvbCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJtb2J4LWtleXNcIik7XG5mdW5jdGlvbiBtYWtlQXV0b09ic2VydmFibGUodGFyZ2V0LCBvdmVycmlkZXMsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmICFpc1BsYWluT2JqZWN0KE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpKSkge1xuICAgICAgZGllKFwiJ21ha2VBdXRvT2JzZXJ2YWJsZScgY2FuIG9ubHkgYmUgdXNlZCBmb3IgY2xhc3NlcyB0aGF0IGRvbid0IGhhdmUgYSBzdXBlcmNsYXNzXCIpO1xuICAgIH1cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgIGRpZShcIm1ha2VBdXRvT2JzZXJ2YWJsZSBjYW4gb25seSBiZSB1c2VkIG9uIG9iamVjdHMgbm90IGFscmVhZHkgbWFkZSBvYnNlcnZhYmxlXCIpO1xuICAgIH1cbiAgfVxuICAvLyBPcHRpbWl6YXRpb246IGF2b2lkIHZpc2l0aW5nIHByb3Rvc1xuICAvLyBBc3N1bWVzIHRoYXQgYW5ub3RhdGlvbi5tYWtlXy8uZXh0ZW5kXyB3b3JrcyB0aGUgc2FtZSBmb3IgcGxhaW4gb2JqZWN0c1xuICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGV4dGVuZE9ic2VydmFibGUodGFyZ2V0LCB0YXJnZXQsIG92ZXJyaWRlcywgb3B0aW9ucyk7XG4gIH1cbiAgaW5pdE9ic2VydmFibGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKVskbW9ieF07XG4gICAgLy8gT3B0aW1pemF0aW9uOiBjYWNoZSBrZXlzIG9uIHByb3RvXG4gICAgLy8gQXNzdW1lcyBtYWtlQXV0b09ic2VydmFibGUgY2FuIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIG9iamVjdCBhbmQgY2FuJ3QgYmUgdXNlZCBpbiBzdWJjbGFzc1xuICAgIGlmICghdGFyZ2V0W2tleXNTeW1ib2xdKSB7XG4gICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICAgIHZhciBrZXlzID0gbmV3IFNldChbXS5jb25jYXQob3duS2V5cyh0YXJnZXQpLCBvd25LZXlzKHByb3RvKSkpO1xuICAgICAga2V5c1tcImRlbGV0ZVwiXShcImNvbnN0cnVjdG9yXCIpO1xuICAgICAga2V5c1tcImRlbGV0ZVwiXSgkbW9ieCk7XG4gICAgICBhZGRIaWRkZW5Qcm9wKHByb3RvLCBrZXlzU3ltYm9sLCBrZXlzKTtcbiAgICB9XG4gICAgdGFyZ2V0W2tleXNTeW1ib2xdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGFkbS5tYWtlXyhrZXksXG4gICAgICAvLyBtdXN0IHBhc3MgXCJ1bmRlZmluZWRcIiBmb3IgeyBrZXk6IHVuZGVmaW5lZCB9XG4gICAgICAhb3ZlcnJpZGVzID8gdHJ1ZSA6IGtleSBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXNba2V5XSA6IHRydWUpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIFNQTElDRSA9IFwic3BsaWNlXCI7XG52YXIgVVBEQVRFID0gXCJ1cGRhdGVcIjtcbnZhciBNQVhfU1BMSUNFX1NJWkUgPSAxMDAwMDsgLy8gU2VlIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2lzc3Vlcy84NTlcbnZhciBhcnJheVRyYXBzID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICB2YXIgYWRtID0gdGFyZ2V0WyRtb2J4XTtcbiAgICBpZiAobmFtZSA9PT0gJG1vYngpIHtcbiAgICAgIHJldHVybiBhZG07XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICByZXR1cm4gYWRtLmdldEFycmF5TGVuZ3RoXygpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgIWlzTmFOKG5hbWUpKSB7XG4gICAgICByZXR1cm4gYWRtLmdldF8ocGFyc2VJbnQobmFtZSkpO1xuICAgIH1cbiAgICBpZiAoaGFzUHJvcChhcnJheUV4dGVuc2lvbnMsIG5hbWUpKSB7XG4gICAgICByZXR1cm4gYXJyYXlFeHRlbnNpb25zW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0W25hbWVdO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGFkbSA9IHRhcmdldFskbW9ieF07XG4gICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGFkbS5zZXRBcnJheUxlbmd0aF8odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIgfHwgaXNOYU4obmFtZSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBudW1lcmljIHN0cmluZ1xuICAgICAgYWRtLnNldF8ocGFyc2VJbnQobmFtZSksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucygpIHtcbiAgICBkaWUoMTUpO1xuICB9XG59O1xudmFyIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIG93bmVkXywgbGVnYWN5TW9kZV8pIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZUFycmF5XCI7XG4gICAgfVxuICAgIHRoaXMub3duZWRfID0gdm9pZCAwO1xuICAgIHRoaXMubGVnYWN5TW9kZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5hdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLnZhbHVlc18gPSBbXTtcbiAgICAvLyB0aGlzIGlzIHRoZSBwcm9wIHRoYXQgZ2V0cyBwcm94aWVkLCBzbyBjYW4ndCByZXBsYWNlIGl0IVxuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RLbm93bkxlbmd0aF8gPSAwO1xuICAgIHRoaXMub3duZWRfID0gb3duZWRfO1xuICAgIHRoaXMubGVnYWN5TW9kZV8gPSBsZWdhY3lNb2RlXztcbiAgICB0aGlzLmF0b21fID0gbmV3IEF0b20obmFtZSk7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSBmdW5jdGlvbiAobmV3Viwgb2xkVikge1xuICAgICAgcmV0dXJuIGVuaGFuY2VyKG5ld1YsIG9sZFYsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IG5hbWUgKyBcIlsuLl1cIiA6IFwiT2JzZXJ2YWJsZUFycmF5Wy4uXVwiKTtcbiAgICB9O1xuICB9XG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGU7XG4gIF9wcm90by5kZWhhbmNlVmFsdWVfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBfcHJvdG8uZGVoYW5jZVZhbHVlc18gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVzXyh2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkICYmIHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdmFsdWVzLm1hcCh0aGlzLmRlaGFuY2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChmaXJlSW1tZWRpYXRlbHkgPT09IHZvaWQgMCkge1xuICAgICAgZmlyZUltbWVkaWF0ZWx5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiYXJyYXlcIixcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLmF0b21fLm5hbWVfLFxuICAgICAgICB0eXBlOiBcInNwbGljZVwiLFxuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgYWRkZWQ6IHRoaXMudmFsdWVzXy5zbGljZSgpLFxuICAgICAgICBhZGRlZENvdW50OiB0aGlzLnZhbHVlc18ubGVuZ3RoLFxuICAgICAgICByZW1vdmVkOiBbXSxcbiAgICAgICAgcmVtb3ZlZENvdW50OiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuICBfcHJvdG8uZ2V0QXJyYXlMZW5ndGhfID0gZnVuY3Rpb24gZ2V0QXJyYXlMZW5ndGhfKCkge1xuICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNfLmxlbmd0aDtcbiAgfTtcbiAgX3Byb3RvLnNldEFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIHNldEFycmF5TGVuZ3RoXyhuZXdMZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIG5ld0xlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihuZXdMZW5ndGgpIHx8IG5ld0xlbmd0aCA8IDApIHtcbiAgICAgIGRpZShcIk91dCBvZiByYW5nZTogXCIgKyBuZXdMZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgY3VycmVudExlbmd0aCA9IHRoaXMudmFsdWVzXy5sZW5ndGg7XG4gICAgaWYgKG5ld0xlbmd0aCA9PT0gY3VycmVudExlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAobmV3TGVuZ3RoID4gY3VycmVudExlbmd0aCkge1xuICAgICAgdmFyIG5ld0l0ZW1zID0gbmV3IEFycmF5KG5ld0xlbmd0aCAtIGN1cnJlbnRMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdMZW5ndGggLSBjdXJyZW50TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3SXRlbXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICB9IC8vIE5vIEFycmF5LmZpbGwgZXZlcnl3aGVyZS4uLlxuICAgICAgdGhpcy5zcGxpY2VXaXRoQXJyYXlfKGN1cnJlbnRMZW5ndGgsIDAsIG5ld0l0ZW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zcGxpY2VXaXRoQXJyYXlfKG5ld0xlbmd0aCwgY3VycmVudExlbmd0aCAtIG5ld0xlbmd0aCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8udXBkYXRlQXJyYXlMZW5ndGhfID0gZnVuY3Rpb24gdXBkYXRlQXJyYXlMZW5ndGhfKG9sZExlbmd0aCwgZGVsdGEpIHtcbiAgICBpZiAob2xkTGVuZ3RoICE9PSB0aGlzLmxhc3RLbm93bkxlbmd0aF8pIHtcbiAgICAgIGRpZSgxNik7XG4gICAgfVxuICAgIHRoaXMubGFzdEtub3duTGVuZ3RoXyArPSBkZWx0YTtcbiAgICBpZiAodGhpcy5sZWdhY3lNb2RlXyAmJiBkZWx0YSA+IDApIHtcbiAgICAgIHJlc2VydmVBcnJheUJ1ZmZlcihvbGRMZW5ndGggKyBkZWx0YSArIDEpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnNwbGljZVdpdGhBcnJheV8gPSBmdW5jdGlvbiBzcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMuYXRvbV8pO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnZhbHVlc18ubGVuZ3RoO1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgfSBlbHNlIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaW5kZXgpO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZGVsZXRlQ291bnQgPSBsZW5ndGggLSBpbmRleDtcbiAgICB9IGVsc2UgaWYgKGRlbGV0ZUNvdW50ID09PSB1bmRlZmluZWQgfHwgZGVsZXRlQ291bnQgPT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNvdW50ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlQ291bnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkZWxldGVDb3VudCwgbGVuZ3RoIC0gaW5kZXgpKTtcbiAgICB9XG4gICAgaWYgKG5ld0l0ZW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld0l0ZW1zID0gRU1QVFlfQVJSQVk7XG4gICAgfVxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgICB0eXBlOiBTUExJQ0UsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgcmVtb3ZlZENvdW50OiBkZWxldGVDb3VudCxcbiAgICAgICAgYWRkZWQ6IG5ld0l0ZW1zXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZUNvdW50ID0gY2hhbmdlLnJlbW92ZWRDb3VudDtcbiAgICAgIG5ld0l0ZW1zID0gY2hhbmdlLmFkZGVkO1xuICAgIH1cbiAgICBuZXdJdGVtcyA9IG5ld0l0ZW1zLmxlbmd0aCA9PT0gMCA/IG5ld0l0ZW1zIDogbmV3SXRlbXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gX3RoaXMuZW5oYW5jZXJfKHYsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB2YXIgbGVuZ3RoRGVsdGEgPSBuZXdJdGVtcy5sZW5ndGggLSBkZWxldGVDb3VudDtcbiAgICAgIHRoaXMudXBkYXRlQXJyYXlMZW5ndGhfKGxlbmd0aCwgbGVuZ3RoRGVsdGEpOyAvLyBjaGVja3MgaWYgaW50ZXJuYWwgYXJyYXkgd2Fzbid0IG1vZGlmaWVkXG4gICAgfVxuICAgIHZhciByZXMgPSB0aGlzLnNwbGljZUl0ZW1zSW50b1ZhbHVlc18oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gICAgaWYgKGRlbGV0ZUNvdW50ICE9PSAwIHx8IG5ld0l0ZW1zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5ub3RpZnlBcnJheVNwbGljZV8oaW5kZXgsIG5ld0l0ZW1zLCByZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVzXyhyZXMpO1xuICB9O1xuICBfcHJvdG8uc3BsaWNlSXRlbXNJbnRvVmFsdWVzXyA9IGZ1bmN0aW9uIHNwbGljZUl0ZW1zSW50b1ZhbHVlc18oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIGlmIChuZXdJdGVtcy5sZW5ndGggPCBNQVhfU1BMSUNFX1NJWkUpIHtcbiAgICAgIHZhciBfdGhpcyR2YWx1ZXNfO1xuICAgICAgcmV0dXJuIChfdGhpcyR2YWx1ZXNfID0gdGhpcy52YWx1ZXNfKS5zcGxpY2UuYXBwbHkoX3RoaXMkdmFsdWVzXywgW2luZGV4LCBkZWxldGVDb3VudF0uY29uY2F0KG5ld0l0ZW1zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBpdGVtcyByZW1vdmVkIGJ5IHRoZSBzcGxpY2VcbiAgICAgIHZhciByZXMgPSB0aGlzLnZhbHVlc18uc2xpY2UoaW5kZXgsIGluZGV4ICsgZGVsZXRlQ291bnQpO1xuICAgICAgLy8gVGhlIGl0ZW1zIHRoYXQgdGhhdCBzaG91bGQgcmVtYWluIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5XG4gICAgICB2YXIgb2xkSXRlbXMgPSB0aGlzLnZhbHVlc18uc2xpY2UoaW5kZXggKyBkZWxldGVDb3VudCk7XG4gICAgICAvLyBOZXcgbGVuZ3RoIGlzIHRoZSBwcmV2aW91cyBsZW5ndGggKyBhZGRpdGlvbiBjb3VudCAtIGRlbGV0aW9uIGNvdW50XG4gICAgICB0aGlzLnZhbHVlc18ubGVuZ3RoICs9IG5ld0l0ZW1zLmxlbmd0aCAtIGRlbGV0ZUNvdW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbHVlc19baW5kZXggKyBpXSA9IG5ld0l0ZW1zW2ldO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9sZEl0ZW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0aGlzLnZhbHVlc19baW5kZXggKyBuZXdJdGVtcy5sZW5ndGggKyBfaV0gPSBvbGRJdGVtc1tfaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm5vdGlmeUFycmF5Q2hpbGRVcGRhdGVfID0gZnVuY3Rpb24gbm90aWZ5QXJyYXlDaGlsZFVwZGF0ZV8oaW5kZXgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIHZhciBub3RpZnlTcHkgPSAhdGhpcy5vd25lZF8gJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgIG9ic2VydmFibGVLaW5kOiBcImFycmF5XCIsXG4gICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLmF0b21fLm5hbWVfLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXG4gICAgfSA6IG51bGw7XG4gICAgLy8gVGhlIHJlYXNvbiB3aHkgdGhpcyBpcyBvbiByaWdodCBoYW5kIHNpZGUgaGVyZSAoYW5kIG5vdCBhYm92ZSksIGlzIHRoaXMgd2F5IHRoZSB1Z2xpZmllciB3aWxsIGRyb3AgaXQsIGJ1dCBpdCB3b24ndFxuICAgIC8vIGNhdXNlIGFueSBydW50aW1lIG92ZXJoZWFkIGluIGRldmVsb3BtZW50IG1vZGUgd2l0aG91dCBOT0RFX0VOViBzZXQsIHVubGVzcyBzcHlpbmcgaXMgZW5hYmxlZFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICBpZiAobm90aWZ5KSB7XG4gICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm5vdGlmeUFycmF5U3BsaWNlXyA9IGZ1bmN0aW9uIG5vdGlmeUFycmF5U3BsaWNlXyhpbmRleCwgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWRfICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgIHR5cGU6IFNQTElDRSxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICBhZGRlZDogYWRkZWQsXG4gICAgICByZW1vdmVkQ291bnQ6IHJlbW92ZWQubGVuZ3RoLFxuICAgICAgYWRkZWRDb3VudDogYWRkZWQubGVuZ3RoXG4gICAgfSA6IG51bGw7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgfVxuICAgIHRoaXMuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgIC8vIGNvbmZvcm06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L29ic2VydmVcbiAgICBpZiAobm90aWZ5KSB7XG4gICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmdldF8gPSBmdW5jdGlvbiBnZXRfKGluZGV4KSB7XG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gJiYgaW5kZXggPj0gdGhpcy52YWx1ZXNfLmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiW21vYnguYXJyYXldIEF0dGVtcHQgdG8gcmVhZCBhbiBhcnJheSBpbmRleCAoXCIgKyBpbmRleCArIFwiKSB0aGF0IGlzIG91dCBvZiBib3VuZHMgKFwiICsgdGhpcy52YWx1ZXNfLmxlbmd0aCArIFwiKS4gUGxlYXNlIGNoZWNrIGxlbmd0aCBmaXJzdC4gT3V0IG9mIGJvdW5kIGluZGljZXMgd2lsbCBub3QgYmUgdHJhY2tlZCBieSBNb2JYXCIgOiBcIlttb2J4XSBPdXQgb2YgYm91bmRzIHJlYWQ6IFwiICsgaW5kZXgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZV8odGhpcy52YWx1ZXNfW2luZGV4XSk7XG4gIH07XG4gIF9wcm90by5zZXRfID0gZnVuY3Rpb24gc2V0XyhpbmRleCwgbmV3VmFsdWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXNfO1xuICAgIGlmICh0aGlzLmxlZ2FjeU1vZGVfICYmIGluZGV4ID4gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgLy8gb3V0IG9mIGJvdW5kc1xuICAgICAgZGllKDE3LCBpbmRleCwgdmFsdWVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIC8vIHVwZGF0ZSBhdCBpbmRleCBpbiByYW5nZVxuICAgICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5hdG9tXyk7XG4gICAgICB2YXIgb2xkVmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgICAvLyBzaW5jZSBcInRoaXNcIiBpcyB0aGUgcmVhbCBhcnJheSB3ZSBuZWVkIHRvIHBhc3MgaXRzIHByb3h5XG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgICB9XG4gICAgICBuZXdWYWx1ZSA9IHRoaXMuZW5oYW5jZXJfKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB2YXIgY2hhbmdlZCA9IG5ld1ZhbHVlICE9PSBvbGRWYWx1ZTtcbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlBcnJheUNoaWxkVXBkYXRlXyhpbmRleCwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIG91dCBvZiBib3VuZCBpbmRleCwgd2UgZG9uJ3QgY3JlYXRlIGFuIGFjdHVhbCBzcGFyc2UgYXJyYXksXG4gICAgICAvLyBidXQgcmF0aGVyIGZpbGwgdGhlIGhvbGVzIHdpdGggdW5kZWZpbmVkIChzYW1lIGFzIHNldEFycmF5TGVuZ3RoXykuXG4gICAgICAvLyBUaGlzIGNvdWxkIGJlIGNvbnNpZGVyZWQgYSBidWcuXG4gICAgICB2YXIgbmV3SXRlbXMgPSBuZXcgQXJyYXkoaW5kZXggKyAxIC0gdmFsdWVzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0l0ZW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBuZXdJdGVtc1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gTm8gQXJyYXkuZmlsbCBldmVyeXdoZXJlLi4uXG4gICAgICBuZXdJdGVtc1tuZXdJdGVtcy5sZW5ndGggLSAxXSA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5zcGxpY2VXaXRoQXJyYXlfKHZhbHVlcy5sZW5ndGgsIDAsIG5ld0l0ZW1zKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSwgb3duZWQpIHtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVBcnJheUBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlQXJyYXlcIjtcbiAgfVxuICBpZiAob3duZWQgPT09IHZvaWQgMCkge1xuICAgIG93bmVkID0gZmFsc2U7XG4gIH1cbiAgYXNzZXJ0UHJveGllcygpO1xuICByZXR1cm4gaW5pdE9ic2VydmFibGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIG93bmVkLCBmYWxzZSk7XG4gICAgYWRkSGlkZGVuRmluYWxQcm9wKGFkbS52YWx1ZXNfLCAkbW9ieCwgYWRtKTtcbiAgICB2YXIgcHJveHkgPSBuZXcgUHJveHkoYWRtLnZhbHVlc18sIGFycmF5VHJhcHMpO1xuICAgIGFkbS5wcm94eV8gPSBwcm94eTtcbiAgICBpZiAoaW5pdGlhbFZhbHVlcyAmJiBpbml0aWFsVmFsdWVzLmxlbmd0aCkge1xuICAgICAgYWRtLnNwbGljZVdpdGhBcnJheV8oMCwgMCwgaW5pdGlhbFZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbiAgfSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbnZhciBhcnJheUV4dGVuc2lvbnMgPSB7XG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoMCk7XG4gIH0sXG4gIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UobmV3SXRlbXMpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKDAsIGFkbS52YWx1ZXNfLmxlbmd0aCwgbmV3SXRlbXMpO1xuICB9LFxuICAvLyBVc2VkIGJ5IEpTT04uc3RyaW5naWZ5XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKCk7XG4gIH0sXG4gIC8qXG4gICAqIGZ1bmN0aW9ucyB0aGF0IGRvIGFsdGVyIHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgb2YgdGhlIGFycmF5LCAoYmFzZWQgb24gbGliLmVzNi5kLnRzKVxuICAgKiBzaW5jZSB0aGVzZSBmdW5jdGlvbnMgYWx0ZXIgdGhlIGlubmVyIHN0cnVjdHVyZSBvZiB0aGUgYXJyYXksIHRoZSBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICogQmVjYXVzZSB0aGUgaGF2ZSBzaWRlIGVmZmVjdHMsIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2VkIGluIGNvbXB1dGVkIGZ1bmN0aW9uLFxuICAgKiBhbmQgZm9yIHRoYXQgcmVhc29uIHRoZSBkbyBub3QgY2FsbCBkZXBlbmRlbmN5U3RhdGUubm90aWZ5T2JzZXJ2ZWRcbiAgICovXG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKGluZGV4LCBkZWxldGVDb3VudCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBuZXdJdGVtcyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBuZXdJdGVtc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oaW5kZXgpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xuICB9LFxuICBzcGxpY2VXaXRoQXJyYXk6IGZ1bmN0aW9uIHNwbGljZVdpdGhBcnJheShpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XG4gICAgcmV0dXJuIHRoaXNbJG1vYnhdLnNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gIH0sXG4gIHB1c2g6IGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGl0ZW1zW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuICAgIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGFkbS52YWx1ZXNfLmxlbmd0aCwgMCwgaXRlbXMpO1xuICAgIHJldHVybiBhZG0udmFsdWVzXy5sZW5ndGg7XG4gIH0sXG4gIHBvcDogZnVuY3Rpb24gcG9wKCkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZShNYXRoLm1heCh0aGlzWyRtb2J4XS52YWx1ZXNfLmxlbmd0aCAtIDEsIDApLCAxKVswXTtcbiAgfSxcbiAgc2hpZnQ6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZSgwLCAxKVswXTtcbiAgfSxcbiAgdW5zaGlmdDogZnVuY3Rpb24gdW5zaGlmdCgpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgaXRlbXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG4gICAgYWRtLnNwbGljZVdpdGhBcnJheV8oMCwgMCwgaXRlbXMpO1xuICAgIHJldHVybiBhZG0udmFsdWVzXy5sZW5ndGg7XG4gIH0sXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgLy8gcmV2ZXJzZSBieSBkZWZhdWx0IG11dGF0ZXMgaW4gcGxhY2UgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0XG4gICAgLy8gd2hpY2ggbWFrZXMgaXQgYm90aCBhICdkZXJpdmF0aW9uJyBhbmQgYSAnbXV0YXRpb24nLlxuICAgIGlmIChnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIGRpZSgzNywgXCJyZXZlcnNlXCIpO1xuICAgIH1cbiAgICB0aGlzLnJlcGxhY2UodGhpcy5zbGljZSgpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgLy8gc29ydCBieSBkZWZhdWx0IG11dGF0ZXMgaW4gcGxhY2UgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0XG4gICAgLy8gd2hpY2ggZ29lcyBhZ2FpbnN0IGFsbCBnb29kIHByYWN0aWNlcy4gTGV0J3Mgbm90IGNoYW5nZSB0aGUgYXJyYXkgaW4gcGxhY2UhXG4gICAgaWYgKGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgZGllKDM3LCBcInNvcnRcIik7XG4gICAgfVxuICAgIHZhciBjb3B5ID0gdGhpcy5zbGljZSgpO1xuICAgIGNvcHkuc29ydC5hcHBseShjb3B5LCBhcmd1bWVudHMpO1xuICAgIHRoaXMucmVwbGFjZShjb3B5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUodmFsdWUpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgdmFyIGlkeCA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXykuaW5kZXhPZih2YWx1ZSk7XG4gICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICB0aGlzLnNwbGljZShpZHgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbi8qKlxuICogV3JhcCBmdW5jdGlvbiBmcm9tIHByb3RvdHlwZVxuICogV2l0aG91dCB0aGlzLCBldmVyeXRoaW5nIHdvcmtzIGFzIHdlbGwsIGJ1dCB0aGlzIHdvcmtzXG4gKiBmYXN0ZXIgYXMgZXZlcnl0aGluZyB3b3JrcyBvbiB1bnByb3hpZWQgdmFsdWVzXG4gKi9cbmFkZEFycmF5RXh0ZW5zaW9uKFwiYXRcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImNvbmNhdFwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmxhdFwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiaW5jbHVkZXNcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImluZGV4T2ZcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImpvaW5cIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImxhc3RJbmRleE9mXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJzbGljZVwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwidG9TdHJpbmdcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInRvTG9jYWxlU3RyaW5nXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJ0b1NvcnRlZFwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwidG9TcGxpY2VkXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJ3aXRoXCIsIHNpbXBsZUZ1bmMpO1xuLy8gbWFwXG5hZGRBcnJheUV4dGVuc2lvbihcImV2ZXJ5XCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmlsdGVyXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmluZFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbmRJbmRleFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbmRMYXN0XCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmluZExhc3RJbmRleFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZsYXRNYXBcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmb3JFYWNoXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwibWFwXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwic29tZVwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInRvUmV2ZXJzZWRcIiwgbWFwTGlrZUZ1bmMpO1xuLy8gcmVkdWNlXG5hZGRBcnJheUV4dGVuc2lvbihcInJlZHVjZVwiLCByZWR1Y2VMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInJlZHVjZVJpZ2h0XCIsIHJlZHVjZUxpa2VGdW5jKTtcbmZ1bmN0aW9uIGFkZEFycmF5RXh0ZW5zaW9uKGZ1bmNOYW1lLCBmdW5jRmFjdG9yeSkge1xuICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVtmdW5jTmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGFycmF5RXh0ZW5zaW9uc1tmdW5jTmFtZV0gPSBmdW5jRmFjdG9yeShmdW5jTmFtZSk7XG4gIH1cbn1cbi8vIFJlcG9ydCBhbmQgZGVsZWdhdGUgdG8gZGVoYW5jZWQgYXJyYXlcbmZ1bmN0aW9uIHNpbXBsZUZ1bmMoZnVuY05hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgYWRtLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgdmFyIGRlaGFuY2VkVmFsdWVzID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKTtcbiAgICByZXR1cm4gZGVoYW5jZWRWYWx1ZXNbZnVuY05hbWVdLmFwcGx5KGRlaGFuY2VkVmFsdWVzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuLy8gTWFrZSBzdXJlIGNhbGxiYWNrcyByZWNlaXZlIGNvcnJlY3QgYXJyYXkgYXJnICMyMzI2XG5mdW5jdGlvbiBtYXBMaWtlRnVuYyhmdW5jTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGFkbS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBkZWhhbmNlZFZhbHVlcyA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXyk7XG4gICAgcmV0dXJuIGRlaGFuY2VkVmFsdWVzW2Z1bmNOYW1lXShmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGVsZW1lbnQsIGluZGV4LCBfdGhpczIpO1xuICAgIH0pO1xuICB9O1xufVxuLy8gTWFrZSBzdXJlIGNhbGxiYWNrcyByZWNlaXZlIGNvcnJlY3QgYXJyYXkgYXJnICMyMzI2XG5mdW5jdGlvbiByZWR1Y2VMaWtlRnVuYyhmdW5jTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBhZG0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgZGVoYW5jZWRWYWx1ZXMgPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pO1xuICAgIC8vICMyNDMyIC0gcmVkdWNlIGJlaGF2aW9yIGRlcGVuZHMgb24gYXJndW1lbnRzLmxlbmd0aFxuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgICBhcmd1bWVudHNbMF0gPSBmdW5jdGlvbiAoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlLCBpbmRleCwgX3RoaXMzKTtcbiAgICB9O1xuICAgIHJldHVybiBkZWhhbmNlZFZhbHVlc1tmdW5jTmFtZV0uYXBwbHkoZGVoYW5jZWRWYWx1ZXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG52YXIgaXNPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb25cIiwgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24pO1xuZnVuY3Rpb24gaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHRoaW5nKSAmJiBpc09ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKHRoaW5nWyRtb2J4XSk7XG59XG5cbnZhciBPYnNlcnZhYmxlTWFwTWFya2VyID0ge307XG52YXIgQUREID0gXCJhZGRcIjtcbnZhciBERUxFVEUgPSBcImRlbGV0ZVwiO1xuLy8ganVzdCBleHRlbmQgTWFwPyBTZWUgYWxzbyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9uZXN0aGFydXMvMTNiNGQ3NGYyZWY0YTJmNDM1N2RiZDNmYzIzYzFlNTRcbi8vIEJ1dDogaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2lzc3Vlcy8xNTU2XG52YXIgT2JzZXJ2YWJsZU1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVNYXAoaW5pdGlhbERhdGEsIGVuaGFuY2VyXywgbmFtZV8pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChlbmhhbmNlcl8gPT09IHZvaWQgMCkge1xuICAgICAgZW5oYW5jZXJfID0gZGVlcEVuaGFuY2VyO1xuICAgIH1cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVNYXBAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZU1hcFwiO1xuICAgIH1cbiAgICB0aGlzLmVuaGFuY2VyXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXNbJG1vYnhdID0gT2JzZXJ2YWJsZU1hcE1hcmtlcjtcbiAgICB0aGlzLmRhdGFfID0gdm9pZCAwO1xuICAgIHRoaXMuaGFzTWFwXyA9IHZvaWQgMDtcbiAgICAvLyBoYXNNYXAsIG5vdCBoYXNoTWFwID4tKS5cbiAgICB0aGlzLmtleXNBdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSBlbmhhbmNlcl87XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIGlmICghaXNGdW5jdGlvbihNYXApKSB7XG4gICAgICBkaWUoMTgpO1xuICAgIH1cbiAgICBpbml0T2JzZXJ2YWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5rZXlzQXRvbV8gPSBjcmVhdGVBdG9tKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IF90aGlzLm5hbWVfICsgXCIua2V5cygpXCIgOiBcIk9ic2VydmFibGVNYXAua2V5cygpXCIpO1xuICAgICAgX3RoaXMuZGF0YV8gPSBuZXcgTWFwKCk7XG4gICAgICBfdGhpcy5oYXNNYXBfID0gbmV3IE1hcCgpO1xuICAgICAgaWYgKGluaXRpYWxEYXRhKSB7XG4gICAgICAgIF90aGlzLm1lcmdlKGluaXRpYWxEYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGU7XG4gIF9wcm90by5oYXNfID0gZnVuY3Rpb24gaGFzXyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhXy5oYXMoa2V5KTtcbiAgfTtcbiAgX3Byb3RvLmhhcyA9IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICBpZiAoIWdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzXyhrZXkpO1xuICAgIH1cbiAgICB2YXIgZW50cnkgPSB0aGlzLmhhc01hcF8uZ2V0KGtleSk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgdmFyIG5ld0VudHJ5ID0gZW50cnkgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKHRoaXMuaGFzXyhrZXkpLCByZWZlcmVuY2VFbmhhbmNlciwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgKyBcIj9cIiA6IFwiT2JzZXJ2YWJsZU1hcC5rZXk/XCIsIGZhbHNlKTtcbiAgICAgIHRoaXMuaGFzTWFwXy5zZXQoa2V5LCBuZXdFbnRyeSk7XG4gICAgICBvbkJlY29tZVVub2JzZXJ2ZWQobmV3RW50cnksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5oYXNNYXBfW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LmdldCgpO1xuICB9O1xuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgaGFzS2V5ID0gdGhpcy5oYXNfKGtleSk7XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IGhhc0tleSA/IFVQREFURSA6IEFERCxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogdmFsdWUsXG4gICAgICAgIG5hbWU6IGtleVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAoaGFzS2V5KSB7XG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlXyhrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG9bXCJkZWxldGVcIl0gPSBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMua2V5c0F0b21fKTtcbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5hbWU6IGtleVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc18oa2V5KSkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBfY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiB0aGlzLmRhdGFfLmdldChrZXkpLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5XG4gICAgICB9IDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UpO1xuICAgICAgfSAvLyBUT0RPIGZpeCB0eXBlXG4gICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpczMkaGFzTWFwXyRnZXQ7XG4gICAgICAgIF90aGlzMy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICAoX3RoaXMzJGhhc01hcF8kZ2V0ID0gX3RoaXMzLmhhc01hcF8uZ2V0KGtleSkpID09IG51bGwgfHwgX3RoaXMzJGhhc01hcF8kZ2V0LnNldE5ld1ZhbHVlXyhmYWxzZSk7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gX3RoaXMzLmRhdGFfLmdldChrZXkpO1xuICAgICAgICBvYnNlcnZhYmxlLnNldE5ld1ZhbHVlXyh1bmRlZmluZWQpO1xuICAgICAgICBfdGhpczMuZGF0YV9bXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIF9wcm90by51cGRhdGVWYWx1ZV8gPSBmdW5jdGlvbiB1cGRhdGVWYWx1ZV8oa2V5LCBuZXdWYWx1ZSkge1xuICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy5kYXRhXy5nZXQoa2V5KTtcbiAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUucHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiBvYnNlcnZhYmxlLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0gOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgIH0gLy8gVE9ETyBmaXggdHlwZVxuICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmFkZFZhbHVlXyA9IGZ1bmN0aW9uIGFkZFZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5rZXlzQXRvbV8pO1xuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpczQkaGFzTWFwXyRnZXQ7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUobmV3VmFsdWUsIF90aGlzNC5lbmhhbmNlcl8sIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IF90aGlzNC5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgOiBcIk9ic2VydmFibGVNYXAua2V5XCIsIGZhbHNlKTtcbiAgICAgIF90aGlzNC5kYXRhXy5zZXQoa2V5LCBvYnNlcnZhYmxlKTtcbiAgICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS52YWx1ZV87IC8vIHZhbHVlIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkXG4gICAgICAoX3RoaXM0JGhhc01hcF8kZ2V0ID0gX3RoaXM0Lmhhc01hcF8uZ2V0KGtleSkpID09IG51bGwgfHwgX3RoaXM0JGhhc01hcF8kZ2V0LnNldE5ld1ZhbHVlXyh0cnVlKTtcbiAgICAgIF90aGlzNC5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgIH0pO1xuICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICB0eXBlOiBBREQsXG4gICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICBuYW1lOiBrZXksXG4gICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICB9IDogbnVsbDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICB9IC8vIFRPRE8gZml4IHR5cGVcbiAgICBpZiAobm90aWZ5KSB7XG4gICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlXyh0aGlzLmRhdGFfLmdldChrZXkpLmdldCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlXyh1bmRlZmluZWQpO1xuICB9O1xuICBfcHJvdG8uZGVoYW5jZVZhbHVlXyA9IGZ1bmN0aW9uIGRlaGFuY2VWYWx1ZV8odmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWhhbmNlcih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgX3Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YV8ua2V5cygpO1xuICB9O1xuICBfcHJvdG8udmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIga2V5cyA9IHRoaXMua2V5cygpO1xuICAgIHJldHVybiBtYWtlSXRlcmFibGVGb3JNYXAoe1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIF9rZXlzJG5leHQgPSBrZXlzLm5leHQoKSxcbiAgICAgICAgICBkb25lID0gX2tleXMkbmV4dC5kb25lLFxuICAgICAgICAgIHZhbHVlID0gX2tleXMkbmV4dC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBkb25lLFxuICAgICAgICAgIHZhbHVlOiBkb25lID8gdW5kZWZpbmVkIDogc2VsZi5nZXQodmFsdWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlRm9yTWFwKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBfa2V5cyRuZXh0MiA9IGtleXMubmV4dCgpLFxuICAgICAgICAgIGRvbmUgPSBfa2V5cyRuZXh0Mi5kb25lLFxuICAgICAgICAgIHZhbHVlID0gX2tleXMkbmV4dDIudmFsdWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgICB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IFt2YWx1ZSwgc2VsZi5nZXQodmFsdWUpXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBfcHJvdG9bU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH07XG4gIF9wcm90by5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc3RlcC52YWx1ZSxcbiAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgIHZhbHVlID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogTWVyZ2UgYW5vdGhlciBvYmplY3QgaW50byB0aGlzIG9iamVjdCwgcmV0dXJucyB0aGlzLiAqLztcbiAgX3Byb3RvLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgTWFwKG90aGVyKTtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob3RoZXIpKSB7XG4gICAgICAgIGdldFBsYWluT2JqZWN0S2V5cyhvdGhlcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS5zZXQoa2V5LCBvdGhlcltrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3RoZXIpKSB7XG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3JlZlswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX3JlZlsxXTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRVM2TWFwKG90aGVyKSkge1xuICAgICAgICBpZiAoIWlzUGxhaW5FUzZNYXAob3RoZXIpKSB7XG4gICAgICAgICAgZGllKDE5LCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXIgIT09IG51bGwgJiYgb3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaWUoMjAsIG90aGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgdW50cmFja2VkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoX3RoaXM2LmtleXMoKSksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBfdGhpczZbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSh2YWx1ZXMpIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiByZXF1aXJlbWVudHM6XG4gICAgLy8gLSByZXNwZWN0IG9yZGVyaW5nIG9mIHJlcGxhY2VtZW50IG1hcFxuICAgIC8vIC0gYWxsb3cgaW50ZXJjZXB0b3JzIHRvIHJ1biBhbmQgcG90ZW50aWFsbHkgcHJldmVudCBpbmRpdmlkdWFsIG9wZXJhdGlvbnNcbiAgICAvLyAtIGRvbid0IHJlY3JlYXRlIG9ic2VydmFibGVzIHRoYXQgYWxyZWFkeSBleGlzdCBpbiBvcmlnaW5hbCBtYXAgKHNvIHdlIGRvbid0IGRlc3Ryb3kgZXhpc3Rpbmcgc3Vic2NyaXB0aW9ucylcbiAgICAvLyAtIGRvbid0IF9rZXlzQXRvbS5yZXBvcnRDaGFuZ2VkIGlmIHRoZSBrZXlzIG9mIHJlc3VsdGluZyBtYXAgYXJlIGluZGVudGljYWwgKG9yZGVyIG1hdHRlcnMhKVxuICAgIC8vIC0gbm90ZSB0aGF0IHJlc3VsdCBtYXAgbWF5IGRpZmZlciBmcm9tIHJlcGxhY2VtZW50IG1hcCBkdWUgdG8gdGhlIGludGVyY2VwdG9yc1xuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gbWFwIHNvIHdlIGNhbiBkbyBxdWljayBrZXkgbG9va3Vwc1xuICAgICAgdmFyIHJlcGxhY2VtZW50TWFwID0gY29udmVydFRvTWFwKHZhbHVlcyk7XG4gICAgICB2YXIgb3JkZXJlZERhdGEgPSBuZXcgTWFwKCk7XG4gICAgICAvLyBVc2VkIGZvciBvcHRpbWl6YXRpb25cbiAgICAgIHZhciBrZXlzUmVwb3J0Q2hhbmdlZENhbGxlZCA9IGZhbHNlO1xuICAgICAgLy8gRGVsZXRlIGtleXMgdGhhdCBkb24ndCBleGlzdCBpbiByZXBsYWNlbWVudCBtYXBcbiAgICAgIC8vIGlmIHRoZSBrZXkgZGVsZXRpb24gaXMgcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAvLyBhZGQgZW50cnkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVzdWx0IG1hcFxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoX3RoaXM3LmRhdGFfLmtleXMoKSksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBrZXkgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgIC8vIENvbmN1cnJlbnRseSBpdGVyYXRpbmcvZGVsZXRpbmcga2V5c1xuICAgICAgICAvLyBpdGVyYXRvciBzaG91bGQgaGFuZGxlIHRoaXMgY29ycmVjdGx5XG4gICAgICAgIGlmICghcmVwbGFjZW1lbnRNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICB2YXIgZGVsZXRlZCA9IF90aGlzN1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgICAgIC8vIFdhcyB0aGUga2V5IHJlbW92ZWQ/XG4gICAgICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgICAgIC8vIF9rZXlzQXRvbS5yZXBvcnRDaGFuZ2VkKCkgd2FzIGFscmVhZHkgY2FsbGVkXG4gICAgICAgICAgICBrZXlzUmVwb3J0Q2hhbmdlZENhbGxlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBwcmV2ZW50ZWQgYnkgaW50ZXJjZXB0b3JcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzNy5kYXRhXy5nZXQoa2V5KTtcbiAgICAgICAgICAgIG9yZGVyZWREYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIGVudHJpZXNcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJlcGxhY2VtZW50TWFwLmVudHJpZXMoKSksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBfc3RlcDQudmFsdWUsXG4gICAgICAgICAgX2tleSA9IF9zdGVwNCR2YWx1ZVswXSxcbiAgICAgICAgICBfdmFsdWUgPSBfc3RlcDQkdmFsdWVbMV07XG4gICAgICAgIC8vIFdlIHdpbGwgd2FudCB0byBrbm93IHdoZXRoZXIgYSBuZXcga2V5IGlzIGFkZGVkXG4gICAgICAgIHZhciBrZXlFeGlzdGVkID0gX3RoaXM3LmRhdGFfLmhhcyhfa2V5KTtcbiAgICAgICAgLy8gQWRkIG9yIHVwZGF0ZSB2YWx1ZVxuICAgICAgICBfdGhpczcuc2V0KF9rZXksIF92YWx1ZSk7XG4gICAgICAgIC8vIFRoZSBhZGRpdGlvbiBjb3VsZCBoYXZlIGJlZW4gcHJldmVudCBieSBpbnRlcmNlcHRvclxuICAgICAgICBpZiAoX3RoaXM3LmRhdGFfLmhhcyhfa2V5KSkge1xuICAgICAgICAgIC8vIFRoZSB1cGRhdGUgY291bGQgaGF2ZSBiZWVuIHByZXZlbnRlZCBieSBpbnRlcmNlcHRvclxuICAgICAgICAgIC8vIGFuZCBhbHNvIHdlIHdhbnQgdG8gcHJlc2VydmUgZXhpc3RpbmcgdmFsdWVzXG4gICAgICAgICAgLy8gc28gdXNlIHZhbHVlIGZyb20gX2RhdGEgbWFwIChpbnN0ZWFkIG9mIHJlcGxhY2VtZW50IG1hcClcbiAgICAgICAgICB2YXIgX3ZhbHVlMiA9IF90aGlzNy5kYXRhXy5nZXQoX2tleSk7XG4gICAgICAgICAgb3JkZXJlZERhdGEuc2V0KF9rZXksIF92YWx1ZTIpO1xuICAgICAgICAgIC8vIFdhcyBhIG5ldyBrZXkgYWRkZWQ/XG4gICAgICAgICAgaWYgKCFrZXlFeGlzdGVkKSB7XG4gICAgICAgICAgICAvLyBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCgpIHdhcyBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAgICAga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIHBvc3NpYmxlIGtleSBvcmRlciBjaGFuZ2VcbiAgICAgIGlmICgha2V5c1JlcG9ydENoYW5nZWRDYWxsZWQpIHtcbiAgICAgICAgaWYgKF90aGlzNy5kYXRhXy5zaXplICE9PSBvcmRlcmVkRGF0YS5zaXplKSB7XG4gICAgICAgICAgLy8gSWYgc2l6ZSBkaWZmZXJzLCBrZXlzIGFyZSBkZWZpbml0ZWx5IG1vZGlmaWVkXG4gICAgICAgICAgX3RoaXM3LmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGl0ZXIxID0gX3RoaXM3LmRhdGFfLmtleXMoKTtcbiAgICAgICAgICB2YXIgaXRlcjIgPSBvcmRlcmVkRGF0YS5rZXlzKCk7XG4gICAgICAgICAgdmFyIG5leHQxID0gaXRlcjEubmV4dCgpO1xuICAgICAgICAgIHZhciBuZXh0MiA9IGl0ZXIyLm5leHQoKTtcbiAgICAgICAgICB3aGlsZSAoIW5leHQxLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChuZXh0MS52YWx1ZSAhPT0gbmV4dDIudmFsdWUpIHtcbiAgICAgICAgICAgICAgX3RoaXM3LmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dDEgPSBpdGVyMS5uZXh0KCk7XG4gICAgICAgICAgICBuZXh0MiA9IGl0ZXIyLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFVzZSBjb3JyZWN0bHkgb3JkZXJlZCBtYXBcbiAgICAgIF90aGlzNy5kYXRhXyA9IG9yZGVyZWREYXRhO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IE9ic2VydmFibGVNYXBdXCI7XG4gIH07XG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiBPYnNlcnZlcyB0aGlzIG9iamVjdC4gVHJpZ2dlcnMgZm9yIHRoZSBldmVudHMgJ2FkZCcsICd1cGRhdGUnIGFuZCAnZGVsZXRlJy5cbiAgICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qvb2JzZXJ2ZVxuICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xuICAgKi9cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSB7XG4gICAgICBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggbWFwcy5cIik7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhPYnNlcnZhYmxlTWFwLCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8uc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIk1hcFwiO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgaXNPYnNlcnZhYmxlTWFwID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlTWFwXCIsIE9ic2VydmFibGVNYXApO1xuZnVuY3Rpb24gbWFrZUl0ZXJhYmxlRm9yTWFwKGl0ZXJhdG9yKSB7XG4gIGl0ZXJhdG9yW1N5bWJvbC50b1N0cmluZ1RhZ10gPSBcIk1hcEl0ZXJhdG9yXCI7XG4gIHJldHVybiBtYWtlSXRlcmFibGUoaXRlcmF0b3IpO1xufVxuZnVuY3Rpb24gY29udmVydFRvTWFwKGRhdGFTdHJ1Y3R1cmUpIHtcbiAgaWYgKGlzRVM2TWFwKGRhdGFTdHJ1Y3R1cmUpIHx8IGlzT2JzZXJ2YWJsZU1hcChkYXRhU3RydWN0dXJlKSkge1xuICAgIHJldHVybiBkYXRhU3RydWN0dXJlO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVN0cnVjdHVyZSkpIHtcbiAgICByZXR1cm4gbmV3IE1hcChkYXRhU3RydWN0dXJlKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGRhdGFTdHJ1Y3R1cmUpKSB7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YVN0cnVjdHVyZSkge1xuICAgICAgbWFwLnNldChrZXksIGRhdGFTdHJ1Y3R1cmVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpZSgyMSwgZGF0YVN0cnVjdHVyZSk7XG4gIH1cbn1cblxudmFyIE9ic2VydmFibGVTZXRNYXJrZXIgPSB7fTtcbnZhciBPYnNlcnZhYmxlU2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZVNldChpbml0aWFsRGF0YSwgZW5oYW5jZXIsIG5hbWVfKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoZW5oYW5jZXIgPT09IHZvaWQgMCkge1xuICAgICAgZW5oYW5jZXIgPSBkZWVwRW5oYW5jZXI7XG4gICAgfVxuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiT2JzZXJ2YWJsZVNldEBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlU2V0XCI7XG4gICAgfVxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpc1skbW9ieF0gPSBPYnNlcnZhYmxlU2V0TWFya2VyO1xuICAgIHRoaXMuZGF0YV8gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5hdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIGlmICghaXNGdW5jdGlvbihTZXQpKSB7XG4gICAgICBkaWUoMjIpO1xuICAgIH1cbiAgICB0aGlzLmVuaGFuY2VyXyA9IGZ1bmN0aW9uIChuZXdWLCBvbGRWKSB7XG4gICAgICByZXR1cm4gZW5oYW5jZXIobmV3Viwgb2xkViwgbmFtZV8pO1xuICAgIH07XG4gICAgaW5pdE9ic2VydmFibGUoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYXRvbV8gPSBjcmVhdGVBdG9tKF90aGlzLm5hbWVfKTtcbiAgICAgIGlmIChpbml0aWFsRGF0YSkge1xuICAgICAgICBfdGhpcy5yZXBsYWNlKGluaXRpYWxEYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZVNldC5wcm90b3R5cGU7XG4gIF9wcm90by5kZWhhbmNlVmFsdWVfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICB1bnRyYWNrZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKF90aGlzMi5kYXRhXy52YWx1ZXMoKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgX3RoaXMyW1wiZGVsZXRlXCJdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja0ZuLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdmFsdWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICBjYWxsYmFja0ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b21fKTtcbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIGlkZWFsbHksIHZhbHVlID0gY2hhbmdlLnZhbHVlIHdvdWxkIGJlIGRvbmUgaGVyZSwgc28gdGhhdCB2YWx1ZXMgY2FuIGJlXG4gICAgICAvLyBjaGFuZ2VkIGJ5IGludGVyY2VwdG9yLiBTYW1lIGFwcGxpZXMgZm9yIG90aGVyIFNldCBhbmQgTWFwIGFwaSdzLlxuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuZGF0YV8uYWRkKF90aGlzMy5lbmhhbmNlcl8odmFsdWUsIHVuZGVmaW5lZCkpO1xuICAgICAgICBfdGhpczMuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBfY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwic2V0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG4gICAgICBpZiAobm90aWZ5U3B5ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBzcHlSZXBvcnRTdGFydChfY2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKG5vdGlmeVNweSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG9bXCJkZWxldGVcIl0gPSBmdW5jdGlvbiBfZGVsZXRlKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5oYXModmFsdWUpKSB7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBfY2hhbmdlMiA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInNldFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgIH0gOiBudWxsO1xuICAgICAgaWYgKG5vdGlmeVNweSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZTIpO1xuICAgICAgfVxuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczQuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICBfdGhpczQuZGF0YV9bXCJkZWxldGVcIl0odmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBpZiAobm90aWZ5KSB7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlMik7XG4gICAgICB9XG4gICAgICBpZiAobm90aWZ5U3B5ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXModmFsdWUpIHtcbiAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YV8uaGFzKHRoaXMuZGVoYW5jZVZhbHVlXyh2YWx1ZSkpO1xuICB9O1xuICBfcHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgdmFyIGtleXMgPSBBcnJheS5mcm9tKHRoaXMua2V5cygpKTtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlRm9yU2V0KHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgbmV4dEluZGV4ICs9IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA8IHZhbHVlcy5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IFtrZXlzW2luZGV4XSwgdmFsdWVzW2luZGV4XV0sXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuICBfcHJvdG8udmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgdmFyIG9ic2VydmFibGVWYWx1ZXMgPSBBcnJheS5mcm9tKHRoaXMuZGF0YV8udmFsdWVzKCkpO1xuICAgIHJldHVybiBtYWtlSXRlcmFibGVGb3JTZXQoe1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIG5leHRJbmRleCA8IG9ic2VydmFibGVWYWx1ZXMubGVuZ3RoID8ge1xuICAgICAgICAgIHZhbHVlOiBzZWxmLmRlaGFuY2VWYWx1ZV8ob2JzZXJ2YWJsZVZhbHVlc1tuZXh0SW5kZXgrK10pLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ob3RoZXJTZXQpIHtcbiAgICBpZiAoaXNFUzZTZXQob3RoZXJTZXQpICYmICFpc09ic2VydmFibGVTZXQob3RoZXJTZXQpKSB7XG4gICAgICByZXR1cm4gb3RoZXJTZXQuaW50ZXJzZWN0aW9uKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGVoYW5jZWRTZXQgPSBuZXcgU2V0KHRoaXMpO1xuICAgICAgcmV0dXJuIGRlaGFuY2VkU2V0LmludGVyc2VjdGlvbihvdGhlclNldCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8udW5pb24gPSBmdW5jdGlvbiB1bmlvbihvdGhlclNldCkge1xuICAgIGlmIChpc0VTNlNldChvdGhlclNldCkgJiYgIWlzT2JzZXJ2YWJsZVNldChvdGhlclNldCkpIHtcbiAgICAgIHJldHVybiBvdGhlclNldC51bmlvbih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRlaGFuY2VkU2V0ID0gbmV3IFNldCh0aGlzKTtcbiAgICAgIHJldHVybiBkZWhhbmNlZFNldC51bmlvbihvdGhlclNldCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIGRpZmZlcmVuY2Uob3RoZXJTZXQpIHtcbiAgICByZXR1cm4gbmV3IFNldCh0aGlzKS5kaWZmZXJlbmNlKG90aGVyU2V0KTtcbiAgfTtcbiAgX3Byb3RvLnN5bW1ldHJpY0RpZmZlcmVuY2UgPSBmdW5jdGlvbiBzeW1tZXRyaWNEaWZmZXJlbmNlKG90aGVyU2V0KSB7XG4gICAgaWYgKGlzRVM2U2V0KG90aGVyU2V0KSAmJiAhaXNPYnNlcnZhYmxlU2V0KG90aGVyU2V0KSkge1xuICAgICAgcmV0dXJuIG90aGVyU2V0LnN5bW1ldHJpY0RpZmZlcmVuY2UodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkZWhhbmNlZFNldCA9IG5ldyBTZXQodGhpcyk7XG4gICAgICByZXR1cm4gZGVoYW5jZWRTZXQuc3ltbWV0cmljRGlmZmVyZW5jZShvdGhlclNldCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uaXNTdWJzZXRPZiA9IGZ1bmN0aW9uIGlzU3Vic2V0T2Yob3RoZXJTZXQpIHtcbiAgICByZXR1cm4gbmV3IFNldCh0aGlzKS5pc1N1YnNldE9mKG90aGVyU2V0KTtcbiAgfTtcbiAgX3Byb3RvLmlzU3VwZXJzZXRPZiA9IGZ1bmN0aW9uIGlzU3VwZXJzZXRPZihvdGhlclNldCkge1xuICAgIHJldHVybiBuZXcgU2V0KHRoaXMpLmlzU3VwZXJzZXRPZihvdGhlclNldCk7XG4gIH07XG4gIF9wcm90by5pc0Rpc2pvaW50RnJvbSA9IGZ1bmN0aW9uIGlzRGlzam9pbnRGcm9tKG90aGVyU2V0KSB7XG4gICAgaWYgKGlzRVM2U2V0KG90aGVyU2V0KSAmJiAhaXNPYnNlcnZhYmxlU2V0KG90aGVyU2V0KSkge1xuICAgICAgcmV0dXJuIG90aGVyU2V0LmlzRGlzam9pbnRGcm9tKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGVoYW5jZWRTZXQgPSBuZXcgU2V0KHRoaXMpO1xuICAgICAgcmV0dXJuIGRlaGFuY2VkU2V0LmlzRGlzam9pbnRGcm9tKG90aGVyU2V0KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShvdGhlcikge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgIGlmIChpc09ic2VydmFibGVTZXQob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZXQob3RoZXIpO1xuICAgIH1cbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvdGhlcikpIHtcbiAgICAgICAgX3RoaXM1LmNsZWFyKCk7XG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFUzZTZXQob3RoZXIpKSB7XG4gICAgICAgIF90aGlzNS5jbGVhcigpO1xuICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuYWRkKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGllKFwiQ2Fubm90IGluaXRpYWxpemUgc2V0IGZyb20gXCIgKyBvdGhlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAvLyAuLi4gJ2ZpcmVJbW1lZGlhdGVseScgY291bGQgYWxzbyBiZSB0cnVlP1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSB7XG4gICAgICBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggc2V0cy5cIik7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBPYnNlcnZhYmxlU2V0XVwiO1xuICB9O1xuICBfcHJvdG9bU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgfTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhPYnNlcnZhYmxlU2V0LCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwiU2V0XCI7XG4gICAgfVxuICB9XSk7XG59KCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbnZhciBpc09ic2VydmFibGVTZXQgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVTZXRcIiwgT2JzZXJ2YWJsZVNldCk7XG5mdW5jdGlvbiBtYWtlSXRlcmFibGVGb3JTZXQoaXRlcmF0b3IpIHtcbiAgaXRlcmF0b3JbU3ltYm9sLnRvU3RyaW5nVGFnXSA9IFwiU2V0SXRlcmF0b3JcIjtcbiAgcmV0dXJuIG1ha2VJdGVyYWJsZShpdGVyYXRvcik7XG59XG5cbnZhciBkZXNjcmlwdG9yQ2FjaGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBSRU1PVkUgPSBcInJlbW92ZVwiO1xudmFyIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbih0YXJnZXRfLCB2YWx1ZXNfLCBuYW1lXyxcbiAgLy8gVXNlZCBhbnl0aW1lIGFubm90YXRpb24gaXMgbm90IGV4cGxpY2l0ZWx5IHByb3ZpZGVkXG4gIGRlZmF1bHRBbm5vdGF0aW9uXykge1xuICAgIGlmICh2YWx1ZXNfID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlc18gPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0QW5ub3RhdGlvbl8gPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdEFubm90YXRpb25fID0gYXV0b0Fubm90YXRpb247XG4gICAgfVxuICAgIHRoaXMudGFyZ2V0XyA9IHZvaWQgMDtcbiAgICB0aGlzLnZhbHVlc18gPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleXNBdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIHRoaXMucHJveHlfID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQbGFpbk9iamVjdF8gPSB2b2lkIDA7XG4gICAgdGhpcy5hcHBsaWVkQW5ub3RhdGlvbnNfID0gdm9pZCAwO1xuICAgIHRoaXMucGVuZGluZ0tleXNfID0gdm9pZCAwO1xuICAgIHRoaXMudGFyZ2V0XyA9IHRhcmdldF87XG4gICAgdGhpcy52YWx1ZXNfID0gdmFsdWVzXztcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG4gICAgdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8gPSBkZWZhdWx0QW5ub3RhdGlvbl87XG4gICAgdGhpcy5rZXlzQXRvbV8gPSBuZXcgQXRvbShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB0aGlzLm5hbWVfICsgXCIua2V5c1wiIDogXCJPYnNlcnZhYmxlT2JqZWN0LmtleXNcIik7XG4gICAgLy8gT3B0aW1pemF0aW9uOiB3ZSB1c2UgdGhpcyBmcmVxdWVudGx5XG4gICAgdGhpcy5pc1BsYWluT2JqZWN0XyA9IGlzUGxhaW5PYmplY3QodGhpcy50YXJnZXRfKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0Fubm90YXRpb24odGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8pKSB7XG4gICAgICBkaWUoXCJkZWZhdWx0QW5ub3RhdGlvbiBtdXN0IGJlIHZhbGlkIGFubm90YXRpb25cIik7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIC8vIFByZXBhcmUgc3RydWN0dXJlIGZvciB0cmFja2luZyB3aGljaCBmaWVsZHMgd2VyZSBhbHJlYWR5IGFubm90YXRlZFxuICAgICAgdGhpcy5hcHBsaWVkQW5ub3RhdGlvbnNfID0ge307XG4gICAgfVxuICB9XG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlO1xuICBfcHJvdG8uZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8gPSBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNfLmdldChrZXkpLmdldCgpO1xuICB9O1xuICBfcHJvdG8uc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8gPSBmdW5jdGlvbiBzZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLnZhbHVlc18uZ2V0KGtleSk7XG4gICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlKSB7XG4gICAgICBvYnNlcnZhYmxlLnNldChuZXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaW50ZXJjZXB0XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfVxuICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS5wcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKTtcbiAgICAvLyBub3RpZnkgc3B5ICYgb2JzZXJ2ZXJzXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIF9jaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBvbGRWYWx1ZTogb2JzZXJ2YWJsZS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UpO1xuICAgICAgfVxuICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90by5nZXRfID0gZnVuY3Rpb24gZ2V0XyhrZXkpIHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uICYmICFoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgLy8gS2V5IGRvZXNuJ3QgZXhpc3QgeWV0LCBzdWJzY3JpYmUgZm9yIGl0IGluIGNhc2UgaXQncyBhZGRlZCBsYXRlclxuICAgICAgdGhpcy5oYXNfKGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhcmdldF9ba2V5XTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Fubm90YXRpb258Ym9vbGVhbn0gYW5ub3RhdGlvbiB0cnVlIC0gdXNlIGRlZmF1bHQgYW5ub3RhdGlvbiwgZmFsc2UgLSBjb3B5IGFzIGlzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcbiAgICovO1xuICBfcHJvdG8uc2V0XyA9IGZ1bmN0aW9uIHNldF8oa2V5LCB2YWx1ZSwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgdXNlIC5oYXMoa2V5KSAtIHdlIGNhcmUgYWJvdXQgb3duXG4gICAgaWYgKGhhc1Byb3AodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICAvLyBFeGlzdGluZyBwcm9wXG4gICAgICBpZiAodGhpcy52YWx1ZXNfLmhhcyhrZXkpKSB7XG4gICAgICAgIC8vIE9ic2VydmFibGUgKGNhbiBiZSBpbnRlcmNlcHRlZClcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICAvLyBOb24tb2JzZXJ2YWJsZSAtIHByb3h5XG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0aGlzLnRhcmdldF8sIGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9uLW9ic2VydmFibGVcbiAgICAgICAgdGhpcy50YXJnZXRfW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5ldyBwcm9wXG4gICAgICByZXR1cm4gdGhpcy5leHRlbmRfKGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0sIHRoaXMuZGVmYXVsdEFubm90YXRpb25fLCBwcm94eVRyYXApO1xuICAgIH1cbiAgfVxuICAvLyBUcmFwIGZvciBcImluXCJcbiAgO1xuICBfcHJvdG8uaGFzXyA9IGZ1bmN0aW9uIGhhc18oa2V5KSB7XG4gICAgaWYgKCFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIC8vIFNraXAga2V5IHN1YnNjcmlwdGlvbiBvdXRzaWRlIGRlcml2YXRpb25cbiAgICAgIHJldHVybiBrZXkgaW4gdGhpcy50YXJnZXRfO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdLZXlzXyB8fCAodGhpcy5wZW5kaW5nS2V5c18gPSBuZXcgTWFwKCkpO1xuICAgIHZhciBlbnRyeSA9IHRoaXMucGVuZGluZ0tleXNfLmdldChrZXkpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGVudHJ5ID0gbmV3IE9ic2VydmFibGVWYWx1ZShrZXkgaW4gdGhpcy50YXJnZXRfLCByZWZlcmVuY2VFbmhhbmNlciwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgKyBcIj9cIiA6IFwiT2JzZXJ2YWJsZU9iamVjdC5rZXk/XCIsIGZhbHNlKTtcbiAgICAgIHRoaXMucGVuZGluZ0tleXNfLnNldChrZXksIGVudHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LmdldCgpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcbiAgICogQHBhcmFtIHtBbm5vdGF0aW9ufGJvb2xlYW59IGFubm90YXRpb24gdHJ1ZSAtIHVzZSBkZWZhdWx0IGFubm90YXRpb24sIGZhbHNlIC0gaWdub3JlIHByb3BcbiAgICovO1xuICBfcHJvdG8ubWFrZV8gPSBmdW5jdGlvbiBtYWtlXyhrZXksIGFubm90YXRpb24pIHtcbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgYW5ub3RhdGlvbiA9IHRoaXMuZGVmYXVsdEFubm90YXRpb25fO1xuICAgIH1cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXNzZXJ0QW5ub3RhYmxlKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG4gICAgaWYgKCEoa2V5IGluIHRoaXMudGFyZ2V0XykpIHtcbiAgICAgIHZhciBfdGhpcyR0YXJnZXRfJHN0b3JlZEE7XG4gICAgICAvLyBUaHJvdyBvbiBtaXNzaW5nIGtleSwgZXhjZXB0IGZvciBkZWNvcmF0b3JzOlxuICAgICAgLy8gRGVjb3JhdG9yIGFubm90YXRpb25zIGFyZSBjb2xsZWN0ZWQgZnJvbSB3aG9sZSBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAvLyBXaGVuIGNhbGxlZCBmcm9tIHN1cGVyKCkgc29tZSBwcm9wcyBtYXkgbm90IGV4aXN0IHlldC5cbiAgICAgIC8vIEhvd2V2ZXIgd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBtaXNzaW5nIHByb3AsXG4gICAgICAvLyBiZWNhdXNlIHRoZSBkZWNvcmF0b3IgbXVzdCBoYXZlIGJlZW4gYXBwbGllZCB0byBzb21ldGhpbmcuXG4gICAgICBpZiAoKF90aGlzJHRhcmdldF8kc3RvcmVkQSA9IHRoaXMudGFyZ2V0X1tzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pICE9IG51bGwgJiYgX3RoaXMkdGFyZ2V0XyRzdG9yZWRBW2tleV0pIHtcbiAgICAgICAgcmV0dXJuOyAvLyB3aWxsIGJlIGFubm90YXRlZCBieSBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGllKDEsIGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfLCB0aGlzLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSB0aGlzLnRhcmdldF87XG4gICAgd2hpbGUgKHNvdXJjZSAmJiBzb3VyY2UgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcbiAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciBvdXRjb21lID0gYW5ub3RhdGlvbi5tYWtlXyh0aGlzLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gICAgICAgIGlmIChvdXRjb21lID09PSAwIC8qIE1ha2VSZXN1bHQuQ2FuY2VsICovKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRjb21lID09PSAxIC8qIE1ha2VSZXN1bHQuQnJlYWsgKi8pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc291cmNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG4gICAgfVxuICAgIHJlY29yZEFubm90YXRpb25BcHBsaWVkKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxuICAgKiBAcGFyYW0ge1Byb3BlcnR5RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxuICAgKiBAcGFyYW0ge0Fubm90YXRpb258Ym9vbGVhbn0gYW5ub3RhdGlvbiB0cnVlIC0gdXNlIGRlZmF1bHQgYW5ub3RhdGlvbiwgZmFsc2UgLSBjb3B5IGFzIGlzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcbiAgICovO1xuICBfcHJvdG8uZXh0ZW5kXyA9IGZ1bmN0aW9uIGV4dGVuZF8oa2V5LCBkZXNjcmlwdG9yLCBhbm5vdGF0aW9uLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgYW5ub3RhdGlvbiA9IHRoaXMuZGVmYXVsdEFubm90YXRpb25fO1xuICAgIH1cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmluZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG4gICAgfVxuICAgIGFzc2VydEFubm90YWJsZSh0aGlzLCBhbm5vdGF0aW9uLCBrZXkpO1xuICAgIHZhciBvdXRjb21lID0gYW5ub3RhdGlvbi5leHRlbmRfKHRoaXMsIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbiAgICBpZiAob3V0Y29tZSkge1xuICAgICAgcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGNvbWU7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxuICAgKiBAcGFyYW0ge1Byb3BlcnR5RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfSB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUgKHByb3h5VHJhcCArIG5vbi1jb25maWd1cmFibGUpLCBudWxsIHdoZW4gY2FuY2VsbGVkIGJ5IGludGVyY2VwdG9yXG4gICAqLztcbiAgX3Byb3RvLmRlZmluZVByb3BlcnR5XyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMua2V5c0F0b21fKTtcbiAgICB0cnkge1xuICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgLy8gRGVsZXRlXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuICAgICAgaWYgKCFkZWxldGVPdXRjb21lKSB7XG4gICAgICAgIC8vIEZhaWx1cmUgb3IgaW50ZXJjZXB0ZWRcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU91dGNvbWU7XG4gICAgICB9XG4gICAgICAvLyBBREQgaW50ZXJjZXB0b3JcbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgICBuZXdWYWx1ZTogZGVzY3JpcHRvci52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgIGRlc2NyaXB0b3IgPSBfZXh0ZW5kcyh7fSwgZGVzY3JpcHRvciwge1xuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIERlZmluZVxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgICAvLyBOb3RpZnlcbiAgICAgIHRoaXMubm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCBkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgb3JpZ2luYWwgZGVzY3JpcHRvciBiZWNvbWVzIHJlbGV2YW50LCBtb3ZlIHRoaXMgdG8gYW5ub3RhdGlvbiBkaXJlY3RseVxuICA7XG4gIF9wcm90by5kZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfID0gZnVuY3Rpb24gZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5XyhrZXksIHZhbHVlLCBlbmhhbmNlciwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5rZXlzQXRvbV8pO1xuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7XG4gICAgICAvLyBEZWxldGVcbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH1cbiAgICAgIC8vIEFERCBpbnRlcmNlcHRvclxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWNoZWREZXNjcmlwdG9yID0gZ2V0Q2FjaGVkT2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9yKGtleSk7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyB0aGlzLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBjYWNoZWREZXNjcmlwdG9yLmdldCxcbiAgICAgICAgc2V0OiBjYWNoZWREZXNjcmlwdG9yLnNldFxuICAgICAgfTtcbiAgICAgIC8vIERlZmluZVxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUodmFsdWUsIGVuaGFuY2VyLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB0aGlzLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSA6IFwiT2JzZXJ2YWJsZU9iamVjdC5rZXlcIiwgZmFsc2UpO1xuICAgICAgdGhpcy52YWx1ZXNfLnNldChrZXksIG9ic2VydmFibGUpO1xuICAgICAgLy8gTm90aWZ5ICh2YWx1ZSBwb3NzaWJseSBjaGFuZ2VkIGJ5IE9ic2VydmFibGVWYWx1ZSlcbiAgICAgIHRoaXMubm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCBvYnNlcnZhYmxlLnZhbHVlXyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIG9yaWdpbmFsIGRlc2NyaXB0b3IgYmVjb21lcyByZWxldmFudCwgbW92ZSB0aGlzIHRvIGFubm90YXRpb24gZGlyZWN0bHlcbiAgO1xuICBfcHJvdG8uZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVDb21wdXRlZFByb3BlcnR5XyhrZXksIG9wdGlvbnMsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMua2V5c0F0b21fKTtcbiAgICB0cnkge1xuICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgLy8gRGVsZXRlXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuICAgICAgaWYgKCFkZWxldGVPdXRjb21lKSB7XG4gICAgICAgIC8vIEZhaWx1cmUgb3IgaW50ZXJjZXB0ZWRcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU91dGNvbWU7XG4gICAgICB9XG4gICAgICAvLyBBREQgaW50ZXJjZXB0b3JcbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgICBuZXdWYWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zLm5hbWUgfHwgKG9wdGlvbnMubmFtZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpIDogXCJPYnNlcnZhYmxlT2JqZWN0LmtleVwiKTtcbiAgICAgIG9wdGlvbnMuY29udGV4dCA9IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XztcbiAgICAgIHZhciBjYWNoZWREZXNjcmlwdG9yID0gZ2V0Q2FjaGVkT2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9yKGtleSk7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyB0aGlzLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogY2FjaGVkRGVzY3JpcHRvci5nZXQsXG4gICAgICAgIHNldDogY2FjaGVkRGVzY3JpcHRvci5zZXRcbiAgICAgIH07XG4gICAgICAvLyBEZWZpbmVcbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgICAgdGhpcy52YWx1ZXNfLnNldChrZXksIG5ldyBDb21wdXRlZFZhbHVlKG9wdGlvbnMpKTtcbiAgICAgIC8vIE5vdGlmeVxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIHVuZGVmaW5lZCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcbiAgICogQHBhcmFtIHtQcm9wZXJ0eURlc2NyaXB0b3J9IGRlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtib29sZWFufSBwcm94eVRyYXAgd2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIHByb3h5IHRyYXBcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxuICAgKi87XG4gIF9wcm90by5kZWxldGVfID0gZnVuY3Rpb24gZGVsZXRlXyhrZXksIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMua2V5c0F0b21fKTtcbiAgICAvLyBObyBzdWNoIHByb3BcbiAgICBpZiAoIWhhc1Byb3AodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSW50ZXJjZXB0XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIHR5cGU6IFJFTU9WRVxuICAgICAgfSk7XG4gICAgICAvLyBDYW5jZWxsZWRcbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEZWxldGVcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzJHBlbmRpbmdLZXlzXztcbiAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLnZhbHVlc18uZ2V0KGtleSk7XG4gICAgICAvLyBWYWx1ZSBuZWVkZWQgZm9yIHNwaWVzL2xpc3RlbmVyc1xuICAgICAgdmFyIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgLy8gT3B0aW1pemF0aW9uOiBkb24ndCBwdWxsIHRoZSB2YWx1ZSB1bmxlc3Mgd2Ugd2lsbCBuZWVkIGl0XG4gICAgICBpZiAoIW9ic2VydmFibGUgJiYgKG5vdGlmeSB8fCBub3RpZnlTcHkpKSB7XG4gICAgICAgIHZhciBfZ2V0RGVzY3JpcHRvcjtcbiAgICAgICAgdmFsdWUgPSAoX2dldERlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKHRoaXMudGFyZ2V0Xywga2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXREZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gZGVsZXRlIHByb3AgKGRvIGZpcnN0LCBtYXkgZmFpbClcbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGFyZ2V0X1trZXldO1xuICAgICAgfVxuICAgICAgLy8gQWxsb3cgcmUtYW5ub3RhdGluZyB0aGlzIGZpZWxkXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFwcGxpZWRBbm5vdGF0aW9uc19ba2V5XTtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIG9ic2VydmFibGVcbiAgICAgIGlmIChvYnNlcnZhYmxlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzX1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgICAvLyBmb3IgY29tcHV0ZWQsIHZhbHVlIGlzIHVuZGVmaW5lZFxuICAgICAgICBpZiAob2JzZXJ2YWJsZSBpbnN0YW5jZW9mIE9ic2VydmFibGVWYWx1ZSkge1xuICAgICAgICAgIHZhbHVlID0gb2JzZXJ2YWJsZS52YWx1ZV87XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90aWZ5OiBhdXRvcnVuKCgpID0+IG9ialtrZXldKSwgc2VlICMxNzk2XG4gICAgICAgIHByb3BhZ2F0ZUNoYW5nZWQob2JzZXJ2YWJsZSk7XG4gICAgICB9XG4gICAgICAvLyBOb3RpZnkgXCJrZXlzL2VudHJpZXMvdmFsdWVzXCIgb2JzZXJ2ZXJzXG4gICAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgICAvLyBOb3RpZnkgXCJoYXNcIiBvYnNlcnZlcnNcbiAgICAgIC8vIFwiaW5cIiBhcyBpdCBtYXkgc3RpbGwgZXhpc3QgaW4gcHJvdG9cbiAgICAgIChfdGhpcyRwZW5kaW5nS2V5c18gPSB0aGlzLnBlbmRpbmdLZXlzXykgPT0gbnVsbCB8fCAoX3RoaXMkcGVuZGluZ0tleXNfID0gX3RoaXMkcGVuZGluZ0tleXNfLmdldChrZXkpKSA9PSBudWxsIHx8IF90aGlzJHBlbmRpbmdLZXlzXy5zZXQoa2V5IGluIHRoaXMudGFyZ2V0Xyk7XG4gICAgICAvLyBOb3RpZnkgc3BpZXMvbGlzdGVuZXJzXG4gICAgICBpZiAobm90aWZ5IHx8IG5vdGlmeVNweSkge1xuICAgICAgICB2YXIgX2NoYW5nZTIgPSB7XG4gICAgICAgICAgdHlwZTogUkVNT1ZFLFxuICAgICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICBvbGRWYWx1ZTogdmFsdWUsXG4gICAgICAgICAgbmFtZToga2V5XG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgICAgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIE9ic2VydmVzIHRoaXMgb2JqZWN0LiBUcmlnZ2VycyBmb3IgdGhlIGV2ZW50cyAnYWRkJywgJ3VwZGF0ZScgYW5kICdkZWxldGUnLlxuICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9vYnNlcnZlXG4gICAqIGZvciBjYWxsYmFjayBkZXRhaWxzXG4gICAqLztcbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8oY2FsbGJhY2ssIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSB7XG4gICAgICBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IHRoZSBmaXJlIGltbWVkaWF0ZWx5IHByb3BlcnR5IGZvciBvYnNlcnZhYmxlIG9iamVjdHMuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBjYWxsYmFjayk7XG4gIH07XG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG4gIF9wcm90by5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyA9IGZ1bmN0aW9uIG5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXMkcGVuZGluZ0tleXNfMjtcbiAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgIHZhciBub3RpZnlTcHkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgaWYgKG5vdGlmeSB8fCBub3RpZnlTcHkpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAoX3RoaXMkcGVuZGluZ0tleXNfMiA9IHRoaXMucGVuZGluZ0tleXNfKSA9PSBudWxsIHx8IChfdGhpcyRwZW5kaW5nS2V5c18yID0gX3RoaXMkcGVuZGluZ0tleXNfMi5nZXQoa2V5KSkgPT0gbnVsbCB8fCBfdGhpcyRwZW5kaW5nS2V5c18yLnNldCh0cnVlKTtcbiAgICAvLyBOb3RpZnkgXCJrZXlzL2VudHJpZXMvdmFsdWVzXCIgb2JzZXJ2ZXJzXG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICB9O1xuICBfcHJvdG8ub3duS2V5c18gPSBmdW5jdGlvbiBvd25LZXlzXygpIHtcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiBvd25LZXlzKHRoaXMudGFyZ2V0Xyk7XG4gIH07XG4gIF9wcm90by5rZXlzXyA9IGZ1bmN0aW9uIGtleXNfKCkge1xuICAgIC8vIFJldHVybnMgZW51bWVyYWJsZSAmJiBvd24sIGJ1dCB1bmZvcnR1bmF0ZWx5IGtleXNBdG9tIHdpbGwgcmVwb3J0IG9uIEFOWSBrZXkgY2hhbmdlLlxuICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIE9iamVjdC5rZXlzKG9iamVjdCkgYW5kIFJlZmxlY3Qub3duS2V5cyhvYmplY3QpIC0gYm90aCBhcmUgaGFuZGxlZCBieSBvd25LZXlzIHRyYXAuXG4gICAgLy8gV2UgY2FuIGVpdGhlciBvdmVyLXJlcG9ydCBpbiBPYmplY3Qua2V5cyhvYmplY3QpIG9yIHVuZGVyLXJlcG9ydCBpbiBSZWZsZWN0Lm93bktleXMob2JqZWN0KVxuICAgIC8vIFdlIGNob29zZSB0byBvdmVyLXJlcG9ydCBpbiBPYmplY3Qua2V5cyhvYmplY3QpLCBiZWNhdXNlOlxuICAgIC8vIC0gdHlwaWNhbGx5IGl0J3MgdXNlZCB3aXRoIHNpbXBsZSBkYXRhIG9iamVjdHNcbiAgICAvLyAtIHdoZW4gc3ltYm9saWMvbm9uLWVudW1lcmFibGUga2V5cyBhcmUgcmVsZXZhbnQgUmVmbGVjdC5vd25LZXlzIHdvcmtzIGFzIGV4cGVjdGVkXG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50YXJnZXRfKTtcbiAgfTtcbiAgcmV0dXJuIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJG5hbWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgb3B0aW9ucyAmJiBpc09ic2VydmFibGVPYmplY3QodGFyZ2V0KSkge1xuICAgIGRpZShcIk9wdGlvbnMgY2FuJ3QgYmUgcHJvdmlkZWQgZm9yIGFscmVhZHkgb2JzZXJ2YWJsZSBvYmplY3RzLlwiKTtcbiAgfVxuICBpZiAoaGFzUHJvcCh0YXJnZXQsICRtb2J4KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShnZXRBZG1pbmlzdHJhdGlvbih0YXJnZXQpIGluc3RhbmNlb2YgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKSkge1xuICAgICAgZGllKFwiQ2Fubm90IGNvbnZlcnQgJ1wiICsgZ2V0RGVidWdOYW1lKHRhcmdldCkgKyBcIicgaW50byBvYnNlcnZhYmxlIG9iamVjdDpcIiArIFwiXFxuVGhlIHRhcmdldCBpcyBhbHJlYWR5IG9ic2VydmFibGUgb2YgZGlmZmVyZW50IHR5cGUuXCIgKyBcIlxcbkV4dGVuZGluZyBidWlsdGlucyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFPYmplY3QuaXNFeHRlbnNpYmxlKHRhcmdldCkpIHtcbiAgICBkaWUoXCJDYW5ub3QgbWFrZSB0aGUgZGVzaWduYXRlZCBvYmplY3Qgb2JzZXJ2YWJsZTsgaXQgaXMgbm90IGV4dGVuc2libGVcIik7XG4gIH1cbiAgdmFyIG5hbWUgPSAoX29wdGlvbnMkbmFtZSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZSkgIT0gbnVsbCA/IF9vcHRpb25zJG5hbWUgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAoaXNQbGFpbk9iamVjdCh0YXJnZXQpID8gXCJPYnNlcnZhYmxlT2JqZWN0XCIgOiB0YXJnZXQuY29uc3RydWN0b3IubmFtZSkgKyBcIkBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlT2JqZWN0XCI7XG4gIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRhcmdldCwgbmV3IE1hcCgpLCBTdHJpbmcobmFtZSksIGdldEFubm90YXRpb25Gcm9tT3B0aW9ucyhvcHRpb25zKSk7XG4gIGFkZEhpZGRlblByb3AodGFyZ2V0LCAkbW9ieCwgYWRtKTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbnZhciBpc09ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uXCIsIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbik7XG5mdW5jdGlvbiBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KSB7XG4gIHJldHVybiBkZXNjcmlwdG9yQ2FjaGVba2V5XSB8fCAoZGVzY3JpcHRvckNhY2hlW2tleV0gPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykge1xuICBpZiAoaXNPYmplY3QodGhpbmcpKSB7XG4gICAgcmV0dXJuIGlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRoaW5nWyRtb2J4XSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQoYWRtLCBhbm5vdGF0aW9uLCBrZXkpIHtcbiAgdmFyIF9hZG0kdGFyZ2V0XyRzdG9yZWRBbjtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfW2tleV0gPSBhbm5vdGF0aW9uO1xuICB9XG4gIC8vIFJlbW92ZSBhcHBsaWVkIGRlY29yYXRvciBhbm5vdGF0aW9uIHNvIHdlIGRvbid0IHRyeSB0byBhcHBseSBpdCBhZ2FpbiBpbiBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAoX2FkbSR0YXJnZXRfJHN0b3JlZEFuID0gYWRtLnRhcmdldF9bc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSA9PSBudWxsIHx8IGRlbGV0ZSBfYWRtJHRhcmdldF8kc3RvcmVkQW5ba2V5XTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFubm90YWJsZShhZG0sIGFubm90YXRpb24sIGtleSkge1xuICAvLyBWYWxpZCBhbm5vdGF0aW9uXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzQW5ub3RhdGlvbihhbm5vdGF0aW9uKSkge1xuICAgIGRpZShcIkNhbm5vdCBhbm5vdGF0ZSAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOiBJbnZhbGlkIGFubm90YXRpb24uXCIpO1xuICB9XG4gIC8qXG4gIC8vIENvbmZpZ3VyYWJsZSwgbm90IHNlYWxlZCwgbm90IGZyb3plblxuICAvLyBQb3NzaWJseSBub3QgbmVlZGVkLCBqdXN0IGEgbGl0dGxlIGJldHRlciBlcnJvciB0aGVuIHRoZSBvbmUgdGhyb3duIGJ5IGVuZ2luZS5cbiAgLy8gQ2FzZXMgd2hlcmUgdGhpcyB3b3VsZCBiZSB1c2VmdWwgdGhlIG1vc3QgKHN1YmNsYXNzIGZpZWxkIGluaXRpYWxpemVyKSBhcmUgbm90IGludGVyY2VwdGFibGUgYnkgdGhpcy5cbiAgaWYgKF9fREVWX18pIHtcbiAgICAgIGNvbnN0IGNvbmZpZ3VyYWJsZSA9IGdldERlc2NyaXB0b3IoYWRtLnRhcmdldF8sIGtleSk/LmNvbmZpZ3VyYWJsZVxuICAgICAgY29uc3QgZnJvemVuID0gT2JqZWN0LmlzRnJvemVuKGFkbS50YXJnZXRfKVxuICAgICAgY29uc3Qgc2VhbGVkID0gT2JqZWN0LmlzU2VhbGVkKGFkbS50YXJnZXRfKVxuICAgICAgaWYgKCFjb25maWd1cmFibGUgfHwgZnJvemVuIHx8IHNlYWxlZCkge1xuICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGAke2FkbS5uYW1lX30uJHtrZXkudG9TdHJpbmcoKX1gXG4gICAgICAgICAgY29uc3QgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlX1xuICAgICAgICAgIGxldCBlcnJvciA9IGBDYW5ub3QgYXBwbHkgJyR7cmVxdWVzdGVkQW5ub3RhdGlvblR5cGV9JyB0byAnJHtmaWVsZE5hbWV9JzpgXG4gICAgICAgICAgaWYgKGZyb3plbikge1xuICAgICAgICAgICAgICBlcnJvciArPSBgXFxuT2JqZWN0IGlzIGZyb3plbi5gXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgICAgICAgZXJyb3IgKz0gYFxcbk9iamVjdCBpcyBzZWFsZWQuYFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICBlcnJvciArPSBgXFxucHJvcGVydHkgaXMgbm90IGNvbmZpZ3VyYWJsZS5gXG4gICAgICAgICAgICAgIC8vIE1lbnRpb24gb25seSBpZiBjYXVzZWQgYnkgdXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICAgICAgICAgICAgIGlmIChoYXNQcm9wKGFkbS5hcHBsaWVkQW5ub3RhdGlvbnMhLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvciArPSBgXFxuVG8gcHJldmVudCBhY2NpZGVudGFsIHJlLWRlZmluaXRpb24gb2YgYSBmaWVsZCBieSBhIHN1YmNsYXNzLCBgXG4gICAgICAgICAgICAgICAgICBlcnJvciArPSBgYWxsIGFubm90YXRlZCBmaWVsZHMgb2Ygbm9uLXBsYWluIG9iamVjdHMgKGNsYXNzZXMpIGFyZSBub3QgY29uZmlndXJhYmxlLmBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkaWUoZXJyb3IpXG4gICAgICB9XG4gIH1cbiAgKi9cbiAgLy8gTm90IGFubm90YXRlZFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc092ZXJyaWRlKGFubm90YXRpb24pICYmIGhhc1Byb3AoYWRtLmFwcGxpZWRBbm5vdGF0aW9uc18sIGtleSkpIHtcbiAgICB2YXIgZmllbGROYW1lID0gYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKTtcbiAgICB2YXIgY3VycmVudEFubm90YXRpb25UeXBlID0gYWRtLmFwcGxpZWRBbm5vdGF0aW9uc19ba2V5XS5hbm5vdGF0aW9uVHlwZV87XG4gICAgdmFyIHJlcXVlc3RlZEFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV87XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIHJlcXVlc3RlZEFubm90YXRpb25UeXBlICsgXCInIHRvICdcIiArIGZpZWxkTmFtZSArIFwiJzpcIiArIChcIlxcblRoZSBmaWVsZCBpcyBhbHJlYWR5IGFubm90YXRlZCB3aXRoICdcIiArIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSArIFwiJy5cIikgKyBcIlxcblJlLWFubm90YXRpbmcgZmllbGRzIGlzIG5vdCBhbGxvd2VkLlwiICsgXCJcXG5Vc2UgJ292ZXJyaWRlJyBhbm5vdGF0aW9uIGZvciBtZXRob2RzIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3MuXCIpO1xuICB9XG59XG5cbi8vIEJ1ZyBpbiBzYWZhcmkgOS4qIChvciBpT1MgOSBzYWZhcmkgbW9iaWxlKS4gU2VlICMzNjRcbnZhciBFTlRSWV8wID0gLyojX19QVVJFX18qL2NyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKDApO1xudmFyIHNhZmFyaVByb3RvdHlwZVNldHRlckluaGVyaXRhbmNlQnVnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIHYgPSBmYWxzZTtcbiAgdmFyIHAgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwiMFwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICB2ID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShwKVtcIjBcIl0gPSAxO1xuICByZXR1cm4gdiA9PT0gZmFsc2U7XG59KCk7XG4vKipcbiAqIFRoaXMgYXJyYXkgYnVmZmVyIGNvbnRhaW5zIHR3byBsaXN0cyBvZiBwcm9wZXJ0aWVzLCBzbyB0aGF0IGFsbCBhcnJheXNcbiAqIGNhbiByZWN5Y2xlIHRoZWlyIHByb3BlcnR5IGRlZmluaXRpb25zLCB3aGljaCBzaWduaWZpY2FudGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlIG9mIGNyZWF0aW5nXG4gKiBwcm9wZXJ0aWVzIG9uIHRoZSBmbHkuXG4gKi9cbnZhciBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFID0gMDtcbi8vIFR5cGVzY3JpcHQgd29ya2Fyb3VuZCB0byBtYWtlIHN1cmUgT2JzZXJ2YWJsZUFycmF5IGV4dGVuZHMgQXJyYXlcbnZhciBTdHViQXJyYXkgPSBmdW5jdGlvbiBTdHViQXJyYXkoKSB7fTtcbmZ1bmN0aW9uIGluaGVyaXQoY3RvciwgcHJvdG8pIHtcbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjdG9yLnByb3RvdHlwZSwgcHJvdG8pO1xuICB9IGVsc2UgaWYgKGN0b3IucHJvdG90eXBlLl9fcHJvdG9fXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3Rvci5wcm90b3R5cGUuX19wcm90b19fID0gcHJvdG87XG4gIH0gZWxzZSB7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwcm90bztcbiAgfVxufVxuaW5oZXJpdChTdHViQXJyYXksIEFycmF5LnByb3RvdHlwZSk7XG4vLyBXZWV4IHByb3RvIGZyZWV6ZSBwcm90ZWN0aW9uIHdhcyBoZXJlLFxuLy8gYnV0IGl0IGlzIHVuY2xlYXIgd2h5IHRoZSBoYWNrIGlzIG5lZWQgYXMgTW9iWCBuZXZlciBjaGFuZ2VkIHRoZSBwcm90b3R5cGVcbi8vIGFueXdheSwgc28gcmVtb3ZlZCBpdCBpbiBWNlxudmFyIExlZ2FjeU9ic2VydmFibGVBcnJheSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0dWJBcnJheSkge1xuICBmdW5jdGlvbiBMZWdhY3lPYnNlcnZhYmxlQXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUsIG93bmVkKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVBcnJheUBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlQXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKG93bmVkID09PSB2b2lkIDApIHtcbiAgICAgIG93bmVkID0gZmFsc2U7XG4gICAgfVxuICAgIF90aGlzID0gX1N0dWJBcnJheS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgaW5pdE9ic2VydmFibGUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbihuYW1lLCBlbmhhbmNlciwgb3duZWQsIHRydWUpO1xuICAgICAgYWRtLnByb3h5XyA9IF90aGlzO1xuICAgICAgYWRkSGlkZGVuRmluYWxQcm9wKF90aGlzLCAkbW9ieCwgYWRtKTtcbiAgICAgIGlmIChpbml0aWFsVmFsdWVzICYmIGluaXRpYWxWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgX3RoaXMuc3BsaWNlV2l0aEFycmF5KDAsIDAsIGluaXRpYWxWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHNhZmFyaVByb3RvdHlwZVNldHRlckluaGVyaXRhbmNlQnVnKSB7XG4gICAgICAgIC8vIFNlZW1zIHRoYXQgU2FmYXJpIHdvbid0IHVzZSBudW1lcmljIHByb3RvdHlwZSBzZXR0ZXIgdW50aWwgYW55ICogbnVtZXJpYyBwcm9wZXJ0eSBpc1xuICAgICAgICAvLyBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZS4gQWZ0ZXIgdGhhdCBpdCB3b3JrcyBmaW5lLCBldmVuIGlmIHRoaXMgcHJvcGVydHkgaXMgZGVsZXRlZC5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIjBcIiwgRU5UUllfMCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0c0xvb3NlKExlZ2FjeU9ic2VydmFibGVBcnJheSwgX1N0dWJBcnJheSk7XG4gIHZhciBfcHJvdG8gPSBMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlO1xuICBfcHJvdG8uY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KCkge1xuICAgIHRoaXNbJG1vYnhdLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFycmF5cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFycmF5c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkodGhpcy5zbGljZSgpLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIGFycmF5cy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBpc09ic2VydmFibGVBcnJheShhKSA/IGEuc2xpY2UoKSA6IGE7XG4gICAgfSkpO1xuICB9O1xuICBfcHJvdG9bU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgc2VsZi5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IHNlbGZbbmV4dEluZGV4KytdLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTGVnYWN5T2JzZXJ2YWJsZUFycmF5LCBbe1xuICAgIGtleTogXCJsZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzWyRtb2J4XS5nZXRBcnJheUxlbmd0aF8oKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xlbmd0aCkge1xuICAgICAgdGhpc1skbW9ieF0uc2V0QXJyYXlMZW5ndGhfKG5ld0xlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJBcnJheVwiO1xuICAgIH1cbiAgfV0pO1xufShTdHViQXJyYXkpO1xuT2JqZWN0LmVudHJpZXMoYXJyYXlFeHRlbnNpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwcm9wID0gX3JlZlswXSxcbiAgICBmbiA9IF9yZWZbMV07XG4gIGlmIChwcm9wICE9PSBcImNvbmNhdFwiKSB7XG4gICAgYWRkSGlkZGVuUHJvcChMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBwcm9wLCBmbik7XG4gIH1cbn0pO1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlFbnRyeURlc2NyaXB0b3IoaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0XyhpbmRleCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpc1skbW9ieF0uc2V0XyhpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5QnVmZmVySXRlbShpbmRleCkge1xuICBkZWZpbmVQcm9wZXJ0eShMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBcIlwiICsgaW5kZXgsIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSk7XG59XG5mdW5jdGlvbiByZXNlcnZlQXJyYXlCdWZmZXIobWF4KSB7XG4gIGlmIChtYXggPiBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFOyBpbmRleCA8IG1heCArIDEwMDsgaW5kZXgrKykge1xuICAgICAgY3JlYXRlQXJyYXlCdWZmZXJJdGVtKGluZGV4KTtcbiAgICB9XG4gICAgT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRSA9IG1heDtcbiAgfVxufVxucmVzZXJ2ZUFycmF5QnVmZmVyKDEwMDApO1xuZnVuY3Rpb24gY3JlYXRlTGVnYWN5QXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBMZWdhY3lPYnNlcnZhYmxlQXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkge1xuICBpZiAodHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmIHRoaW5nICE9PSBudWxsKSB7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KHRoaW5nKSkge1xuICAgICAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGllKDIzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF0uYXRvbV87XG4gICAgfVxuICAgIGlmIChpc09ic2VydmFibGVTZXQodGhpbmcpKSB7XG4gICAgICByZXR1cm4gdGhpbmcuYXRvbV87XG4gICAgfVxuICAgIGlmIChpc09ic2VydmFibGVNYXAodGhpbmcpKSB7XG4gICAgICBpZiAocHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpbmcua2V5c0F0b21fO1xuICAgICAgfVxuICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGluZy5kYXRhXy5nZXQocHJvcGVydHkpIHx8IHRoaW5nLmhhc01hcF8uZ2V0KHByb3BlcnR5KTtcbiAgICAgIGlmICghb2JzZXJ2YWJsZSkge1xuICAgICAgICBkaWUoMjUsIHByb3BlcnR5LCBnZXREZWJ1Z05hbWUodGhpbmcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH1cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSkge1xuICAgICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gZGllKDI2KTtcbiAgICAgIH1cbiAgICAgIHZhciBfb2JzZXJ2YWJsZSA9IHRoaW5nWyRtb2J4XS52YWx1ZXNfLmdldChwcm9wZXJ0eSk7XG4gICAgICBpZiAoIV9vYnNlcnZhYmxlKSB7XG4gICAgICAgIGRpZSgyNywgcHJvcGVydHksIGdldERlYnVnTmFtZSh0aGluZykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9vYnNlcnZhYmxlO1xuICAgIH1cbiAgICBpZiAoaXNBdG9tKHRoaW5nKSB8fCBpc0NvbXB1dGVkVmFsdWUodGhpbmcpIHx8IGlzUmVhY3Rpb24odGhpbmcpKSB7XG4gICAgICByZXR1cm4gdGhpbmc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpbmcpKSB7XG4gICAgaWYgKGlzUmVhY3Rpb24odGhpbmdbJG1vYnhdKSkge1xuICAgICAgLy8gZGlzcG9zZXIgZnVuY3Rpb25cbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF07XG4gICAgfVxuICB9XG4gIGRpZSgyOCk7XG59XG5mdW5jdGlvbiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpIHtcbiAgaWYgKCF0aGluZykge1xuICAgIGRpZSgyOSk7XG4gIH1cbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24oZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbiAgfVxuICBpZiAoaXNBdG9tKHRoaW5nKSB8fCBpc0NvbXB1dGVkVmFsdWUodGhpbmcpIHx8IGlzUmVhY3Rpb24odGhpbmcpKSB7XG4gICAgcmV0dXJuIHRoaW5nO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVNYXAodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHtcbiAgICByZXR1cm4gdGhpbmc7XG4gIH1cbiAgaWYgKHRoaW5nWyRtb2J4XSkge1xuICAgIHJldHVybiB0aGluZ1skbW9ieF07XG4gIH1cbiAgZGllKDI0LCB0aGluZyk7XG59XG5mdW5jdGlvbiBnZXREZWJ1Z05hbWUodGhpbmcsIHByb3BlcnR5KSB7XG4gIHZhciBuYW1lZDtcbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lZCA9IGdldEF0b20odGhpbmcsIHByb3BlcnR5KTtcbiAgfSBlbHNlIGlmIChpc0FjdGlvbih0aGluZykpIHtcbiAgICByZXR1cm4gdGhpbmcubmFtZTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZU1hcCh0aGluZykgfHwgaXNPYnNlcnZhYmxlU2V0KHRoaW5nKSkge1xuICAgIG5hbWVkID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpO1xuICB9IGVsc2Uge1xuICAgIC8vIHZhbGlkIGZvciBhcnJheXMgYXMgd2VsbFxuICAgIG5hbWVkID0gZ2V0QXRvbSh0aGluZyk7XG4gIH1cbiAgcmV0dXJuIG5hbWVkLm5hbWVfO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGluaXRpYWxpemluZyBvYnNlcnZhYmxlIHN0cnVjdHVyZXMsIGl0IGFwcGxpZXM6XG4gKiAxLiBhbGxvd1N0YXRlQ2hhbmdlcyBzbyB3ZSBkb24ndCB2aW9sYXRlIGVuZm9yY2VBY3Rpb25zLlxuICogMi4gdW50cmFja2VkIHNvIHdlIGRvbid0IGFjY2lkZW50YWx5IHN1YnNjcmliZSB0byBhbnl0aGluZyBvYnNlcnZhYmxlIGFjY2Vzc2VkIGR1cmluZyBpbml0IGluIGNhc2UgdGhlIG9ic2VydmFibGUgaXMgY3JlYXRlZCBpbnNpZGUgZGVyaXZhdGlvbi5cbiAqIDMuIGJhdGNoIHRvIGF2b2lkIHN0YXRlIHZlcnNpb24gdXBkYXRlc1xuICovXG5mdW5jdGlvbiBpbml0T2JzZXJ2YWJsZShjYikge1xuICB2YXIgZGVyaXZhdGlvbiA9IHVudHJhY2tlZFN0YXJ0KCk7XG4gIHZhciBhbGxvd1N0YXRlQ2hhbmdlcyA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQodHJ1ZSk7XG4gIHN0YXJ0QmF0Y2goKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2IoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRCYXRjaCgpO1xuICAgIGFsbG93U3RhdGVDaGFuZ2VzRW5kKGFsbG93U3RhdGVDaGFuZ2VzKTtcbiAgICB1bnRyYWNrZWRFbmQoZGVyaXZhdGlvbik7XG4gIH1cbn1cblxudmFyIHRvU3RyaW5nID0gb2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIsIGRlcHRoKSB7XG4gIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgZGVwdGggPSAtMTtcbiAgfVxuICByZXR1cm4gZXEoYSwgYiwgZGVwdGgpO1xufVxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2Jsb2IvNWMyMzdhN2M2ODJmYjY4ZmQ1Mzc4MjAzZjBiZjIyZGNlMTYyNDg1NC91bmRlcnNjb3JlLmpzI0wxMTg2LUwxMjg5XG4vLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuZnVuY3Rpb24gZXEoYSwgYiwgZGVwdGgsIGFTdGFjaywgYlN0YWNrKSB7XG4gIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICB9XG4gIC8vIGBudWxsYCBvciBgdW5kZWZpbmVkYCBvbmx5IGVxdWFsIHRvIGl0c2VsZiAoc3RyaWN0IGNvbXBhcmlzb24pLlxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICBpZiAoYSAhPT0gYSkge1xuICAgIHJldHVybiBiICE9PSBiO1xuICB9XG4gIC8vIEV4aGF1c3QgcHJpbWl0aXZlIGNoZWNrc1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhO1xuICBpZiAodHlwZSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgIT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgIGNhc2UgXCJbb2JqZWN0IFJlZ0V4cF1cIjpcbiAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICByZXR1cm4gXCJcIiArIGEgPT09IFwiXCIgKyBiO1xuICAgIGNhc2UgXCJbb2JqZWN0IE51bWJlcl1cIjpcbiAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTi5cbiAgICAgIGlmICgrYSAhPT0gK2EpIHtcbiAgICAgICAgcmV0dXJuICtiICE9PSArYjtcbiAgICAgIH1cbiAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgIGNhc2UgXCJbb2JqZWN0IERhdGVdXCI6XG4gICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcbiAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgY2FzZSBcIltvYmplY3QgU3ltYm9sXVwiOlxuICAgICAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLnZhbHVlT2YuY2FsbChhKSA9PT0gU3ltYm9sLnZhbHVlT2YuY2FsbChiKTtcbiAgICBjYXNlIFwiW29iamVjdCBNYXBdXCI6XG4gICAgY2FzZSBcIltvYmplY3QgU2V0XVwiOlxuICAgICAgLy8gTWFwcyBhbmQgU2V0cyBhcmUgdW53cmFwcGVkIHRvIGFycmF5cyBvZiBlbnRyeS1wYWlycywgYWRkaW5nIGFuIGluY2lkZW50YWwgbGV2ZWwuXG4gICAgICAvLyBIaWRlIHRoaXMgZXh0cmEgbGV2ZWwgYnkgaW5jcmVhc2luZyB0aGUgZGVwdGguXG4gICAgICBpZiAoZGVwdGggPj0gMCkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gIGEgPSB1bndyYXAoYSk7XG4gIGIgPSB1bndyYXAoYik7XG4gIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICBpZiAodHlwZW9mIGEgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvcixcbiAgICAgIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJiBpc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gYSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZGVwdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoZGVwdGggPCAwKSB7XG4gICAgZGVwdGggPSAtMTtcbiAgfVxuICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSB7XG4gICAgICByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuICB9XG4gIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgYVN0YWNrLnB1c2goYSk7XG4gIGJTdGFjay5wdXNoKGIpO1xuICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgaWYgKGFyZUFycmF5cykge1xuICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBkZXB0aCAtIDEsIGFTdGFjaywgYlN0YWNrKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgdmFyIGtleTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgaWYgKE9iamVjdC5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICBpZiAoIShoYXNQcm9wKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGRlcHRoIC0gMSwgYVN0YWNrLCBiU3RhY2spKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICBhU3RhY2sucG9wKCk7XG4gIGJTdGFjay5wb3AoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1bndyYXAoYSkge1xuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gYS5zbGljZSgpO1xuICB9XG4gIGlmIChpc0VTNk1hcChhKSB8fCBpc09ic2VydmFibGVNYXAoYSkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhLmVudHJpZXMoKSk7XG4gIH1cbiAgaWYgKGlzRVM2U2V0KGEpIHx8IGlzT2JzZXJ2YWJsZVNldChhKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGEuZW50cmllcygpKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxudmFyIF9nZXRHbG9iYWwkSXRlcmF0b3I7XG4vLyBzYWZlbHkgZ2V0IGl0ZXJhdG9yIHByb3RvdHlwZSBpZiBhdmFpbGFibGVcbnZhciBtYXliZUl0ZXJhdG9yUHJvdG90eXBlID0gKChfZ2V0R2xvYmFsJEl0ZXJhdG9yID0gLyojX19QVVJFX18qL2dldEdsb2JhbCgpLkl0ZXJhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2dldEdsb2JhbCRJdGVyYXRvci5wcm90b3R5cGUpIHx8IHt9O1xuZnVuY3Rpb24gbWFrZUl0ZXJhYmxlKGl0ZXJhdG9yKSB7XG4gIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBnZXRTZWxmO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG1heWJlSXRlcmF0b3JQcm90b3R5cGUpLCBpdGVyYXRvcik7XG59XG5mdW5jdGlvbiBnZXRTZWxmKCkge1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gaXNBbm5vdGF0aW9uKHRoaW5nKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQ2FuIGJlIGZ1bmN0aW9uXG4gICAgdGhpbmcgaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZW9mIHRoaW5nLmFubm90YXRpb25UeXBlXyA9PT0gXCJzdHJpbmdcIiAmJiBpc0Z1bmN0aW9uKHRoaW5nLm1ha2VfKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLmV4dGVuZF8pXG4gICk7XG59XG5cbi8qKlxuICogKGMpIE1pY2hlbCBXZXN0c3RyYXRlIDIwMTUgLSAyMDIwXG4gKiBNSVQgTGljZW5zZWRcbiAqXG4gKiBXZWxjb21lIHRvIHRoZSBtb2J4IHNvdXJjZXMhIFRvIGdldCBhIGdsb2JhbCBvdmVydmlldyBvZiBob3cgTW9iWCBpbnRlcm5hbGx5IHdvcmtzLFxuICogdGhpcyBpcyBhIGdvb2QgcGxhY2UgdG8gc3RhcnQ6XG4gKiBodHRwczovL21lZGl1bS5jb20vQG13ZXN0c3RyYXRlL2JlY29taW5nLWZ1bGx5LXJlYWN0aXZlLWFuLWluLWRlcHRoLWV4cGxhbmF0aW9uLW9mLW1vYnNlcnZhYmxlLTU1OTk1MjYyYTI1NCMueHZiaDZxZDc0XG4gKlxuICogU291cmNlIGZvbGRlcnM6XG4gKiA9PT09PT09PT09PT09PT1cbiAqXG4gKiAtIGFwaS8gICAgIE1vc3Qgb2YgdGhlIHB1YmxpYyBzdGF0aWMgbWV0aG9kcyBleHBvc2VkIGJ5IHRoZSBtb2R1bGUgY2FuIGJlIGZvdW5kIGhlcmUuXG4gKiAtIGNvcmUvICAgIEltcGxlbWVudGF0aW9uIG9mIHRoZSBNb2JYIGFsZ29yaXRobTsgYXRvbXMsIGRlcml2YXRpb25zLCByZWFjdGlvbnMsIGRlcGVuZGVuY3kgdHJlZXMsIG9wdGltaXphdGlvbnMuIENvb2wgc3R1ZmYgY2FuIGJlIGZvdW5kIGhlcmUuXG4gKiAtIHR5cGVzLyAgIEFsbCB0aGUgbWFnaWMgdGhhdCBpcyBuZWVkIHRvIGhhdmUgb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIHZhbHVlcyBpcyBpbiB0aGlzIGZvbGRlci4gSW5jbHVkaW5nIHRoZSBtb2RpZmllcnMgbGlrZSBgYXNGbGF0YC5cbiAqIC0gdXRpbHMvICAgVXRpbGl0eSBzdHVmZi5cbiAqXG4gKi9cbltcIlN5bWJvbFwiLCBcIk1hcFwiLCBcIlNldFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gIHZhciBnID0gZ2V0R2xvYmFsKCk7XG4gIGlmICh0eXBlb2YgZ1ttXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGRpZShcIk1vYlggcmVxdWlyZXMgZ2xvYmFsICdcIiArIG0gKyBcIicgdG8gYmUgYXZhaWxhYmxlIG9yIHBvbHlmaWxsZWRcIik7XG4gIH1cbn0pO1xuaWYgKHR5cGVvZiBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gXCJvYmplY3RcIikge1xuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmR5a29nL21vYngtZGV2dG9vbHMvXG4gIF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdE1vYngoe1xuICAgIHNweTogc3B5LFxuICAgIGV4dHJhczoge1xuICAgICAgZ2V0RGVidWdOYW1lOiBnZXREZWJ1Z05hbWVcbiAgICB9LFxuICAgICRtb2J4OiAkbW9ieFxuICB9KTtcbn1cblxuZXhwb3J0IHsgJG1vYngsIEZsb3dDYW5jZWxsYXRpb25FcnJvciwgT2JzZXJ2YWJsZU1hcCwgT2JzZXJ2YWJsZVNldCwgUmVhY3Rpb24sIGFsbG93U3RhdGVDaGFuZ2VzIGFzIF9hbGxvd1N0YXRlQ2hhbmdlcywgcnVuSW5BY3Rpb24gYXMgX2FsbG93U3RhdGVDaGFuZ2VzSW5zaWRlQ29tcHV0ZWQsIGFsbG93U3RhdGVSZWFkc0VuZCBhcyBfYWxsb3dTdGF0ZVJlYWRzRW5kLCBhbGxvd1N0YXRlUmVhZHNTdGFydCBhcyBfYWxsb3dTdGF0ZVJlYWRzU3RhcnQsIGF1dG9BY3Rpb24gYXMgX2F1dG9BY3Rpb24sIF9lbmRBY3Rpb24sIGdldEFkbWluaXN0cmF0aW9uIGFzIF9nZXRBZG1pbmlzdHJhdGlvbiwgZ2V0R2xvYmFsU3RhdGUgYXMgX2dldEdsb2JhbFN0YXRlLCBpbnRlcmNlcHRSZWFkcyBhcyBfaW50ZXJjZXB0UmVhZHMsIGlzQ29tcHV0aW5nRGVyaXZhdGlvbiBhcyBfaXNDb21wdXRpbmdEZXJpdmF0aW9uLCByZXNldEdsb2JhbFN0YXRlIGFzIF9yZXNldEdsb2JhbFN0YXRlLCBfc3RhcnRBY3Rpb24sIGFjdGlvbiwgYXV0b3J1biwgY29tcGFyZXIsIGNvbXB1dGVkLCBjb25maWd1cmUsIGNyZWF0ZUF0b20sIGFwaURlZmluZVByb3BlcnR5IGFzIGRlZmluZVByb3BlcnR5LCBlbnRyaWVzLCBleHRlbmRPYnNlcnZhYmxlLCBmbG93LCBmbG93UmVzdWx0LCBnZXQsIGdldEF0b20sIGdldERlYnVnTmFtZSwgZ2V0RGVwZW5kZW5jeVRyZWUsIGdldE9ic2VydmVyVHJlZSwgaGFzLCBpbnRlcmNlcHQsIGlzQWN0aW9uLCBpc09ic2VydmFibGVWYWx1ZSBhcyBpc0JveGVkT2JzZXJ2YWJsZSwgaXNDb21wdXRlZCwgaXNDb21wdXRlZFByb3AsIGlzRmxvdywgaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3IsIGlzT2JzZXJ2YWJsZSwgaXNPYnNlcnZhYmxlQXJyYXksIGlzT2JzZXJ2YWJsZU1hcCwgaXNPYnNlcnZhYmxlT2JqZWN0LCBpc09ic2VydmFibGVQcm9wLCBpc09ic2VydmFibGVTZXQsIGtleXMsIG1ha2VBdXRvT2JzZXJ2YWJsZSwgbWFrZU9ic2VydmFibGUsIG9ic2VydmFibGUsIG9ic2VydmUsIG9uQmVjb21lT2JzZXJ2ZWQsIG9uQmVjb21lVW5vYnNlcnZlZCwgb25SZWFjdGlvbkVycm9yLCBvdmVycmlkZSwgYXBpT3duS2V5cyBhcyBvd25LZXlzLCByZWFjdGlvbiwgcmVtb3ZlLCBydW5JbkFjdGlvbiwgc2V0LCBzcHksIHRvSlMsIHRyYWNlLCB0cmFuc2FjdGlvbiwgdW50cmFja2VkLCB2YWx1ZXMsIHdoZW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vYnguZXNtLmpzLm1hcFxuIiwiaW1wb3J0IHsgbWFrZU9ic2VydmFibGUgfSBmcm9tIFwibW9ieFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmlmICghdXNlU3RhdGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2J4LXJlYWN0LWxpdGUgcmVxdWlyZXMgUmVhY3Qgd2l0aCBIb29rcyBzdXBwb3J0XCIpO1xufVxuaWYgKCFtYWtlT2JzZXJ2YWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1vYngtcmVhY3QtbGl0ZUAzIHJlcXVpcmVzIG1vYnggYXQgbGVhc3QgdmVyc2lvbiA2IHRvIGJlIGF2YWlsYWJsZVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydEVudmlyb25tZW50LmpzLm1hcCIsImV4cG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3RCYXRjaGVkVXBkYXRlcy5qcy5tYXAiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tIFwibW9ieFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVyQmF0Y2hpbmcocmVhY3Rpb25TY2hlZHVsZXIpIHtcbiAgICBpZiAoIXJlYWN0aW9uU2NoZWR1bGVyKSB7XG4gICAgICAgIHJlYWN0aW9uU2NoZWR1bGVyID0gZGVmYXVsdE5vb3BCYXRjaDtcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW01vYlhdIEZhaWxlZCB0byBnZXQgdW5zdGFibGVfYmF0Y2hlZCB1cGRhdGVzIGZyb20gcmVhY3QtZG9tIC8gcmVhY3QtbmF0aXZlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbmZpZ3VyZSh7IHJlYWN0aW9uU2NoZWR1bGVyOiByZWFjdGlvblNjaGVkdWxlciB9KTtcbn1cbmV4cG9ydCB2YXIgaXNPYnNlcnZlckJhdGNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbTW9iWF0gRGVwcmVjYXRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXJCYXRjaGluZy5qcy5tYXAiLCJpbXBvcnQgeyBnZXREZXBlbmRlbmN5VHJlZSB9IGZyb20gXCJtb2J4XCI7XG5leHBvcnQgZnVuY3Rpb24gcHJpbnREZWJ1Z1ZhbHVlKHYpIHtcbiAgICByZXR1cm4gZ2V0RGVwZW5kZW5jeVRyZWUodik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmludERlYnVnVmFsdWUuanMubWFwIiwidmFyIGdsb2JhbElzVXNpbmdTdGF0aWNSZW5kZXJpbmcgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVTdGF0aWNSZW5kZXJpbmcoZW5hYmxlKSB7XG4gICAgZ2xvYmFsSXNVc2luZ1N0YXRpY1JlbmRlcmluZyA9IGVuYWJsZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1VzaW5nU3RhdGljUmVuZGVyaW5nKCkge1xuICAgIHJldHVybiBnbG9iYWxJc1VzaW5nU3RhdGljUmVuZGVyaW5nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGljUmVuZGVyaW5nLmpzLm1hcCIsImV4cG9ydCB2YXIgUkVHSVNUUllfRklOQUxJWkVfQUZURVIgPSAxMDAwMDtcbmV4cG9ydCB2YXIgUkVHSVNUUllfU1dFRVBfSU5URVJWQUwgPSAxMDAwMDtcbnZhciBUaW1lckJhc2VkRmluYWxpemF0aW9uUmVnaXN0cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZXJCYXNlZEZpbmFsaXphdGlvblJlZ2lzdHJ5KGZpbmFsaXplKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbmFsaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmaW5hbGl6ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVnaXN0cmF0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzd2VlcFRpbWVvdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQm91bmQgc28gaXQgY2FuIGJlIHVzZWQgZGlyZWN0bHkgYXMgc2V0VGltZW91dCBjYWxsYmFjay5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3dlZXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChtYXhBZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4QWdlID09PSB2b2lkIDApIHsgbWF4QWdlID0gUkVHSVNUUllfRklOQUxJWkVfQUZURVI7IH1cbiAgICAgICAgICAgICAgICAvLyBjYW5jZWwgdGltZW91dCBzbyB3ZSBjYW4gZm9yY2Ugc3dlZXAgYW55dGltZVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5zd2VlcFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnN3ZWVwVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbiwgdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyAtIHJlZ2lzdHJhdGlvbi5yZWdpc3RlcmVkQXQgPj0gbWF4QWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maW5hbGl6ZShyZWdpc3RyYXRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0cmF0aW9ucy5kZWxldGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlZ2lzdHJhdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2NoZWR1bGVTd2VlcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEJvdW5kIHNvIGl0IGNhbiBiZSBleHBvcnRlZCBkaXJlY3RseSBhcyBjbGVhclRpbWVycyB0ZXN0IHV0aWxpdHkuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbmFsaXplQWxsSW1tZWRpYXRlbHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zd2VlcCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRva2VuIGlzIGFjdHVhbGx5IHJlcXVpcmVkIHdpdGggdGhpcyBpbXBsXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVyQmFzZWRGaW5hbGl6YXRpb25SZWdpc3RyeS5wcm90b3R5cGUsIFwicmVnaXN0ZXJcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlLCB0b2tlbikge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25zLnNldCh0b2tlbiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkQXQ6IERhdGUubm93KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVN3ZWVwKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZXJCYXNlZEZpbmFsaXphdGlvblJlZ2lzdHJ5LnByb3RvdHlwZSwgXCJ1bnJlZ2lzdGVyXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9ucy5kZWxldGUodG9rZW4pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVyQmFzZWRGaW5hbGl6YXRpb25SZWdpc3RyeS5wcm90b3R5cGUsIFwic2NoZWR1bGVTd2VlcFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3dlZXBUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN3ZWVwVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5zd2VlcCwgUkVHSVNUUllfU1dFRVBfSU5URVJWQUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFRpbWVyQmFzZWRGaW5hbGl6YXRpb25SZWdpc3RyeTtcbn0oKSk7XG5leHBvcnQgeyBUaW1lckJhc2VkRmluYWxpemF0aW9uUmVnaXN0cnkgfTtcbmV4cG9ydCB2YXIgVW5pdmVyc2FsRmluYWxpemF0aW9uUmVnaXN0cnkgPSB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IEZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgOiBUaW1lckJhc2VkRmluYWxpemF0aW9uUmVnaXN0cnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Vbml2ZXJzYWxGaW5hbGl6YXRpb25SZWdpc3RyeS5qcy5tYXAiLCJpbXBvcnQgeyBVbml2ZXJzYWxGaW5hbGl6YXRpb25SZWdpc3RyeSB9IGZyb20gXCIuL1VuaXZlcnNhbEZpbmFsaXphdGlvblJlZ2lzdHJ5XCI7XG5leHBvcnQgdmFyIG9ic2VydmVyRmluYWxpemF0aW9uUmVnaXN0cnkgPSBuZXcgVW5pdmVyc2FsRmluYWxpemF0aW9uUmVnaXN0cnkoZnVuY3Rpb24gKGFkbSkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBhZG0ucmVhY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgYWRtLnJlYWN0aW9uID0gbnVsbDtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeS5qcy5tYXAiLCJpbXBvcnQgeyBSZWFjdGlvbiB9IGZyb20gXCJtb2J4XCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBwcmludERlYnVnVmFsdWUgfSBmcm9tIFwiLi91dGlscy9wcmludERlYnVnVmFsdWVcIjtcbmltcG9ydCB7IGlzVXNpbmdTdGF0aWNSZW5kZXJpbmcgfSBmcm9tIFwiLi9zdGF0aWNSZW5kZXJpbmdcIjtcbmltcG9ydCB7IG9ic2VydmVyRmluYWxpemF0aW9uUmVnaXN0cnkgfSBmcm9tIFwiLi91dGlscy9vYnNlcnZlckZpbmFsaXphdGlvblJlZ2lzdHJ5XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltXCI7XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGlvbihhZG0pIHtcbiAgICBhZG0ucmVhY3Rpb24gPSBuZXcgUmVhY3Rpb24oXCJvYnNlcnZlclwiLmNvbmNhdChhZG0ubmFtZSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhZG0uc3RhdGVWZXJzaW9uID0gU3ltYm9sKCk7XG4gICAgICAgIC8vIG9uU3RvcmVDaGFuZ2Ugd29uJ3QgYmUgYXZhaWxhYmxlIHVudGlsIHRoZSBjb21wb25lbnQgXCJtb3VudHNcIi5cbiAgICAgICAgLy8gSWYgc3RhdGUgY2hhbmdlcyBpbiBiZXR3ZWVuIGluaXRpYWwgcmVuZGVyIGFuZCBtb3VudCxcbiAgICAgICAgLy8gYHVzZVN5bmNFeHRlcm5hbFN0b3JlYCBzaG91bGQgaGFuZGxlIHRoYXQgYnkgY2hlY2tpbmcgdGhlIHN0YXRlIHZlcnNpb24gYW5kIGlzc3VpbmcgdXBkYXRlLlxuICAgICAgICAoX2EgPSBhZG0ub25TdG9yZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYWRtKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VPYnNlcnZlcihyZW5kZXIsIGJhc2VDb21wb25lbnROYW1lKSB7XG4gICAgaWYgKGJhc2VDb21wb25lbnROYW1lID09PSB2b2lkIDApIHsgYmFzZUNvbXBvbmVudE5hbWUgPSBcIm9ic2VydmVkXCI7IH1cbiAgICBpZiAoaXNVc2luZ1N0YXRpY1JlbmRlcmluZygpKSB7XG4gICAgICAgIHJldHVybiByZW5kZXIoKTtcbiAgICB9XG4gICAgdmFyIGFkbVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBpZiAoIWFkbVJlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIEZpcnN0IHJlbmRlclxuICAgICAgICB2YXIgYWRtXzEgPSB7XG4gICAgICAgICAgICByZWFjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIG9uU3RvcmVDaGFuZ2U6IG51bGwsXG4gICAgICAgICAgICBzdGF0ZVZlcnNpb246IFN5bWJvbCgpLFxuICAgICAgICAgICAgbmFtZTogYmFzZUNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChvblN0b3JlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gTk9UIGFjY2VzcyBhZG1SZWYgaGVyZSFcbiAgICAgICAgICAgICAgICBvYnNlcnZlckZpbmFsaXphdGlvblJlZ2lzdHJ5LnVucmVnaXN0ZXIoYWRtXzEpO1xuICAgICAgICAgICAgICAgIGFkbV8xLm9uU3RvcmVDaGFuZ2UgPSBvblN0b3JlQ2hhbmdlO1xuICAgICAgICAgICAgICAgIGlmICghYWRtXzEucmVhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgbG9zdCBvdXIgcmVhY3Rpb24gYW5kIHRoZXJlZm9yZSBhbGwgc3Vic2NyaXB0aW9ucywgb2NjdXJzIHdoZW46XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIFRpbWVyIGJhc2VkIGZpbmFsaXphdGlvbiByZWdpc3RyeSBkaXNwb3NlZCByZWFjdGlvbiBiZWZvcmUgY29tcG9uZW50IG1vdW50ZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIFJlYWN0IFwicmUtbW91bnRzXCIgc2FtZSBjb21wb25lbnQgd2l0aG91dCBjYWxsaW5nIHJlbmRlciBpbiBiZXR3ZWVuICh0eXBpY2FsbHkgPFN0cmljdE1vZGU+KS5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byByZWNyZWF0ZSByZWFjdGlvbiBhbmQgc2NoZWR1bGUgcmUtcmVuZGVyIHRvIHJlY3JlYXRlIHN1YnNjcmlwdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgc3RhdGUgZGlkIG5vdCBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlYWN0aW9uKGFkbV8xKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYG9uU3RvcmVDaGFuZ2VgIHdvbid0IGZvcmNlIHVwZGF0ZSBpZiBzdWJzZXF1ZW50IGBnZXRTbmFwc2hvdGAgcmV0dXJucyBzYW1lIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCBpcyBub3QgdGhlIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgYWRtXzEuc3RhdGVWZXJzaW9uID0gU3ltYm9sKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gTk9UIGFjY2VzcyBhZG1SZWYgaGVyZSFcbiAgICAgICAgICAgICAgICAgICAgYWRtXzEub25TdG9yZUNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGFkbV8xLnJlYWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBhZG1fMS5yZWFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIERvIE5PVCBhY2Nlc3MgYWRtUmVmIGhlcmUhXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkbV8xLnN0YXRlVmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYWRtUmVmLmN1cnJlbnQgPSBhZG1fMTtcbiAgICB9XG4gICAgdmFyIGFkbSA9IGFkbVJlZi5jdXJyZW50O1xuICAgIGlmICghYWRtLnJlYWN0aW9uKSB7XG4gICAgICAgIC8vIEZpcnN0IHJlbmRlciBvciByZWFjdGlvbiB3YXMgZGlzcG9zZWQgYnkgcmVnaXN0cnkgYmVmb3JlIHN1YnNjcmliZVxuICAgICAgICBjcmVhdGVSZWFjdGlvbihhZG0pO1xuICAgICAgICAvLyBTdHJpY3RNb2RlL0NvbmN1cnJlbnRNb2RlL1N1c3BlbnNlIG1heSBtZWFuIHRoYXQgb3VyIGNvbXBvbmVudCBpc1xuICAgICAgICAvLyByZW5kZXJlZCBhbmQgYWJhbmRvbmVkIG11bHRpcGxlIHRpbWVzLCBzbyB3ZSBuZWVkIHRvIHRyYWNrIGxlYWtlZFxuICAgICAgICAvLyBSZWFjdGlvbnMuXG4gICAgICAgIG9ic2VydmVyRmluYWxpemF0aW9uUmVnaXN0cnkucmVnaXN0ZXIoYWRtUmVmLCBhZG0sIGFkbSk7XG4gICAgfVxuICAgIFJlYWN0LnVzZURlYnVnVmFsdWUoYWRtLnJlYWN0aW9uLCBwcmludERlYnVnVmFsdWUpO1xuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIC8vIEJvdGggb2YgdGhlc2UgbXVzdCBiZSBzdGFibGUsIG90aGVyd2lzZSBpdCB3b3VsZCBrZWVwIHJlc3Vic2NyaWJpbmcgZXZlcnkgcmVuZGVyLlxuICAgIGFkbS5zdWJzY3JpYmUsIGFkbS5nZXRTbmFwc2hvdCwgYWRtLmdldFNuYXBzaG90KTtcbiAgICAvLyByZW5kZXIgdGhlIG9yaWdpbmFsIGNvbXBvbmVudCwgYnV0IGhhdmUgdGhlXG4gICAgLy8gcmVhY3Rpb24gdHJhY2sgdGhlIG9ic2VydmFibGVzLCBzbyB0aGF0IHJlbmRlcmluZ1xuICAgIC8vIGNhbiBiZSBpbnZhbGlkYXRlZCAoc2VlIGFib3ZlKSBvbmNlIGEgZGVwZW5kZW5jeSBjaGFuZ2VzXG4gICAgdmFyIHJlbmRlclJlc3VsdDtcbiAgICB2YXIgZXhjZXB0aW9uO1xuICAgIGFkbS5yZWFjdGlvbi50cmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZW5kZXJSZXN1bHQgPSByZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXhjZXB0aW9uID0gZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChleGNlcHRpb24pIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uOyAvLyByZS10aHJvdyBhbnkgZXhjZXB0aW9ucyBjYXVnaHQgZHVyaW5nIHJlbmRlcmluZ1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyUmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlT2JzZXJ2ZXIuanMubWFwIiwidmFyIF9hLCBfYjtcbmltcG9ydCB7IGZvcndhcmRSZWYsIG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGlzVXNpbmdTdGF0aWNSZW5kZXJpbmcgfSBmcm9tIFwiLi9zdGF0aWNSZW5kZXJpbmdcIjtcbmltcG9ydCB7IHVzZU9ic2VydmVyIH0gZnJvbSBcIi4vdXNlT2JzZXJ2ZXJcIjtcbnZhciB3YXJuT2JzZXJ2ZXJPcHRpb25zRGVwcmVjYXRlZCA9IHRydWU7XG52YXIgd2FybkxlZ2FjeUNvbnRleHRUeXBlcyA9IHRydWU7XG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3I7XG52YXIgaXNGdW5jdGlvbk5hbWVDb25maWd1cmFibGUgPSAoX2IgPSAoX2EgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZ1bmN0aW9uICgpIHsgfSwgXCJuYW1lXCIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlndXJhYmxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbi8vIFVzaW5nIHJlYWN0LWlzIGhhZCBzb21lIGlzc3VlcyAoYW5kIG9wZXJhdGVzIG9uIGVsZW1lbnRzLCBub3Qgb24gdHlwZXMpLCBzZWUgIzYwOCAvICM2MDlcbnZhciBSZWFjdEZvcndhcmRSZWZTeW1ib2wgPSBoYXNTeW1ib2xcbiAgICA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKVxuICAgIDogdHlwZW9mIGZvcndhcmRSZWYgPT09IFwiZnVuY3Rpb25cIiAmJiBmb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gbnVsbDsgfSlbXCIkJHR5cGVvZlwiXTtcbnZhciBSZWFjdE1lbW9TeW1ib2wgPSBoYXNTeW1ib2xcbiAgICA/IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpXG4gICAgOiB0eXBlb2YgbWVtbyA9PT0gXCJmdW5jdGlvblwiICYmIG1lbW8oZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBudWxsOyB9KVtcIiQkdHlwZW9mXCJdO1xuLy8gbi5iLiBiYXNlIGNhc2UgaXMgbm90IHVzZWQgZm9yIGFjdHVhbCB0eXBpbmdzIG9yIGV4cG9ydGVkIGluIHRoZSB0eXBpbmcgZmlsZXNcbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlcihiYXNlQ29tcG9uZW50LCBcbi8vIFRPRE8gcmVtb3ZlIGluIG5leHQgbWFqb3Jcbm9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB3YXJuT2JzZXJ2ZXJPcHRpb25zRGVwcmVjYXRlZCAmJiBvcHRpb25zKSB7XG4gICAgICAgIHdhcm5PYnNlcnZlck9wdGlvbnNEZXByZWNhdGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlttb2J4LXJlYWN0LWxpdGVdIGBvYnNlcnZlcihmbiwgeyBmb3J3YXJkUmVmOiB0cnVlIH0pYCBpcyBkZXByZWNhdGVkLCB1c2UgYG9ic2VydmVyKFJlYWN0LmZvcndhcmRSZWYoZm4pKWBcIik7XG4gICAgfVxuICAgIGlmIChSZWFjdE1lbW9TeW1ib2wgJiYgYmFzZUNvbXBvbmVudFtcIiQkdHlwZW9mXCJdID09PSBSZWFjdE1lbW9TeW1ib2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYngtcmVhY3QtbGl0ZV0gWW91IGFyZSB0cnlpbmcgdG8gdXNlIGBvYnNlcnZlcmAgb24gYSBmdW5jdGlvbiBjb21wb25lbnQgd3JhcHBlZCBpbiBlaXRoZXIgYW5vdGhlciBgb2JzZXJ2ZXJgIG9yIGBSZWFjdC5tZW1vYC4gVGhlIG9ic2VydmVyIGFscmVhZHkgYXBwbGllcyAnUmVhY3QubWVtbycgZm9yIHlvdS5cIik7XG4gICAgfVxuICAgIC8vIFRoZSB3b3JraW5nIG9mIG9ic2VydmVyIGlzIGV4cGxhaW5lZCBzdGVwIGJ5IHN0ZXAgaW4gdGhpcyB0YWxrOiBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PWNQRjRpQmVkb0YwJmZlYXR1cmU9eW91dHUuYmUmdD0xMzA3XG4gICAgaWYgKGlzVXNpbmdTdGF0aWNSZW5kZXJpbmcoKSkge1xuICAgICAgICByZXR1cm4gYmFzZUNvbXBvbmVudDtcbiAgICB9XG4gICAgdmFyIHVzZUZvcndhcmRSZWYgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yd2FyZFJlZikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgdmFyIHJlbmRlciA9IGJhc2VDb21wb25lbnQ7XG4gICAgdmFyIGJhc2VDb21wb25lbnROYW1lID0gYmFzZUNvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBiYXNlQ29tcG9uZW50Lm5hbWU7XG4gICAgLy8gSWYgYWxyZWFkeSB3cmFwcGVkIHdpdGggZm9yd2FyZFJlZiwgdW53cmFwLFxuICAgIC8vIHNvIHdlIGNhbiBwYXRjaCByZW5kZXIgYW5kIGFwcGx5IG1lbW9cbiAgICBpZiAoUmVhY3RGb3J3YXJkUmVmU3ltYm9sICYmIGJhc2VDb21wb25lbnRbXCIkJHR5cGVvZlwiXSA9PT0gUmVhY3RGb3J3YXJkUmVmU3ltYm9sKSB7XG4gICAgICAgIHVzZUZvcndhcmRSZWYgPSB0cnVlO1xuICAgICAgICByZW5kZXIgPSBiYXNlQ29tcG9uZW50W1wicmVuZGVyXCJdO1xuICAgICAgICBpZiAodHlwZW9mIHJlbmRlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdC1saXRlXSBgcmVuZGVyYCBwcm9wZXJ0eSBvZiBGb3J3YXJkUmVmIHdhcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgb2JzZXJ2ZXJDb21wb25lbnQgPSBmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgICAgICByZXR1cm4gdXNlT2JzZXJ2ZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVuZGVyKHByb3BzLCByZWYpOyB9LCBiYXNlQ29tcG9uZW50TmFtZSk7XG4gICAgfTtcbiAgICBvYnNlcnZlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGJhc2VDb21wb25lbnQuZGlzcGxheU5hbWU7XG4gICAgaWYgKGlzRnVuY3Rpb25OYW1lQ29uZmlndXJhYmxlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYnNlcnZlckNvbXBvbmVudCwgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBiYXNlQ29tcG9uZW50Lm5hbWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gU3VwcG9ydCBsZWdhY3kgY29udGV4dDogYGNvbnRleHRUeXBlc2AgbXVzdCBiZSBhcHBsaWVkIGJlZm9yZSBgbWVtb2BcbiAgICBpZiAoYmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgO1xuICAgICAgICBvYnNlcnZlckNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBiYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB3YXJuTGVnYWN5Q29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgICB3YXJuTGVnYWN5Q29udGV4dFR5cGVzID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbbW9ieC1yZWFjdC1saXRlXSBTdXBwb3J0IGZvciBMZWdhY3kgQ29udGV4dCBpbiBmdW5jdGlvbiBjb21wb25lbnRzIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodXNlRm9yd2FyZFJlZikge1xuICAgICAgICAvLyBgZm9yd2FyZFJlZmAgbXVzdCBiZSBhcHBsaWVkIHByaW9yIGBtZW1vYFxuICAgICAgICAvLyBgZm9yd2FyZFJlZihvYnNlcnZlcihjbXApKWAgdGhyb3dzOlxuICAgICAgICAvLyBcImZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gIGNvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSBtZW1vKGZvcndhcmRSZWYoLi4uKSlcIlxuICAgICAgICBvYnNlcnZlckNvbXBvbmVudCA9IGZvcndhcmRSZWYob2JzZXJ2ZXJDb21wb25lbnQpO1xuICAgIH1cbiAgICAvLyBtZW1vOyB3ZSBhcmUgbm90IGludGVyZXN0ZWQgaW4gZGVlcCB1cGRhdGVzXG4gICAgLy8gaW4gcHJvcHM7IHdlIGFzc3VtZSB0aGF0IGlmIGRlZXAgb2JqZWN0cyBhcmUgY2hhbmdlZCxcbiAgICAvLyB0aGlzIGlzIGluIG9ic2VydmFibGVzLCB3aGljaCB3b3VsZCBoYXZlIGJlZW4gdHJhY2tlZCBhbnl3YXlcbiAgICBvYnNlcnZlckNvbXBvbmVudCA9IG1lbW8ob2JzZXJ2ZXJDb21wb25lbnQpO1xuICAgIGNvcHlTdGF0aWNQcm9wZXJ0aWVzKGJhc2VDb21wb25lbnQsIG9ic2VydmVyQ29tcG9uZW50KTtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYnNlcnZlckNvbXBvbmVudCwgXCJjb250ZXh0VHlwZXNcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdC1saXRlXSBgXCIuY29uY2F0KHRoaXMuZGlzcGxheU5hbWUgfHwgKChfYSA9IHRoaXMudHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3BsYXlOYW1lKSB8fCAoKF9iID0gdGhpcy50eXBlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgfHwgXCJDb21wb25lbnRcIiwgXCIuY29udGV4dFR5cGVzYCBtdXN0IGJlIHNldCBiZWZvcmUgYXBwbHlpbmcgYG9ic2VydmVyYC5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9ic2VydmVyQ29tcG9uZW50O1xufVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21yaWRnd2F5L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xudmFyIGhvaXN0QmxhY2tMaXN0ID0ge1xuICAgICQkdHlwZW9mOiB0cnVlLFxuICAgIHJlbmRlcjogdHJ1ZSxcbiAgICBjb21wYXJlOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsXG4gICAgLy8gRG9uJ3QgcmVkZWZpbmUgYGRpc3BsYXlOYW1lYCxcbiAgICAvLyBpdCdzIGRlZmluZWQgYXMgZ2V0dGVyLXNldHRlciBwYWlyIG9uIGBtZW1vYCAoc2VlICMzMTkyKS5cbiAgICBkaXNwbGF5TmFtZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGNvcHlTdGF0aWNQcm9wZXJ0aWVzKGJhc2UsIHRhcmdldCkge1xuICAgIE9iamVjdC5rZXlzKGJhc2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWhvaXN0QmxhY2tMaXN0W2tleV0pIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBrZXkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXIuanMubWFwIiwiaW1wb3J0IHsgdXNlT2JzZXJ2ZXIgfSBmcm9tIFwiLi91c2VPYnNlcnZlclwiO1xuZnVuY3Rpb24gT2JzZXJ2ZXJDb21wb25lbnQoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgcmVuZGVyID0gX2EucmVuZGVyO1xuICAgIGlmIChjaGlsZHJlbiAmJiByZW5kZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk1vYlggT2JzZXJ2ZXI6IERvIG5vdCB1c2UgY2hpbGRyZW4gYW5kIHJlbmRlciBpbiB0aGUgc2FtZSB0aW1lIGluIGBPYnNlcnZlcmBcIik7XG4gICAgfVxuICAgIHZhciBjb21wb25lbnQgPSBjaGlsZHJlbiB8fCByZW5kZXI7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU9ic2VydmVyKGNvbXBvbmVudCk7XG59XG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgT2JzZXJ2ZXJDb21wb25lbnQucHJvcFR5cGVzID0ge1xuICAgICAgICBjaGlsZHJlbjogT2JzZXJ2ZXJQcm9wc0NoZWNrLFxuICAgICAgICByZW5kZXI6IE9ic2VydmVyUHJvcHNDaGVja1xuICAgIH07XG59XG5PYnNlcnZlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9IFwiT2JzZXJ2ZXJcIjtcbmV4cG9ydCB7IE9ic2VydmVyQ29tcG9uZW50IGFzIE9ic2VydmVyIH07XG5mdW5jdGlvbiBPYnNlcnZlclByb3BzQ2hlY2socHJvcHMsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBleHRyYUtleSA9IGtleSA9PT0gXCJjaGlsZHJlblwiID8gXCJyZW5kZXJcIiA6IFwiY2hpbGRyZW5cIjtcbiAgICB2YXIgaGFzUHJvcCA9IHR5cGVvZiBwcm9wc1trZXldID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGhhc0V4dHJhUHJvcCA9IHR5cGVvZiBwcm9wc1tleHRyYUtleV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICBpZiAoaGFzUHJvcCAmJiBoYXNFeHRyYVByb3ApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIk1vYlggT2JzZXJ2ZXI6IERvIG5vdCB1c2UgY2hpbGRyZW4gYW5kIHJlbmRlciBpbiB0aGUgc2FtZSB0aW1lIGluYFwiICsgY29tcG9uZW50TmFtZSk7XG4gICAgfVxuICAgIGlmIChoYXNQcm9wIHx8IGhhc0V4dHJhUHJvcCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkludmFsaWQgcHJvcCBgXCIgK1xuICAgICAgICBwcm9wRnVsbE5hbWUgK1xuICAgICAgICBcImAgb2YgdHlwZSBgXCIgK1xuICAgICAgICB0eXBlb2YgcHJvcHNba2V5XSArXG4gICAgICAgIFwiYCBzdXBwbGllZCB0b1wiICtcbiAgICAgICAgXCIgYFwiICtcbiAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgIFwiYCwgZXhwZWN0ZWQgYGZ1bmN0aW9uYC5cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZlckNvbXBvbmVudC5qcy5tYXAiLCJpbXBvcnQgeyBvYnNlcnZhYmxlIH0gZnJvbSBcIm1vYnhcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxPYnNlcnZhYmxlKGluaXRpYWxpemVyLCBhbm5vdGF0aW9ucykge1xuICAgIHJldHVybiB1c2VTdGF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZhYmxlKGluaXRpYWxpemVyKCksIGFubm90YXRpb25zLCB7IGF1dG9CaW5kOiB0cnVlIH0pOyB9KVswXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUxvY2FsT2JzZXJ2YWJsZS5qcy5tYXAiLCJpbXBvcnQgeyB1c2VEZXByZWNhdGVkIH0gZnJvbSBcIi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IG9ic2VydmFibGUsIHJ1bkluQWN0aW9uIH0gZnJvbSBcIm1vYnhcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gdXNlQXNPYnNlcnZhYmxlU291cmNlKGN1cnJlbnQpIHtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKVxuICAgICAgICB1c2VEZXByZWNhdGVkKFwiW21vYngtcmVhY3QtbGl0ZV0gJ3VzZUFzT2JzZXJ2YWJsZVNvdXJjZScgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHN0b3JlIHRoZSB2YWx1ZXMgZGlyZWN0bHkgaW4gYW4gb2JzZXJ2YWJsZSwgZm9yIGV4YW1wbGUgYnkgdXNpbmcgJ3VzZUxvY2FsT2JzZXJ2YWJsZScsIGFuZCBzeW5jIGZ1dHVyZSB1cGRhdGVzIHVzaW5nICd1c2VFZmZlY3QnIHdoZW4gbmVlZGVkLiBTZWUgdGhlIFJFQURNRSBmb3IgZXhhbXBsZXMuXCIpO1xuICAgIC8vIFdlJ3JlIGRlbGliZXJhdGVseSBub3QgdXNpbmcgaWRpb21hdGljIGRlc3RydWN0dXJpbmcgZm9yIHRoZSBob29rIGhlcmUuXG4gICAgLy8gQWNjZXNzaW5nIHRoZSBzdGF0ZSB2YWx1ZSBhcyBhbiBhcnJheSBlbGVtZW50IHByZXZlbnRzIFR5cGVTY3JpcHQgZnJvbSBnZW5lcmF0aW5nIHVubmVjZXNzYXJ5IGhlbHBlcnMgaW4gdGhlIHJlc3VsdGluZyBjb2RlLlxuICAgIC8vIEZvciBmdXJ0aGVyIGRldGFpbHMsIHBsZWFzZSByZWZlciB0byBtb2J4anMvbW9ieCMzODQyLlxuICAgIHZhciByZXMgPSB1c2VTdGF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZhYmxlKGN1cnJlbnQsIHt9LCB7IGRlZXA6IGZhbHNlIH0pOyB9KVswXTtcbiAgICBydW5JbkFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBjdXJyZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlQXNPYnNlcnZhYmxlU291cmNlLmpzLm1hcCIsImltcG9ydCB7IG9ic2VydmFibGUgfSBmcm9tIFwibW9ieFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZURlcHJlY2F0ZWQgfSBmcm9tIFwiLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgdXNlQXNPYnNlcnZhYmxlU291cmNlIH0gZnJvbSBcIi4vdXNlQXNPYnNlcnZhYmxlU291cmNlXCI7XG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxTdG9yZShpbml0aWFsaXplciwgY3VycmVudCkge1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgdXNlRGVwcmVjYXRlZChcIlttb2J4LXJlYWN0LWxpdGVdICd1c2VMb2NhbFN0b3JlJyBpcyBkZXByZWNhdGVkLCB1c2UgJ3VzZUxvY2FsT2JzZXJ2YWJsZScgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSBjdXJyZW50ICYmIHVzZUFzT2JzZXJ2YWJsZVNvdXJjZShjdXJyZW50KTtcbiAgICByZXR1cm4gdXNlU3RhdGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2YWJsZShpbml0aWFsaXplcihzb3VyY2UpLCB1bmRlZmluZWQsIHsgYXV0b0JpbmQ6IHRydWUgfSk7IH0pWzBdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlTG9jYWxTdG9yZS5qcy5tYXAiLCJ2YXIgX2E7XG5pbXBvcnQgXCIuL3V0aWxzL2Fzc2VydEVudmlyb25tZW50XCI7XG5pbXBvcnQgeyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBhcyBiYXRjaCB9IGZyb20gXCIuL3V0aWxzL3JlYWN0QmF0Y2hlZFVwZGF0ZXNcIjtcbmltcG9ydCB7IG9ic2VydmVyQmF0Y2hpbmcgfSBmcm9tIFwiLi91dGlscy9vYnNlcnZlckJhdGNoaW5nXCI7XG5pbXBvcnQgeyB1c2VEZXByZWNhdGVkIH0gZnJvbSBcIi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IHVzZU9ic2VydmVyIGFzIHVzZU9ic2VydmVyT3JpZ2luYWwgfSBmcm9tIFwiLi91c2VPYnNlcnZlclwiO1xuaW1wb3J0IHsgZW5hYmxlU3RhdGljUmVuZGVyaW5nIH0gZnJvbSBcIi4vc3RhdGljUmVuZGVyaW5nXCI7XG5pbXBvcnQgeyBvYnNlcnZlckZpbmFsaXphdGlvblJlZ2lzdHJ5IH0gZnJvbSBcIi4vdXRpbHMvb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeVwiO1xub2JzZXJ2ZXJCYXRjaGluZyhiYXRjaCk7XG5leHBvcnQgeyBpc1VzaW5nU3RhdGljUmVuZGVyaW5nLCBlbmFibGVTdGF0aWNSZW5kZXJpbmcgfSBmcm9tIFwiLi9zdGF0aWNSZW5kZXJpbmdcIjtcbmV4cG9ydCB7IG9ic2VydmVyIH0gZnJvbSBcIi4vb2JzZXJ2ZXJcIjtcbmV4cG9ydCB7IE9ic2VydmVyIH0gZnJvbSBcIi4vT2JzZXJ2ZXJDb21wb25lbnRcIjtcbmV4cG9ydCB7IHVzZUxvY2FsT2JzZXJ2YWJsZSB9IGZyb20gXCIuL3VzZUxvY2FsT2JzZXJ2YWJsZVwiO1xuZXhwb3J0IHsgdXNlTG9jYWxTdG9yZSB9IGZyb20gXCIuL3VzZUxvY2FsU3RvcmVcIjtcbmV4cG9ydCB7IHVzZUFzT2JzZXJ2YWJsZVNvdXJjZSB9IGZyb20gXCIuL3VzZUFzT2JzZXJ2YWJsZVNvdXJjZVwiO1xuZXhwb3J0IHsgb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeSBhcyBfb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeSB9O1xuZXhwb3J0IHZhciBjbGVhclRpbWVycyA9IChfYSA9IG9ic2VydmVyRmluYWxpemF0aW9uUmVnaXN0cnlbXCJmaW5hbGl6ZUFsbEltbWVkaWF0ZWx5XCJdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoZnVuY3Rpb24gKCkgeyB9KTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VPYnNlcnZlcihmbiwgYmFzZUNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoYmFzZUNvbXBvbmVudE5hbWUgPT09IHZvaWQgMCkgeyBiYXNlQ29tcG9uZW50TmFtZSA9IFwib2JzZXJ2ZWRcIjsgfVxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgdXNlRGVwcmVjYXRlZChcIlttb2J4LXJlYWN0LWxpdGVdICd1c2VPYnNlcnZlcihmbiknIGlzIGRlcHJlY2F0ZWQuIFVzZSBgPE9ic2VydmVyPntmbn08L09ic2VydmVyPmAgaW5zdGVhZCwgb3Igd3JhcCB0aGUgZW50aXJlIGNvbXBvbmVudCBpbiBgb2JzZXJ2ZXJgLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU9ic2VydmVyT3JpZ2luYWwoZm4sIGJhc2VDb21wb25lbnROYW1lKTtcbn1cbmV4cG9ydCB7IGlzT2JzZXJ2ZXJCYXRjaGVkLCBvYnNlcnZlckJhdGNoaW5nIH0gZnJvbSBcIi4vdXRpbHMvb2JzZXJ2ZXJCYXRjaGluZ1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRpY1JlbmRlcmluZyhlbmFibGUpIHtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlttb2J4LXJlYWN0LWxpdGVdICd1c2VTdGF0aWNSZW5kZXJpbmcnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnZW5hYmxlU3RhdGljUmVuZGVyaW5nJyBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgICBlbmFibGVTdGF0aWNSZW5kZXJpbmcoZW5hYmxlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IF9nZXRHbG9iYWxTdGF0ZSwgUmVhY3Rpb24sIF9hbGxvd1N0YXRlQ2hhbmdlcywgdW50cmFja2VkLCBpc09ic2VydmFibGVNYXAsIGlzT2JzZXJ2YWJsZU9iamVjdCwgaXNPYnNlcnZhYmxlQXJyYXksIG9ic2VydmFibGUgfSBmcm9tICdtb2J4JztcbmltcG9ydCBSZWFjdF9fZGVmYXVsdCwgeyBQdXJlQ29tcG9uZW50LCBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc1VzaW5nU3RhdGljUmVuZGVyaW5nLCBfb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeSwgb2JzZXJ2ZXIgYXMgb2JzZXJ2ZXIkMSB9IGZyb20gJ21vYngtcmVhY3QtbGl0ZSc7XG5leHBvcnQgeyBPYnNlcnZlciwgZW5hYmxlU3RhdGljUmVuZGVyaW5nLCBpc1VzaW5nU3RhdGljUmVuZGVyaW5nLCBvYnNlcnZlckJhdGNoaW5nLCB1c2VBc09ic2VydmFibGVTb3VyY2UsIHVzZUxvY2FsT2JzZXJ2YWJsZSwgdXNlTG9jYWxTdG9yZSwgdXNlT2JzZXJ2ZXIsIHVzZVN0YXRpY1JlbmRlcmluZyB9IGZyb20gJ21vYngtcmVhY3QtbGl0ZSc7XG5cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIC8vRnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9jNjk5MDRhNTExYjkwMDI2NjkzNTE2ODIyMzA2M2RkODc3MmRmYzQwL3BhY2thZ2VzL2ZianMvc3JjL2NvcmUvc2hhbGxvd0VxdWFsLmpzXG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBGcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2M2OTkwNGE1MTFiOTAwMjY2OTM1MTY4MjIzMDYzZGQ4NzcyZGZjNDAvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9zaGFsbG93RXF1YWwuanNcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21yaWRnd2F5L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xudmFyIGhvaXN0QmxhY2tMaXN0ID0ge1xuICAkJHR5cGVvZjogMSxcbiAgcmVuZGVyOiAxLFxuICBjb21wYXJlOiAxLFxuICB0eXBlOiAxLFxuICBjaGlsZENvbnRleHRUeXBlczogMSxcbiAgY29udGV4dFR5cGU6IDEsXG4gIGNvbnRleHRUeXBlczogMSxcbiAgZGVmYXVsdFByb3BzOiAxLFxuICBnZXREZWZhdWx0UHJvcHM6IDEsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogMSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiAxLFxuICBtaXhpbnM6IDEsXG4gIGRpc3BsYXlOYW1lOiAxLFxuICBwcm9wVHlwZXM6IDFcbn07XG5mdW5jdGlvbiBjb3B5U3RhdGljUHJvcGVydGllcyhiYXNlLCB0YXJnZXQpIHtcbiAgdmFyIHByb3RvUHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZSkpO1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiYXNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWhvaXN0QmxhY2tMaXN0W2tleV0gJiYgcHJvdG9Qcm9wcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwga2V5KSk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogVXRpbGl0aWVzIGZvciBwYXRjaGluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgdG8gbWFrZSBzdXJlIEBkaXNwb3NlT25Vbm1vdW50IHdvcmtzIGNvcnJlY3RseSBpY20gd2l0aCB1c2VyIGRlZmluZWQgaG9va3NcbiAqIGFuZCB0aGUgaGFuZGxlciBwcm92aWRlZCBieSBtb2J4LXJlYWN0XG4gKi9cbnZhciBtb2J4TWl4aW5zID0gLyojX19QVVJFX18qL1N5bWJvbChcInBhdGNoTWl4aW5zXCIpO1xudmFyIG1vYnhQYXRjaGVkRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJwYXRjaGVkRGVmaW5pdGlvblwiKTtcbmZ1bmN0aW9uIGdldE1peGlucyh0YXJnZXQsIG1ldGhvZE5hbWUpIHtcbiAgdmFyIG1peGlucyA9IHRhcmdldFttb2J4TWl4aW5zXSA9IHRhcmdldFttb2J4TWl4aW5zXSB8fCB7fTtcbiAgdmFyIG1ldGhvZE1peGlucyA9IG1peGluc1ttZXRob2ROYW1lXSA9IG1peGluc1ttZXRob2ROYW1lXSB8fCB7fTtcbiAgbWV0aG9kTWl4aW5zLmxvY2tzID0gbWV0aG9kTWl4aW5zLmxvY2tzIHx8IDA7XG4gIG1ldGhvZE1peGlucy5tZXRob2RzID0gbWV0aG9kTWl4aW5zLm1ldGhvZHMgfHwgW107XG4gIHJldHVybiBtZXRob2RNaXhpbnM7XG59XG5mdW5jdGlvbiB3cmFwcGVyKHJlYWxNZXRob2QsIG1peGlucykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgLy8gbG9ja3MgYXJlIHVzZWQgdG8gZW5zdXJlIHRoYXQgbWl4aW5zIGFyZSBpbnZva2VkIG9ubHkgb25jZSBwZXIgaW52b2NhdGlvbiwgZXZlbiBvbiByZWN1cnNpdmUgY2FsbHNcbiAgbWl4aW5zLmxvY2tzKys7XG4gIHRyeSB7XG4gICAgdmFyIHJldFZhbDtcbiAgICBpZiAocmVhbE1ldGhvZCAhPT0gdW5kZWZpbmVkICYmIHJlYWxNZXRob2QgIT09IG51bGwpIHtcbiAgICAgIHJldFZhbCA9IHJlYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiByZXRWYWw7XG4gIH0gZmluYWxseSB7XG4gICAgbWl4aW5zLmxvY2tzLS07XG4gICAgaWYgKG1peGlucy5sb2NrcyA9PT0gMCkge1xuICAgICAgbWl4aW5zLm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobXgpIHtcbiAgICAgICAgbXguYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB3cmFwRnVuY3Rpb24ocmVhbE1ldGhvZCwgbWl4aW5zKSB7XG4gIHZhciBmbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICB3cmFwcGVyLmNhbGwuYXBwbHkod3JhcHBlciwgW3RoaXMsIHJlYWxNZXRob2QsIG1peGluc10uY29uY2F0KGFyZ3MpKTtcbiAgfTtcbiAgcmV0dXJuIGZuO1xufVxuZnVuY3Rpb24gcGF0Y2godGFyZ2V0LCBtZXRob2ROYW1lLCBtaXhpbk1ldGhvZCkge1xuICB2YXIgbWl4aW5zID0gZ2V0TWl4aW5zKHRhcmdldCwgbWV0aG9kTmFtZSk7XG4gIGlmIChtaXhpbnMubWV0aG9kcy5pbmRleE9mKG1peGluTWV0aG9kKSA8IDApIHtcbiAgICBtaXhpbnMubWV0aG9kcy5wdXNoKG1peGluTWV0aG9kKTtcbiAgfVxuICB2YXIgb2xkRGVmaW5pdGlvbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBtZXRob2ROYW1lKTtcbiAgaWYgKG9sZERlZmluaXRpb24gJiYgb2xkRGVmaW5pdGlvblttb2J4UGF0Y2hlZERlZmluaXRpb25dKSB7XG4gICAgLy8gYWxyZWFkeSBwYXRjaGVkIGRlZmluaXRpb24sIGRvIG5vdCByZXBhdGNoXG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvcmlnaW5hbE1ldGhvZCA9IHRhcmdldFttZXRob2ROYW1lXTtcbiAgdmFyIG5ld0RlZmluaXRpb24gPSBjcmVhdGVEZWZpbml0aW9uKHRhcmdldCwgbWV0aG9kTmFtZSwgb2xkRGVmaW5pdGlvbiA/IG9sZERlZmluaXRpb24uZW51bWVyYWJsZSA6IHVuZGVmaW5lZCwgbWl4aW5zLCBvcmlnaW5hbE1ldGhvZCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG1ldGhvZE5hbWUsIG5ld0RlZmluaXRpb24pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbih0YXJnZXQsIG1ldGhvZE5hbWUsIGVudW1lcmFibGUsIG1peGlucywgb3JpZ2luYWxNZXRob2QpIHtcbiAgdmFyIF9yZWY7XG4gIHZhciB3cmFwcGVkRnVuYyA9IHdyYXBGdW5jdGlvbihvcmlnaW5hbE1ldGhvZCwgbWl4aW5zKTtcbiAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZlttb2J4UGF0Y2hlZERlZmluaXRpb25dID0gdHJ1ZSwgX3JlZi5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHdyYXBwZWRGdW5jO1xuICB9LCBfcmVmLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIGlmICh0aGlzID09PSB0YXJnZXQpIHtcbiAgICAgIHdyYXBwZWRGdW5jID0gd3JhcEZ1bmN0aW9uKHZhbHVlLCBtaXhpbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3aGVuIGl0IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBwcm90b3R5cGUvYSBjaGlsZCBwcm90b3R5cGUgcGF0Y2ggdGhhdCBwYXJ0aWN1bGFyIGNhc2UgYWdhaW4gc2VwYXJhdGVseVxuICAgICAgLy8gc2luY2Ugd2UgbmVlZCB0byBzdG9yZSBzZXBhcmF0ZSB2YWx1ZXMgZGVwZW5kaW5nIG9uIHdldGhlciBpdCBpcyB0aGUgYWN0dWFsIGluc3RhbmNlLCB0aGUgcHJvdG90eXBlLCBldGNcbiAgICAgIC8vIGUuZy4gdGhlIG1ldGhvZCBmb3Igc3VwZXIgbWlnaHQgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBtZXRob2QgZm9yIHRoZSBwcm90b3R5cGUgd2hpY2ggbWlnaHQgYmUgbm90IHRoZSBzYW1lXG4gICAgICAvLyBhcyB0aGUgbWV0aG9kIGZvciB0aGUgaW5zdGFuY2VcbiAgICAgIHZhciBuZXdEZWZpbml0aW9uID0gY3JlYXRlRGVmaW5pdGlvbih0aGlzLCBtZXRob2ROYW1lLCBlbnVtZXJhYmxlLCBtaXhpbnMsIHZhbHVlKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBtZXRob2ROYW1lLCBuZXdEZWZpbml0aW9uKTtcbiAgICB9XG4gIH0sIF9yZWYuY29uZmlndXJhYmxlID0gdHJ1ZSwgX3JlZi5lbnVtZXJhYmxlID0gZW51bWVyYWJsZSwgX3JlZjtcbn1cblxudmFyIGFkbWluaXN0cmF0aW9uU3ltYm9sID0gLyojX19QVVJFX18qL1N5bWJvbChcIk9ic2VydmVyQWRtaW5pc3RyYXRpb25cIik7XG52YXIgaXNNb2JYUmVhY3RPYnNlcnZlclN5bWJvbCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJpc01vYlhSZWFjdE9ic2VydmVyXCIpO1xudmFyIG9ic2VydmFibGVQcm9wRGVzY3JpcHRvcnM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG9ic2VydmFibGVQcm9wRGVzY3JpcHRvcnMgPSB7XG4gICAgcHJvcHM6IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3IoXCJwcm9wc1wiKSxcbiAgICBzdGF0ZTogLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVQcm9wRGVzY3JpcHRvcihcInN0YXRlXCIpLFxuICAgIGNvbnRleHQ6IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3IoXCJjb250ZXh0XCIpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBZG1pbmlzdHJhdGlvbihjb21wb25lbnQpIHtcbiAgdmFyIF9jb21wb25lbnQkYWRtaW5pc3RyYTtcbiAgLy8gV2UgY3JlYXRlIGFkbWluaXN0cmF0aW9uIGxhemlseSwgYmVjYXVzZSB3ZSBjYW4ndCBwYXRjaCBjb25zdHJ1Y3RvclxuICAvLyBhbmQgdGhlIGV4YWN0IG1vbWVudCBvZiBpbml0aWFsaXphdGlvbiBwYXJ0aWFsbHkgZGVwZW5kcyBvbiBSZWFjdCBpbnRlcm5hbHMuXG4gIC8vIEF0IHRoZSB0aW1lIG9mIHdyaXRpbmcgdGhpcywgdGhlIGZpcnN0IHRoaW5nIGludm9rZWQgaXMgb25lIG9mIHRoZSBvYnNlcnZhYmxlIGdldHRlci9zZXR0ZXIgKHN0YXRlL3Byb3BzL2NvbnRleHQpLlxuICByZXR1cm4gKF9jb21wb25lbnQkYWRtaW5pc3RyYSA9IGNvbXBvbmVudFthZG1pbmlzdHJhdGlvblN5bWJvbF0pICE9IG51bGwgPyBfY29tcG9uZW50JGFkbWluaXN0cmEgOiBjb21wb25lbnRbYWRtaW5pc3RyYXRpb25TeW1ib2xdID0ge1xuICAgIHJlYWN0aW9uOiBudWxsLFxuICAgIG1vdW50ZWQ6IGZhbHNlLFxuICAgIHJlYWN0aW9uSW52YWxpZGF0ZWRCZWZvcmVNb3VudDogZmFsc2UsXG4gICAgZm9yY2VVcGRhdGU6IG51bGwsXG4gICAgbmFtZTogZ2V0RGlzcGxheU5hbWUoY29tcG9uZW50LmNvbnN0cnVjdG9yKSxcbiAgICBzdGF0ZTogdW5kZWZpbmVkLFxuICAgIHByb3BzOiB1bmRlZmluZWQsXG4gICAgY29udGV4dDogdW5kZWZpbmVkXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlQ2xhc3NDb21wb25lbnRPYnNlcnZlcihjb21wb25lbnRDbGFzcykge1xuICB2YXIgcHJvdG90eXBlID0gY29tcG9uZW50Q2xhc3MucHJvdG90eXBlO1xuICBpZiAoY29tcG9uZW50Q2xhc3NbaXNNb2JYUmVhY3RPYnNlcnZlclN5bWJvbF0pIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZShjb21wb25lbnRDbGFzcyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb3ZpZGVkIGNvbXBvbmVudCBjbGFzcyAoXCIgKyBkaXNwbGF5TmFtZSArIFwiKSBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkIGFzIGFuIG9ic2VydmVyIGNvbXBvbmVudC5cIik7XG4gIH0gZWxzZSB7XG4gICAgY29tcG9uZW50Q2xhc3NbaXNNb2JYUmVhY3RPYnNlcnZlclN5bWJvbF0gPSB0cnVlO1xuICB9XG4gIGlmIChwcm90b3R5cGUuY29tcG9uZW50V2lsbFJlYWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbXBvbmVudFdpbGxSZWFjdCBsaWZlLWN5Y2xlIGV2ZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7XG4gIH1cbiAgaWYgKGNvbXBvbmVudENsYXNzW1wiX19wcm90b19fXCJdICE9PSBQdXJlQ29tcG9uZW50KSB7XG4gICAgaWYgKCFwcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICBwcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gb2JzZXJ2ZXJTQ1U7XG4gICAgfSBlbHNlIGlmIChwcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSBvYnNlcnZlclNDVSkge1xuICAgICAgLy8gbi5iLiB1bmVxdWFsIGNoZWNrLCBpbnN0ZWFkIG9mIGV4aXN0ZW5jZSBjaGVjaywgYXMgQG9ic2VydmVyIG1pZ2h0IGJlIG9uIHN1cGVyY2xhc3MgYXMgd2VsbFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXQgaXMgbm90IGFsbG93ZWQgdG8gdXNlIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpbiBvYnNlcnZlciBiYXNlZCBjb21wb25lbnRzLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3RvdHlwZSwgb2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9ycyk7XG4gIH1cbiAgdmFyIG9yaWdpbmFsUmVuZGVyID0gcHJvdG90eXBlLnJlbmRlcjtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbFJlbmRlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIF9kaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKGNvbXBvbmVudENsYXNzKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdF0gY2xhc3MgY29tcG9uZW50IChcIiArIF9kaXNwbGF5TmFtZSArIFwiKSBpcyBtaXNzaW5nIGByZW5kZXJgIG1ldGhvZC5cIiArIFwiXFxuYG9ic2VydmVyYCByZXF1aXJlcyBgcmVuZGVyYCBiZWluZyBhIGZ1bmN0aW9uIGRlZmluZWQgb24gcHJvdG90eXBlLlwiICsgXCJcXG5gcmVuZGVyID0gKCkgPT4ge31gIG9yIGByZW5kZXIgPSBmdW5jdGlvbigpIHt9YCBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgfVxuICBwcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlbmRlclwiLCB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBzYWZlIHdheSB0byByZXBsYWNlIHJlbmRlciwgdGhlcmVmb3JlIGl0J3MgZm9yYmlkZGVuLlxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBpc1VzaW5nU3RhdGljUmVuZGVyaW5nKCkgPyBvcmlnaW5hbFJlbmRlciA6IGNyZWF0ZVJlYWN0aXZlUmVuZGVyLmNhbGwodGhpcywgb3JpZ2luYWxSZW5kZXIpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyKCk7XG4gIH07XG4gIHZhciBvcmlnaW5hbENvbXBvbmVudERpZE1vdW50ID0gcHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50O1xuICBwcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMuY29tcG9uZW50RGlkTW91bnQgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgdmFyIF9kaXNwbGF5TmFtZTIgPSBnZXREaXNwbGF5TmFtZShjb21wb25lbnRDbGFzcyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdF0gYG9ic2VydmVyKFwiICsgX2Rpc3BsYXlOYW1lMiArIFwiKS5jb21wb25lbnREaWRNb3VudGAgbXVzdCBiZSBkZWZpbmVkIG9uIHByb3RvdHlwZS5cIiArIFwiXFxuYGNvbXBvbmVudERpZE1vdW50ID0gKCkgPT4ge31gIG9yIGBjb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge31gIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICAvLyBgY29tcG9uZW50RGlkTW91bnRgIG1heSBub3QgYmUgY2FsbGVkIGF0IGFsbC4gUmVhY3QgY2FuIGFiYW5kb24gdGhlIGluc3RhbmNlIGFmdGVyIGByZW5kZXJgLlxuICAgIC8vIFRoYXQncyB3aHkgd2UgdXNlIGZpbmFsaXphdGlvbiByZWdpc3RyeSB0byBkaXNwb3NlIHJlYWN0aW9uIGNyZWF0ZWQgZHVyaW5nIHJlbmRlci5cbiAgICAvLyBIYXBwZW5zIHdpdGggYDxTdXNwZW5kPmAgc2VlICMzNDkyXG4gICAgLy9cbiAgICAvLyBgY29tcG9uZW50RGlkTW91bnRgIGNhbiBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYGNvbXBvbmVudFdpbGxVbm1vdW50YCB3aXRob3V0IGNhbGxpbmcgYHJlbmRlcmAgaW4gYmV0d2Vlbi5cbiAgICAvLyBIYXBwZW5zIHdpdGggYDxTdHJpY3RNb2RlPmBzZWUgIzMzOTUuXG4gICAgLy9cbiAgICAvLyBJZiBgY29tcG9uZW50RGlkTW91bnRgIGlzIGNhbGxlZCwgaXQncyBndWFyYW50ZWVkIHRvIHJ1biBzeW5jaHJvbm91c2x5IHdpdGggcmVuZGVyIChzaW1pbGFyeSB0byBgdXNlTGF5b3V0RWZmZWN0YCkuXG4gICAgLy8gVGhlcmVmb3JlIHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgZXh0ZXJuYWwgKG9ic2VydmFibGUpIHN0YXRlIGJlaW5nIHVwZGF0ZWQgYmVmb3JlIG1vdW50IChubyBzdGF0ZSB2ZXJzaW9uIGNoZWNraW5nKS5cbiAgICAvL1xuICAgIC8vIFRoaW5ncyBtYXkgY2hhbmdlOiBcIkluIHRoZSBmdXR1cmUsIFJlYWN0IHdpbGwgcHJvdmlkZSBhIGZlYXR1cmUgdGhhdCBsZXRzIGNvbXBvbmVudHMgcHJlc2VydmUgc3RhdGUgYmV0d2VlbiB1bm1vdW50c1wiXG4gICAgdmFyIGFkbWluID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpcyk7XG4gICAgYWRtaW4ubW91bnRlZCA9IHRydWU7XG4gICAgLy8gQ29tcG9uZW50IGluc3RhbmNlIGNvbW1pdHRlZCwgcHJldmVudCByZWFjdGlvbiBkaXNwb3NhbC5cbiAgICBfb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeS51bnJlZ2lzdGVyKHRoaXMpO1xuICAgIC8vIFdlIGRvbid0IHNldCBmb3JjZVVwZGF0ZSBiZWZvcmUgbW91bnQgYmVjYXVzZSBpdCByZXF1aXJlcyBhIHJlZmVyZW5jZSB0byBgdGhpc2AsXG4gICAgLy8gdGhlcmVmb3JlIGB0aGlzYCBjb3VsZCBOT1QgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYmVmb3JlIG1vdW50LFxuICAgIC8vIHByZXZlbnRpbmcgcmVhY3Rpb24gZGlzcG9zYWwgYnkgRmluYWxpemF0aW9uUmVnaXN0cnkgYW5kIGxlYWRpbmcgdG8gbWVtb3J5IGxlYWsuXG4gICAgLy8gQXMgYW4gYWx0ZXJuYXRpdmUgd2UgY291bGQgaGF2ZSBgYWRtaW4uaW5zdGFuY2VSZWYgPSBuZXcgV2Vha1JlZih0aGlzKWAsIGJ1dCBsZXRzIGF2b2lkIGl0IGlmIHBvc3NpYmxlLlxuICAgIGFkbWluLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfTtcbiAgICBpZiAoIWFkbWluLnJlYWN0aW9uIHx8IGFkbWluLnJlYWN0aW9uSW52YWxpZGF0ZWRCZWZvcmVNb3VudCkge1xuICAgICAgLy8gTWlzc2luZyByZWFjdGlvbjpcbiAgICAgIC8vIDEuIEluc3RhbmNlIHdhcyB1bm1vdW50ZWQgKHJlYWN0aW9uIGRpc3Bvc2VkKSBhbmQgaW1tZWRpYXRlbHkgcmVtb3VudGVkIHdpdGhvdXQgcnVubmluZyByZW5kZXIgIzMzOTUuXG4gICAgICAvLyAyLiBSZWFjdGlvbiB3YXMgZGlzcG9zZWQgYnkgZmluYWxpemF0aW9uIHJlZ2lzdHJ5IGJlZm9yZSBtb3VudC4gU2hvdWxkbid0IGV2ZXIgaGFwcGVuIGZvciBjbGFzcyBjb21wb25lbnRzOlxuICAgICAgLy8gYGNvbXBvbmVudERpZE1vdW50YCBydW5zIHN5bmNocm9ub3VzbHkgYWZ0ZXIgcmVuZGVyLCBidXQgb3VyIHJlZ2lzdHJ5IGFyZSBkZWZlcnJlZCAoY2FuJ3QgcnVuIGluIGJldHdlZW4pLlxuICAgICAgLy8gSW4gYW55IGNhc2Ugd2UgbG9zdCBzdWJzY3JpcHRpb25zIHRvIG9ic2VydmFibGVzLCBzbyB3ZSBoYXZlIHRvIGNyZWF0ZSBuZXcgcmVhY3Rpb24gYW5kIHJlLXJlbmRlciB0byByZXN1YnNjcmliZS5cbiAgICAgIC8vIFRoZSByZWFjdGlvbiB3aWxsIGJlIGNyZWF0ZWQgbGF6aWx5IGJ5IGZvbGxvd2luZyByZW5kZXIuXG4gICAgICAvLyBSZWFjdGlvbiBpbnZhbGlkYXRlZCBiZWZvcmUgbW91bnQ6XG4gICAgICAvLyAxLiBBIGRlc2NlbmRhbnQncyBgY29tcG9uZW5EaWRNb3VudGAgaW52YWxpZGF0ZWQgaXQncyBwYXJlbnQgIzM3MzBcbiAgICAgIGFkbWluLmZvcmNlVXBkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnaW5hbENvbXBvbmVudERpZE1vdW50ID09IG51bGwgPyB2b2lkIDAgOiBvcmlnaW5hbENvbXBvbmVudERpZE1vdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIC8vIFRPRE9AbWFqb3IgT3Zlcmx5IGNvbXBsaWNhdGVkIFwicGF0Y2hcIiBpcyBvbmx5IG5lZWRlZCB0byBzdXBwb3J0IHRoZSBkZXByZWNhdGVkIEBkaXNwb3NlT25Vbm1vdW50XG4gIHBhdGNoKHByb3RvdHlwZSwgXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hZG1pbiRyZWFjdGlvbjtcbiAgICBpZiAoaXNVc2luZ1N0YXRpY1JlbmRlcmluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhZG1pbiA9IGdldEFkbWluaXN0cmF0aW9uKHRoaXMpO1xuICAgIChfYWRtaW4kcmVhY3Rpb24gPSBhZG1pbi5yZWFjdGlvbikgPT0gbnVsbCB8fCBfYWRtaW4kcmVhY3Rpb24uZGlzcG9zZSgpO1xuICAgIGFkbWluLnJlYWN0aW9uID0gbnVsbDtcbiAgICBhZG1pbi5mb3JjZVVwZGF0ZSA9IG51bGw7XG4gICAgYWRtaW4ubW91bnRlZCA9IGZhbHNlO1xuICAgIGFkbWluLnJlYWN0aW9uSW52YWxpZGF0ZWRCZWZvcmVNb3VudCA9IGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIGNvbXBvbmVudENsYXNzO1xufVxuLy8gR2VuZXJhdGVzIGEgZnJpZW5kbHkgbmFtZSBmb3IgZGVidWdnaW5nXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShjb21wb25lbnRDbGFzcykge1xuICByZXR1cm4gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZSB8fCBcIjxjb21wb25lbnQ+XCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZVJlbmRlcihvcmlnaW5hbFJlbmRlcikge1xuICB2YXIgYm91bmRPcmlnaW5hbFJlbmRlciA9IG9yaWdpbmFsUmVuZGVyLmJpbmQodGhpcyk7XG4gIHZhciBhZG1pbiA9IGdldEFkbWluaXN0cmF0aW9uKHRoaXMpO1xuICBmdW5jdGlvbiByZWFjdGl2ZVJlbmRlcigpIHtcbiAgICBpZiAoIWFkbWluLnJlYWN0aW9uKSB7XG4gICAgICAvLyBDcmVhdGUgcmVhY3Rpb24gbGF6aWx5IHRvIHN1cHBvcnQgcmUtbW91bnRpbmcgIzMzOTVcbiAgICAgIGFkbWluLnJlYWN0aW9uID0gY3JlYXRlUmVhY3Rpb24oYWRtaW4pO1xuICAgICAgaWYgKCFhZG1pbi5tb3VudGVkKSB7XG4gICAgICAgIC8vIFJlYWN0IGNhbiBhYmFuZG9uIHRoaXMgaW5zdGFuY2UgYW5kIG5ldmVyIGNhbGwgYGNvbXBvbmVudERpZE1vdW50YC9gY29tcG9uZW50V2lsbFVubW91bnRgLFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSByZWFjdGlvbiB3aWxsIGJlIGRpc3Bvc2VkLlxuICAgICAgICBfb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCBhZG1pbiwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBlcnJvciA9IHVuZGVmaW5lZDtcbiAgICB2YXIgcmVuZGVyUmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgIGFkbWluLnJlYWN0aW9uLnRyYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRPRE9AbWFqb3JcbiAgICAgICAgLy8gT3B0aW1pemF0aW9uOiByZXBsYWNlIHdpdGggX2FsbG93U3RhdGVDaGFuZ2VzU3RhcnQvRW5kIChub3QgYXZhaWxhYmxlIGluIG1vYnhANi4wLjApXG4gICAgICAgIHJlbmRlclJlc3VsdCA9IF9hbGxvd1N0YXRlQ2hhbmdlcyhmYWxzZSwgYm91bmRPcmlnaW5hbFJlbmRlcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yID0gZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyUmVzdWx0O1xuICB9XG4gIHJldHVybiByZWFjdGl2ZVJlbmRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aW9uKGFkbWluKSB7XG4gIHJldHVybiBuZXcgUmVhY3Rpb24oYWRtaW4ubmFtZSArIFwiLnJlbmRlcigpXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWFkbWluLm1vdW50ZWQpIHtcbiAgICAgIC8vIFRoaXMgaXMgbmVjY2Vzc2FyeSB0byBhdm9pZCByZWFjdCB3YXJuaW5nIGFib3V0IGNhbGxpbmcgZm9yY2VVcGRhdGUgb24gY29tcG9uZW50IHRoYXQgaXNuJ3QgbW91bnRlZCB5ZXQuXG4gICAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiBjb21wb25lbnQgaXMgYWJhbmRvbmVkIGFmdGVyIHJlbmRlciAtIG91ciByZWFjdGlvbiBpcyBhbHJlYWR5IGNyZWF0ZWQgYW5kIHJlYWN0cyB0byBjaGFuZ2VzLlxuICAgICAgLy8gYGNvbXBvbmVuRGlkTW91bnRgIHJ1bnMgc3luY2hyb25vdXNseSBhZnRlciBgcmVuZGVyYCwgc28gdW5saWtlIGZ1bmN0aW9uYWwgY29tcG9uZW50LCB0aGVyZSBpcyBubyBkZWxheSBkdXJpbmcgd2hpY2ggdGhlIHJlYWN0aW9uIGNvdWxkIGJlIGludmFsaWRhdGVkLlxuICAgICAgLy8gSG93ZXZlciBgY29tcG9uZW50RGlkTW91bnRgIHJ1bnMgQUZURVIgaXQncyBkZXNjZW5kYW50cycgYGNvbXBvbmVudERpZE1vdW50YCwgd2hpY2ggQ0FOIGludmFsaWRhdGUgdGhlIHJlYWN0aW9uLCBzZWUgIzM3MzAuIFRoZXJlZm9yZSByZW1lbWJlciBhbmQgZm9yY2VVcGRhdGUgb24gbW91bnQuXG4gICAgICBhZG1pbi5yZWFjdGlvbkludmFsaWRhdGVkQmVmb3JlTW91bnQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYWRtaW4uZm9yY2VVcGRhdGUgPT0gbnVsbCB8fCBhZG1pbi5mb3JjZVVwZGF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB2YXIgX2FkbWluJHJlYWN0aW9uMjtcbiAgICAgIChfYWRtaW4kcmVhY3Rpb24yID0gYWRtaW4ucmVhY3Rpb24pID09IG51bGwgfHwgX2FkbWluJHJlYWN0aW9uMi5kaXNwb3NlKCk7XG4gICAgICBhZG1pbi5yZWFjdGlvbiA9IG51bGw7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVyU0NVKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gIGlmIChpc1VzaW5nU3RhdGljUmVuZGVyaW5nKCkpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieC1yZWFjdF0gSXQgc2VlbXMgdGhhdCBhIHJlLXJlbmRlcmluZyBvZiBhIFJlYWN0IGNvbXBvbmVudCBpcyB0cmlnZ2VyZWQgd2hpbGUgaW4gc3RhdGljIChzZXJ2ZXItc2lkZSkgbW9kZS4gUGxlYXNlIG1ha2Ugc3VyZSBjb21wb25lbnRzIGFyZSByZW5kZXJlZCBvbmx5IG9uY2Ugc2VydmVyLXNpZGUuXCIpO1xuICB9XG4gIC8vIHVwZGF0ZSBvbiBhbnkgc3RhdGUgY2hhbmdlcyAoYXMgaXMgdGhlIGRlZmF1bHQpXG4gIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyB1cGRhdGUgaWYgcHJvcHMgYXJlIHNoYWxsb3dseSBub3QgZXF1YWwsIGluc3BpcmVkIGJ5IFB1cmVSZW5kZXJNaXhpblxuICAvLyB3ZSBjb3VsZCByZXR1cm4ganVzdCAnZmFsc2UnIGhlcmUsIGFuZCBhdm9pZCB0aGUgYHNraXBSZW5kZXJgIGNoZWNrcyBldGNcbiAgLy8gaG93ZXZlciwgaXQgaXMgbmljZXIgaWYgbGlmZWN5Y2xlIGV2ZW50cyBhcmUgdHJpZ2dlcmVkIGxpa2UgdXN1YWxseSxcbiAgLy8gc28gd2UgcmV0dXJuIHRydWUgaGVyZSBpZiBwcm9wcyBhcmUgc2hhbGxvd2x5IG1vZGlmaWVkLlxuICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xufVxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9yKGtleSkge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGFkbWluID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpcyk7XG4gICAgICB2YXIgZGVyaXZhdGlvbiA9IF9nZXRHbG9iYWxTdGF0ZSgpLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgICAgIGlmIChkZXJpdmF0aW9uICYmIGRlcml2YXRpb24gIT09IGFkbWluLnJlYWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlttb2J4LXJlYWN0XSBDYW5ub3QgcmVhZCBcXFwiXCIgKyBhZG1pbi5uYW1lICsgXCIuXCIgKyBrZXkgKyBcIlxcXCIgaW4gYSByZWFjdGl2ZSBjb250ZXh0LCBhcyBpdCBpc24ndCBvYnNlcnZhYmxlLlxcbiAgICAgICAgICAgICAgICAgICAgUGxlYXNlIHVzZSBjb21wb25lbnQgbGlmZWN5Y2xlIG1ldGhvZCB0byBjb3B5IHRoZSB2YWx1ZSBpbnRvIGEgbG9jYWwgb2JzZXJ2YWJsZSBmaXJzdC5cXG4gICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvYmxvYi9tYWluL3BhY2thZ2VzL21vYngtcmVhY3QvUkVBRE1FLm1kI25vdGUtb24tdXNpbmctcHJvcHMtYW5kLXN0YXRlLWluLWRlcml2YXRpb25zXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkbWluW2tleV07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgZ2V0QWRtaW5pc3RyYXRpb24odGhpcylba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZXIoY29tcG9uZW50LCBjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0ICYmIGNvbnRleHQua2luZCAhPT0gXCJjbGFzc1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEBvYnNlcnZlciBkZWNvcmF0b3IgY2FuIGJlIHVzZWQgb24gY2xhc3NlcyBvbmx5XCIpO1xuICB9XG4gIGlmIChjb21wb25lbnRbXCJpc01vYnhJbmplY3RvclwiXSA9PT0gdHJ1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIk1vYnggb2JzZXJ2ZXI6IFlvdSBhcmUgdHJ5aW5nIHRvIHVzZSBgb2JzZXJ2ZXJgIG9uIGEgY29tcG9uZW50IHRoYXQgYWxyZWFkeSBoYXMgYGluamVjdGAuIFBsZWFzZSBhcHBseSBgb2JzZXJ2ZXJgIGJlZm9yZSBhcHBseWluZyBgaW5qZWN0YFwiKTtcbiAgfVxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoQ29tcG9uZW50LCBjb21wb25lbnQpIHx8IE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKFB1cmVDb21wb25lbnQsIGNvbXBvbmVudCkpIHtcbiAgICAvLyBDbGFzcyBjb21wb25lbnRcbiAgICByZXR1cm4gbWFrZUNsYXNzQ29tcG9uZW50T2JzZXJ2ZXIoY29tcG9uZW50KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGdW5jdGlvbiBjb21wb25lbnRcbiAgICByZXR1cm4gb2JzZXJ2ZXIkMShjb21wb25lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAobikge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoZS5pbmRleE9mKG4pID49IDApIGNvbnRpbnVlO1xuICAgIHRbbl0gPSByW25dO1xuICB9XG4gIHJldHVybiB0O1xufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wiY2hpbGRyZW5cIl07XG52YXIgTW9iWFByb3ZpZGVyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVDb250ZXh0KHt9KTtcbmZ1bmN0aW9uIFByb3ZpZGVyKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgIHN0b3JlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQpO1xuICB2YXIgcGFyZW50VmFsdWUgPSBSZWFjdF9fZGVmYXVsdC51c2VDb250ZXh0KE1vYlhQcm92aWRlckNvbnRleHQpO1xuICB2YXIgbXV0YWJsZVByb3ZpZGVyUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKF9leHRlbmRzKHt9LCBwYXJlbnRWYWx1ZSwgc3RvcmVzKSk7XG4gIHZhciB2YWx1ZSA9IG11dGFibGVQcm92aWRlclJlZi5jdXJyZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIG5ld1ZhbHVlID0gX2V4dGVuZHMoe30sIHZhbHVlLCBzdG9yZXMpOyAvLyBzcHJlYWQgaW4gcHJldmlvdXMgc3RhdGUgZm9yIHRoZSBjb250ZXh0IGJhc2VkIHN0b3Jlc1xuICAgIGlmICghc2hhbGxvd0VxdWFsKHZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vYlggUHJvdmlkZXI6IFRoZSBzZXQgb2YgcHJvdmlkZWQgc3RvcmVzIGhhcyBjaGFuZ2VkLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1yZWFjdCN0aGUtc2V0LW9mLXByb3ZpZGVkLXN0b3Jlcy1oYXMtY2hhbmdlZC1lcnJvci5cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1vYlhQcm92aWRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSwgY2hpbGRyZW4pO1xufVxuUHJvdmlkZXIuZGlzcGxheU5hbWUgPSBcIk1vYlhQcm92aWRlclwiO1xuXG4vKipcbiAqIFN0b3JlIEluamVjdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVTdG9yZUluamVjdG9yKGdyYWJTdG9yZXNGbiwgY29tcG9uZW50LCBpbmplY3ROYW1lcywgbWFrZVJlYWN0aXZlKSB7XG4gIC8vIFN1cHBvcnQgZm9yd2FyZCByZWZzXG4gIHZhciBJbmplY3RvciA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgICB2YXIgbmV3UHJvcHMgPSBfZXh0ZW5kcyh7fSwgcHJvcHMpO1xuICAgIHZhciBjb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChNb2JYUHJvdmlkZXJDb250ZXh0KTtcbiAgICBPYmplY3QuYXNzaWduKG5ld1Byb3BzLCBncmFiU3RvcmVzRm4oY29udGV4dCB8fCB7fSwgbmV3UHJvcHMpIHx8IHt9KTtcbiAgICBpZiAocmVmKSB7XG4gICAgICBuZXdQcm9wcy5yZWYgPSByZWY7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgbmV3UHJvcHMpO1xuICB9KTtcbiAgaWYgKG1ha2VSZWFjdGl2ZSkgSW5qZWN0b3IgPSBvYnNlcnZlcihJbmplY3Rvcik7XG4gIEluamVjdG9yW1wiaXNNb2J4SW5qZWN0b3JcIl0gPSB0cnVlOyAvLyBhc3NpZ25lZCBsYXRlIHRvIHN1cHByZXNzIG9ic2VydmVyIHdhcm5pbmdcbiAgLy8gU3RhdGljIGZpZWxkcyBmcm9tIGNvbXBvbmVudCBzaG91bGQgYmUgdmlzaWJsZSBvbiB0aGUgZ2VuZXJhdGVkIEluamVjdG9yXG4gIGNvcHlTdGF0aWNQcm9wZXJ0aWVzKGNvbXBvbmVudCwgSW5qZWN0b3IpO1xuICBJbmplY3RvcltcIndyYXBwZWRDb21wb25lbnRcIl0gPSBjb21wb25lbnQ7XG4gIEluamVjdG9yLmRpc3BsYXlOYW1lID0gZ2V0SW5qZWN0TmFtZShjb21wb25lbnQsIGluamVjdE5hbWVzKTtcbiAgcmV0dXJuIEluamVjdG9yO1xufVxuZnVuY3Rpb24gZ2V0SW5qZWN0TmFtZShjb21wb25lbnQsIGluamVjdE5hbWVzKSB7XG4gIHZhciBkaXNwbGF5TmFtZTtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Lm5hbWUgfHwgY29tcG9uZW50LmNvbnN0cnVjdG9yICYmIGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiQ29tcG9uZW50XCI7XG4gIGlmIChpbmplY3ROYW1lcykgZGlzcGxheU5hbWUgPSBcImluamVjdC13aXRoLVwiICsgaW5qZWN0TmFtZXMgKyBcIihcIiArIGNvbXBvbmVudE5hbWUgKyBcIilcIjtlbHNlIGRpc3BsYXlOYW1lID0gXCJpbmplY3QoXCIgKyBjb21wb25lbnROYW1lICsgXCIpXCI7XG4gIHJldHVybiBkaXNwbGF5TmFtZTtcbn1cbmZ1bmN0aW9uIGdyYWJTdG9yZXNCeU5hbWUoc3RvcmVOYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24gKGJhc2VTdG9yZXMsIG5leHRQcm9wcykge1xuICAgIHN0b3JlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG4gICAgICBpZiAoc3RvcmVOYW1lIGluIG5leHRQcm9wcyAvLyBwcmVmZXIgcHJvcHMgb3ZlciBzdG9yZXNcbiAgICAgICkgcmV0dXJuO1xuICAgICAgaWYgKCEoc3RvcmVOYW1lIGluIGJhc2VTdG9yZXMpKSB0aHJvdyBuZXcgRXJyb3IoXCJNb2JYIGluamVjdG9yOiBTdG9yZSAnXCIgKyBzdG9yZU5hbWUgKyBcIicgaXMgbm90IGF2YWlsYWJsZSEgTWFrZSBzdXJlIGl0IGlzIHByb3ZpZGVkIGJ5IHNvbWUgUHJvdmlkZXJcIik7XG4gICAgICBuZXh0UHJvcHNbc3RvcmVOYW1lXSA9IGJhc2VTdG9yZXNbc3RvcmVOYW1lXTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dFByb3BzO1xuICB9O1xufVxuLyoqXG4gKiBoaWdoZXIgb3JkZXIgY29tcG9uZW50IHRoYXQgaW5qZWN0cyBzdG9yZXMgdG8gYSBjaGlsZC5cbiAqIHRha2VzIGVpdGhlciBhIHZhcmFyZ3MgbGlzdCBvZiBzdHJpbmdzLCB3aGljaCBhcmUgc3RvcmVzIHJlYWQgZnJvbSB0aGUgY29udGV4dCxcbiAqIG9yIGEgZnVuY3Rpb24gdGhhdCBtYW51YWxseSBtYXBzIHRoZSBhdmFpbGFibGUgc3RvcmVzIGZyb20gdGhlIGNvbnRleHQgdG8gcHJvcHM6XG4gKiBzdG9yZXNUb1Byb3BzKG1vYnhTdG9yZXMsIHByb3BzLCBjb250ZXh0KSA9PiBuZXdQcm9wc1xuICovXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdG9yZU5hbWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0b3JlTmFtZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBncmFiU3RvcmVzRm4gPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVN0b3JlSW5qZWN0b3IoZ3JhYlN0b3Jlc0ZuLCBjb21wb25lbnRDbGFzcywgZ3JhYlN0b3Jlc0ZuLm5hbWUsIHRydWUpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVN0b3JlSW5qZWN0b3IoZ3JhYlN0b3Jlc0J5TmFtZShzdG9yZU5hbWVzKSwgY29tcG9uZW50Q2xhc3MsIHN0b3JlTmFtZXMuam9pbihcIi1cIiksIGZhbHNlKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciByZWFjdE1ham9yVmVyc2lvbiA9IC8qI19fUFVSRV9fKi9OdW1iZXIucGFyc2VJbnQoIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC52ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSk7XG52YXIgd2FybmVkQWJvdXREaXNwb3NlT25Vbm1vdW50RGVwcmVjYXRlZCA9IGZhbHNlO1xudmFyIHByb3RvU3RvcmVLZXkgPSAvKiNfX1BVUkVfXyovU3ltYm9sKFwiZGlzcG9zZU9uVW5tb3VudFByb3RvXCIpO1xudmFyIGluc3RTdG9yZUtleSA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJkaXNwb3NlT25Vbm1vdW50SW5zdFwiKTtcbmZ1bmN0aW9uIHJ1bkRpc3Bvc2Vyc09uV2lsbFVubW91bnQoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIFtdLmNvbmNhdCh0aGlzW3Byb3RvU3RvcmVLZXldIHx8IFtdLCB0aGlzW2luc3RTdG9yZUtleV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHByb3BLZXlPckZ1bmN0aW9uKSB7XG4gICAgdmFyIHByb3AgPSB0eXBlb2YgcHJvcEtleU9yRnVuY3Rpb24gPT09IFwic3RyaW5nXCIgPyBfdGhpc1twcm9wS2V5T3JGdW5jdGlvbl0gOiBwcm9wS2V5T3JGdW5jdGlvbjtcbiAgICBpZiAocHJvcCAhPT0gdW5kZWZpbmVkICYmIHByb3AgIT09IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ApKSBwcm9wLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgICAgfSk7ZWxzZSBwcm9wKCk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgYGRpc3Bvc2VPblVubW91bnRgIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggUmVhY3QgMTggYW5kIGhpZ2hlci5cbiAqL1xuZnVuY3Rpb24gZGlzcG9zZU9uVW5tb3VudCh0YXJnZXQsIHByb3BlcnR5S2V5T3JGdW5jdGlvbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eUtleU9yRnVuY3Rpb24pKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5T3JGdW5jdGlvbi5tYXAoZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZGlzcG9zZU9uVW5tb3VudCh0YXJnZXQsIGZuKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIXdhcm5lZEFib3V0RGlzcG9zZU9uVW5tb3VudERlcHJlY2F0ZWQpIHtcbiAgICBpZiAocmVhY3RNYWpvclZlcnNpb24gPj0gMTgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbbW9ieC1yZWFjdF0gZGlzcG9zZU9uVW5tb3VudCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIFJlYWN0IDE4IGFuZCBoaWdoZXIuIERvbid0IHVzZSBpdC5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlttb2J4LXJlYWN0XSBkaXNwb3NlT25Vbm1vdW50IGlzIGRlcHJlY2F0ZWQuIEl0IHdvbid0IHdvcmsgY29ycmVjdGx5IHdpdGggUmVhY3QgMTggYW5kIGhpZ2hlci5cIik7XG4gICAgfVxuICAgIHdhcm5lZEFib3V0RGlzcG9zZU9uVW5tb3VudERlcHJlY2F0ZWQgPSB0cnVlO1xuICB9XG4gIHZhciBjID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkuY29uc3RydWN0b3I7XG4gIHZhciBjMiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQuY29uc3RydWN0b3IpO1xuICAvLyBTcGVjaWFsIGNhc2UgZm9yIHJlYWN0LWhvdC1sb2FkZXJcbiAgdmFyIGMzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpKTtcbiAgaWYgKCEoYyA9PT0gUmVhY3RfX2RlZmF1bHQuQ29tcG9uZW50IHx8IGMgPT09IFJlYWN0X19kZWZhdWx0LlB1cmVDb21wb25lbnQgfHwgYzIgPT09IFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCB8fCBjMiA9PT0gUmVhY3RfX2RlZmF1bHQuUHVyZUNvbXBvbmVudCB8fCBjMyA9PT0gUmVhY3RfX2RlZmF1bHQuQ29tcG9uZW50IHx8IGMzID09PSBSZWFjdF9fZGVmYXVsdC5QdXJlQ29tcG9uZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlttb2J4LXJlYWN0XSBkaXNwb3NlT25Vbm1vdW50IG9ubHkgc3VwcG9ydHMgZGlyZWN0IHN1YmNsYXNzZXMgb2YgUmVhY3QuQ29tcG9uZW50IG9yIFJlYWN0LlB1cmVDb21wb25lbnQuXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcGVydHlLZXlPckZ1bmN0aW9uICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcm9wZXJ0eUtleU9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIiAmJiAhQXJyYXkuaXNBcnJheShwcm9wZXJ0eUtleU9yRnVuY3Rpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYngtcmVhY3RdIGRpc3Bvc2VPblVubW91bnQgb25seSB3b3JrcyBpZiB0aGUgcGFyYW1ldGVyIGlzIGVpdGhlciBhIHByb3BlcnR5IGtleSBvciBhIGZ1bmN0aW9uLlwiKTtcbiAgfVxuICAvLyBkZWNvcmF0b3IncyB0YXJnZXQgaXMgdGhlIHByb3RvdHlwZSwgc28gaXQgZG9lc24ndCBoYXZlIGFueSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGxpa2UgcHJvcHNcbiAgdmFyIGlzRGVjb3JhdG9yID0gdHlwZW9mIHByb3BlcnR5S2V5T3JGdW5jdGlvbiA9PT0gXCJzdHJpbmdcIjtcbiAgLy8gYWRkIHByb3BlcnR5IGtleSAvIGZ1bmN0aW9uIHdlIHdhbnQgcnVuIChkaXNwb3NlZCkgdG8gdGhlIHN0b3JlXG4gIHZhciBjb21wb25lbnRXYXNBbHJlYWR5TW9kaWZpZWQgPSAhIXRhcmdldFtwcm90b1N0b3JlS2V5XSB8fCAhIXRhcmdldFtpbnN0U3RvcmVLZXldO1xuICB2YXIgc3RvcmUgPSBpc0RlY29yYXRvciA/XG4gIC8vIGRlY29yYXRvcnMgYXJlIGFkZGVkIHRvIHRoZSBwcm90b3R5cGUgc3RvcmVcbiAgdGFyZ2V0W3Byb3RvU3RvcmVLZXldIHx8ICh0YXJnZXRbcHJvdG9TdG9yZUtleV0gPSBbXSkgOlxuICAvLyBmdW5jdGlvbnMgYXJlIGFkZGVkIHRvIHRoZSBpbnN0YW5jZSBzdG9yZVxuICB0YXJnZXRbaW5zdFN0b3JlS2V5XSB8fCAodGFyZ2V0W2luc3RTdG9yZUtleV0gPSBbXSk7XG4gIHN0b3JlLnB1c2gocHJvcGVydHlLZXlPckZ1bmN0aW9uKTtcbiAgLy8gdHdlYWsgdGhlIGNvbXBvbmVudCBjbGFzcyBjb21wb25lbnRXaWxsVW5tb3VudCBpZiBub3QgZG9uZSBhbHJlYWR5XG4gIGlmICghY29tcG9uZW50V2FzQWxyZWFkeU1vZGlmaWVkKSB7XG4gICAgcGF0Y2godGFyZ2V0LCBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsIHJ1bkRpc3Bvc2Vyc09uV2lsbFVubW91bnQpO1xuICB9XG4gIC8vIHJldHVybiB0aGUgZGlzcG9zZXIgYXMgaXMgaWYgaW52b2tlZCBhcyBhIG5vbiBkZWNvcmF0b3JcbiAgaWYgKHR5cGVvZiBwcm9wZXJ0eUtleU9yRnVuY3Rpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcHJvcGVydHlLZXlPckZ1bmN0aW9uO1xuICB9XG59XG5cbi8vIENvcGllZCBmcm9tIFJlYWN0LlByb3BUeXBlc1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdG9yKSB7XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gNiA/IF9sZW4gLSA2IDogMCksIF9rZXkgPSA2OyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICByZXN0W19rZXkgLSA2XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBcIjw8YW5vbnltb3VzPj5cIjtcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIHZhciBhY3R1YWwgPSBwcm9wc1twcm9wTmFtZV0gPT09IG51bGwgPyBcIm51bGxcIiA6IFwidW5kZWZpbmVkXCI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIlRoZSBcIiArIGxvY2F0aW9uICsgXCIgYFwiICsgcHJvcEZ1bGxOYW1lICsgXCJgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBcIiArIFwiaW4gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgYnV0IGl0cyB2YWx1ZSBpcyBgXCIgKyBhY3R1YWwgKyBcImAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSByZXN0IGFyZyBpcyBuZWNlc3NhcnkgZm9yIHNvbWUgUmVhY3QgaW50ZXJuYWxzIC0gZmFpbHMgdGVzdHMgb3RoZXJ3aXNlXG4gICAgICAgIHJldHVybiB2YWxpZGF0b3IuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAvLyBBZGQgaXNSZXF1aXJlZCB0byBzYXRpc2Z5IFJlcXVpcmFibGVcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuLy8gQ29waWVkIGZyb20gUmVhY3QuUHJvcFR5cGVzXG5mdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gIC8vIE5hdGl2ZSBTeW1ib2wuXG4gIGlmIChwcm9wVHlwZSA9PT0gXCJzeW1ib2xcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gIGlmIChwcm9wVmFsdWVbXCJAQHRvU3RyaW5nVGFnXCJdID09PSBcIlN5bWJvbFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIENvcGllZCBmcm9tIFJlYWN0LlByb3BUeXBlc1xuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9XG4gIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuIFwic3ltYm9sXCI7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuLy8gQ29waWVkIGZyb20gUmVhY3QuUHJvcFR5cGVzXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgaWYgKHByb3BUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIFwicmVnZXhwXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVUeXBlQ2hlY2tlckNyZWF0b3IoYWxsb3dOYXRpdmVUeXBlLCBtb2J4VHlwZSkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHJldHVybiB1bnRyYWNrZWQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGFsbG93TmF0aXZlVHlwZSkge1xuICAgICAgICBpZiAoZ2V0UHJvcFR5cGUocHJvcHNbcHJvcE5hbWVdKSA9PT0gbW9ieFR5cGUudG9Mb3dlckNhc2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbW9ieENoZWNrZXI7XG4gICAgICBzd2l0Y2ggKG1vYnhUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgIG1vYnhDaGVja2VyID0gaXNPYnNlcnZhYmxlQXJyYXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICAgICAgICBtb2J4Q2hlY2tlciA9IGlzT2JzZXJ2YWJsZU9iamVjdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1hcFwiOlxuICAgICAgICAgIG1vYnhDaGVja2VyID0gaXNPYnNlcnZhYmxlTWFwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbW9ieFR5cGU6IFwiICsgbW9ieFR5cGUpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghbW9ieENoZWNrZXIocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICB2YXIgbmF0aXZlVHlwZUV4cGVjdGF0aW9uTWVzc2FnZSA9IGFsbG93TmF0aXZlVHlwZSA/IFwiIG9yIGphdmFzY3JpcHQgYFwiICsgbW9ieFR5cGUudG9Mb3dlckNhc2UoKSArIFwiYFwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkludmFsaWQgcHJvcCBgXCIgKyBwcm9wRnVsbE5hbWUgKyBcImAgb2YgdHlwZSBgXCIgKyBwcmVjaXNlVHlwZSArIFwiYCBzdXBwbGllZCB0b1wiICsgXCIgYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgYG1vYnguT2JzZXJ2YWJsZVwiICsgbW9ieFR5cGUgKyBcImBcIiArIG5hdGl2ZVR5cGVFeHBlY3RhdGlvbk1lc3NhZ2UgKyBcIi5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlQXJyYXlPZlR5cGVDaGVja2VyKGFsbG93TmF0aXZlVHlwZSwgdHlwZUNoZWNrZXIpIHtcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjIgPiA1ID8gX2xlbjIgLSA1IDogMCksIF9rZXkyID0gNTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgcmVzdFtfa2V5MiAtIDVdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgcmV0dXJuIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIlByb3BlcnR5IGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBvZiBjb21wb25lbnQgYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCBoYXMgXCIgKyBcImludmFsaWQgUHJvcFR5cGUgbm90YXRpb24uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yID0gY3JlYXRlT2JzZXJ2YWJsZVR5cGVDaGVja2VyQ3JlYXRvcihhbGxvd05hdGl2ZVR5cGUsIFwiQXJyYXlcIikocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBlcnJvcjtcbiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlcnJvciA9IHR5cGVDaGVja2VyLmFwcGx5KHZvaWQgMCwgW3Byb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArIFwiW1wiICsgaSArIFwiXVwiXS5jb25jYXQocmVzdCkpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxudmFyIG9ic2VydmFibGVBcnJheSA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlVHlwZUNoZWNrZXJDcmVhdG9yKGZhbHNlLCBcIkFycmF5XCIpO1xudmFyIG9ic2VydmFibGVBcnJheU9mID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVBcnJheU9mVHlwZUNoZWNrZXIuYmluZChudWxsLCBmYWxzZSk7XG52YXIgb2JzZXJ2YWJsZU1hcCA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlVHlwZUNoZWNrZXJDcmVhdG9yKGZhbHNlLCBcIk1hcFwiKTtcbnZhciBvYnNlcnZhYmxlT2JqZWN0ID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVUeXBlQ2hlY2tlckNyZWF0b3IoZmFsc2UsIFwiT2JqZWN0XCIpO1xudmFyIGFycmF5T3JPYnNlcnZhYmxlQXJyYXkgPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZVR5cGVDaGVja2VyQ3JlYXRvcih0cnVlLCBcIkFycmF5XCIpO1xudmFyIGFycmF5T3JPYnNlcnZhYmxlQXJyYXlPZiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQXJyYXlPZlR5cGVDaGVja2VyLmJpbmQobnVsbCwgdHJ1ZSk7XG52YXIgb2JqZWN0T3JPYnNlcnZhYmxlT2JqZWN0ID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVUeXBlQ2hlY2tlckNyZWF0b3IodHJ1ZSwgXCJPYmplY3RcIik7XG52YXIgUHJvcFR5cGVzID0ge1xuICBvYnNlcnZhYmxlQXJyYXk6IG9ic2VydmFibGVBcnJheSxcbiAgb2JzZXJ2YWJsZUFycmF5T2Y6IG9ic2VydmFibGVBcnJheU9mLFxuICBvYnNlcnZhYmxlTWFwOiBvYnNlcnZhYmxlTWFwLFxuICBvYnNlcnZhYmxlT2JqZWN0OiBvYnNlcnZhYmxlT2JqZWN0LFxuICBhcnJheU9yT2JzZXJ2YWJsZUFycmF5OiBhcnJheU9yT2JzZXJ2YWJsZUFycmF5LFxuICBhcnJheU9yT2JzZXJ2YWJsZUFycmF5T2Y6IGFycmF5T3JPYnNlcnZhYmxlQXJyYXlPZixcbiAgb2JqZWN0T3JPYnNlcnZhYmxlT2JqZWN0OiBvYmplY3RPck9ic2VydmFibGVPYmplY3Rcbn07XG5cbmlmICghQ29tcG9uZW50KSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm1vYngtcmVhY3QgcmVxdWlyZXMgUmVhY3QgdG8gYmUgYXZhaWxhYmxlXCIpO1xufVxuaWYgKCFvYnNlcnZhYmxlKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm1vYngtcmVhY3QgcmVxdWlyZXMgbW9ieCB0byBiZSBhdmFpbGFibGVcIik7XG59XG5cbmV4cG9ydCB7IE1vYlhQcm92aWRlckNvbnRleHQsIFByb3BUeXBlcywgUHJvdmlkZXIsIGRpc3Bvc2VPblVubW91bnQsIGluamVjdCwgb2JzZXJ2ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vYnhyZWFjdC5lc20uanMubWFwXG4iLCJleHBvcnQgY29uc3QgVEFTS19UQUJMRV9OQU1FID0gJ3Rhc2snOyIsImV4cG9ydCBjb25zdCBnZXRDb25uZWN0aW9uID0gKHRhYmxlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxJREJEYXRhYmFzZT4gPT4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgY29uc3QgSURCID0gaW5kZXhlZERCLm9wZW4odGFibGVOYW1lLCAxKVxuXG4gICAgSURCLm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKElEQi5yZXN1bHQub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIElEQi5yZXN1bHQuY3JlYXRlT2JqZWN0U3RvcmUodGFibGVOYW1lLCB7XG4gICAgICAgICAgICBrZXlQYXRoOiAnaWQnLFxuICAgICAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIElEQi5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgIHJlcyhJREIucmVzdWx0KVxuICAgIH1cblxuICAgIElEQi5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICByZWooSURCLmVycm9yKVxuICAgIH1cbn0pIiwiaW1wb3J0IHtUQVNLX1RBQkxFX05BTUV9IGZyb20gXCJAc3JjL2VudGl0aWVzL3Rhc2svY29uZmlnXCI7XG5pbXBvcnQge2dldENvbm5lY3Rpb259IGZyb20gJ0BzcmMvc2hhcmVkL2FwaS9pbmRleGVkLWRiL2luZGV4ZWREQidcbmltcG9ydCB7VGFza30gZnJvbSBcIkBzcmMvZW50aXRpZXMvdGFzay9tb2RlbFwiO1xuaW1wb3J0IHtJREJNb2RlbH0gZnJvbSBcIkBzcmMvc2hhcmVkL21vZGVsL2luZGV4ZWQtZGIvaWRiLXJlc3VsdFwiO1xuXG50eXBlIFJldHVyblZhbHVlID0gUHJvbWlzZTxJREJNb2RlbDxUYXNrPltdPlxuXG5leHBvcnQgY29uc3QgZ2V0QWxsVGFza3MgPSBhc3luYyAoKTogUmV0dXJuVmFsdWUgPT4ge1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBnZXRDb25uZWN0aW9uKFRBU0tfVEFCTEVfTkFNRSlcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNvbm5lY3Rpb24udHJhbnNhY3Rpb24oVEFTS19UQUJMRV9OQU1FLCAncmVhZG9ubHknKVxuICAgIGNvbnN0IHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShUQVNLX1RBQkxFX05BTUUpLmdldEFsbCgpXG4gICAgY29uc3QgdGFza3M6IFJldHVyblZhbHVlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzKHJlcXVlc3QucmVzdWx0KVxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWoocmVxdWVzdC5lcnJvcilcbiAgICB9KVxuICAgIGNvbm5lY3Rpb24uY2xvc2UoKVxuICAgIHJldHVybiBhd2FpdCB0YXNrc1xufSIsImltcG9ydCB7VGFza30gZnJvbSBcIkBzcmMvZW50aXRpZXMvdGFzay9tb2RlbFwiO1xuaW1wb3J0IHtnZXRDb25uZWN0aW9ufSBmcm9tIFwiQHNyYy9zaGFyZWQvYXBpL2luZGV4ZWQtZGIvaW5kZXhlZERCXCI7XG5pbXBvcnQge1RBU0tfVEFCTEVfTkFNRX0gZnJvbSBcIkBzcmMvZW50aXRpZXMvdGFzay9jb25maWdcIjtcblxuZXhwb3J0IHR5cGUgQ3JlYXRlVGFza0RhdGEgPSBPbWl0PFRhc2ssICdjcmVhdGVkQXQnIHwgJ2lkJz5cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRhc2sgPSBhc3luYyAoZGF0YTogQ3JlYXRlVGFza0RhdGEpOiBQcm9taXNlPElEQlZhbGlkS2V5IHwgRE9NRXhjZXB0aW9uPiA9PiB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IGdldENvbm5lY3Rpb24oVEFTS19UQUJMRV9OQU1FKVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY29ubmVjdGlvbi50cmFuc2FjdGlvbihUQVNLX1RBQkxFX05BTUUsICdyZWFkd3JpdGUnKVxuICAgIGNvbnN0IHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShUQVNLX1RBQkxFX05BTUUpLmFkZCh7XG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgLi4uZGF0YVxuICAgIH0pXG4gICAgY29uc3QgcmVzdWx0OiBQcm9taXNlPElEQlZhbGlkS2V5IHwgRE9NRXhjZXB0aW9uPiA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlcyhyZXF1ZXN0LnJlc3VsdClcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqKHJlcXVlc3QuZXJyb3IpXG4gICAgfSlcbiAgICBjb25uZWN0aW9uLmNsb3NlKClcbiAgICByZXR1cm4gYXdhaXQgcmVzdWx0XG59IiwiaW1wb3J0IHtnZXRDb25uZWN0aW9ufSBmcm9tIFwiQHNyYy9zaGFyZWQvYXBpL2luZGV4ZWQtZGIvaW5kZXhlZERCXCI7XG5pbXBvcnQge1RBU0tfVEFCTEVfTkFNRX0gZnJvbSBcIkBzcmMvZW50aXRpZXMvdGFzay9jb25maWdcIjtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVRhc2sgPSBhc3luYyAoaWQ6IElEQlZhbGlkS2V5KSA9PiB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IGdldENvbm5lY3Rpb24oVEFTS19UQUJMRV9OQU1FKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNvbm5lY3Rpb24udHJhbnNhY3Rpb24oVEFTS19UQUJMRV9OQU1FLCAncmVhZHdyaXRlJyk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFRBU0tfVEFCTEVfTkFNRSkuZGVsZXRlKGlkKVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzKHJlcXVlc3QucmVzdWx0KVxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWoocmVxdWVzdC5lcnJvcilcbiAgICB9KVxuICAgIGNvbm5lY3Rpb24uY2xvc2UoKVxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZVxufSIsImltcG9ydCB7bWFrZUF1dG9PYnNlcnZhYmxlLCBydW5JbkFjdGlvbn0gZnJvbSBcIm1vYnhcIjtcbmltcG9ydCB7VGFza30gZnJvbSBcIkBzcmMvZW50aXRpZXMvdGFzay9tb2RlbC9pbmRleFwiO1xuaW1wb3J0IHtnZXRBbGxUYXNrc30gZnJvbSBcIkBzcmMvZW50aXRpZXMvdGFzay9hcGkvZ2V0QWxsVGFza3NcIjtcbmltcG9ydCB7Y3JlYXRlVGFzaywgQ3JlYXRlVGFza0RhdGF9IGZyb20gXCJAc3JjL2VudGl0aWVzL3Rhc2svYXBpL2NyZWF0ZVRhc2tcIjtcbmltcG9ydCB7ZGVsZXRlVGFza30gZnJvbSBcIkBzcmMvZW50aXRpZXMvdGFzay9hcGkvZGVsZXRlVGFza1wiO1xuXG5leHBvcnQgY2xhc3MgVGFza1N0b3JlIHtcbiAgICB0YXNrczogUmVjb3JkPHN0cmluZywgVGFzaz4gPSB7fVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIG1ha2VBdXRvT2JzZXJ2YWJsZSh0aGlzKVxuICAgIH1cblxuICAgIGFzeW5jIGZldGNoKCkge1xuICAgICAgICBjb25zdCB0YXNrcyA9IGF3YWl0IGdldEFsbFRhc2tzKClcbiAgICAgICAgY29uc3QgZmV0Y2hlZFRhc2tzOiB0eXBlb2YgdGhpcy50YXNrcyA9IHt9XG5cbiAgICAgICAgdGFza3MuZm9yRWFjaCgodGFzaykgPT4ge1xuICAgICAgICAgICAgZmV0Y2hlZFRhc2tzW3Rhc2suaWQudG9TdHJpbmcoKV0gPSB0YXNrXG4gICAgICAgIH0pXG5cbiAgICAgICAgcnVuSW5BY3Rpb24oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXNrcyA9IGZldGNoZWRUYXNrc1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIGFzeW5jIGFkZChkYXRhOiBDcmVhdGVUYXNrRGF0YSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgY3JlYXRlVGFzayhkYXRhKVxuICAgIH1cblxuICAgIGFzeW5jIGRlbGV0ZShpZDogbnVtYmVyKSB7XG4gICAgICAgIGF3YWl0IGRlbGV0ZVRhc2soaWQpXG4gICAgfVxufSIsImltcG9ydCB7bWFrZUF1dG9PYnNlcnZhYmxlfSBmcm9tIFwibW9ieFwiO1xuaW1wb3J0IHtOb3RpZnl9IGZyb20gXCJAc3JjL2VudGl0aWVzL25vdGlmeS9tb2RlbC9tb2RlbFwiO1xuXG5leHBvcnQgY2xhc3MgTm90aWZ5U3RvcmUge1xuICAgIG5vdGlmaWVzOiBOb3RpZnlbXSA9IFtdXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbWFrZUF1dG9PYnNlcnZhYmxlKHRoaXMpXG4gICAgfVxuXG4gICAgcHVzaChub3RpZnk6IE5vdGlmeSkge1xuICAgICAgICB0aGlzLm5vdGlmaWVzID0gWy4uLnRoaXMubm90aWZpZXMsIG5vdGlmeV1cbiAgICB9XG5cbiAgICBkZWxldGUoaWQ6IG51bWJlcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVzID0gdGhpcy5ub3RpZmllcy5maWx0ZXIoaSA9PiBpLmlkICE9PSBpZClcbiAgICB9XG59IiwiaW1wb3J0IHtUYXNrU3RvcmV9IGZyb20gXCJAc3JjL2VudGl0aWVzL3Rhc2svbW9kZWxcIjtcbmltcG9ydCB7Tm90aWZ5U3RvcmV9IGZyb20gXCJAc3JjL2VudGl0aWVzL25vdGlmeS9tb2RlbFwiO1xuXG5leHBvcnQgY2xhc3MgUm9vdFN0b3JlIHtcbiAgICB0YXNrID0gbmV3IFRhc2tTdG9yZSgpXG4gICAgbm90aWZ5ID0gbmV3IE5vdGlmeVN0b3JlKClcbn0iLCJpbXBvcnQge2NyZWF0ZUNvbnRleHQsIFByb3BzV2l0aENoaWxkcmVuLCB1c2VDb250ZXh0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7Um9vdFN0b3JlfSBmcm9tIFwiQHNyYy9hcHAvc3RvcmVzL3Jvb3RTdG9yZVwiO1xuXG5jb25zdCBkZWZhdWx0VmFsdWUgPSBuZXcgUm9vdFN0b3JlKClcbmNvbnN0IFJvb3RDb250ZXh0ID0gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpXG5cbmV4cG9ydCBjb25zdCB1c2VSb290Q29udGV4dCA9ICgpID0+IHVzZUNvbnRleHQoUm9vdENvbnRleHQpXG5cbmV4cG9ydCBjb25zdCBSb290UHJvdmlkZXIgPSAocDogUHJvcHNXaXRoQ2hpbGRyZW4pID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8Um9vdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2RlZmF1bHRWYWx1ZX0+XG4gICAgICAgICAgICB7cC5jaGlsZHJlbn1cbiAgICAgICAgPC9Sb290Q29udGV4dC5Qcm92aWRlcj5cbiAgICApO1xufTsiLCJleHBvcnQgY29uc3QgUGx1c0ljb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPHN2Z1xuICAgICAgICAgICAgd2lkdGg9XCIyNC4wMDAwMDBcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiMjQuMDAwMDAwXCJcbiAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgaWQ9XCJwYXRoXCJcbiAgICAgICAgICAgICAgICBkPVwiTTIuMDIgMTMuOThMMiAxNEMwLjg4IDE0IDAgMTMuMTIgMCAxMkMwIDEwLjg4IDAuODggMTAgMiAxMEwyLjAyIDEwLjAyTDIuMDIgMTMuOThaTTIxLjk4IDEwLjAyTDIyIDEwQzIzLjEyIDEwIDI0IDEwLjg4IDI0IDEyQzI0IDEzLjEyIDIzLjEyIDE0IDIyIDE0TDIxLjk4IDEzLjk4TDIxLjk4IDEwLjAyWk0xMC4wMiAyLjAxTDEwIDJDMTAgMC44OCAxMC44OCAwIDEyIDBDMTMuMTIgMCAxNCAwLjg4IDE0IDJMMTMuOTggMi4wMUwxMC4wMiAyLjAxWk0xMy45OCAyMS45OEwxNCAyMkMxNCAyMy4xMiAxMy4xMiAyNCAxMiAyNEMxMC44OCAyNCAxMCAyMy4xMiAxMCAyMkwxMC4wMiAyMS45OEwxMy45OCAyMS45OFpcIlxuICAgICAgICAgICAgICAgIGZpbGw9XCIjMjYzNTRDXCJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eT1cIjBcIlxuICAgICAgICAgICAgICAgIGZpbGxSdWxlPVwibm9uemVyb1wiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICBpZD1cInBhdGhcIlxuICAgICAgICAgICAgICAgIGQ9XCJNMiAxMkwyMiAxMk0xMiAyTDEyIDIyXCJcbiAgICAgICAgICAgICAgICBzdHJva2U9XCIjMjYzNTRDXCJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5PVwiMS4wMDAwMDBcIlxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiNC4wMDAwMDBcIlxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L3N2Zz5cbiAgICApO1xufTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbnZhciBfMSA9IFwidFlUbGdvS1lSVHRwR3B0R3VBSlNcIjtcbnZhciBfMiA9IFwiVDZ0aTV2SEJPY29pbWwxSWtOUGdcIjtcbnZhciBfMyA9IFwia2xLTHpJNWpldm1oUkxzclBxaWVcIjtcbnZhciBfNCA9IFwiRE1vaUd4dlhMVGFKdnRTbzJoUmZcIjtcbnZhciBfNSA9IFwiSXRwZzBJd3lmU1Z5ckhCczVnbndcIjtcbnZhciBfNiA9IFwiSHVLa0dIUlRIYzA1Sl95MldzNzZcIjtcbnZhciBfNyA9IFwibTBQTFdNSHFNYWY3dFhJVms5WURcIjtcbnZhciBfOCA9IFwiekNkSmR6MG9vWEJTb194RFNYbXJcIjtcbmV4cG9ydCB7IF8xIGFzIFwiYmFja2Ryb3BcIiwgXzIgYXMgXCJjbG9zZV9idXR0b25cIiwgXzMgYXMgXCJjb250YWluZXJcIiwgXzQgYXMgXCJmYWRlX2luXCIsIF81IGFzIFwiZmFkZV9vdXRcIiwgXzYgYXMgXCJmYWRlX291dF9tb2RhbFwiLCBfNyBhcyBcIm1vZGFsX2hlYWRcIiwgXzggYXMgXCJzaG93X2JhY2tkcm9wXCIgfVxuIiwiaW1wb3J0IHtjcmVhdGVQb3J0YWx9IGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7UHJvcHNXaXRoQ2hpbGRyZW4sIHVzZVJlZn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBzIGZyb20gJy4vTW9kYWwuY3NzJ1xuaW1wb3J0IENyb3NzSWNvbiBmcm9tICdAc3JjL3NoYXJlZC91aS9hc3NldHMvaW1hZ2VzL2Nyb3NzLnN2ZydcblxuZXhwb3J0IHR5cGUgTW9kYWxQcm9wcyA9IHtcbiAgICBvcGVuOiBib29sZWFuLFxuICAgIGNsb3NlOiAoKSA9PiB2b2lkLFxufVxuXG5leHBvcnQgY29uc3QgTW9kYWwgPSAocDogUHJvcHNXaXRoQ2hpbGRyZW48TW9kYWxQcm9wcz4pID0+IHtcbiAgICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpXG4gICAgY29uc3QgYmFja2Ryb3BSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpXG5cbiAgICBjb25zdCBoYW5kbGVDbGljayA9ICgpID0+IHtcbiAgICAgICAgY29udGFpbmVyUmVmLmN1cnJlbnQ/LmNsYXNzTGlzdC5hZGQocy5mYWRlX291dClcbiAgICAgICAgYmFja2Ryb3BSZWYuY3VycmVudD8uY2xhc3NMaXN0LmFkZChzLmZhZGVfb3V0KVxuICAgICAgICBjb25zdCB0aW1lQ2FsbCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIGNvbnN0IHRpbWVXYWl0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gdGltZUNhbGwgPj0gMzAwKSB7XG4gICAgICAgICAgICAgICAgcC5jbG9zZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aW1lV2FpdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGltZVdhaXQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHAub3BlbiAmJiBjcmVhdGVQb3J0YWwoKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cy5iYWNrZHJvcH1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cbiAgICAgICAgICAgICAgICByZWY9e2JhY2tkcm9wUmVmfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3MuY29udGFpbmVyfVxuICAgICAgICAgICAgICAgIHJlZj17Y29udGFpbmVyUmVmfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLm1vZGFsX2hlYWR9PlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3MuY2xvc2VfYnV0dG9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtDcm9zc0ljb259IGFsdD1cIlwiLz5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAge3AuY2hpbGRyZW59XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsLXBvcnRhbCcpISlcbn1cbiIsImV4cG9ydCB7TW9kYWx9IGZyb20gJy4vTW9kYWwnIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG52YXIgXzEgPSBcImlJdmpNNE1aa3l4Z1VWdElqTUtYXCI7XG52YXIgXzIgPSBcImk1c2lhQzBDT1FCZXpkZlF0SFZxXCI7XG5leHBvcnQgeyBfMSBhcyBcImNvbnRhaW5lclwiLCBfMiBhcyBcImlucHV0XCIgfVxuIiwiZXhwb3J0IGNvbnN0IGNsYXNzZXMgPSAoLi4uYXJnczogKHN0cmluZyB8IHVuZGVmaW5lZClbXSkgPT4gYXJncy5maWx0ZXIoQm9vbGVhbikuam9pbignICcpIiwiaW1wb3J0ICogYXMgcyBmcm9tICcuL1RleHRJbnB1dC5jc3MnXG5pbXBvcnQge2ZvcndhcmRSZWYsIEhUTUxBdHRyaWJ1dGVzfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7Y2xhc3Nlc30gZnJvbSBcIkBzcmMvc2hhcmVkL2xpYi9jbGFzc2VzXCI7XG5cbnR5cGUgUHJvcHMgPSB7XG4gICAgdmFsdWU6IHN0cmluZ1xuICAgIHNldFZhbHVlOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZFxuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nLFxuICAgIGludmFsaWQ/OiBib29sZWFuXG59O1xuZXhwb3J0IGNvbnN0IFRleHRJbnB1dCA9IGZvcndhcmRSZWY8SFRNTElucHV0RWxlbWVudCwgUHJvcHMgJiBIVE1MQXR0cmlidXRlczxIVE1MSW5wdXRFbGVtZW50Pj4oXG4gICAgKHAsIHJlZikgPT4ge1xuICAgICAgICBjb25zdCB7dmFsdWUsIHNldFZhbHVlLCBpbnZhbGlkLCAuLi5vdGhlcn0gPSBwXG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLmNvbnRhaW5lcn0+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIHsuLi5vdGhlcn1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS1pbnZhbGlkPXtpbnZhbGlkfVxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NlcyhzLmlucHV0LCBwLmNsYXNzTmFtZSl9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e3AucGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0VmFsdWUoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbikiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbnZhciBfMSA9IFwiSFcwSWRLdTZGbnBrN2FLa1BYYVNcIjtcbnZhciBfMiA9IFwiQlJQdzZ2YzVQRkJ2bnU1eUZfZ3BcIjtcbnZhciBfMyA9IFwiT193T3FxMjFCb1hEY2x3Um81M0hcIjtcbnZhciBfNCA9IFwiZGlMd0Rtelp2QmZDR011aDlsRW1cIjtcbmV4cG9ydCB7IF8xIGFzIFwiY29udGFpbmVyXCIsIF8yIGFzIFwiZGF0ZV9waWNrZXJfY29udGFpbmVyXCIsIF8zIGFzIFwiaWNvblwiLCBfNCBhcyBcImlucHV0XCIgfVxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG52YXIgXzEgPSBcIkl1WjBEbXJINGJOX1pWejBFVTVnXCI7XG52YXIgXzIgPSBcImxicmZENFhnZmRTcGVEYWFDdlJJXCI7XG52YXIgXzMgPSBcImU5Z2N6YjQ2ejNPZTJjdk1jTEpHXCI7XG52YXIgXzQgPSBcImZ5cnVQZjk1aHViSXNsNDNTWldXXCI7XG52YXIgXzUgPSBcIkFXcGN2OWpLcENHbm8wV2xBN2ZQXCI7XG52YXIgXzYgPSBcIkFmU05KVmJyckcxdWNjVDJDdVZnXCI7XG52YXIgXzcgPSBcInp5WkdsTFFwS05OcWxjazZaTk1LXCI7XG5leHBvcnQgeyBfMSBhcyBcImNhbGVuZGFyXCIsIF8yIGFzIFwiY29udGFpbmVyXCIsIF8zIGFzIFwicm90YXRlZF9pbWFnZVwiLCBfNCBhcyBcInRvcF9ibG9ja1wiLCBfNSBhcyBcInRvcF9idXR0b25cIiwgXzYgYXMgXCJ0b3BfdGV4dFwiLCBfNyBhcyBcIndlZWtcIiB9XG4iLCJleHBvcnQgY29uc3QgTmV4dEljb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPHN2ZyB3aWR0aD1cIjguMDY0NzU0XCIgaGVpZ2h0PVwiMTQuMDA4MTg0XCIgdmlld0JveD1cIjAgMCA4LjA2NDc1IDE0LjAwODJcIiBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICAgICAgPHBhdGggaWQ9XCLQpNC+0YDQvNCwIDRcIlxuICAgICAgICAgICAgICAgICAgZD1cIk0wLjMyIDEuNzFMMC4yOSAxLjcxQy0wLjEgMS4zMSAtMC4xIDAuNjkgMC4yOSAwLjI5QzAuNjkgLTAuMSAxLjMxIC0wLjEgMS43MSAwLjI5TDEuNzEgMC4zMkwwLjMyIDEuNzFaTTEuNzEgMTMuNjhMMS43MSAxMy43MUMxLjMxIDE0LjEgMC42OSAxNC4xIDAuMjkgMTMuNzFDLTAuMSAxMy4zMSAtMC4xIDEyLjY5IDAuMjkgMTIuMjlMMC4zMiAxMi4yOUwxLjcxIDEzLjY4WlwiXG4gICAgICAgICAgICAgICAgICBmaWxsPVwiIzAwMDAwMFwiIGZpbGxPcGFjaXR5PVwiMFwiIGZpbGxSdWxlPVwibm9uemVyb1wiLz5cbiAgICAgICAgICAgIDxwYXRoIGlkPVwi0KTQvtGA0LzQsCA0XCIgZD1cIk0xIDFMNyA3TDEgMTNcIiBzdHJva2U9XCIjMjYzNTRDXCIgc3Ryb2tlT3BhY2l0eT1cIjEuMDAwMDAwXCIgc3Ryb2tlV2lkdGg9XCIyLjAwMDAwMFwiXG4gICAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICApO1xufTsiLCJleHBvcnQge05leHRJY29ufSBmcm9tICcuL05leHRJY29uJyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxudmFyIF8xID0gXCJ2eTJpVDlmM01GV2UyXzhsdTMwNlwiO1xudmFyIF8yID0gXCJJbnVyMWJCb1hfekxQYW1HWXBwUFwiO1xudmFyIF8zID0gXCJ3RzVxRmtleUdBX3FZalB0QUtIM1wiO1xuZXhwb3J0IHsgXzEgYXMgXCJjb250YWluZXJcIiwgXzIgYXMgXCJjdXJyZW50XCIsIF8zIGFzIFwibm90X2N1cnJlbnRcIiB9XG4iLCJpbXBvcnQgKiBhcyBzIGZyb20gJy4vQ2FsZW5kYXJEYXRlLmNzcydcbmltcG9ydCB7VHlwb2dyYXBoeX0gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL3R5cG9ncmFwaHlcIjtcbmltcG9ydCB7dXNlRGF0ZUlucHV0Q29udGV4dH0gZnJvbSBcIkBzcmMvd2lkZ2V0cy9kYXRlLXBpY2tlci91aS9kYXRlLWlucHV0XCI7XG5cbnR5cGUgUHJvcHMgPSB7XG4gICAgZGF0ZTogbnVtYmVyXG4gICAgY3VycmVudE1vbnRoOiBib29sZWFuLFxuICAgIGN1cnJlbnREYXk6IGJvb2xlYW4sXG4gICAgZGF0ZVN0cmluZzogc3RyaW5nLFxufTtcbmV4cG9ydCBjb25zdCBDYWxlbmRhckRhdGUgPSAocDogUHJvcHMpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q2xhc3MgPSBwLmN1cnJlbnRNb250aCA/IHMuY3VycmVudCA6IHMubm90X2N1cnJlbnRcbiAgICBjb25zdCB7c2V0VmFsdWV9ID0gdXNlRGF0ZUlucHV0Q29udGV4dCgpXG5cbiAgICBjb25zdCBvbkNsaWNrSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgc2V0VmFsdWUocC5kYXRlU3RyaW5nKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzTmFtZT17cy5jb250YWluZXJ9XG4gICAgICAgICAgICBkYXRhLWN1cnJlbnQtZGF5PXtwLmN1cnJlbnREYXl9XG4gICAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrSGFuZGxlcn1cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICA+XG4gICAgICAgICAgICA8VHlwb2dyYXBoeS5UZXh0IGNsYXNzTmFtZT17Y3VycmVudENsYXNzfT5cbiAgICAgICAgICAgICAgICB7cC5kYXRlfVxuICAgICAgICAgICAgPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICk7XG59OyIsImV4cG9ydCB7Q2FsZW5kYXJEYXRlfSBmcm9tICcuL0NhbGVuZGFyRGF0ZSciLCIvKipcbiAqINCc0LXRgtC+0LQg0LTQu9GPINC/0L7Qu9GD0YfQtdC90LjRjyDQvdCw0YfQsNC70YzQvdC+0Lkg0LTQsNGC0Ysg0LTQu9GPINC60LDQu9C10L3QtNCw0YDRj1xuICogQHBhcmFtIGRhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE1vbnRoU3RhcnREYXRlID0gKGRhdGU6IERhdGUpID0+IHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZShkYXRlKVxuICAgIG5vdy5zZXREYXRlKDEpXG4gICAgY29uc3Qgd2Vla0RheSA9IG5vdy5nZXREYXkoKVxuICAgIG5vdy5zZXREYXRlKG5vdy5nZXREYXRlKCkgLSAod2Vla0RheSAtIDEpKVxuICAgIHJldHVybiBub3dcbn0iLCIvKipcbiAqINCc0LXRgtC+0LQg0LTQu9GPINC/0L7Qu9GD0YfQtdC90LjRjyDQutC+0L3QtdGH0L3QvtC5INC00LDRgtGLINC00LvRjyDQutCw0LvQtdC90LTQsNGA0Y9cbiAqIEBwYXJhbSBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRNb250aEVuZERhdGUgPSAoZGF0ZTogRGF0ZSkgPT4ge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKGRhdGUpXG4gICAgbm93LnNldEZ1bGxZZWFyKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSArIDEsIDEpXG4gICAgY29uc3Qgd2Vla0RheSA9IG5vdy5nZXREYXkoKVxuICAgIGlmICh3ZWVrRGF5ID09PSAxKSB7XG4gICAgICAgIG5vdy5zZXREYXRlKG5vdy5nZXREYXRlKCkgLSAxKVxuICAgIH0gZWxzZSBpZiAod2Vla0RheSAhPT0gMCkge1xuICAgICAgICBub3cuc2V0RGF0ZShub3cuZ2V0RGF0ZSgpICsgNyAtIHdlZWtEYXkpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vd1xufSIsImltcG9ydCB7Z2V0TW9udGhTdGFydERhdGV9IGZyb20gXCJAc3JjL3dpZGdldHMvZGF0ZS1waWNrZXIvbGliL2dldC1tb250aC1zdGFydC1kYXRlXCI7XG5pbXBvcnQge2dldE1vbnRoRW5kRGF0ZX0gZnJvbSBcIkBzcmMvd2lkZ2V0cy9kYXRlLXBpY2tlci9saWIvZ2V0LW1vbnRoLWVuZC1kYXRlXCI7XG5cbmV4cG9ydCB0eXBlIFRNb250aERhdGVzID0gQXJyYXk8e1xuICAgIGRhdGU6IG51bWJlcixcbiAgICBjdXJyZW50TW9udGg6IGJvb2xlYW4sXG4gICAgY3VycmVudERhdGU6IGJvb2xlYW4sXG4gICAgZGF0ZVN0cmluZzogc3RyaW5nXG59PlxuXG5leHBvcnQgY29uc3QgZ2V0TW9udGhEYXRlcyA9IChjdXJyZW50TW9udGg6IG51bWJlcik6IFRNb250aERhdGVzID0+IHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgY29uc3QgY3VycmVudERhdGUgPSBub3cudG9EYXRlU3RyaW5nKClcbiAgICBub3cuc2V0TW9udGgoY3VycmVudE1vbnRoLCAxKVxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0TW9udGhTdGFydERhdGUobm93KVxuICAgIGNvbnN0IGVuZCA9IGdldE1vbnRoRW5kRGF0ZShub3cpXG4gICAgY29uc3QgZGF0ZXM6IFRNb250aERhdGVzID0gW11cbiAgICBjb25zdCBlbmREYXRlU3RyaW5nID0gZW5kLnRvTG9jYWxlRGF0ZVN0cmluZygpXG4gICAgbGV0IHN0YXJ0RGF0ZVN0cmluZyA9ICcnXG5cbiAgICB3aGlsZSAoc3RhcnREYXRlU3RyaW5nICE9PSBlbmREYXRlU3RyaW5nKSB7XG4gICAgICAgIGRhdGVzLnB1c2goe1xuICAgICAgICAgICAgZGF0ZTogc3RhcnQuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgY3VycmVudE1vbnRoOiBzdGFydC5nZXRNb250aCgpID09PSBjdXJyZW50TW9udGgsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZTogc3RhcnQudG9EYXRlU3RyaW5nKCkgPT09IGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZGF0ZVN0cmluZzogc3RhcnQudG9Mb2NhbGVEYXRlU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgc3RhcnQuc2V0RGF0ZShzdGFydC5nZXREYXRlKCkgKyAxKVxuICAgICAgICBzdGFydERhdGVTdHJpbmcgPSBzdGFydC50b0xvY2FsZURhdGVTdHJpbmcoKVxuICAgIH1cbiAgICBkYXRlcy5wdXNoKHtcbiAgICAgICAgZGF0ZTogc3RhcnQuZ2V0RGF0ZSgpLFxuICAgICAgICBjdXJyZW50TW9udGg6IHN0YXJ0LmdldE1vbnRoKCkgPT09IGN1cnJlbnRNb250aCxcbiAgICAgICAgY3VycmVudERhdGU6IHN0YXJ0LnRvRGF0ZVN0cmluZygpID09PSBjdXJyZW50RGF0ZSxcbiAgICAgICAgZGF0ZVN0cmluZzogc3RhcnQudG9Mb2NhbGVEYXRlU3RyaW5nKClcbiAgICB9KVxuICAgIHJldHVybiBkYXRlc1xufSIsImV4cG9ydCBjb25zdCBnZXREYXRlVGl0bGUgPSAoZGF0ZTogRGF0ZSkgPT4ge1xuICAgIHJldHVybiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygncnUtUlUnLCB7XG4gICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgbW9udGg6ICdsb25nJyxcbiAgICB9KVxufSIsImltcG9ydCAqIGFzIHMgZnJvbSAnLi9EYXRlUGlja2VyLmNzcydcbmltcG9ydCB7VHlwb2dyYXBoeX0gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL3R5cG9ncmFwaHlcIjtcbmltcG9ydCB7Y2xhc3Nlc30gZnJvbSBcIkBzcmMvc2hhcmVkL2xpYi9jbGFzc2VzXCI7XG5pbXBvcnQge05leHRJY29ufSBmcm9tIFwiQHNyYy93aWRnZXRzL2RhdGUtcGlja2VyL3VpL25leHQtaWNvblwiO1xuaW1wb3J0IHtDYWxlbmRhckRhdGV9IGZyb20gXCJAc3JjL3dpZGdldHMvZGF0ZS1waWNrZXIvdWkvY2FsZW5kYXItZGF0ZVwiO1xuaW1wb3J0IHtnZXRNb250aERhdGVzfSBmcm9tIFwiQHNyYy93aWRnZXRzL2RhdGUtcGlja2VyL2xpYi9nZXQtbW9udGgtZGF0ZXNcIjtcbmltcG9ydCB7dXNlU3RhdGV9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtnZXREYXRlVGl0bGV9IGZyb20gXCJAc3JjL3dpZGdldHMvZGF0ZS1waWNrZXIvbGliL2dldC1kYXRlLXRpdGxlXCI7XG5cbnR5cGUgUHJvcHMgPSB7fVxuZXhwb3J0IGNvbnN0IERhdGVQaWNrZXIgPSAocDogUHJvcHMpID0+IHtcbiAgICBjb25zdCBbY3VycmVudE1vbnRoLCBzZXRDdXJyZW50TW9udGhdID0gdXNlU3RhdGUobmV3IERhdGUoKS5nZXRNb250aCgpKVxuICAgIGNvbnN0IGRhdGVzID0gZ2V0TW9udGhEYXRlcyhjdXJyZW50TW9udGgpXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICAgIG5vdy5zZXRNb250aChjdXJyZW50TW9udGgsIDEpXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cy5jb250YWluZXJ9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3MudG9wX2Jsb2NrfT5cbiAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeS5IZWFkaW5nIGNsYXNzTmFtZT17cy50b3BfdGV4dH0+e2dldERhdGVUaXRsZShub3cpfTwvVHlwb2dyYXBoeS5IZWFkaW5nPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzKHMudG9wX2J1dHRvbiwgcy5yb3RhdGVkX2ltYWdlKX1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0Q3VycmVudE1vbnRoKHByZXYgPT4gcHJldiAtIDEpfVxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxOZXh0SWNvbi8+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3MudG9wX2J1dHRvbn1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0Q3VycmVudE1vbnRoKHByZXYgPT4gcHJldiArIDEpfVxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxOZXh0SWNvbi8+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3Mud2Vla30+XG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dD7Qn9C9PC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dD7QktGCPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dD7QodGAPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dD7Qp9GCPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dD7Qn9GCPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dD7QodCxPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dD7QktGBPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3MuY2FsZW5kYXJ9PlxuICAgICAgICAgICAgICAgIHtkYXRlcy5tYXAoaSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxDYWxlbmRhckRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU9e2kuZGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNb250aD17aS5jdXJyZW50TW9udGh9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF5PXtpLmN1cnJlbnREYXRlfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZVN0cmluZz17aS5kYXRlU3RyaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpLmRhdGVTdHJpbmd9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07IiwiZXhwb3J0IHtEYXRlUGlja2VyfSBmcm9tICcuL0RhdGVQaWNrZXInIiwiaW1wb3J0ICogYXMgcyBmcm9tICcuL0RhdGVJbnB1dC5jc3MnXG5pbXBvcnQgQ2FsZW5kYXJJY29uIGZyb20gJ0BzcmMvc2hhcmVkL3VpL2Fzc2V0cy9pbWFnZXMvY2FsZW5kYXIuc3ZnJ1xuaW1wb3J0IHtEYXRlUGlja2VyfSBmcm9tIFwiQHNyYy93aWRnZXRzL2RhdGUtcGlja2VyL3VpL2RhdGUtcGlja2VyXCI7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZn0gZnJvbSBcInJlYWN0XCI7XG5cbnR5cGUgUHJvcHMgPSB7XG4gICAgdmFsdWU6IHN0cmluZyxcbiAgICBzZXRWYWx1ZTogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWQsXG4gICAgaW52YWxpZD86IGJvb2xlYW5cbn07XG5cbmludGVyZmFjZSBJRGF0ZUlucHV0Q29udGV4dCB7XG4gICAgdmFsdWU6IHN0cmluZyxcbiAgICBzZXRWYWx1ZTogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWRcbn1cblxuY29uc3QgRGF0ZUlucHV0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8SURhdGVJbnB1dENvbnRleHQ+KHtcbiAgICB2YWx1ZTogJycsXG4gICAgc2V0VmFsdWU6ICgpID0+IHt9LFxufSlcblxuZXhwb3J0IGNvbnN0IHVzZURhdGVJbnB1dENvbnRleHQgPSAoKSA9PiB1c2VDb250ZXh0KERhdGVJbnB1dENvbnRleHQpXG5cbmV4cG9ydCBjb25zdCBEYXRlSW5wdXQgPSAoe3ZhbHVlLCBzZXRWYWx1ZSwgaW52YWxpZH06IFByb3BzKSA9PiB7XG4gICAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWY8SFRNTElucHV0RWxlbWVudD4obnVsbCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8RGF0ZUlucHV0Q29udGV4dC5Qcm92aWRlclxuICAgICAgICAgICAgdmFsdWU9e3sgdmFsdWUsIHNldFZhbHVlIH19XG4gICAgICAgID5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3MuY29udGFpbmVyfVxuICAgICAgICAgICAgICAgIGRhdGEtaW52YWxpZD17aW52YWxpZH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cy5kYXRlX3BpY2tlcl9jb250YWluZXJ9PlxuICAgICAgICAgICAgICAgICAgICA8RGF0ZVBpY2tlci8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIHJlZj17aW5wdXRSZWZ9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cy5pbnB1dH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiMDAuMDAuMDAwMFwiXG4gICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8aW1nIGNsYXNzTmFtZT17cy5pY29ufSBzcmM9e0NhbGVuZGFySWNvbn0gYWx0PVwiXCIvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvRGF0ZUlucHV0Q29udGV4dC5Qcm92aWRlcj5cbiAgICApO1xufTsiLCJleHBvcnQgKiBmcm9tICcuL0RhdGVJbnB1dCciLCJleHBvcnQge0RhdGVJbnB1dCBhcyBEYXRlUGlja2VyfSBmcm9tICcuL3VpL2RhdGUtaW5wdXQnIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG52YXIgXzEgPSBcIkhiX1l2eXV1am5OaXFFOXVjOEw1XCI7XG52YXIgXzIgPSBcIldZZHVBY1pXekd4anAzdEhxdnBLXCI7XG52YXIgXzMgPSBcIk5RcnFLQW80RXBNUUYxd1FLN3RRXCI7XG52YXIgXzQgPSBcInJ3MUVjNWRjeTdNVGRNd1BfMUhXXCI7XG52YXIgXzUgPSBcImZOVnR5YVNwWWlWTEUzaXhOM1RWXCI7XG5leHBvcnQgeyBfMSBhcyBcImNvbG9yX2NvbnRhaW5lclwiLCBfMiBhcyBcImRhdGVzXCIsIF8zIGFzIFwibGFiZWxcIiwgXzQgYXMgXCJ0ZXh0X2lucHV0XCIsIF81IGFzIFwidGV4dGFyZWFcIiB9XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbnZhciBfMSA9IFwib2c2T1d2TUxDY0VkUFRFOHB6YVhcIjtcbnZhciBfMiA9IFwiZDZmUDFOaEFwa1NLUDhNUzNvbmxcIjtcbmV4cG9ydCB7IF8xIGFzIFwiY29udGFpbmVyXCIsIF8yIGFzIFwidGV4dGFyZWFcIiB9XG4iLCJpbXBvcnQgKiBhcyBzIGZyb20gJy4vVGV4dGFyZWEuY3NzJ1xuaW1wb3J0IHtIVE1MQXR0cmlidXRlc30gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge2NsYXNzZXN9IGZyb20gXCJAc3JjL3NoYXJlZC9saWIvY2xhc3Nlc1wiO1xuXG50eXBlIFByb3BzID0ge1xuICAgIHZhbHVlOiBzdHJpbmcsXG4gICAgc2V0VmFsdWU6ICh2YWx1ZTogc3RyaW5nKSA9PiB2b2lkLFxufTtcbmV4cG9ydCBjb25zdCBUZXh0YXJlYSA9IChwOiBQcm9wcyAmIEhUTUxBdHRyaWJ1dGVzPEhUTUxUZXh0QXJlYUVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3Qge3ZhbHVlLCBzZXRWYWx1ZSwgLi4ub3RoZXJ9ID0gcDtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLmNvbnRhaW5lcn0+XG4gICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgICB7Li4ub3RoZXJ9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHNldFZhbHVlKGUuY3VycmVudFRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzKHMudGV4dGFyZWEsIHAuY2xhc3NOYW1lKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59OyIsImV4cG9ydCBjb25zdCBjb2xvcnMgPSB7XG4gICAgcmVkOiAnI0U3NUE2MicsXG4gICAgYmx1ZTogJyMzZDdmZWQnLFxuICAgIGdyZWVuOiAnIzMyOTc1ZCcsXG4gICAgcHVycGxlOiAnIzliNTJlMScsXG4gICAgeWVsbG93OiAnI2YyYzk1NycsXG4gICAgb3JhbmdlOiAnI2YyOTk1NScsXG59IiwiZXhwb3J0IHtjb2xvcnN9IGZyb20gJy4vY29sb3JzJyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxudmFyIF8xID0gXCJMOXVfVWdGSVk1U0xfRHNicjk3VVwiO1xuZXhwb3J0IHsgXzEgYXMgXCJidXR0b25cIiB9XG4iLCJpbXBvcnQgKiBhcyBzIGZyb20gJy4vQnV0dG9uLmNzcydcbmltcG9ydCB7SFRNTEF0dHJpYnV0ZXMsIFByb3BzV2l0aENoaWxkcmVufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7Y2xhc3Nlc30gZnJvbSBcIkBzcmMvc2hhcmVkL2xpYi9jbGFzc2VzXCI7XG5cbmV4cG9ydCBjb25zdCBCdXR0b24gPSAocDogUHJvcHNXaXRoQ2hpbGRyZW48SFRNTEF0dHJpYnV0ZXM8SFRNTEJ1dHRvbkVsZW1lbnQ+PikgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b24gey4uLnB9IGNsYXNzTmFtZT17Y2xhc3NlcyhzLmJ1dHRvbiwgcC5jbGFzc05hbWUpfT5cbiAgICAgICAgICAgIHtwLmNoaWxkcmVufVxuICAgICAgICA8L2J1dHRvbj5cbiAgICApO1xufTsiLCJleHBvcnQge0J1dHRvbn0gZnJvbSAnLi9CdXR0b24nIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG52YXIgXzEgPSBcIngwTXUwMl8zclhGS2ZSSE9GbGx3XCI7XG52YXIgXzIgPSBcIlBpRTlHcmxBVnRreG9HSEYwa0xkXCI7XG5leHBvcnQgeyBfMSBhcyBcImNvbG9yX2lucHV0XCIsIF8yIGFzIFwiY29sb3JfbGFiZWxcIiB9XG4iLCJpbXBvcnQgKiBhcyBzIGZyb20gXCJAc3JjL3dpZGdldHMvY3JlYXRlLXRhc2stbW9kYWwvdWkvY29sb3ItcGljay9Db2xvclBpY2suY3NzXCI7XG5pbXBvcnQge3VzZUlkfSBmcm9tIFwicmVhY3RcIjtcblxudHlwZSBQcm9wcyA9IHtcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNoZWNrZWQ6IGJvb2xlYW4sXG4gICAgb25DaGFuZ2U6ICgpID0+IHZvaWQsXG59O1xuZXhwb3J0IGNvbnN0IENvbG9yUGljayA9IChwOiBQcm9wcykgPT4ge1xuICAgIGNvbnN0IGlkID0gdXNlSWQoKVxuICAgIHJldHVybiAoXG4gICAgICAgIDxsYWJlbFxuICAgICAgICAgICAgaHRtbEZvcj17aWR9XG4gICAgICAgICAgICBjbGFzc05hbWU9e3MuY29sb3JfbGFiZWx9XG4gICAgICAgICAgICBzdHlsZT17e2NvbG9yOiBwLnZhbHVlfX1cbiAgICAgICAgPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgICAgICBuYW1lPVwiY29sb3JcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtwLnZhbHVlfVxuICAgICAgICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICAgICAgICBjaGVja2VkPXtwLmNoZWNrZWR9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3Aub25DaGFuZ2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3MuY29sb3JfaW5wdXR9IHN0eWxlPXt7YmFja2dyb3VuZENvbG9yOiBwLnZhbHVlfX0vPlxuICAgICAgICA8L2xhYmVsPlxuICAgICk7XG59OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbnZhciBpc0NoZWNrQm94SW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAnY2hlY2tib3gnO1xuXG52YXIgaXNEYXRlT2JqZWN0ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG5cbnZhciBpc051bGxPclVuZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdmFsdWUgPT0gbnVsbDtcblxuY29uc3QgaXNPYmplY3RUeXBlID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xudmFyIGlzT2JqZWN0ID0gKHZhbHVlKSA9PiAhaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpICYmXG4gICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgaXNPYmplY3RUeXBlKHZhbHVlKSAmJlxuICAgICFpc0RhdGVPYmplY3QodmFsdWUpO1xuXG52YXIgZ2V0RXZlbnRWYWx1ZSA9IChldmVudCkgPT4gaXNPYmplY3QoZXZlbnQpICYmIGV2ZW50LnRhcmdldFxuICAgID8gaXNDaGVja0JveElucHV0KGV2ZW50LnRhcmdldClcbiAgICAgICAgPyBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICA6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgIDogZXZlbnQ7XG5cbnZhciBnZXROb2RlUGFyZW50TmFtZSA9IChuYW1lKSA9PiBuYW1lLnN1YnN0cmluZygwLCBuYW1lLnNlYXJjaCgvXFwuXFxkKyhcXC58JCkvKSkgfHwgbmFtZTtcblxudmFyIGlzTmFtZUluRmllbGRBcnJheSA9IChuYW1lcywgbmFtZSkgPT4gbmFtZXMuaGFzKGdldE5vZGVQYXJlbnROYW1lKG5hbWUpKTtcblxudmFyIGlzUGxhaW5PYmplY3QgPSAodGVtcE9iamVjdCkgPT4ge1xuICAgIGNvbnN0IHByb3RvdHlwZUNvcHkgPSB0ZW1wT2JqZWN0LmNvbnN0cnVjdG9yICYmIHRlbXBPYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHJldHVybiAoaXNPYmplY3QocHJvdG90eXBlQ29weSkgJiYgcHJvdG90eXBlQ29weS5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpKTtcbn07XG5cbnZhciBpc1dlYiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5IVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBjbG9uZU9iamVjdChkYXRhKSB7XG4gICAgbGV0IGNvcHk7XG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XG4gICAgY29uc3QgaXNGaWxlTGlzdEluc3RhbmNlID0gdHlwZW9mIEZpbGVMaXN0ICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgaW5zdGFuY2VvZiBGaWxlTGlzdCA6IGZhbHNlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjb3B5ID0gbmV3IERhdGUoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29weSA9IG5ldyBTZXQoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEoaXNXZWIgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IGlzRmlsZUxpc3RJbnN0YW5jZSkpICYmXG4gICAgICAgIChpc0FycmF5IHx8IGlzT2JqZWN0KGRhdGEpKSkge1xuICAgICAgICBjb3B5ID0gaXNBcnJheSA/IFtdIDoge307XG4gICAgICAgIGlmICghaXNBcnJheSAmJiAhaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgY29weSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBjbG9uZU9iamVjdChkYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuXG52YXIgY29tcGFjdCA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcblxudmFyIGlzVW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsID09PSB1bmRlZmluZWQ7XG5cbnZhciBnZXQgPSAob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICBpZiAoIXBhdGggfHwgIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gY29tcGFjdChwYXRoLnNwbGl0KC9bLFtcXF0uXSs/LykpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHJlc3VsdCkgPyByZXN1bHQgOiByZXN1bHRba2V5XSwgb2JqZWN0KTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQocmVzdWx0KSB8fCByZXN1bHQgPT09IG9iamVjdFxuICAgICAgICA/IGlzVW5kZWZpbmVkKG9iamVjdFtwYXRoXSlcbiAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICA6IG9iamVjdFtwYXRoXVxuICAgICAgICA6IHJlc3VsdDtcbn07XG5cbnZhciBpc0Jvb2xlYW4gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuXG52YXIgaXNLZXkgPSAodmFsdWUpID0+IC9eXFx3KiQvLnRlc3QodmFsdWUpO1xuXG52YXIgc3RyaW5nVG9QYXRoID0gKGlucHV0KSA9PiBjb21wYWN0KGlucHV0LnJlcGxhY2UoL1tcInwnXXxcXF0vZywgJycpLnNwbGl0KC9cXC58XFxbLykpO1xuXG52YXIgc2V0ID0gKG9iamVjdCwgcGF0aCwgdmFsdWUpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCB0ZW1wUGF0aCA9IGlzS2V5KHBhdGgpID8gW3BhdGhdIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRlbXBQYXRoLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRlbXBQYXRoW2luZGV4XTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmIChpbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KG9ialZhbHVlKSB8fCBBcnJheS5pc0FycmF5KG9ialZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogIWlzTmFOKCt0ZW1wUGF0aFtpbmRleCArIDFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuY29uc3QgRVZFTlRTID0ge1xuICAgIEJMVVI6ICdibHVyJyxcbiAgICBGT0NVU19PVVQ6ICdmb2N1c291dCcsXG4gICAgQ0hBTkdFOiAnY2hhbmdlJyxcbn07XG5jb25zdCBWQUxJREFUSU9OX01PREUgPSB7XG4gICAgb25CbHVyOiAnb25CbHVyJyxcbiAgICBvbkNoYW5nZTogJ29uQ2hhbmdlJyxcbiAgICBvblN1Ym1pdDogJ29uU3VibWl0JyxcbiAgICBvblRvdWNoZWQ6ICdvblRvdWNoZWQnLFxuICAgIGFsbDogJ2FsbCcsXG59O1xuY29uc3QgSU5QVVRfVkFMSURBVElPTl9SVUxFUyA9IHtcbiAgICBtYXg6ICdtYXgnLFxuICAgIG1pbjogJ21pbicsXG4gICAgbWF4TGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgICBtaW5MZW5ndGg6ICdtaW5MZW5ndGgnLFxuICAgIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgICB2YWxpZGF0ZTogJ3ZhbGlkYXRlJyxcbn07XG5cbmNvbnN0IEhvb2tGb3JtQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBhY2Nlc3MgdGhlIGZvcm0gY29udGV4dC4gdXNlRm9ybUNvbnRleHQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBkZWVwbHkgbmVzdGVkIHN0cnVjdHVyZXMsIHdoZXJlIGl0IHdvdWxkIGJlY29tZSBpbmNvbnZlbmllbnQgdG8gcGFzcyB0aGUgY29udGV4dCBhcyBhIHByb3AuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgRm9ybVByb3ZpZGVyfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybWNvbnRleHQpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny1mb3JtLWNvbnRleHQteXR1ZGkpXG4gKlxuICogQHJldHVybnMgcmV0dXJuIGFsbCB1c2VGb3JtIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm1Qcm92aWRlciB7Li4ubWV0aG9kc30gPlxuICogICAgICAgPGZvcm0gb25TdWJtaXQ9e21ldGhvZHMuaGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICAgIDxOZXN0ZWRJbnB1dCAvPlxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgICA8L2Zvcm0+XG4gKiAgICAgPC9Gb3JtUHJvdmlkZXI+XG4gKiAgICk7XG4gKiB9XG4gKlxuICogIGZ1bmN0aW9uIE5lc3RlZElucHV0KCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB1c2VGb3JtQ29udGV4dCgpOyAvLyByZXRyaWV2ZSBhbGwgaG9vayBtZXRob2RzXG4gKiAgIHJldHVybiA8aW5wdXQgey4uLnJlZ2lzdGVyKFwidGVzdFwiKX0gLz47XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgdXNlRm9ybUNvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEhvb2tGb3JtQ29udGV4dCk7XG4vKipcbiAqIEEgcHJvdmlkZXIgY29tcG9uZW50IHRoYXQgcHJvcGFnYXRlcyB0aGUgYHVzZUZvcm1gIG1ldGhvZHMgdG8gYWxsIGNoaWxkcmVuIGNvbXBvbmVudHMgdmlhIFtSZWFjdCBDb250ZXh0XShodHRwczovL3JlYWN0anMub3JnL2RvY3MvY29udGV4dC5odG1sKSBBUEkuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgdXNlRm9ybUNvbnRleHR9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtY29udGV4dCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LWZvcm0tY29udGV4dC15dHVkaSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBhbGwgdXNlRm9ybSBtZXRob2RzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBtZXRob2RzID0gdXNlRm9ybSgpO1xuICogICBjb25zdCBvblN1Ym1pdCA9IGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxGb3JtUHJvdmlkZXIgey4uLm1ldGhvZHN9ID5cbiAqICAgICAgIDxmb3JtIG9uU3VibWl0PXttZXRob2RzLmhhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgICA8TmVzdGVkSW5wdXQgLz5cbiAqICAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgICAgPC9mb3JtPlxuICogICAgIDwvRm9ybVByb3ZpZGVyPlxuICogICApO1xuICogfVxuICpcbiAqICBmdW5jdGlvbiBOZXN0ZWRJbnB1dCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciB9ID0gdXNlRm9ybUNvbnRleHQoKTsgLy8gcmV0cmlldmUgYWxsIGhvb2sgbWV0aG9kc1xuICogICByZXR1cm4gPGlucHV0IHsuLi5yZWdpc3RlcihcInRlc3RcIil9IC8+O1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IEZvcm1Qcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLmRhdGEgfSA9IHByb3BzO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChIb29rRm9ybUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGRhdGEgfSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBnZXRQcm94eUZvcm1TdGF0ZSA9IChmb3JtU3RhdGUsIGNvbnRyb2wsIGxvY2FsUHJveHlGb3JtU3RhdGUsIGlzUm9vdCA9IHRydWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZXM6IGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtU3RhdGUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfa2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSAhPT0gVkFMSURBVElPTl9NT0RFLmFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSA9ICFpc1Jvb3QgfHwgVkFMSURBVElPTl9NT0RFLmFsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxQcm94eUZvcm1TdGF0ZSAmJiAobG9jYWxQcm94eUZvcm1TdGF0ZVtfa2V5XSA9IHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtU3RhdGVbX2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBpc0VtcHR5T2JqZWN0ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG5cbnZhciBzaG91bGRSZW5kZXJGb3JtU3RhdGUgPSAoZm9ybVN0YXRlRGF0YSwgX3Byb3h5Rm9ybVN0YXRlLCB1cGRhdGVGb3JtU3RhdGUsIGlzUm9vdCkgPT4ge1xuICAgIHVwZGF0ZUZvcm1TdGF0ZShmb3JtU3RhdGVEYXRhKTtcbiAgICBjb25zdCB7IG5hbWUsIC4uLmZvcm1TdGF0ZSB9ID0gZm9ybVN0YXRlRGF0YTtcbiAgICByZXR1cm4gKGlzRW1wdHlPYmplY3QoZm9ybVN0YXRlKSB8fFxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmxlbmd0aCA+PSBPYmplY3Qua2V5cyhfcHJveHlGb3JtU3RhdGUpLmxlbmd0aCB8fFxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmZpbmQoKGtleSkgPT4gX3Byb3h5Rm9ybVN0YXRlW2tleV0gPT09XG4gICAgICAgICAgICAoIWlzUm9vdCB8fCBWQUxJREFUSU9OX01PREUuYWxsKSkpO1xufTtcblxudmFyIGNvbnZlcnRUb0FycmF5UGF5bG9hZCA9ICh2YWx1ZSkgPT4gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcblxudmFyIHNob3VsZFN1YnNjcmliZUJ5TmFtZSA9IChuYW1lLCBzaWduYWxOYW1lLCBleGFjdCkgPT4gIW5hbWUgfHxcbiAgICAhc2lnbmFsTmFtZSB8fFxuICAgIG5hbWUgPT09IHNpZ25hbE5hbWUgfHxcbiAgICBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkuc29tZSgoY3VycmVudE5hbWUpID0+IGN1cnJlbnROYW1lICYmXG4gICAgICAgIChleGFjdFxuICAgICAgICAgICAgPyBjdXJyZW50TmFtZSA9PT0gc2lnbmFsTmFtZVxuICAgICAgICAgICAgOiBjdXJyZW50TmFtZS5zdGFydHNXaXRoKHNpZ25hbE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgc2lnbmFsTmFtZS5zdGFydHNXaXRoKGN1cnJlbnROYW1lKSkpO1xuXG5mdW5jdGlvbiB1c2VTdWJzY3JpYmUocHJvcHMpIHtcbiAgICBjb25zdCBfcHJvcHMgPSBSZWFjdC51c2VSZWYocHJvcHMpO1xuICAgIF9wcm9wcy5jdXJyZW50ID0gcHJvcHM7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gIXByb3BzLmRpc2FibGVkICYmXG4gICAgICAgICAgICBfcHJvcHMuY3VycmVudC5zdWJqZWN0ICYmXG4gICAgICAgICAgICBfcHJvcHMuY3VycmVudC5zdWJqZWN0LnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogX3Byb3BzLmN1cnJlbnQubmV4dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uICYmIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtwcm9wcy5kaXNhYmxlZF0pO1xufVxuXG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBzdWJzY3JpYmUgdG8gZWFjaCBmb3JtIHN0YXRlLCBhbmQgaXNvbGF0ZSB0aGUgcmUtcmVuZGVyIGF0IHRoZSBjdXN0b20gaG9vayBsZXZlbC4gSXQgaGFzIGl0cyBzY29wZSBpbiB0ZXJtcyBvZiBmb3JtIHN0YXRlIHN1YnNjcmlwdGlvbiwgc28gaXQgd291bGQgbm90IGFmZmVjdCBvdGhlciB1c2VGb3JtU3RhdGUgYW5kIHVzZUZvcm0uIFVzaW5nIHRoaXMgaG9vayBjYW4gcmVkdWNlIHRoZSByZS1yZW5kZXIgaW1wYWN0IG9uIGxhcmdlIGFuZCBjb21wbGV4IGZvcm0gYXBwbGljYXRpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm1zdGF0ZSkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdXNlZm9ybXN0YXRlLTc1eGx5KVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIGluY2x1ZGUgb3B0aW9ucyBvbiBzcGVjaWZ5IGZpZWxkcyB0byBzdWJzY3JpYmUuIHtAbGluayBVc2VGb3JtU3RhdGVSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBoYW5kbGVTdWJtaXQsIGNvbnRyb2wgfSA9IHVzZUZvcm0oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICBmaXJzdE5hbWU6IFwiZmlyc3ROYW1lXCJcbiAqICAgfX0pO1xuICogICBjb25zdCB7IGRpcnR5RmllbGRzIH0gPSB1c2VGb3JtU3RhdGUoe1xuICogICAgIGNvbnRyb2xcbiAqICAgfSk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gKGRhdGEpID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwiZmlyc3ROYW1lXCIpfSBwbGFjZWhvbGRlcj1cIkZpcnN0IE5hbWVcIiAvPlxuICogICAgICAge2RpcnR5RmllbGRzLmZpcnN0TmFtZSAmJiA8cD5GaWVsZCBpcyBkaXJ0eS48L3A+fVxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGb3JtU3RhdGUocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIGRpc2FibGVkLCBuYW1lLCBleGFjdCB9ID0gcHJvcHMgfHwge307XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGNvbnRyb2wuX2Zvcm1TdGF0ZSk7XG4gICAgY29uc3QgX21vdW50ZWQgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gICAgY29uc3QgX2xvY2FsUHJveHlGb3JtU3RhdGUgPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB0b3VjaGVkRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH0pO1xuICAgIGNvbnN0IF9uYW1lID0gUmVhY3QudXNlUmVmKG5hbWUpO1xuICAgIF9uYW1lLmN1cnJlbnQgPSBuYW1lO1xuICAgIHVzZVN1YnNjcmliZSh7XG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBuZXh0OiAodmFsdWUpID0+IF9tb3VudGVkLmN1cnJlbnQgJiZcbiAgICAgICAgICAgIHNob3VsZFN1YnNjcmliZUJ5TmFtZShfbmFtZS5jdXJyZW50LCB2YWx1ZS5uYW1lLCBleGFjdCkgJiZcbiAgICAgICAgICAgIHNob3VsZFJlbmRlckZvcm1TdGF0ZSh2YWx1ZSwgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudCwgY29udHJvbC5fdXBkYXRlRm9ybVN0YXRlKSAmJlxuICAgICAgICAgICAgdXBkYXRlRm9ybVN0YXRlKHtcbiAgICAgICAgICAgICAgICAuLi5jb250cm9sLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgc3ViamVjdDogY29udHJvbC5fc3ViamVjdHMuc3RhdGUsXG4gICAgfSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgX21vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIF9sb2NhbFByb3h5Rm9ybVN0YXRlLmN1cnJlbnQuaXNWYWxpZCAmJiBjb250cm9sLl91cGRhdGVWYWxpZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIF9tb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbY29udHJvbF0pO1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGdldFByb3h5Rm9ybVN0YXRlKGZvcm1TdGF0ZSwgY29udHJvbCwgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudCwgZmFsc2UpLCBbZm9ybVN0YXRlLCBjb250cm9sXSk7XG59XG5cbnZhciBpc1N0cmluZyA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcblxudmFyIGdlbmVyYXRlV2F0Y2hPdXRwdXQgPSAobmFtZXMsIF9uYW1lcywgZm9ybVZhbHVlcywgaXNHbG9iYWwsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIGlmIChpc1N0cmluZyhuYW1lcykpIHtcbiAgICAgICAgaXNHbG9iYWwgJiYgX25hbWVzLndhdGNoLmFkZChuYW1lcyk7XG4gICAgICAgIHJldHVybiBnZXQoZm9ybVZhbHVlcywgbmFtZXMsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWVzKSkge1xuICAgICAgICByZXR1cm4gbmFtZXMubWFwKChmaWVsZE5hbWUpID0+IChpc0dsb2JhbCAmJiBfbmFtZXMud2F0Y2guYWRkKGZpZWxkTmFtZSksIGdldChmb3JtVmFsdWVzLCBmaWVsZE5hbWUpKSk7XG4gICAgfVxuICAgIGlzR2xvYmFsICYmIChfbmFtZXMud2F0Y2hBbGwgPSB0cnVlKTtcbiAgICByZXR1cm4gZm9ybVZhbHVlcztcbn07XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgdG8gc3Vic2NyaWJlIHRvIGZpZWxkIGNoYW5nZSBhbmQgaXNvbGF0ZSByZS1yZW5kZXJpbmcgYXQgdGhlIGNvbXBvbmVudCBsZXZlbC5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZXdhdGNoKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctdHMtdXNld2F0Y2gtaDlpNWUpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgeyBjb250cm9sIH0gPSB1c2VGb3JtKCk7XG4gKiBjb25zdCB2YWx1ZXMgPSB1c2VXYXRjaCh7XG4gKiAgIG5hbWU6IFwiZmllbGROYW1lXCJcbiAqICAgY29udHJvbCxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlV2F0Y2gocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIG5hbWUsIGRlZmF1bHRWYWx1ZSwgZGlzYWJsZWQsIGV4YWN0LCB9ID0gcHJvcHMgfHwge307XG4gICAgY29uc3QgX25hbWUgPSBSZWFjdC51c2VSZWYobmFtZSk7XG4gICAgX25hbWUuY3VycmVudCA9IG5hbWU7XG4gICAgdXNlU3Vic2NyaWJlKHtcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIHN1YmplY3Q6IGNvbnRyb2wuX3N1YmplY3RzLnZhbHVlcyxcbiAgICAgICAgbmV4dDogKGZvcm1TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3VsZFN1YnNjcmliZUJ5TmFtZShfbmFtZS5jdXJyZW50LCBmb3JtU3RhdGUubmFtZSwgZXhhY3QpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoY2xvbmVPYmplY3QoZ2VuZXJhdGVXYXRjaE91dHB1dChfbmFtZS5jdXJyZW50LCBjb250cm9sLl9uYW1lcywgZm9ybVN0YXRlLnZhbHVlcyB8fCBjb250cm9sLl9mb3JtVmFsdWVzLCBmYWxzZSwgZGVmYXVsdFZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IFt2YWx1ZSwgdXBkYXRlVmFsdWVdID0gUmVhY3QudXNlU3RhdGUoY29udHJvbC5fZ2V0V2F0Y2gobmFtZSwgZGVmYXVsdFZhbHVlKSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IGNvbnRyb2wuX3JlbW92ZVVubW91bnRlZCgpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgdG8gd29yayB3aXRoIGNvbnRyb2xsZWQgY29tcG9uZW50LCB0aGlzIGZ1bmN0aW9uIHByb3ZpZGUgeW91IHdpdGggYm90aCBmb3JtIGFuZCBmaWVsZCBsZXZlbCBzdGF0ZS4gUmUtcmVuZGVyIGlzIGlzb2xhdGVkIGF0IHRoZSBob29rIGxldmVsLlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vjb250cm9sbGVyKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy91c2Vjb250cm9sbGVyLTBvOHB4KVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIHRoZSBwYXRoIG5hbWUgdG8gdGhlIGZvcm0gZmllbGQgdmFsdWUsIGFuZCB2YWxpZGF0aW9uIHJ1bGVzLlxuICpcbiAqIEByZXR1cm5zIGZpZWxkIHByb3BlcnRpZXMsIGZpZWxkIGFuZCBmb3JtIHN0YXRlLiB7QGxpbmsgVXNlQ29udHJvbGxlclJldHVybn1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBJbnB1dChwcm9wcykge1xuICogICBjb25zdCB7IGZpZWxkLCBmaWVsZFN0YXRlLCBmb3JtU3RhdGUgfSA9IHVzZUNvbnRyb2xsZXIocHJvcHMpO1xuICogICByZXR1cm4gKFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8aW5wdXQgey4uLmZpZWxkfSBwbGFjZWhvbGRlcj17cHJvcHMubmFtZX0gLz5cbiAqICAgICAgIDxwPntmaWVsZFN0YXRlLmlzVG91Y2hlZCAmJiBcIlRvdWNoZWRcIn08L3A+XG4gKiAgICAgICA8cD57Zm9ybVN0YXRlLmlzU3VibWl0dGVkID8gXCJzdWJtaXR0ZWRcIiA6IFwiXCJ9PC9wPlxuICogICAgIDwvZGl2PlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUNvbnRyb2xsZXIocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IG5hbWUsIGRpc2FibGVkLCBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBzaG91bGRVbnJlZ2lzdGVyIH0gPSBwcm9wcztcbiAgICBjb25zdCBpc0FycmF5RmllbGQgPSBpc05hbWVJbkZpZWxkQXJyYXkoY29udHJvbC5fbmFtZXMuYXJyYXksIG5hbWUpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlV2F0Y2goe1xuICAgICAgICBjb250cm9sLFxuICAgICAgICBuYW1lLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lLCBnZXQoY29udHJvbC5fZGVmYXVsdFZhbHVlcywgbmFtZSwgcHJvcHMuZGVmYXVsdFZhbHVlKSksXG4gICAgICAgIGV4YWN0OiB0cnVlLFxuICAgIH0pO1xuICAgIGNvbnN0IGZvcm1TdGF0ZSA9IHVzZUZvcm1TdGF0ZSh7XG4gICAgICAgIGNvbnRyb2wsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGV4YWN0OiB0cnVlLFxuICAgIH0pO1xuICAgIGNvbnN0IF9yZWdpc3RlclByb3BzID0gUmVhY3QudXNlUmVmKGNvbnRyb2wucmVnaXN0ZXIobmFtZSwge1xuICAgICAgICAuLi5wcm9wcy5ydWxlcyxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIC4uLihpc0Jvb2xlYW4ocHJvcHMuZGlzYWJsZWQpID8geyBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfSA6IHt9KSxcbiAgICB9KSk7XG4gICAgY29uc3QgZmllbGRTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe30sIHtcbiAgICAgICAgaW52YWxpZDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gISFnZXQoZm9ybVN0YXRlLmVycm9ycywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlydHk6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgICAgIGlzVG91Y2hlZDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gISFnZXQoZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBuYW1lKSxcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+IGdldChmb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgfSxcbiAgICB9KSwgW2Zvcm1TdGF0ZSwgbmFtZV0pO1xuICAgIGNvbnN0IGZpZWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uKGlzQm9vbGVhbihkaXNhYmxlZCkgfHwgZm9ybVN0YXRlLmRpc2FibGVkXG4gICAgICAgICAgICA/IHsgZGlzYWJsZWQ6IGZvcm1TdGF0ZS5kaXNhYmxlZCB8fCBkaXNhYmxlZCB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgb25DaGFuZ2U6IChldmVudCkgPT4gX3JlZ2lzdGVyUHJvcHMuY3VycmVudC5vbkNoYW5nZSh7XG4gICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0RXZlbnRWYWx1ZShldmVudCksXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiBFVkVOVFMuQ0hBTkdFLFxuICAgICAgICB9KSxcbiAgICAgICAgb25CbHVyOiAoKSA9PiBfcmVnaXN0ZXJQcm9wcy5jdXJyZW50Lm9uQmx1cih7XG4gICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUpLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogRVZFTlRTLkJMVVIsXG4gICAgICAgIH0pLFxuICAgICAgICByZWY6IChlbG0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICBpZiAoZmllbGQgJiYgZWxtKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuX2YucmVmID0ge1xuICAgICAgICAgICAgICAgICAgICBmb2N1czogKCkgPT4gZWxtLmZvY3VzKCksXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdDogKCkgPT4gZWxtLnNlbGVjdCgpLFxuICAgICAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eTogKG1lc3NhZ2UpID0+IGVsbS5zZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0VmFsaWRpdHk6ICgpID0+IGVsbS5yZXBvcnRWYWxpZGl0eSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSksIFtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY29udHJvbC5fZm9ybVZhbHVlcyxcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIGZvcm1TdGF0ZS5kaXNhYmxlZCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNvbnRyb2wuX2ZpZWxkcyxcbiAgICBdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBfc2hvdWxkVW5yZWdpc3RlckZpZWxkID0gY29udHJvbC5fb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IHNob3VsZFVucmVnaXN0ZXI7XG4gICAgICAgIGNvbnN0IHVwZGF0ZU1vdW50ZWQgPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5tb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB1cGRhdGVNb3VudGVkKG5hbWUsIHRydWUpO1xuICAgICAgICBpZiAoX3Nob3VsZFVucmVnaXN0ZXJGaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjbG9uZU9iamVjdChnZXQoY29udHJvbC5fb3B0aW9ucy5kZWZhdWx0VmFsdWVzLCBuYW1lKSk7XG4gICAgICAgICAgICBzZXQoY29udHJvbC5fZGVmYXVsdFZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBzZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICFpc0FycmF5RmllbGQgJiYgY29udHJvbC5yZWdpc3RlcihuYW1lKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIChpc0FycmF5RmllbGRcbiAgICAgICAgICAgICAgICA/IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQgJiYgIWNvbnRyb2wuX3N0YXRlLmFjdGlvblxuICAgICAgICAgICAgICAgIDogX3Nob3VsZFVucmVnaXN0ZXJGaWVsZClcbiAgICAgICAgICAgICAgICA/IGNvbnRyb2wudW5yZWdpc3RlcihuYW1lKVxuICAgICAgICAgICAgICAgIDogdXBkYXRlTW91bnRlZChuYW1lLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgfSwgW25hbWUsIGNvbnRyb2wsIGlzQXJyYXlGaWVsZCwgc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZURpc2FibGVkRmllbGQoe1xuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBmaWVsZHM6IGNvbnRyb2wuX2ZpZWxkcyxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH0pO1xuICAgIH0sIFtkaXNhYmxlZCwgbmFtZSwgY29udHJvbF0pO1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGZpZWxkLFxuICAgICAgICBmb3JtU3RhdGUsXG4gICAgICAgIGZpZWxkU3RhdGUsXG4gICAgfSksIFtmaWVsZCwgZm9ybVN0YXRlLCBmaWVsZFN0YXRlXSk7XG59XG5cbi8qKlxuICogQ29tcG9uZW50IGJhc2VkIG9uIGB1c2VDb250cm9sbGVyYCBob29rIHRvIHdvcmsgd2l0aCBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlY29udHJvbGxlci9jb250cm9sbGVyKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjYtY29udHJvbGxlci10cy1qd3l6dykg4oCiIFtWaWRlb10oaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1OMlVOa19VQ1Z5QSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB0aGUgcGF0aCBuYW1lIHRvIHRoZSBmb3JtIGZpZWxkIHZhbHVlLCBhbmQgdmFsaWRhdGlvbiBydWxlcy5cbiAqXG4gKiBAcmV0dXJucyBwcm92aWRlIGZpZWxkIGhhbmRsZXIgZnVuY3Rpb25zLCBmaWVsZCBhbmQgZm9ybSBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgY29udHJvbCB9ID0gdXNlRm9ybTxGb3JtVmFsdWVzPih7XG4gKiAgICAgZGVmYXVsdFZhbHVlczoge1xuICogICAgICAgdGVzdDogXCJcIlxuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxmb3JtPlxuICogICAgICAgPENvbnRyb2xsZXJcbiAqICAgICAgICAgY29udHJvbD17Y29udHJvbH1cbiAqICAgICAgICAgbmFtZT1cInRlc3RcIlxuICogICAgICAgICByZW5kZXI9eyh7IGZpZWxkOiB7IG9uQ2hhbmdlLCBvbkJsdXIsIHZhbHVlLCByZWYgfSwgZm9ybVN0YXRlLCBmaWVsZFN0YXRlIH0pID0+IChcbiAqICAgICAgICAgICA8PlxuICogICAgICAgICAgICAgPGlucHV0XG4gKiAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX0gLy8gc2VuZCB2YWx1ZSB0byBob29rIGZvcm1cbiAqICAgICAgICAgICAgICAgb25CbHVyPXtvbkJsdXJ9IC8vIG5vdGlmeSB3aGVuIGlucHV0IGlzIHRvdWNoZWRcbiAqICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfSAvLyByZXR1cm4gdXBkYXRlZCB2YWx1ZVxuICogICAgICAgICAgICAgICByZWY9e3JlZn0gLy8gc2V0IHJlZiBmb3IgZm9jdXMgbWFuYWdlbWVudFxuICogICAgICAgICAgICAgLz5cbiAqICAgICAgICAgICAgIDxwPntmb3JtU3RhdGUuaXNTdWJtaXR0ZWQgPyBcInN1Ym1pdHRlZFwiIDogXCJcIn08L3A+XG4gKiAgICAgICAgICAgICA8cD57ZmllbGRTdGF0ZS5pc1RvdWNoZWQgPyBcInRvdWNoZWRcIiA6IFwiXCJ9PC9wPlxuICogICAgICAgICAgIDwvPlxuICogICAgICAgICApfVxuICogICAgICAgLz5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgQ29udHJvbGxlciA9IChwcm9wcykgPT4gcHJvcHMucmVuZGVyKHVzZUNvbnRyb2xsZXIocHJvcHMpKTtcblxuY29uc3QgZmxhdHRlbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgIGlmIChpc09iamVjdFR5cGUob2JqW2tleV0pICYmIG9ialtrZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXN0ZWQgPSBmbGF0dGVuKG9ialtrZXldKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmVzdGVkS2V5IG9mIE9iamVjdC5rZXlzKG5lc3RlZCkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbYCR7a2V5fS4ke25lc3RlZEtleX1gXSA9IG5lc3RlZFtuZXN0ZWRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29uc3QgUE9TVF9SRVFVRVNUID0gJ3Bvc3QnO1xuLyoqXG4gKiBGb3JtIGNvbXBvbmVudCB0byBtYW5hZ2Ugc3VibWlzc2lvbi5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB0byBzZXR1cCBzdWJtaXNzaW9uIGRldGFpbC4ge0BsaW5rIEZvcm1Qcm9wc31cbiAqXG4gKiBAcmV0dXJucyBmb3JtIGNvbXBvbmVudCBvciBoZWFkbGVzcyByZW5kZXIgcHJvcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgY29udHJvbCwgZm9ybVN0YXRlOiB7IGVycm9ycyB9IH0gPSB1c2VGb3JtKCk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxGb3JtIGFjdGlvbj1cIi9hcGlcIiBjb250cm9sPXtjb250cm9sfT5cbiAqICAgICAgIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJuYW1lXCIpfSAvPlxuICogICAgICAgPHA+e2Vycm9ycz8ucm9vdD8uc2VydmVyICYmICdTZXJ2ZXIgZXJyb3InfTwvcD5cbiAqICAgICAgIDxidXR0b24+U3VibWl0PC9idXR0b24+XG4gKiAgICAgPC9Gb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIEZvcm0ocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBvblN1Ym1pdCwgY2hpbGRyZW4sIGFjdGlvbiwgbWV0aG9kID0gUE9TVF9SRVFVRVNULCBoZWFkZXJzLCBlbmNUeXBlLCBvbkVycm9yLCByZW5kZXIsIG9uU3VjY2VzcywgdmFsaWRhdGVTdGF0dXMsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIGNvbnN0IHN1Ym1pdCA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgbGV0IHR5cGUgPSAnJztcbiAgICAgICAgYXdhaXQgY29udHJvbC5oYW5kbGVTdWJtaXQoYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICBsZXQgZm9ybURhdGFKc29uID0gJyc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhSnNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5Gb3JtVmFsdWVzID0gZmxhdHRlbihjb250cm9sLl9mb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZsYXR0ZW5Gb3JtVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgZmxhdHRlbkZvcm1WYWx1ZXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25TdWJtaXQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvblN1Ym1pdCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YUpzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgXS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgJiYgdmFsdWUuaW5jbHVkZXMoJ2pzb24nKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goU3RyaW5nKGFjdGlvbiksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihlbmNUeXBlID8geyAnQ29udGVudC1UeXBlJzogZW5jVHlwZSB9IDoge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHNob3VsZFN0cmluZ2lmeVN1Ym1pc3Npb25EYXRhID8gZm9ybURhdGFKc29uIDogZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWxpZGF0ZVN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gIXZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLnN0YXR1cyA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPj0gMzAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvciAmJiBvbkVycm9yKHsgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gU3RyaW5nKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MgJiYgb25TdWNjZXNzKHsgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvciAmJiBvbkVycm9yKHsgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KShldmVudCk7XG4gICAgICAgIGlmIChoYXNFcnJvciAmJiBwcm9wcy5jb250cm9sKSB7XG4gICAgICAgICAgICBwcm9wcy5jb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9wcy5jb250cm9sLnNldEVycm9yKCdyb290LnNlcnZlcicsIHtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiByZW5kZXIgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcmVuZGVyKHtcbiAgICAgICAgc3VibWl0LFxuICAgIH0pKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgeyBub1ZhbGlkYXRlOiBtb3VudGVkLCBhY3Rpb246IGFjdGlvbiwgbWV0aG9kOiBtZXRob2QsIGVuY1R5cGU6IGVuY1R5cGUsIG9uU3VibWl0OiBzdWJtaXQsIC4uLnJlc3QgfSwgY2hpbGRyZW4pKTtcbn1cblxudmFyIGFwcGVuZEVycm9ycyA9IChuYW1lLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGVycm9ycywgdHlwZSwgbWVzc2FnZSkgPT4gdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhXG4gICAgPyB7XG4gICAgICAgIC4uLmVycm9yc1tuYW1lXSxcbiAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICAgIC4uLihlcnJvcnNbbmFtZV0gJiYgZXJyb3JzW25hbWVdLnR5cGVzID8gZXJyb3JzW25hbWVdLnR5cGVzIDoge30pLFxuICAgICAgICAgICAgW3R5cGVdOiBtZXNzYWdlIHx8IHRydWUsXG4gICAgICAgIH0sXG4gICAgfVxuICAgIDoge307XG5cbnZhciBnZW5lcmF0ZUlkID0gKCkgPT4ge1xuICAgIGNvbnN0IGQgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnID8gRGF0ZS5ub3coKSA6IHBlcmZvcm1hbmNlLm5vdygpICogMTAwMDtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNiArIGQpICUgMTYgfCAwO1xuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufTtcblxudmFyIGdldEZvY3VzRmllbGROYW1lID0gKG5hbWUsIGluZGV4LCBvcHRpb25zID0ge30pID0+IG9wdGlvbnMuc2hvdWxkRm9jdXMgfHwgaXNVbmRlZmluZWQob3B0aW9ucy5zaG91bGRGb2N1cylcbiAgICA/IG9wdGlvbnMuZm9jdXNOYW1lIHx8XG4gICAgICAgIGAke25hbWV9LiR7aXNVbmRlZmluZWQob3B0aW9ucy5mb2N1c0luZGV4KSA/IGluZGV4IDogb3B0aW9ucy5mb2N1c0luZGV4fS5gXG4gICAgOiAnJztcblxudmFyIGdldFZhbGlkYXRpb25Nb2RlcyA9IChtb2RlKSA9PiAoe1xuICAgIGlzT25TdWJtaXQ6ICFtb2RlIHx8IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcbiAgICBpc09uQmx1cjogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQmx1cixcbiAgICBpc09uQ2hhbmdlOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsXG4gICAgaXNPbkFsbDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbCxcbiAgICBpc09uVG91Y2g6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblRvdWNoZWQsXG59KTtcblxudmFyIGlzV2F0Y2hlZCA9IChuYW1lLCBfbmFtZXMsIGlzQmx1ckV2ZW50KSA9PiAhaXNCbHVyRXZlbnQgJiZcbiAgICAoX25hbWVzLndhdGNoQWxsIHx8XG4gICAgICAgIF9uYW1lcy53YXRjaC5oYXMobmFtZSkgfHxcbiAgICAgICAgWy4uLl9uYW1lcy53YXRjaF0uc29tZSgod2F0Y2hOYW1lKSA9PiBuYW1lLnN0YXJ0c1dpdGgod2F0Y2hOYW1lKSAmJlxuICAgICAgICAgICAgL15cXC5cXHcrLy50ZXN0KG5hbWUuc2xpY2Uod2F0Y2hOYW1lLmxlbmd0aCkpKSk7XG5cbmNvbnN0IGl0ZXJhdGVGaWVsZHNCeUFjdGlvbiA9IChmaWVsZHMsIGFjdGlvbiwgZmllbGRzTmFtZXMsIGFib3J0RWFybHkpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBmaWVsZHNOYW1lcyB8fCBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGZpZWxkcywga2V5KTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCB7IF9mLCAuLi5jdXJyZW50RmllbGQgfSA9IGZpZWxkO1xuICAgICAgICAgICAgaWYgKF9mKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9mLnJlZnMgJiYgX2YucmVmc1swXSAmJiBhY3Rpb24oX2YucmVmc1swXSwga2V5KSAmJiAhYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2YucmVmICYmIGFjdGlvbihfZi5yZWYsIF9mLm5hbWUpICYmICFhYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihjdXJyZW50RmllbGQsIGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QoY3VycmVudEZpZWxkKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRlRmllbGRzQnlBY3Rpb24oY3VycmVudEZpZWxkLCBhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59O1xuXG52YXIgdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvciA9IChlcnJvcnMsIGVycm9yLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgZmllbGRBcnJheUVycm9ycyA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChnZXQoZXJyb3JzLCBuYW1lKSk7XG4gICAgc2V0KGZpZWxkQXJyYXlFcnJvcnMsICdyb290JywgZXJyb3JbbmFtZV0pO1xuICAgIHNldChlcnJvcnMsIG5hbWUsIGZpZWxkQXJyYXlFcnJvcnMpO1xuICAgIHJldHVybiBlcnJvcnM7XG59O1xuXG52YXIgaXNGaWxlSW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAnZmlsZSc7XG5cbnZhciBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cbnZhciBpc0hUTUxFbGVtZW50ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc1dlYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG93bmVyID0gdmFsdWUgPyB2YWx1ZS5vd25lckRvY3VtZW50IDogMDtcbiAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2ZcbiAgICAgICAgKG93bmVyICYmIG93bmVyLmRlZmF1bHRWaWV3ID8gb3duZXIuZGVmYXVsdFZpZXcuSFRNTEVsZW1lbnQgOiBIVE1MRWxlbWVudCkpO1xufTtcblxudmFyIGlzTWVzc2FnZSA9ICh2YWx1ZSkgPT4gaXNTdHJpbmcodmFsdWUpO1xuXG52YXIgaXNSYWRpb0lucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJztcblxudmFyIGlzUmVnZXggPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuXG5jb25zdCBkZWZhdWx0UmVzdWx0ID0ge1xuICAgIHZhbHVlOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbn07XG5jb25zdCB2YWxpZFJlc3VsdCA9IHsgdmFsdWU6IHRydWUsIGlzVmFsaWQ6IHRydWUgfTtcbnZhciBnZXRDaGVja2JveFZhbHVlID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBvcHRpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigob3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICAubWFwKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWVzLCBpc1ZhbGlkOiAhIXZhbHVlcy5sZW5ndGggfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9uc1swXS5jaGVja2VkICYmICFvcHRpb25zWzBdLmRpc2FibGVkXG4gICAgICAgICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3IgZXhwZWN0ZWQgdG8gd29yayBpbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uYXR0cmlidXRlcyAmJiAhaXNVbmRlZmluZWQob3B0aW9uc1swXS5hdHRyaWJ1dGVzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IGlzVW5kZWZpbmVkKG9wdGlvbnNbMF0udmFsdWUpIHx8IG9wdGlvbnNbMF0udmFsdWUgPT09ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbGlkUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgdmFsdWU6IG9wdGlvbnNbMF0udmFsdWUsIGlzVmFsaWQ6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICA6IHZhbGlkUmVzdWx0XG4gICAgICAgICAgICA6IGRlZmF1bHRSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xufTtcblxuY29uc3QgZGVmYXVsdFJldHVybiA9IHtcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICB2YWx1ZTogbnVsbCxcbn07XG52YXIgZ2V0UmFkaW9WYWx1ZSA9IChvcHRpb25zKSA9PiBBcnJheS5pc0FycmF5KG9wdGlvbnMpXG4gICAgPyBvcHRpb25zLnJlZHVjZSgocHJldmlvdXMsIG9wdGlvbikgPT4gb3B0aW9uICYmIG9wdGlvbi5jaGVja2VkICYmICFvcHRpb24uZGlzYWJsZWRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcbiAgICAgICAgfVxuICAgICAgICA6IHByZXZpb3VzLCBkZWZhdWx0UmV0dXJuKVxuICAgIDogZGVmYXVsdFJldHVybjtcblxuZnVuY3Rpb24gZ2V0VmFsaWRhdGVFcnJvcihyZXN1bHQsIHJlZiwgdHlwZSA9ICd2YWxpZGF0ZScpIHtcbiAgICBpZiAoaXNNZXNzYWdlKHJlc3VsdCkgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQuZXZlcnkoaXNNZXNzYWdlKSkgfHxcbiAgICAgICAgKGlzQm9vbGVhbihyZXN1bHQpICYmICFyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNNZXNzYWdlKHJlc3VsdCkgPyByZXN1bHQgOiAnJyxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbnZhciBnZXRWYWx1ZUFuZE1lc3NhZ2UgPSAodmFsaWRhdGlvbkRhdGEpID0+IGlzT2JqZWN0KHZhbGlkYXRpb25EYXRhKSAmJiAhaXNSZWdleCh2YWxpZGF0aW9uRGF0YSlcbiAgICA/IHZhbGlkYXRpb25EYXRhXG4gICAgOiB7XG4gICAgICAgIHZhbHVlOiB2YWxpZGF0aW9uRGF0YSxcbiAgICAgICAgbWVzc2FnZTogJycsXG4gICAgfTtcblxudmFyIHZhbGlkYXRlRmllbGQgPSBhc3luYyAoZmllbGQsIGRpc2FibGVkRmllbGROYW1lcywgZm9ybVZhbHVlcywgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uLCBpc0ZpZWxkQXJyYXkpID0+IHtcbiAgICBjb25zdCB7IHJlZiwgcmVmcywgcmVxdWlyZWQsIG1heExlbmd0aCwgbWluTGVuZ3RoLCBtaW4sIG1heCwgcGF0dGVybiwgdmFsaWRhdGUsIG5hbWUsIHZhbHVlQXNOdW1iZXIsIG1vdW50LCB9ID0gZmllbGQuX2Y7XG4gICAgY29uc3QgaW5wdXRWYWx1ZSA9IGdldChmb3JtVmFsdWVzLCBuYW1lKTtcbiAgICBpZiAoIW1vdW50IHx8IGRpc2FibGVkRmllbGROYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFJlZiA9IHJlZnMgPyByZWZzWzBdIDogcmVmO1xuICAgIGNvbnN0IHNldEN1c3RvbVZhbGlkaXR5ID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24gJiYgaW5wdXRSZWYucmVwb3J0VmFsaWRpdHkpIHtcbiAgICAgICAgICAgIGlucHV0UmVmLnNldEN1c3RvbVZhbGlkaXR5KGlzQm9vbGVhbihtZXNzYWdlKSA/ICcnIDogbWVzc2FnZSB8fCAnJyk7XG4gICAgICAgICAgICBpbnB1dFJlZi5yZXBvcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlcnJvciA9IHt9O1xuICAgIGNvbnN0IGlzUmFkaW8gPSBpc1JhZGlvSW5wdXQocmVmKTtcbiAgICBjb25zdCBpc0NoZWNrQm94ID0gaXNDaGVja0JveElucHV0KHJlZik7XG4gICAgY29uc3QgaXNSYWRpb09yQ2hlY2tib3ggPSBpc1JhZGlvIHx8IGlzQ2hlY2tCb3g7XG4gICAgY29uc3QgaXNFbXB0eSA9ICgodmFsdWVBc051bWJlciB8fCBpc0ZpbGVJbnB1dChyZWYpKSAmJlxuICAgICAgICBpc1VuZGVmaW5lZChyZWYudmFsdWUpICYmXG4gICAgICAgIGlzVW5kZWZpbmVkKGlucHV0VmFsdWUpKSB8fFxuICAgICAgICAoaXNIVE1MRWxlbWVudChyZWYpICYmIHJlZi52YWx1ZSA9PT0gJycpIHx8XG4gICAgICAgIGlucHV0VmFsdWUgPT09ICcnIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpICYmICFpbnB1dFZhbHVlLmxlbmd0aCk7XG4gICAgY29uc3QgYXBwZW5kRXJyb3JzQ3VycnkgPSBhcHBlbmRFcnJvcnMuYmluZChudWxsLCBuYW1lLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGVycm9yKTtcbiAgICBjb25zdCBnZXRNaW5NYXhNZXNzYWdlID0gKGV4Y2VlZE1heCwgbWF4TGVuZ3RoTWVzc2FnZSwgbWluTGVuZ3RoTWVzc2FnZSwgbWF4VHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWF4TGVuZ3RoLCBtaW5UeXBlID0gSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW5MZW5ndGgpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV4Y2VlZE1heCA/IG1heExlbmd0aE1lc3NhZ2UgOiBtaW5MZW5ndGhNZXNzYWdlO1xuICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV4Y2VlZE1heCA/IG1heFR5cGUgOiBtaW5UeXBlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KGV4Y2VlZE1heCA/IG1heFR5cGUgOiBtaW5UeXBlLCBtZXNzYWdlKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGlmIChpc0ZpZWxkQXJyYXlcbiAgICAgICAgPyAhQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSB8fCAhaW5wdXRWYWx1ZS5sZW5ndGhcbiAgICAgICAgOiByZXF1aXJlZCAmJlxuICAgICAgICAgICAgKCghaXNSYWRpb09yQ2hlY2tib3ggJiYgKGlzRW1wdHkgfHwgaXNOdWxsT3JVbmRlZmluZWQoaW5wdXRWYWx1ZSkpKSB8fFxuICAgICAgICAgICAgICAgIChpc0Jvb2xlYW4oaW5wdXRWYWx1ZSkgJiYgIWlucHV0VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgKGlzQ2hlY2tCb3ggJiYgIWdldENoZWNrYm94VmFsdWUocmVmcykuaXNWYWxpZCkgfHxcbiAgICAgICAgICAgICAgICAoaXNSYWRpbyAmJiAhZ2V0UmFkaW9WYWx1ZShyZWZzKS5pc1ZhbGlkKSkpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgbWVzc2FnZSB9ID0gaXNNZXNzYWdlKHJlcXVpcmVkKVxuICAgICAgICAgICAgPyB7IHZhbHVlOiAhIXJlcXVpcmVkLCBtZXNzYWdlOiByZXF1aXJlZCB9XG4gICAgICAgICAgICA6IGdldFZhbHVlQW5kTWVzc2FnZShyZXF1aXJlZCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlZjogaW5wdXRSZWYsXG4gICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCwgbWVzc2FnZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0VtcHR5ICYmICghaXNOdWxsT3JVbmRlZmluZWQobWluKSB8fCAhaXNOdWxsT3JVbmRlZmluZWQobWF4KSkpIHtcbiAgICAgICAgbGV0IGV4Y2VlZE1heDtcbiAgICAgICAgbGV0IGV4Y2VlZE1pbjtcbiAgICAgICAgY29uc3QgbWF4T3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heCk7XG4gICAgICAgIGNvbnN0IG1pbk91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW4pO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGlucHV0VmFsdWUpICYmICFpc05hTihpbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVOdW1iZXIgPSByZWYudmFsdWVBc051bWJlciB8fFxuICAgICAgICAgICAgICAgIChpbnB1dFZhbHVlID8gK2lucHV0VmFsdWUgOiBpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWF4T3V0cHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IHZhbHVlTnVtYmVyID4gbWF4T3V0cHV0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtaW5PdXRwdXQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWluID0gdmFsdWVOdW1iZXIgPCBtaW5PdXRwdXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZURhdGUgPSByZWYudmFsdWVBc0RhdGUgfHwgbmV3IERhdGUoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0VGltZVRvRGF0ZSA9ICh0aW1lKSA9PiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnRvRGF0ZVN0cmluZygpICsgJyAnICsgdGltZSk7XG4gICAgICAgICAgICBjb25zdCBpc1RpbWUgPSByZWYudHlwZSA9PSAndGltZSc7XG4gICAgICAgICAgICBjb25zdCBpc1dlZWsgPSByZWYudHlwZSA9PSAnd2Vlayc7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWF4T3V0cHV0LnZhbHVlKSAmJiBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWF4ID0gaXNUaW1lXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFRpbWVUb0RhdGUoaW5wdXRWYWx1ZSkgPiBjb252ZXJ0VGltZVRvRGF0ZShtYXhPdXRwdXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaXNXZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGlucHV0VmFsdWUgPiBtYXhPdXRwdXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVEYXRlID4gbmV3IERhdGUobWF4T3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhtaW5PdXRwdXQudmFsdWUpICYmIGlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNaW4gPSBpc1RpbWVcbiAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0VGltZVRvRGF0ZShpbnB1dFZhbHVlKSA8IGNvbnZlcnRUaW1lVG9EYXRlKG1pbk91dHB1dC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBpc1dlZWtcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5wdXRWYWx1ZSA8IG1pbk91dHB1dC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZURhdGUgPCBuZXcgRGF0ZShtaW5PdXRwdXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKCEhZXhjZWVkTWF4LCBtYXhPdXRwdXQubWVzc2FnZSwgbWluT3V0cHV0Lm1lc3NhZ2UsIElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWF4LCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1pbik7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KGVycm9yW25hbWVdLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKG1heExlbmd0aCB8fCBtaW5MZW5ndGgpICYmXG4gICAgICAgICFpc0VtcHR5ICYmXG4gICAgICAgIChpc1N0cmluZyhpbnB1dFZhbHVlKSB8fCAoaXNGaWVsZEFycmF5ICYmIEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkpKSkge1xuICAgICAgICBjb25zdCBtYXhMZW5ndGhPdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWF4TGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWluTGVuZ3RoT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbkxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGV4Y2VlZE1heCA9ICFpc051bGxPclVuZGVmaW5lZChtYXhMZW5ndGhPdXRwdXQudmFsdWUpICYmXG4gICAgICAgICAgICBpbnB1dFZhbHVlLmxlbmd0aCA+ICttYXhMZW5ndGhPdXRwdXQudmFsdWU7XG4gICAgICAgIGNvbnN0IGV4Y2VlZE1pbiA9ICFpc051bGxPclVuZGVmaW5lZChtaW5MZW5ndGhPdXRwdXQudmFsdWUpICYmXG4gICAgICAgICAgICBpbnB1dFZhbHVlLmxlbmd0aCA8ICttaW5MZW5ndGhPdXRwdXQudmFsdWU7XG4gICAgICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKGV4Y2VlZE1heCwgbWF4TGVuZ3RoT3V0cHV0Lm1lc3NhZ2UsIG1pbkxlbmd0aE91dHB1dC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3JbbmFtZV0ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuICYmICFpc0VtcHR5ICYmIGlzU3RyaW5nKGlucHV0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IHBhdHRlcm5WYWx1ZSwgbWVzc2FnZSB9ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKHBhdHRlcm4pO1xuICAgICAgICBpZiAoaXNSZWdleChwYXR0ZXJuVmFsdWUpICYmICFpbnB1dFZhbHVlLm1hdGNoKHBhdHRlcm5WYWx1ZSkpIHtcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucGF0dGVybixcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sIG1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWxpZGF0ZSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlKGlucHV0VmFsdWUsIGZvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCBpbnB1dFJlZik7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi52YWxpZGF0ZUVycm9yLFxuICAgICAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnZhbGlkYXRlLCB2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkodmFsaWRhdGVFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSAmJiAhdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihhd2FpdCB2YWxpZGF0ZVtrZXldKGlucHV0VmFsdWUsIGZvcm1WYWx1ZXMpLCBpbnB1dFJlZiwga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRhdGVFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KGtleSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkodmFsaWRhdGVFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB2YWxpZGF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHZhbGlkYXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogaW5wdXRSZWYsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkYXRpb25SZXN1bHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEN1c3RvbVZhbGlkaXR5KHRydWUpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG5cbnZhciBhcHBlbmRBdCA9IChkYXRhLCB2YWx1ZSkgPT4gW1xuICAgIC4uLmRhdGEsXG4gICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcbl07XG5cbnZhciBmaWxsRW1wdHlBcnJheSA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoKCkgPT4gdW5kZWZpbmVkKSA6IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaW5zZXJ0KGRhdGEsIGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIC4uLmRhdGEuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpLFxuICAgICAgICAuLi5kYXRhLnNsaWNlKGluZGV4KSxcbiAgICBdO1xufVxuXG52YXIgbW92ZUFycmF5QXQgPSAoZGF0YSwgZnJvbSwgdG8pID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZmluZWQoZGF0YVt0b10pKSB7XG4gICAgICAgIGRhdGFbdG9dID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBkYXRhLnNwbGljZSh0bywgMCwgZGF0YS5zcGxpY2UoZnJvbSwgMSlbMF0pO1xuICAgIHJldHVybiBkYXRhO1xufTtcblxudmFyIHByZXBlbmRBdCA9IChkYXRhLCB2YWx1ZSkgPT4gW1xuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZCh2YWx1ZSksXG4gICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKGRhdGEpLFxuXTtcblxuZnVuY3Rpb24gcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGluZGV4ZXMpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgdGVtcCA9IFsuLi5kYXRhXTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgICAgdGVtcC5zcGxpY2UoaW5kZXggLSBpLCAxKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGFjdCh0ZW1wKS5sZW5ndGggPyB0ZW1wIDogW107XG59XG52YXIgcmVtb3ZlQXJyYXlBdCA9IChkYXRhLCBpbmRleCkgPT4gaXNVbmRlZmluZWQoaW5kZXgpXG4gICAgPyBbXVxuICAgIDogcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGNvbnZlcnRUb0FycmF5UGF5bG9hZChpbmRleCkuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcblxudmFyIHN3YXBBcnJheUF0ID0gKGRhdGEsIGluZGV4QSwgaW5kZXhCKSA9PiB7XG4gICAgW2RhdGFbaW5kZXhBXSwgZGF0YVtpbmRleEJdXSA9IFtkYXRhW2luZGV4Ql0sIGRhdGFbaW5kZXhBXV07XG59O1xuXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgdXBkYXRlUGF0aCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHVwZGF0ZVBhdGguc2xpY2UoMCwgLTEpLmxlbmd0aDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBpc1VuZGVmaW5lZChvYmplY3QpID8gaW5kZXgrKyA6IG9iamVjdFt1cGRhdGVQYXRoW2luZGV4KytdXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlBcnJheShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShwYXRoKVxuICAgICAgICA/IHBhdGhcbiAgICAgICAgOiBpc0tleShwYXRoKVxuICAgICAgICAgICAgPyBbcGF0aF1cbiAgICAgICAgICAgIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xuICAgIGNvbnN0IGNoaWxkT2JqZWN0ID0gcGF0aHMubGVuZ3RoID09PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIHBhdGhzKTtcbiAgICBjb25zdCBpbmRleCA9IHBhdGhzLmxlbmd0aCAtIDE7XG4gICAgY29uc3Qga2V5ID0gcGF0aHNbaW5kZXhdO1xuICAgIGlmIChjaGlsZE9iamVjdCkge1xuICAgICAgICBkZWxldGUgY2hpbGRPYmplY3Rba2V5XTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSAwICYmXG4gICAgICAgICgoaXNPYmplY3QoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlPYmplY3QoY2hpbGRPYmplY3QpKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlBcnJheShjaGlsZE9iamVjdCkpKSkge1xuICAgICAgICB1bnNldChvYmplY3QsIHBhdGhzLnNsaWNlKDAsIC0xKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciB1cGRhdGVBdCA9IChmaWVsZFZhbHVlcywgaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgZmllbGRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgcmV0dXJuIGZpZWxkVmFsdWVzO1xufTtcblxuLyoqXG4gKiBBIGN1c3RvbSBob29rIHRoYXQgZXhwb3NlcyBjb252ZW5pZW50IG1ldGhvZHMgdG8gcGVyZm9ybSBvcGVyYXRpb25zIHdpdGggYSBsaXN0IG9mIGR5bmFtaWMgaW5wdXRzIHRoYXQgbmVlZCB0byBiZSBhcHBlbmRlZCwgdXBkYXRlZCwgcmVtb3ZlZCBldGMuIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS11c2VmaWVsZGFycmF5LXNzdWduKSDigKIgW1ZpZGVvXShodHRwczovL3lvdXR1LmJlLzRNcmJmR1NGWTJBKVxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2VmaWVsZGFycmF5KSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdXNlZmllbGRhcnJheS1zc3VnbilcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB1c2VGaWVsZEFycmF5IHByb3BzXG4gKlxuICogQHJldHVybnMgbWV0aG9kcyAtIGZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIHdpdGggdGhlIEZpZWxkIEFycmF5cyAoZHluYW1pYyBpbnB1dHMpIHtAbGluayBVc2VGaWVsZEFycmF5UmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciwgY29udHJvbCwgaGFuZGxlU3VibWl0LCByZXNldCwgdHJpZ2dlciwgc2V0RXJyb3IgfSA9IHVzZUZvcm0oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICAgIHRlc3Q6IFtdXG4gKiAgICAgfVxuICogICB9KTtcbiAqICAgY29uc3QgeyBmaWVsZHMsIGFwcGVuZCB9ID0gdXNlRmllbGRBcnJheSh7XG4gKiAgICAgY29udHJvbCxcbiAqICAgICBuYW1lOiBcInRlc3RcIlxuICogICB9KTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpKX0+XG4gKiAgICAgICB7ZmllbGRzLm1hcCgoaXRlbSwgaW5kZXgpID0+IChcbiAqICAgICAgICAgIDxpbnB1dCBrZXk9e2l0ZW0uaWR9IHsuLi5yZWdpc3RlcihgdGVzdC4ke2luZGV4fS5maXJzdE5hbWVgKX0gIC8+XG4gKiAgICAgICApKX1cbiAqICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IGFwcGVuZCh7IGZpcnN0TmFtZTogXCJiaWxsXCIgfSl9PlxuICogICAgICAgICBhcHBlbmRcbiAqICAgICAgIDwvYnV0dG9uPlxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGaWVsZEFycmF5KHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBuYW1lLCBrZXlOYW1lID0gJ2lkJywgc2hvdWxkVW5yZWdpc3RlciwgcnVsZXMsIH0gPSBwcm9wcztcbiAgICBjb25zdCBbZmllbGRzLCBzZXRGaWVsZHNdID0gUmVhY3QudXNlU3RhdGUoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSk7XG4gICAgY29uc3QgaWRzID0gUmVhY3QudXNlUmVmKGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSkubWFwKGdlbmVyYXRlSWQpKTtcbiAgICBjb25zdCBfZmllbGRJZHMgPSBSZWFjdC51c2VSZWYoZmllbGRzKTtcbiAgICBjb25zdCBfbmFtZSA9IFJlYWN0LnVzZVJlZihuYW1lKTtcbiAgICBjb25zdCBfYWN0aW9uZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIF9uYW1lLmN1cnJlbnQgPSBuYW1lO1xuICAgIF9maWVsZElkcy5jdXJyZW50ID0gZmllbGRzO1xuICAgIGNvbnRyb2wuX25hbWVzLmFycmF5LmFkZChuYW1lKTtcbiAgICBydWxlcyAmJlxuICAgICAgICBjb250cm9sLnJlZ2lzdGVyKG5hbWUsIHJ1bGVzKTtcbiAgICB1c2VTdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoeyB2YWx1ZXMsIG5hbWU6IGZpZWxkQXJyYXlOYW1lLCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGRBcnJheU5hbWUgPT09IF9uYW1lLmN1cnJlbnQgfHwgIWZpZWxkQXJyYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXQodmFsdWVzLCBfbmFtZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RmllbGRzKGZpZWxkVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWRzLmN1cnJlbnQgPSBmaWVsZFZhbHVlcy5tYXAoZ2VuZXJhdGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdWJqZWN0OiBjb250cm9sLl9zdWJqZWN0cy5hcnJheSxcbiAgICB9KTtcbiAgICBjb25zdCB1cGRhdGVWYWx1ZXMgPSBSZWFjdC51c2VDYWxsYmFjaygodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpID0+IHtcbiAgICAgICAgX2FjdGlvbmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICB9LCBbY29udHJvbCwgbmFtZV0pO1xuICAgIGNvbnN0IGFwcGVuZCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBhcHBlbmRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGFwcGVuZEF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGFwcGVuZFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcy5sZW5ndGggLSAxLCBvcHRpb25zKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBhcHBlbmRBdChpZHMuY3VycmVudCwgYXBwZW5kVmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgYXBwZW5kQXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGZpbGxFbXB0eUFycmF5KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwZW5kID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXBlbmRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHByZXBlbmRBdChjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLCBwcmVwZW5kVmFsdWUpO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9IGdldEZvY3VzRmllbGROYW1lKG5hbWUsIDAsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IHByZXBlbmRBdChpZHMuY3VycmVudCwgcHJlcGVuZFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHByZXBlbmRBdCwge1xuICAgICAgICAgICAgYXJnQTogZmlsbEVtcHR5QXJyYXkodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSA9IChpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHJlbW92ZUFycmF5QXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgpO1xuICAgICAgICBpZHMuY3VycmVudCA9IHJlbW92ZUFycmF5QXQoaWRzLmN1cnJlbnQsIGluZGV4KTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSkpICYmXG4gICAgICAgICAgICBzZXQoY29udHJvbC5fZmllbGRzLCBuYW1lLCB1bmRlZmluZWQpO1xuICAgICAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCByZW1vdmVBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnQkMSA9IChpbmRleCwgdmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgaW5zZXJ0VmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBpbnNlcnQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgsIGluc2VydFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gaW5zZXJ0KGlkcy5jdXJyZW50LCBpbmRleCwgaW5zZXJ0VmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgaW5zZXJ0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgICAgIGFyZ0I6IGZpbGxFbXB0eUFycmF5KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzd2FwID0gKGluZGV4QSwgaW5kZXhCKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKTtcbiAgICAgICAgc3dhcEFycmF5QXQodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGluZGV4QSwgaW5kZXhCKTtcbiAgICAgICAgc3dhcEFycmF5QXQoaWRzLmN1cnJlbnQsIGluZGV4QSwgaW5kZXhCKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgc3dhcEFycmF5QXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4QSxcbiAgICAgICAgICAgIGFyZ0I6IGluZGV4QixcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgbW92ZSA9IChmcm9tLCB0bykgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIG1vdmVBcnJheUF0KHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBmcm9tLCB0byk7XG4gICAgICAgIG1vdmVBcnJheUF0KGlkcy5jdXJyZW50LCBmcm9tLCB0byk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIG1vdmVBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBmcm9tLFxuICAgICAgICAgICAgYXJnQjogdG8sXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZSA9IChpbmRleCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlVmFsdWUgPSBjbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gdXBkYXRlQXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgsIHVwZGF0ZVZhbHVlKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdLm1hcCgoaXRlbSwgaSkgPT4gIWl0ZW0gfHwgaSA9PT0gaW5kZXggPyBnZW5lcmF0ZUlkKCkgOiBpZHMuY3VycmVudFtpXSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgdXBkYXRlQXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4LFxuICAgICAgICAgICAgYXJnQjogdXBkYXRlVmFsdWUsXG4gICAgICAgIH0sIHRydWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcGxhY2UgPSAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSB1cGRhdGVkRmllbGRBcnJheVZhbHVlcy5tYXAoZ2VuZXJhdGVJZCk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgc2V0RmllbGRzKFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10pO1xuICAgICAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10sIChkYXRhKSA9PiBkYXRhLCB7fSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH07XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29udHJvbC5fc3RhdGUuYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGlzV2F0Y2hlZChuYW1lLCBjb250cm9sLl9uYW1lcykgJiZcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoX2FjdGlvbmVkLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICghZ2V0VmFsaWRhdGlvbk1vZGVzKGNvbnRyb2wuX29wdGlvbnMubW9kZSkuaXNPblN1Ym1pdCB8fFxuICAgICAgICAgICAgICAgIGNvbnRyb2wuX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCkpIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sLl9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5fZXhlY3V0ZVNjaGVtYShbbmFtZV0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGdldChyZXN1bHQuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFcnJvciA9IGdldChjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKCFlcnJvciAmJiBleGlzdGluZ0Vycm9yLnR5cGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGlzdGluZ0Vycm9yLnR5cGUgIT09IGVycm9yLnR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRXJyb3IubWVzc2FnZSAhPT0gZXJyb3IubWVzc2FnZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVycm9yICYmIGVycm9yLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5fZiAmJlxuICAgICAgICAgICAgICAgICAgICAhKGdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLnJlVmFsaWRhdGVNb2RlKS5pc09uU3VibWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5tb2RlKS5pc09uU3VibWl0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBjb250cm9sLl9uYW1lcy5kaXNhYmxlZCwgY29udHJvbC5fZm9ybVZhbHVlcywgY29udHJvbC5fb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGwsIGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgdHJ1ZSkudGhlbigoZXJyb3IpID0+ICFpc0VtcHR5T2JqZWN0KGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiB1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yKGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIGVycm9yLCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5fc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlczogeyAuLi5jb250cm9sLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyAmJlxuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGNvbnRyb2wuX2ZpZWxkcywgKHJlZiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuX25hbWVzLmZvY3VzICYmXG4gICAgICAgICAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKGNvbnRyb2wuX25hbWVzLmZvY3VzKSAmJlxuICAgICAgICAgICAgICAgICAgICByZWYuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSAnJztcbiAgICAgICAgY29udHJvbC5fdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgX2FjdGlvbmVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LCBbZmllbGRzLCBuYW1lLCBjb250cm9sXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgIWdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSAmJiBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgKGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBzaG91bGRVbnJlZ2lzdGVyKSAmJlxuICAgICAgICAgICAgICAgIGNvbnRyb2wudW5yZWdpc3RlcihuYW1lKTtcbiAgICAgICAgfTtcbiAgICB9LCBbbmFtZSwgY29udHJvbCwga2V5TmFtZSwgc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN3YXA6IFJlYWN0LnVzZUNhbGxiYWNrKHN3YXAsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgbW92ZTogUmVhY3QudXNlQ2FsbGJhY2sobW92ZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBwcmVwZW5kOiBSZWFjdC51c2VDYWxsYmFjayhwcmVwZW5kLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIGFwcGVuZDogUmVhY3QudXNlQ2FsbGJhY2soYXBwZW5kLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHJlbW92ZTogUmVhY3QudXNlQ2FsbGJhY2socmVtb3ZlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIGluc2VydDogUmVhY3QudXNlQ2FsbGJhY2soaW5zZXJ0JDEsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgdXBkYXRlOiBSZWFjdC51c2VDYWxsYmFjayh1cGRhdGUsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgcmVwbGFjZTogUmVhY3QudXNlQ2FsbGJhY2socmVwbGFjZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBmaWVsZHM6IFJlYWN0LnVzZU1lbW8oKCkgPT4gZmllbGRzLm1hcCgoZmllbGQsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICBba2V5TmFtZV06IGlkcy5jdXJyZW50W2luZGV4XSB8fCBnZW5lcmF0ZUlkKCksXG4gICAgICAgIH0pKSwgW2ZpZWxkcywga2V5TmFtZV0pLFxuICAgIH07XG59XG5cbnZhciBjcmVhdGVTdWJqZWN0ID0gKCkgPT4ge1xuICAgIGxldCBfb2JzZXJ2ZXJzID0gW107XG4gICAgY29uc3QgbmV4dCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIF9vYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IChvYnNlcnZlcikgPT4ge1xuICAgICAgICBfb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBfb2JzZXJ2ZXJzID0gX29ic2VydmVycy5maWx0ZXIoKG8pID0+IG8gIT09IG9ic2VydmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgICAgX29ic2VydmVycyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JzZXJ2ZXJzO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0LFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIHVuc3Vic2NyaWJlLFxuICAgIH07XG59O1xuXG52YXIgaXNQcmltaXRpdmUgPSAodmFsdWUpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCAhaXNPYmplY3RUeXBlKHZhbHVlKTtcblxuZnVuY3Rpb24gZGVlcEVxdWFsKG9iamVjdDEsIG9iamVjdDIpIHtcbiAgICBpZiAoaXNQcmltaXRpdmUob2JqZWN0MSkgfHwgaXNQcmltaXRpdmUob2JqZWN0MikpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDEgPT09IG9iamVjdDI7XG4gICAgfVxuICAgIGlmIChpc0RhdGVPYmplY3Qob2JqZWN0MSkgJiYgaXNEYXRlT2JqZWN0KG9iamVjdDIpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QxLmdldFRpbWUoKSA9PT0gb2JqZWN0Mi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqZWN0MSk7XG4gICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmplY3QyKTtcbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgICAgICBjb25zdCB2YWwxID0gb2JqZWN0MVtrZXldO1xuICAgICAgICBpZiAoIWtleXMyLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ICE9PSAncmVmJykge1xuICAgICAgICAgICAgY29uc3QgdmFsMiA9IG9iamVjdDJba2V5XTtcbiAgICAgICAgICAgIGlmICgoaXNEYXRlT2JqZWN0KHZhbDEpICYmIGlzRGF0ZU9iamVjdCh2YWwyKSkgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QodmFsMSkgJiYgaXNPYmplY3QodmFsMikpIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkodmFsMSkgJiYgQXJyYXkuaXNBcnJheSh2YWwyKSlcbiAgICAgICAgICAgICAgICA/ICFkZWVwRXF1YWwodmFsMSwgdmFsMilcbiAgICAgICAgICAgICAgICA6IHZhbDEgIT09IHZhbDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBpc011bHRpcGxlU2VsZWN0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gYHNlbGVjdC1tdWx0aXBsZWA7XG5cbnZhciBpc1JhZGlvT3JDaGVja2JveCA9IChyZWYpID0+IGlzUmFkaW9JbnB1dChyZWYpIHx8IGlzQ2hlY2tCb3hJbnB1dChyZWYpO1xuXG52YXIgbGl2ZSA9IChyZWYpID0+IGlzSFRNTEVsZW1lbnQocmVmKSAmJiByZWYuaXNDb25uZWN0ZWQ7XG5cbnZhciBvYmplY3RIYXNGdW5jdGlvbiA9IChkYXRhKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihkYXRhW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBtYXJrRmllbGRzRGlydHkoZGF0YSwgZmllbGRzID0ge30pIHtcbiAgICBjb25zdCBpc1BhcmVudE5vZGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpIHx8IGlzUGFyZW50Tm9kZUFycmF5KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QoZGF0YVtrZXldKSAmJiAhb2JqZWN0SGFzRnVuY3Rpb24oZGF0YVtrZXldKSkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHNba2V5XSA9IEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSA/IFtdIDoge307XG4gICAgICAgICAgICAgICAgbWFya0ZpZWxkc0RpcnR5KGRhdGFba2V5XSwgZmllbGRzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cbmZ1bmN0aW9uIGdldERpcnR5RmllbGRzRnJvbURlZmF1bHRWYWx1ZXMoZGF0YSwgZm9ybVZhbHVlcywgZGlydHlGaWVsZHNGcm9tVmFsdWVzKSB7XG4gICAgY29uc3QgaXNQYXJlbnROb2RlQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgIGlmIChpc09iamVjdChkYXRhKSB8fCBpc1BhcmVudE5vZGVBcnJheSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pIHx8XG4gICAgICAgICAgICAgICAgKGlzT2JqZWN0KGRhdGFba2V5XSkgJiYgIW9iamVjdEhhc0Z1bmN0aW9uKGRhdGFba2V5XSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzUHJpbWl0aXZlKGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9IEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtYXJrRmllbGRzRGlydHkoZGF0YVtrZXldLCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyAuLi5tYXJrRmllbGRzRGlydHkoZGF0YVtrZXldKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyhkYXRhW2tleV0sIGlzTnVsbE9yVW5kZWZpbmVkKGZvcm1WYWx1ZXMpID8ge30gOiBmb3JtVmFsdWVzW2tleV0sIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9ICFkZWVwRXF1YWwoZGF0YVtrZXldLCBmb3JtVmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXM7XG59XG52YXIgZ2V0RGlydHlGaWVsZHMgPSAoZGVmYXVsdFZhbHVlcywgZm9ybVZhbHVlcykgPT4gZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyhkZWZhdWx0VmFsdWVzLCBmb3JtVmFsdWVzLCBtYXJrRmllbGRzRGlydHkoZm9ybVZhbHVlcykpO1xuXG52YXIgZ2V0RmllbGRWYWx1ZUFzID0gKHZhbHVlLCB7IHZhbHVlQXNOdW1iZXIsIHZhbHVlQXNEYXRlLCBzZXRWYWx1ZUFzIH0pID0+IGlzVW5kZWZpbmVkKHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IHZhbHVlQXNOdW1iZXJcbiAgICAgICAgPyB2YWx1ZSA9PT0gJydcbiAgICAgICAgICAgID8gTmFOXG4gICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgICAgICAgICAgPyArdmFsdWVcbiAgICAgICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgIDogdmFsdWVBc0RhdGUgJiYgaXNTdHJpbmcodmFsdWUpXG4gICAgICAgICAgICA/IG5ldyBEYXRlKHZhbHVlKVxuICAgICAgICAgICAgOiBzZXRWYWx1ZUFzXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZUFzKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogdmFsdWU7XG5cbmZ1bmN0aW9uIGdldEZpZWxkVmFsdWUoX2YpIHtcbiAgICBjb25zdCByZWYgPSBfZi5yZWY7XG4gICAgaWYgKGlzRmlsZUlucHV0KHJlZikpIHtcbiAgICAgICAgcmV0dXJuIHJlZi5maWxlcztcbiAgICB9XG4gICAgaWYgKGlzUmFkaW9JbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiBnZXRSYWRpb1ZhbHVlKF9mLnJlZnMpLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNNdWx0aXBsZVNlbGVjdChyZWYpKSB7XG4gICAgICAgIHJldHVybiBbLi4ucmVmLnNlbGVjdGVkT3B0aW9uc10ubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzQ2hlY2tCb3hJbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKF9mLnJlZnMpLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RmllbGRWYWx1ZUFzKGlzVW5kZWZpbmVkKHJlZi52YWx1ZSkgPyBfZi5yZWYudmFsdWUgOiByZWYudmFsdWUsIF9mKTtcbn1cblxudmFyIGdldFJlc29sdmVyT3B0aW9ucyA9IChmaWVsZHNOYW1lcywgX2ZpZWxkcywgY3JpdGVyaWFNb2RlLCBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSA9PiB7XG4gICAgY29uc3QgZmllbGRzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGZpZWxkc05hbWVzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBmaWVsZCAmJiBzZXQoZmllbGRzLCBuYW1lLCBmaWVsZC5fZik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyaXRlcmlhTW9kZSxcbiAgICAgICAgbmFtZXM6IFsuLi5maWVsZHNOYW1lc10sXG4gICAgICAgIGZpZWxkcyxcbiAgICAgICAgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbixcbiAgICB9O1xufTtcblxudmFyIGdldFJ1bGVWYWx1ZSA9IChydWxlKSA9PiBpc1VuZGVmaW5lZChydWxlKVxuICAgID8gcnVsZVxuICAgIDogaXNSZWdleChydWxlKVxuICAgICAgICA/IHJ1bGUuc291cmNlXG4gICAgICAgIDogaXNPYmplY3QocnVsZSlcbiAgICAgICAgICAgID8gaXNSZWdleChydWxlLnZhbHVlKVxuICAgICAgICAgICAgICAgID8gcnVsZS52YWx1ZS5zb3VyY2VcbiAgICAgICAgICAgICAgICA6IHJ1bGUudmFsdWVcbiAgICAgICAgICAgIDogcnVsZTtcblxuY29uc3QgQVNZTkNfRlVOQ1RJT04gPSAnQXN5bmNGdW5jdGlvbic7XG52YXIgaGFzUHJvbWlzZVZhbGlkYXRpb24gPSAoZmllbGRSZWZlcmVuY2UpID0+ICEhZmllbGRSZWZlcmVuY2UgJiZcbiAgICAhIWZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlICYmXG4gICAgISEoKGlzRnVuY3Rpb24oZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgICAgIGZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFTWU5DX0ZVTkNUSU9OKSB8fFxuICAgICAgICAoaXNPYmplY3QoZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKGZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlKS5maW5kKCh2YWxpZGF0ZUZ1bmN0aW9uKSA9PiB2YWxpZGF0ZUZ1bmN0aW9uLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFTWU5DX0ZVTkNUSU9OKSkpO1xuXG52YXIgaGFzVmFsaWRhdGlvbiA9IChvcHRpb25zKSA9PiBvcHRpb25zLm1vdW50ICYmXG4gICAgKG9wdGlvbnMucmVxdWlyZWQgfHxcbiAgICAgICAgb3B0aW9ucy5taW4gfHxcbiAgICAgICAgb3B0aW9ucy5tYXggfHxcbiAgICAgICAgb3B0aW9ucy5tYXhMZW5ndGggfHxcbiAgICAgICAgb3B0aW9ucy5taW5MZW5ndGggfHxcbiAgICAgICAgb3B0aW9ucy5wYXR0ZXJuIHx8XG4gICAgICAgIG9wdGlvbnMudmFsaWRhdGUpO1xuXG5mdW5jdGlvbiBzY2hlbWFFcnJvckxvb2t1cChlcnJvcnMsIF9maWVsZHMsIG5hbWUpIHtcbiAgICBjb25zdCBlcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xuICAgIGlmIChlcnJvciB8fCBpc0tleShuYW1lKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICB3aGlsZSAobmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IG5hbWVzLmpvaW4oJy4nKTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgY29uc3QgZm91bmRFcnJvciA9IGdldChlcnJvcnMsIGZpZWxkTmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCAmJiAhQXJyYXkuaXNBcnJheShmaWVsZCkgJiYgbmFtZSAhPT0gZmllbGROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kRXJyb3IgJiYgZm91bmRFcnJvci50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZm91bmRFcnJvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgfTtcbn1cblxudmFyIHNraXBWYWxpZGF0aW9uID0gKGlzQmx1ckV2ZW50LCBpc1RvdWNoZWQsIGlzU3VibWl0dGVkLCByZVZhbGlkYXRlTW9kZSwgbW9kZSkgPT4ge1xuICAgIGlmIChtb2RlLmlzT25BbGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNTdWJtaXR0ZWQgJiYgbW9kZS5pc09uVG91Y2gpIHtcbiAgICAgICAgcmV0dXJuICEoaXNUb3VjaGVkIHx8IGlzQmx1ckV2ZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQmx1ciA6IG1vZGUuaXNPbkJsdXIpIHtcbiAgICAgICAgcmV0dXJuICFpc0JsdXJFdmVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQ2hhbmdlIDogbW9kZS5pc09uQ2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBpc0JsdXJFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgdW5zZXRFbXB0eUFycmF5ID0gKHJlZiwgbmFtZSkgPT4gIWNvbXBhY3QoZ2V0KHJlZiwgbmFtZSkpLmxlbmd0aCAmJiB1bnNldChyZWYsIG5hbWUpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBWQUxJREFUSU9OX01PREUub25TdWJtaXQsXG4gICAgcmVWYWxpZGF0ZU1vZGU6IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSxcbiAgICBzaG91bGRGb2N1c0Vycm9yOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUZvcm1Db250cm9sKHByb3BzID0ge30pIHtcbiAgICBsZXQgX29wdGlvbnMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICB9O1xuICAgIGxldCBfZm9ybVN0YXRlID0ge1xuICAgICAgICBzdWJtaXRDb3VudDogMCxcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogaXNGdW5jdGlvbihfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczoge30sXG4gICAgICAgIGRpcnR5RmllbGRzOiB7fSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczoge30sXG4gICAgICAgIGVycm9yczogX29wdGlvbnMuZXJyb3JzIHx8IHt9LFxuICAgICAgICBkaXNhYmxlZDogX29wdGlvbnMuZGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX2ZpZWxkcyA9IHt9O1xuICAgIGxldCBfZGVmYXVsdFZhbHVlcyA9IGlzT2JqZWN0KF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMpIHx8IGlzT2JqZWN0KF9vcHRpb25zLnZhbHVlcylcbiAgICAgICAgPyBjbG9uZU9iamVjdChfb3B0aW9ucy5kZWZhdWx0VmFsdWVzIHx8IF9vcHRpb25zLnZhbHVlcykgfHwge31cbiAgICAgICAgOiB7fTtcbiAgICBsZXQgX2Zvcm1WYWx1ZXMgPSBfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgID8ge31cbiAgICAgICAgOiBjbG9uZU9iamVjdChfZGVmYXVsdFZhbHVlcyk7XG4gICAgbGV0IF9zdGF0ZSA9IHtcbiAgICAgICAgYWN0aW9uOiBmYWxzZSxcbiAgICAgICAgbW91bnQ6IGZhbHNlLFxuICAgICAgICB3YXRjaDogZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX25hbWVzID0ge1xuICAgICAgICBtb3VudDogbmV3IFNldCgpLFxuICAgICAgICBkaXNhYmxlZDogbmV3IFNldCgpLFxuICAgICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgfTtcbiAgICBsZXQgZGVsYXlFcnJvckNhbGxiYWNrO1xuICAgIGxldCB0aW1lciA9IDA7XG4gICAgY29uc3QgX3Byb3h5Rm9ybVN0YXRlID0ge1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgX3N1YmplY3RzID0ge1xuICAgICAgICB2YWx1ZXM6IGNyZWF0ZVN1YmplY3QoKSxcbiAgICAgICAgYXJyYXk6IGNyZWF0ZVN1YmplY3QoKSxcbiAgICAgICAgc3RhdGU6IGNyZWF0ZVN1YmplY3QoKSxcbiAgICB9O1xuICAgIGNvbnN0IHZhbGlkYXRpb25Nb2RlQmVmb3JlU3VibWl0ID0gZ2V0VmFsaWRhdGlvbk1vZGVzKF9vcHRpb25zLm1vZGUpO1xuICAgIGNvbnN0IHZhbGlkYXRpb25Nb2RlQWZ0ZXJTdWJtaXQgPSBnZXRWYWxpZGF0aW9uTW9kZXMoX29wdGlvbnMucmVWYWxpZGF0ZU1vZGUpO1xuICAgIGNvbnN0IHNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzID0gX29wdGlvbnMuY3JpdGVyaWFNb2RlID09PSBWQUxJREFUSU9OX01PREUuYWxsO1xuICAgIGNvbnN0IGRlYm91bmNlID0gKGNhbGxiYWNrKSA9PiAod2FpdCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHdhaXQpO1xuICAgIH07XG4gICAgY29uc3QgX3VwZGF0ZVZhbGlkID0gYXN5bmMgKHNob3VsZFVwZGF0ZVZhbGlkKSA9PiB7XG4gICAgICAgIGlmICghX29wdGlvbnMuZGlzYWJsZWQgJiYgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8IHNob3VsZFVwZGF0ZVZhbGlkKSkge1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IF9vcHRpb25zLnJlc29sdmVyXG4gICAgICAgICAgICAgICAgPyBpc0VtcHR5T2JqZWN0KChhd2FpdCBfZXhlY3V0ZVNjaGVtYSgpKS5lcnJvcnMpXG4gICAgICAgICAgICAgICAgOiBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZCAhPT0gX2Zvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfdXBkYXRlSXNWYWxpZGF0aW5nID0gKG5hbWVzLCBpc1ZhbGlkYXRpbmcpID0+IHtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkYXRpbmcgfHwgX3Byb3h5Rm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpKSB7XG4gICAgICAgICAgICAobmFtZXMgfHwgQXJyYXkuZnJvbShfbmFtZXMubW91bnQpKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUsIGlzVmFsaWRhdGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiBfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsXG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiAhaXNFbXB0eU9iamVjdChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF91cGRhdGVGaWVsZEFycmF5ID0gKG5hbWUsIHZhbHVlcyA9IFtdLCBtZXRob2QsIGFyZ3MsIHNob3VsZFNldFZhbHVlcyA9IHRydWUsIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlID0gdHJ1ZSkgPT4ge1xuICAgICAgICBpZiAoYXJncyAmJiBtZXRob2QgJiYgIV9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBfc3RhdGUuYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJiBBcnJheS5pc0FycmF5KGdldChfZmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IG1ldGhvZChnZXQoX2ZpZWxkcywgbmFtZSksIGFyZ3MuYXJnQSwgYXJncy5hcmdCKTtcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRWYWx1ZXMgJiYgc2V0KF9maWVsZHMsIG5hbWUsIGZpZWxkVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBtZXRob2QoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgdW5zZXRFbXB0eUFycmF5KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaGVkRmllbGRzID0gbWV0aG9kKGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUsIHRvdWNoZWRGaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcykge1xuICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuZGlydHlGaWVsZHMgPSBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgaXNEaXJ0eTogX2dldERpcnR5KG5hbWUsIHZhbHVlcyksXG4gICAgICAgICAgICAgICAgZGlydHlGaWVsZHM6IF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiBfZm9ybVN0YXRlLmlzVmFsaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRXJyb3JzID0gKG5hbWUsIGVycm9yKSA9PiB7XG4gICAgICAgIHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IF9zZXRFcnJvcnMgPSAoZXJyb3JzKSA9PiB7XG4gICAgICAgIF9mb3JtU3RhdGUuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdXBkYXRlVmFsaWRBbmRWYWx1ZSA9IChuYW1lLCBzaG91bGRTa2lwU2V0VmFsdWVBcywgdmFsdWUsIHJlZikgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBnZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGlzVW5kZWZpbmVkKHZhbHVlKSA/IGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkgOiB2YWx1ZSk7XG4gICAgICAgICAgICBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgKHJlZiAmJiByZWYuZGVmYXVsdENoZWNrZWQpIHx8XG4gICAgICAgICAgICAgICAgc2hvdWxkU2tpcFNldFZhbHVlQXNcbiAgICAgICAgICAgICAgICA/IHNldChfZm9ybVZhbHVlcywgbmFtZSwgc2hvdWxkU2tpcFNldFZhbHVlQXMgPyBkZWZhdWx0VmFsdWUgOiBnZXRGaWVsZFZhbHVlKGZpZWxkLl9mKSlcbiAgICAgICAgICAgICAgICA6IHNldEZpZWxkVmFsdWUobmFtZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIF9zdGF0ZS5tb3VudCAmJiBfdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlVG91Y2hBbmREaXJ0eSA9IChuYW1lLCBmaWVsZFZhbHVlLCBpc0JsdXJFdmVudCwgc2hvdWxkRGlydHksIHNob3VsZFJlbmRlcikgPT4ge1xuICAgICAgICBsZXQgc2hvdWxkVXBkYXRlRmllbGQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzUHJldmlvdXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIV9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNhYmxlZEZpZWxkID0gISEoZ2V0KF9maWVsZHMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICAgZ2V0KF9maWVsZHMsIG5hbWUpLl9mICYmXG4gICAgICAgICAgICAgICAgZ2V0KF9maWVsZHMsIG5hbWUpLl9mLmRpc2FibGVkKTtcbiAgICAgICAgICAgIGlmICghaXNCbHVyRXZlbnQgfHwgc2hvdWxkRGlydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNQcmV2aW91c0RpcnR5ID0gX2Zvcm1TdGF0ZS5pc0RpcnR5O1xuICAgICAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmlzRGlydHkgPSBvdXRwdXQuaXNEaXJ0eSA9IF9nZXREaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9IGlzUHJldmlvdXNEaXJ0eSAhPT0gb3V0cHV0LmlzRGlydHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudEZpZWxkUHJpc3RpbmUgPSBkaXNhYmxlZEZpZWxkIHx8IGRlZXBFcXVhbChnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSAhISghZGlzYWJsZWRGaWVsZCAmJiBnZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSkpO1xuICAgICAgICAgICAgICAgIGlzQ3VycmVudEZpZWxkUHJpc3RpbmUgfHwgZGlzYWJsZWRGaWVsZFxuICAgICAgICAgICAgICAgICAgICA/IHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpXG4gICAgICAgICAgICAgICAgICAgIDogc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5kaXJ0eUZpZWxkcyA9IF9mb3JtU3RhdGUuZGlydHlGaWVsZHM7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPVxuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJldmlvdXNEaXJ0eSAhPT0gIWlzQ3VycmVudEZpZWxkUHJpc3RpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQmx1ckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCA9IGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lLCBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC50b3VjaGVkRmllbGRzID0gX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRmllbGRUb3VjaGVkICE9PSBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgJiYgc2hvdWxkUmVuZGVyICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZUZpZWxkID8gb3V0cHV0IDoge307XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRSZW5kZXJCeUVycm9yID0gKG5hbWUsIGlzVmFsaWQsIGVycm9yLCBmaWVsZFN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRmllbGRFcnJvciA9IGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZVZhbGlkID0gX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgJiZcbiAgICAgICAgICAgIGlzQm9vbGVhbihpc1ZhbGlkKSAmJlxuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc1ZhbGlkICE9PSBpc1ZhbGlkO1xuICAgICAgICBpZiAoX29wdGlvbnMuZGVsYXlFcnJvciAmJiBlcnJvcikge1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gZGVib3VuY2UoKCkgPT4gdXBkYXRlRXJyb3JzKG5hbWUsIGVycm9yKSk7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2soX29wdGlvbnMuZGVsYXlFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZXJyb3IgPyAhZGVlcEVxdWFsKHByZXZpb3VzRmllbGRFcnJvciwgZXJyb3IpIDogcHJldmlvdXNGaWVsZEVycm9yKSB8fFxuICAgICAgICAgICAgIWlzRW1wdHlPYmplY3QoZmllbGRTdGF0ZSkgfHxcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZVZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4uKHNob3VsZFVwZGF0ZVZhbGlkICYmIGlzQm9vbGVhbihpc1ZhbGlkKSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfZm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh1cGRhdGVkRm9ybVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX2V4ZWN1dGVTY2hlbWEgPSBhc3luYyAobmFtZSkgPT4ge1xuICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKG5hbWUsIHRydWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBfb3B0aW9ucy5yZXNvbHZlcihfZm9ybVZhbHVlcywgX29wdGlvbnMuY29udGV4dCwgZ2V0UmVzb2x2ZXJPcHRpb25zKG5hbWUgfHwgX25hbWVzLm1vdW50LCBfZmllbGRzLCBfb3B0aW9ucy5jcml0ZXJpYU1vZGUsIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pKTtcbiAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhuYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGV4ZWN1dGVTY2hlbWFBbmRVcGRhdGVTdGF0ZSA9IGFzeW5jIChuYW1lcykgPT4ge1xuICAgICAgICBjb25zdCB7IGVycm9ycyB9ID0gYXdhaXQgX2V4ZWN1dGVTY2hlbWEobmFtZXMpO1xuICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICA6IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24gPSBhc3luYyAoZmllbGRzLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCA9IHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgfSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgX2YsIC4uLmZpZWxkVmFsdWUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIGlmIChfZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXlSb290ID0gX25hbWVzLmFycmF5LmhhcyhfZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNQcm9taXNlRnVuY3Rpb24gPSBmaWVsZC5fZiAmJiBoYXNQcm9taXNlVmFsaWRhdGlvbihmaWVsZC5fZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2VGdW5jdGlvbiAmJiBfcHJveHlGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbbmFtZV0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkRXJyb3IgPSBhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBfbmFtZXMuZGlzYWJsZWQsIF9mb3JtVmFsdWVzLCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycywgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiAmJiAhc2hvdWxkT25seUNoZWNrVmFsaWQsIGlzRmllbGRBcnJheVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlRnVuY3Rpb24gJiYgX3Byb3h5Rm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRFcnJvcltfZi5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZE9ubHlDaGVja1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIXNob3VsZE9ubHlDaGVja1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZ2V0KGZpZWxkRXJyb3IsIF9mLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpc0ZpZWxkQXJyYXlSb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvcihfZm9ybVN0YXRlLmVycm9ycywgZmllbGRFcnJvciwgX2YubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUsIGZpZWxkRXJyb3JbX2YubmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgX2YubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhaXNFbXB0eU9iamVjdChmaWVsZFZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKGZpZWxkVmFsdWUsIHNob3VsZE9ubHlDaGVja1ZhbGlkLCBjb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQudmFsaWQ7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlVW5tb3VudGVkID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLnVuTW91bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgZmllbGQgJiZcbiAgICAgICAgICAgICAgICAoZmllbGQuX2YucmVmc1xuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkLl9mLnJlZnMuZXZlcnkoKHJlZikgPT4gIWxpdmUocmVmKSlcbiAgICAgICAgICAgICAgICAgICAgOiAhbGl2ZShmaWVsZC5fZi5yZWYpKSAmJlxuICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgX25hbWVzLnVuTW91bnQgPSBuZXcgU2V0KCk7XG4gICAgfTtcbiAgICBjb25zdCBfZ2V0RGlydHkgPSAobmFtZSwgZGF0YSkgPT4gIV9vcHRpb25zLmRpc2FibGVkICYmXG4gICAgICAgIChuYW1lICYmIGRhdGEgJiYgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBkYXRhKSxcbiAgICAgICAgICAgICFkZWVwRXF1YWwoZ2V0VmFsdWVzKCksIF9kZWZhdWx0VmFsdWVzKSk7XG4gICAgY29uc3QgX2dldFdhdGNoID0gKG5hbWVzLCBkZWZhdWx0VmFsdWUsIGlzR2xvYmFsKSA9PiBnZW5lcmF0ZVdhdGNoT3V0cHV0KG5hbWVzLCBfbmFtZXMsIHtcbiAgICAgICAgLi4uKF9zdGF0ZS5tb3VudFxuICAgICAgICAgICAgPyBfZm9ybVZhbHVlc1xuICAgICAgICAgICAgOiBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgPyBfZGVmYXVsdFZhbHVlc1xuICAgICAgICAgICAgICAgIDogaXNTdHJpbmcobmFtZXMpXG4gICAgICAgICAgICAgICAgICAgID8geyBbbmFtZXNdOiBkZWZhdWx0VmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZSksXG4gICAgfSwgaXNHbG9iYWwsIGRlZmF1bHRWYWx1ZSk7XG4gICAgY29uc3QgX2dldEZpZWxkQXJyYXkgPSAobmFtZSkgPT4gY29tcGFjdChnZXQoX3N0YXRlLm1vdW50ID8gX2Zvcm1WYWx1ZXMgOiBfZGVmYXVsdFZhbHVlcywgbmFtZSwgX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciA/IGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSwgW10pIDogW10pKTtcbiAgICBjb25zdCBzZXRGaWVsZFZhbHVlID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGxldCBmaWVsZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZC5fZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICFmaWVsZFJlZmVyZW5jZS5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldEZpZWxkVmFsdWVBcyh2YWx1ZSwgZmllbGRSZWZlcmVuY2UpKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZS5yZWYpICYmIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNdWx0aXBsZVNlbGVjdChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIFsuLi5maWVsZFJlZmVyZW5jZS5yZWYub3B0aW9uc10uZm9yRWFjaCgob3B0aW9uUmVmKSA9PiAob3B0aW9uUmVmLnNlbGVjdGVkID0gZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25SZWYudmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkUmVmZXJlbmNlLnJlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tCb3hJbnB1dChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWZzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZpZWxkUmVmZXJlbmNlLnJlZnMuZm9yRWFjaCgoY2hlY2tib3hSZWYpID0+ICghY2hlY2tib3hSZWYuZGVmYXVsdENoZWNrZWQgfHwgIWNoZWNrYm94UmVmLmRpc2FibGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hlY2tib3hSZWYuY2hlY2tlZCA9IEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gISFmaWVsZFZhbHVlLmZpbmQoKGRhdGEpID0+IGRhdGEgPT09IGNoZWNrYm94UmVmLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZFZhbHVlID09PSBjaGVja2JveFJlZi52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZFJlZmVyZW5jZS5yZWZzWzBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWVsZFJlZmVyZW5jZS5yZWZzWzBdLmNoZWNrZWQgPSAhIWZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmcy5mb3JFYWNoKChyYWRpb1JlZikgPT4gKHJhZGlvUmVmLmNoZWNrZWQgPSByYWRpb1JlZi52YWx1ZSA9PT0gZmllbGRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlsZUlucHV0KGZpZWxkUmVmZXJlbmNlLnJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWYudmFsdWUgPSBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkUmVmZXJlbmNlLnJlZi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAob3B0aW9ucy5zaG91bGREaXJ0eSB8fCBvcHRpb25zLnNob3VsZFRvdWNoKSAmJlxuICAgICAgICAgICAgdXBkYXRlVG91Y2hBbmREaXJ0eShuYW1lLCBmaWVsZFZhbHVlLCBvcHRpb25zLnNob3VsZFRvdWNoLCBvcHRpb25zLnNob3VsZERpcnR5LCB0cnVlKTtcbiAgICAgICAgb3B0aW9ucy5zaG91bGRWYWxpZGF0ZSAmJiB0cmlnZ2VyKG5hbWUpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0VmFsdWVzID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRLZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSB2YWx1ZVtmaWVsZEtleV07XG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBgJHtuYW1lfS4ke2ZpZWxkS2V5fWA7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgKF9uYW1lcy5hcnJheS5oYXMobmFtZSkgfHxcbiAgICAgICAgICAgICAgICBpc09iamVjdChmaWVsZFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChmaWVsZCAmJiAhZmllbGQuX2YpKSAmJlxuICAgICAgICAgICAgICAgICFpc0RhdGVPYmplY3QoZmllbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlcyhmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiBzZXRGaWVsZFZhbHVlKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldFZhbHVlID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IGlzRmllbGRBcnJheSA9IF9uYW1lcy5hcnJheS5oYXMobmFtZSk7XG4gICAgICAgIGNvbnN0IGNsb25lVmFsdWUgPSBjbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgY2xvbmVWYWx1ZSk7XG4gICAgICAgIGlmIChpc0ZpZWxkQXJyYXkpIHtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5hcnJheS5uZXh0KHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoKF9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5IHx8IF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcykgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNob3VsZERpcnR5KSB7XG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkczogZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIF9mb3JtVmFsdWVzKSxcbiAgICAgICAgICAgICAgICAgICAgaXNEaXJ0eTogX2dldERpcnR5KG5hbWUsIGNsb25lVmFsdWUpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmllbGQgJiYgIWZpZWxkLl9mICYmICFpc051bGxPclVuZGVmaW5lZChjbG9uZVZhbHVlKVxuICAgICAgICAgICAgICAgID8gc2V0VmFsdWVzKG5hbWUsIGNsb25lVmFsdWUsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiBzZXRGaWVsZFZhbHVlKG5hbWUsIGNsb25lVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlzV2F0Y2hlZChuYW1lLCBfbmFtZXMpICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uX2Zvcm1TdGF0ZSB9KTtcbiAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgIG5hbWU6IF9zdGF0ZS5tb3VudCA/IG5hbWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWx1ZXM6IHsgLi4uX2Zvcm1WYWx1ZXMgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBfc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGxldCBuYW1lID0gdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGxldCBpc0ZpZWxkVmFsdWVVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IGdldEN1cnJlbnRGaWVsZFZhbHVlID0gKCkgPT4gdGFyZ2V0LnR5cGUgPyBnZXRGaWVsZFZhbHVlKGZpZWxkLl9mKSA6IGdldEV2ZW50VmFsdWUoZXZlbnQpO1xuICAgICAgICBjb25zdCBfdXBkYXRlSXNGaWVsZFZhbHVlVXBkYXRlZCA9IChmaWVsZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpc0ZpZWxkVmFsdWVVcGRhdGVkID1cbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNOYU4oZmllbGRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzRGF0ZU9iamVjdChmaWVsZFZhbHVlKSAmJiBpc05hTihmaWVsZFZhbHVlLmdldFRpbWUoKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRlZXBFcXVhbChmaWVsZFZhbHVlLCBnZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGZpZWxkVmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgICAgICBsZXQgaXNWYWxpZDtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSBnZXRDdXJyZW50RmllbGRWYWx1ZSgpO1xuICAgICAgICAgICAgY29uc3QgaXNCbHVyRXZlbnQgPSBldmVudC50eXBlID09PSBFVkVOVFMuQkxVUiB8fCBldmVudC50eXBlID09PSBFVkVOVFMuRk9DVVNfT1VUO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2tpcFZhbGlkYXRpb24gPSAoIWhhc1ZhbGlkYXRpb24oZmllbGQuX2YpICYmXG4gICAgICAgICAgICAgICAgIV9vcHRpb25zLnJlc29sdmVyICYmXG4gICAgICAgICAgICAgICAgIWdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgICAhZmllbGQuX2YuZGVwcykgfHxcbiAgICAgICAgICAgICAgICBza2lwVmFsaWRhdGlvbihpc0JsdXJFdmVudCwgZ2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSksIF9mb3JtU3RhdGUuaXNTdWJtaXR0ZWQsIHZhbGlkYXRpb25Nb2RlQWZ0ZXJTdWJtaXQsIHZhbGlkYXRpb25Nb2RlQmVmb3JlU3VibWl0KTtcbiAgICAgICAgICAgIGNvbnN0IHdhdGNoZWQgPSBpc1dhdGNoZWQobmFtZSwgX25hbWVzLCBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzQmx1ckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZmllbGQuX2Yub25CbHVyICYmIGZpZWxkLl9mLm9uQmx1cihldmVudCk7XG4gICAgICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrICYmIGRlbGF5RXJyb3JDYWxsYmFjaygwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLl9mLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuX2Yub25DaGFuZ2UoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmllbGRTdGF0ZSA9IHVwZGF0ZVRvdWNoQW5kRGlydHkobmFtZSwgZmllbGRWYWx1ZSwgaXNCbHVyRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFJlbmRlciA9ICFpc0VtcHR5T2JqZWN0KGZpZWxkU3RhdGUpIHx8IHdhdGNoZWQ7XG4gICAgICAgICAgICAhaXNCbHVyRXZlbnQgJiZcbiAgICAgICAgICAgICAgICBfc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBldmVudC50eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4uX2Zvcm1WYWx1ZXMgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX29wdGlvbnMubW9kZSA9PT0gJ29uQmx1cicgJiYgaXNCbHVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVWYWxpZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZVZhbGlkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzaG91bGRSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyBuYW1lLCAuLi4od2F0Y2hlZCA/IHt9IDogZmllbGRTdGF0ZSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmIHdhdGNoZWQgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgICAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9leGVjdXRlU2NoZW1hKFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNFcnJvckxvb2t1cFJlc3VsdCA9IHNjaGVtYUVycm9yTG9va3VwKF9mb3JtU3RhdGUuZXJyb3JzLCBfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JMb29rdXBSZXN1bHQgPSBzY2hlbWFFcnJvckxvb2t1cChlcnJvcnMsIF9maWVsZHMsIHByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQubmFtZSB8fCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvckxvb2t1cFJlc3VsdC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGVycm9yTG9va3VwUmVzdWx0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbbmFtZV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGVycm9yID0gKGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGQsIF9uYW1lcy5kaXNhYmxlZCwgX2Zvcm1WYWx1ZXMsIHNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzLCBfb3B0aW9ucy5zaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSlbbmFtZV07XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbbmFtZV0pO1xuICAgICAgICAgICAgICAgIF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkVmFsdWVVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5kZXBzICYmXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoZmllbGQuX2YuZGVwcyk7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyQnlFcnJvcihuYW1lLCBpc1ZhbGlkLCBlcnJvciwgZmllbGRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9mb2N1c0lucHV0ID0gKHJlZiwga2V5KSA9PiB7XG4gICAgICAgIGlmIChnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGtleSkgJiYgcmVmLmZvY3VzKSB7XG4gICAgICAgICAgICByZWYuZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIGNvbnN0IHRyaWdnZXIgPSBhc3luYyAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGxldCBpc1ZhbGlkO1xuICAgICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdDtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKTtcbiAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBhd2FpdCBleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUoaXNVbmRlZmluZWQobmFtZSkgPyBuYW1lIDogZmllbGROYW1lcyk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IG5hbWVcbiAgICAgICAgICAgICAgICA/ICFmaWVsZE5hbWVzLnNvbWUoKG5hbWUpID0+IGdldChlcnJvcnMsIG5hbWUpKVxuICAgICAgICAgICAgICAgIDogaXNWYWxpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gKGF3YWl0IFByb21pc2UuYWxsKGZpZWxkTmFtZXMubWFwKGFzeW5jIChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oZmllbGQgJiYgZmllbGQuX2YgPyB7IFtmaWVsZE5hbWVdOiBmaWVsZCB9IDogZmllbGQpO1xuICAgICAgICAgICAgfSkpKS5ldmVyeShCb29sZWFuKTtcbiAgICAgICAgICAgICEoIXZhbGlkYXRpb25SZXN1bHQgJiYgIV9mb3JtU3RhdGUuaXNWYWxpZCkgJiYgX3VwZGF0ZVZhbGlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gaXNWYWxpZCA9IGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAuLi4oIWlzU3RyaW5nKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmIGlzVmFsaWQgIT09IF9mb3JtU3RhdGUuaXNWYWxpZClcbiAgICAgICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICAgICAgOiB7IG5hbWUgfSksXG4gICAgICAgICAgICAuLi4oX29wdGlvbnMucmVzb2x2ZXIgfHwgIW5hbWUgPyB7IGlzVmFsaWQgfSA6IHt9KSxcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLnNob3VsZEZvY3VzICYmXG4gICAgICAgICAgICAhdmFsaWRhdGlvblJlc3VsdCAmJlxuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKF9maWVsZHMsIF9mb2N1c0lucHV0LCBuYW1lID8gZmllbGROYW1lcyA6IF9uYW1lcy5tb3VudCk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0O1xuICAgIH07XG4gICAgY29uc3QgZ2V0VmFsdWVzID0gKGZpZWxkTmFtZXMpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgICAgICAgLi4uKF9zdGF0ZS5tb3VudCA/IF9mb3JtVmFsdWVzIDogX2RlZmF1bHRWYWx1ZXMpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZmllbGROYW1lcylcbiAgICAgICAgICAgID8gdmFsdWVzXG4gICAgICAgICAgICA6IGlzU3RyaW5nKGZpZWxkTmFtZXMpXG4gICAgICAgICAgICAgICAgPyBnZXQodmFsdWVzLCBmaWVsZE5hbWVzKVxuICAgICAgICAgICAgICAgIDogZmllbGROYW1lcy5tYXAoKG5hbWUpID0+IGdldCh2YWx1ZXMsIG5hbWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEZpZWxkU3RhdGUgPSAobmFtZSwgZm9ybVN0YXRlKSA9PiAoe1xuICAgICAgICBpbnZhbGlkOiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmVycm9ycywgbmFtZSksXG4gICAgICAgIGlzRGlydHk6ICEhZ2V0KChmb3JtU3RhdGUgfHwgX2Zvcm1TdGF0ZSkuZGlydHlGaWVsZHMsIG5hbWUpLFxuICAgICAgICBlcnJvcjogZ2V0KChmb3JtU3RhdGUgfHwgX2Zvcm1TdGF0ZSkuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiAhIWdldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUpLFxuICAgICAgICBpc1RvdWNoZWQ6ICEhZ2V0KChmb3JtU3RhdGUgfHwgX2Zvcm1TdGF0ZSkudG91Y2hlZEZpZWxkcywgbmFtZSksXG4gICAgfSk7XG4gICAgY29uc3QgY2xlYXJFcnJvcnMgPSAobmFtZSkgPT4ge1xuICAgICAgICBuYW1lICYmXG4gICAgICAgICAgICBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkuZm9yRWFjaCgoaW5wdXROYW1lKSA9PiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgaW5wdXROYW1lKSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGVycm9yczogbmFtZSA/IF9mb3JtU3RhdGUuZXJyb3JzIDoge30sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0RXJyb3IgPSAobmFtZSwgZXJyb3IsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgcmVmID0gKGdldChfZmllbGRzLCBuYW1lLCB7IF9mOiB7fSB9KS5fZiB8fCB7fSkucmVmO1xuICAgICAgICBjb25zdCBjdXJyZW50RXJyb3IgPSBnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpIHx8IHt9O1xuICAgICAgICAvLyBEb24ndCBvdmVycmlkZSBleGlzdGluZyBlcnJvciBtZXNzYWdlcyBlbHNld2hlcmUgaW4gdGhlIG9iamVjdCB0cmVlLlxuICAgICAgICBjb25zdCB7IHJlZjogY3VycmVudFJlZiwgbWVzc2FnZSwgdHlwZSwgLi4ucmVzdE9mRXJyb3JUcmVlIH0gPSBjdXJyZW50RXJyb3I7XG4gICAgICAgIHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwge1xuICAgICAgICAgICAgLi4ucmVzdE9mRXJyb3JUcmVlLFxuICAgICAgICAgICAgLi4uZXJyb3IsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgIH0pO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLnNob3VsZEZvY3VzICYmIHJlZiAmJiByZWYuZm9jdXMgJiYgcmVmLmZvY3VzKCk7XG4gICAgfTtcbiAgICBjb25zdCB3YXRjaCA9IChuYW1lLCBkZWZhdWx0VmFsdWUpID0+IGlzRnVuY3Rpb24obmFtZSlcbiAgICAgICAgPyBfc3ViamVjdHMudmFsdWVzLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiAocGF5bG9hZCkgPT4gbmFtZShfZ2V0V2F0Y2godW5kZWZpbmVkLCBkZWZhdWx0VmFsdWUpLCBwYXlsb2FkKSxcbiAgICAgICAgfSlcbiAgICAgICAgOiBfZ2V0V2F0Y2gobmFtZSwgZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgICBjb25zdCB1bnJlZ2lzdGVyID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBuYW1lID8gY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpIDogX25hbWVzLm1vdW50KSB7XG4gICAgICAgICAgICBfbmFtZXMubW91bnQuZGVsZXRlKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICBfbmFtZXMuYXJyYXkuZGVsZXRlKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVZhbHVlcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICFvcHRpb25zLmtlZXBFcnJvciAmJiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICFvcHRpb25zLmtlZXBEaXJ0eSAmJiB1bnNldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIW9wdGlvbnMua2VlcFRvdWNoZWQgJiYgdW5zZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIW9wdGlvbnMua2VlcElzVmFsaWRhdGluZyAmJlxuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICFfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyICYmXG4gICAgICAgICAgICAgICAgIW9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgIHVuc2V0KF9kZWZhdWx0VmFsdWVzLCBmaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIF9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XG4gICAgICAgICAgICB2YWx1ZXM6IHsgLi4uX2Zvcm1WYWx1ZXMgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAuLi4oIW9wdGlvbnMua2VlcERpcnR5ID8ge30gOiB7IGlzRGlydHk6IF9nZXREaXJ0eSgpIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgIW9wdGlvbnMua2VlcElzVmFsaWQgJiYgX3VwZGF0ZVZhbGlkKCk7XG4gICAgfTtcbiAgICBjb25zdCBfdXBkYXRlRGlzYWJsZWRGaWVsZCA9ICh7IGRpc2FibGVkLCBuYW1lLCBmaWVsZCwgZmllbGRzLCB9KSA9PiB7XG4gICAgICAgIGlmICgoaXNCb29sZWFuKGRpc2FibGVkKSAmJiBfc3RhdGUubW91bnQpIHx8XG4gICAgICAgICAgICAhIWRpc2FibGVkIHx8XG4gICAgICAgICAgICBfbmFtZXMuZGlzYWJsZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBkaXNhYmxlZCA/IF9uYW1lcy5kaXNhYmxlZC5hZGQobmFtZSkgOiBfbmFtZXMuZGlzYWJsZWQuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgdXBkYXRlVG91Y2hBbmREaXJ0eShuYW1lLCBnZXRGaWVsZFZhbHVlKGZpZWxkID8gZmllbGQuX2YgOiBnZXQoZmllbGRzLCBuYW1lKS5fZiksIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBsZXQgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkSXNEZWZpbmVkID0gaXNCb29sZWFuKG9wdGlvbnMuZGlzYWJsZWQpIHx8IGlzQm9vbGVhbihfb3B0aW9ucy5kaXNhYmxlZCk7XG4gICAgICAgIHNldChfZmllbGRzLCBuYW1lLCB7XG4gICAgICAgICAgICAuLi4oZmllbGQgfHwge30pLFxuICAgICAgICAgICAgX2Y6IHtcbiAgICAgICAgICAgICAgICAuLi4oZmllbGQgJiYgZmllbGQuX2YgPyBmaWVsZC5fZiA6IHsgcmVmOiB7IG5hbWUgfSB9KSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIG1vdW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgX25hbWVzLm1vdW50LmFkZChuYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBfdXBkYXRlRGlzYWJsZWRGaWVsZCh7XG4gICAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGlzQm9vbGVhbihvcHRpb25zLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgOiBfb3B0aW9ucy5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVWYWxpZEFuZFZhbHVlKG5hbWUsIHRydWUsIG9wdGlvbnMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi4oZGlzYWJsZWRJc0RlZmluZWRcbiAgICAgICAgICAgICAgICA/IHsgZGlzYWJsZWQ6IG9wdGlvbnMuZGlzYWJsZWQgfHwgX29wdGlvbnMuZGlzYWJsZWQgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgLi4uKF9vcHRpb25zLnByb2dyZXNzaXZlXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhIW9wdGlvbnMucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgICAgIG1pbjogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWluKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBnZXRSdWxlVmFsdWUob3B0aW9ucy5tYXgpLFxuICAgICAgICAgICAgICAgICAgICBtaW5MZW5ndGg6IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1pbkxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIG1heExlbmd0aDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWF4TGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZ2V0UnVsZVZhbHVlKG9wdGlvbnMucGF0dGVybiksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICAgICAgb25CbHVyOiBvbkNoYW5nZSxcbiAgICAgICAgICAgIHJlZjogKHJlZikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXIobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFJlZiA9IGlzVW5kZWZpbmVkKHJlZi52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLnF1ZXJ5U2VsZWN0b3JBbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCxzZWxlY3QsdGV4dGFyZWEnKVswXSB8fCByZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWY7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhZGlvT3JDaGVja2JveCA9IGlzUmFkaW9PckNoZWNrYm94KGZpZWxkUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcyA9IGZpZWxkLl9mLnJlZnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYWRpb09yQ2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmcy5maW5kKChvcHRpb24pID0+IG9wdGlvbiA9PT0gZmllbGRSZWYpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkUmVmID09PSBmaWVsZC5fZi5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQoX2ZpZWxkcywgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Y6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5maWVsZC5fZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4ocmFkaW9PckNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlZnMuZmlsdGVyKGxpdmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkpID8gW3t9XSA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IHsgdHlwZTogZmllbGRSZWYudHlwZSwgbmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeyByZWY6IGZpZWxkUmVmIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbGlkQW5kVmFsdWUobmFtZSwgZmFsc2UsIHVuZGVmaW5lZCwgZmllbGRSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSwge30pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLm1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgfHwgb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIShpc05hbWVJbkZpZWxkQXJyYXkoX25hbWVzLmFycmF5LCBuYW1lKSAmJiBfc3RhdGUuYWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgX25hbWVzLnVuTW91bnQuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBfZm9jdXNFcnJvciA9ICgpID0+IF9vcHRpb25zLnNob3VsZEZvY3VzRXJyb3IgJiZcbiAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKF9maWVsZHMsIF9mb2N1c0lucHV0LCBfbmFtZXMubW91bnQpO1xuICAgIGNvbnN0IF9kaXNhYmxlRm9ybSA9IChkaXNhYmxlZCkgPT4ge1xuICAgICAgICBpZiAoaXNCb29sZWFuKGRpc2FibGVkKSkge1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyBkaXNhYmxlZCB9KTtcbiAgICAgICAgICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihfZmllbGRzLCAocmVmLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmRpc2FibGVkID0gY3VycmVudEZpZWxkLl9mLmRpc2FibGVkIHx8IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50RmllbGQuX2YucmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaWVsZC5fZi5yZWZzLmZvckVhY2goKGlucHV0UmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRSZWYuZGlzYWJsZWQgPSBjdXJyZW50RmllbGQuX2YuZGlzYWJsZWQgfHwgZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlU3VibWl0ID0gKG9uVmFsaWQsIG9uSW52YWxpZCkgPT4gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgbGV0IG9uVmFsaWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5wZXJzaXN0ICYmIGUucGVyc2lzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZFZhbHVlcyA9IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKTtcbiAgICAgICAgaWYgKF9uYW1lcy5kaXNhYmxlZC5zaXplKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgc2V0KGZpZWxkVmFsdWVzLCBuYW1lLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMsIHZhbHVlcyB9ID0gYXdhaXQgX2V4ZWN1dGVTY2hlbWEoKTtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgZmllbGRWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsICdyb290Jyk7XG4gICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUuZXJyb3JzKSkge1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGVycm9yczoge30sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25WYWxpZChmaWVsZFZhbHVlcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvblZhbGlkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvbkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvbkludmFsaWQoeyAuLi5fZm9ybVN0YXRlLmVycm9ycyB9LCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mb2N1c0Vycm9yKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KF9mb2N1c0Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBpc1N1Ym1pdHRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGlzRW1wdHlPYmplY3QoX2Zvcm1TdGF0ZS5lcnJvcnMpICYmICFvblZhbGlkRXJyb3IsXG4gICAgICAgICAgICBzdWJtaXRDb3VudDogX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudCArIDEsXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9uVmFsaWRFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgb25WYWxpZEVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXNldEZpZWxkID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBpZiAoZ2V0KF9maWVsZHMsIG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQob3B0aW9ucy5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUobmFtZSwgY2xvbmVPYmplY3QoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUobmFtZSwgb3B0aW9ucy5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIHNldChfZGVmYXVsdFZhbHVlcywgbmFtZSwgY2xvbmVPYmplY3Qob3B0aW9ucy5kZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVG91Y2hlZCkge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcERpcnR5KSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc0RpcnR5ID0gb3B0aW9ucy5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgPyBfZ2V0RGlydHkobmFtZSwgY2xvbmVPYmplY3QoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkpXG4gICAgICAgICAgICAgICAgICAgIDogX2dldERpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmIF91cGRhdGVWYWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRWYWx1ZXMgPSBmb3JtVmFsdWVzID8gY2xvbmVPYmplY3QoZm9ybVZhbHVlcykgOiBfZGVmYXVsdFZhbHVlcztcbiAgICAgICAgY29uc3QgY2xvbmVVcGRhdGVkVmFsdWVzID0gY2xvbmVPYmplY3QodXBkYXRlZFZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGlzRW1wdHlSZXNldFZhbHVlcyA9IGlzRW1wdHlPYmplY3QoZm9ybVZhbHVlcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGlzRW1wdHlSZXNldFZhbHVlcyA/IF9kZWZhdWx0VmFsdWVzIDogY2xvbmVVcGRhdGVkVmFsdWVzO1xuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgICAgIF9kZWZhdWx0VmFsdWVzID0gdXBkYXRlZFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzVG9DaGVjayA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgICAgICAgICAuLi5fbmFtZXMubW91bnQsXG4gICAgICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcykpLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIEFycmF5LmZyb20oZmllbGRzVG9DaGVjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KHZhbHVlcywgZmllbGROYW1lLCBnZXQoX2Zvcm1WYWx1ZXMsIGZpZWxkTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNldFZhbHVlKGZpZWxkTmFtZSwgZ2V0KHZhbHVlcywgZmllbGROYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2ViICYmIGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBBcnJheS5pc0FycmF5KGZpZWxkLl9mLnJlZnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmllbGQuX2YucmVmc1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkLl9mLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGZpZWxkUmVmZXJlbmNlLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9maWVsZHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mb3JtVmFsdWVzID0gX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlclxuICAgICAgICAgICAgICAgID8ga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICA/IGNsb25lT2JqZWN0KF9kZWZhdWx0VmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICA6IHt9XG4gICAgICAgICAgICAgICAgOiBjbG9uZU9iamVjdCh2YWx1ZXMpO1xuICAgICAgICAgICAgX3N1YmplY3RzLmFycmF5Lm5leHQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi52YWx1ZXMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4udmFsdWVzIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfbmFtZXMgPSB7XG4gICAgICAgICAgICBtb3VudDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXMgPyBfbmFtZXMubW91bnQgOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgICAgICBhcnJheTogbmV3IFNldCgpLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB3YXRjaEFsbDogZmFsc2UsXG4gICAgICAgICAgICBmb2N1czogJycsXG4gICAgICAgIH07XG4gICAgICAgIF9zdGF0ZS5tb3VudCA9XG4gICAgICAgICAgICAhX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcElzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzO1xuICAgICAgICBfc3RhdGUud2F0Y2ggPSAhIV9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXI7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIHN1Ym1pdENvdW50OiBrZWVwU3RhdGVPcHRpb25zLmtlZXBTdWJtaXRDb3VudFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudFxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGlzRGlydHk6IGlzRW1wdHlSZXNldFZhbHVlc1xuICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5XG4gICAgICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5pc0RpcnR5XG4gICAgICAgICAgICAgICAgICAgIDogISEoa2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWRlZXBFcXVhbChmb3JtVmFsdWVzLCBfZGVmYXVsdFZhbHVlcykpLFxuICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcElzU3VibWl0dGVkXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzU3VibWl0dGVkXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGRpcnR5RmllbGRzOiBpc0VtcHR5UmVzZXRWYWx1ZXNcbiAgICAgICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlc1xuICAgICAgICAgICAgICAgICAgICA/IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiYgX2Zvcm1WYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIF9mb3JtVmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfZm9ybVN0YXRlLmRpcnR5RmllbGRzXG4gICAgICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcyAmJiBmb3JtVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBmb3JtVmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICB0b3VjaGVkRmllbGRzOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBUb3VjaGVkXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHNcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgZXJyb3JzOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBFcnJvcnMgPyBfZm9ybVN0YXRlLmVycm9ycyA6IHt9LFxuICAgICAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1N1Ym1pdFN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuaXNTdWJtaXRTdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucykgPT4gX3Jlc2V0KGlzRnVuY3Rpb24oZm9ybVZhbHVlcylcbiAgICAgICAgPyBmb3JtVmFsdWVzKF9mb3JtVmFsdWVzKVxuICAgICAgICA6IGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMpO1xuICAgIGNvbnN0IHNldEZvY3VzID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZCAmJiBmaWVsZC5fZjtcbiAgICAgICAgaWYgKGZpZWxkUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFJlZiA9IGZpZWxkUmVmZXJlbmNlLnJlZnNcbiAgICAgICAgICAgICAgICA/IGZpZWxkUmVmZXJlbmNlLnJlZnNbMF1cbiAgICAgICAgICAgICAgICA6IGZpZWxkUmVmZXJlbmNlLnJlZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZi5mb2N1cykge1xuICAgICAgICAgICAgICAgIGZpZWxkUmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGRTZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihmaWVsZFJlZi5zZWxlY3QpICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmLnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfdXBkYXRlRm9ybVN0YXRlID0gKHVwZGF0ZWRGb3JtU3RhdGUpID0+IHtcbiAgICAgICAgX2Zvcm1TdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAuLi51cGRhdGVkRm9ybVN0YXRlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgX3Jlc2V0RGVmYXVsdFZhbHVlcyA9ICgpID0+IGlzRnVuY3Rpb24oX29wdGlvbnMuZGVmYXVsdFZhbHVlcykgJiZcbiAgICAgICAgX29wdGlvbnMuZGVmYXVsdFZhbHVlcygpLnRoZW4oKHZhbHVlcykgPT4ge1xuICAgICAgICAgICAgcmVzZXQodmFsdWVzLCBfb3B0aW9ucy5yZXNldE9wdGlvbnMpO1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgICAgICB1bnJlZ2lzdGVyLFxuICAgICAgICAgICAgZ2V0RmllbGRTdGF0ZSxcbiAgICAgICAgICAgIGhhbmRsZVN1Ym1pdCxcbiAgICAgICAgICAgIHNldEVycm9yLFxuICAgICAgICAgICAgX2V4ZWN1dGVTY2hlbWEsXG4gICAgICAgICAgICBfZ2V0V2F0Y2gsXG4gICAgICAgICAgICBfZ2V0RGlydHksXG4gICAgICAgICAgICBfdXBkYXRlVmFsaWQsXG4gICAgICAgICAgICBfcmVtb3ZlVW5tb3VudGVkLFxuICAgICAgICAgICAgX3VwZGF0ZUZpZWxkQXJyYXksXG4gICAgICAgICAgICBfdXBkYXRlRGlzYWJsZWRGaWVsZCxcbiAgICAgICAgICAgIF9nZXRGaWVsZEFycmF5LFxuICAgICAgICAgICAgX3Jlc2V0LFxuICAgICAgICAgICAgX3Jlc2V0RGVmYXVsdFZhbHVlcyxcbiAgICAgICAgICAgIF91cGRhdGVGb3JtU3RhdGUsXG4gICAgICAgICAgICBfZGlzYWJsZUZvcm0sXG4gICAgICAgICAgICBfc3ViamVjdHMsXG4gICAgICAgICAgICBfcHJveHlGb3JtU3RhdGUsXG4gICAgICAgICAgICBfc2V0RXJyb3JzLFxuICAgICAgICAgICAgZ2V0IF9maWVsZHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9maWVsZHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9mb3JtVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZm9ybVZhbHVlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX3N0YXRlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3RhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IF9zdGF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9zdGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfZGVmYXVsdFZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2RlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9uYW1lcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25hbWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBfbmFtZXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfbmFtZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX2Zvcm1TdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zvcm1TdGF0ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX2Zvcm1TdGF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX29wdGlvbnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9vcHRpb25zO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBfb3B0aW9ucyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9vcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5fb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXIsXG4gICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICBoYW5kbGVTdWJtaXQsXG4gICAgICAgIHdhdGNoLFxuICAgICAgICBzZXRWYWx1ZSxcbiAgICAgICAgZ2V0VmFsdWVzLFxuICAgICAgICByZXNldCxcbiAgICAgICAgcmVzZXRGaWVsZCxcbiAgICAgICAgY2xlYXJFcnJvcnMsXG4gICAgICAgIHVucmVnaXN0ZXIsXG4gICAgICAgIHNldEVycm9yLFxuICAgICAgICBzZXRGb2N1cyxcbiAgICAgICAgZ2V0RmllbGRTdGF0ZSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEN1c3RvbSBob29rIHRvIG1hbmFnZSB0aGUgZW50aXJlIGZvcm0uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm0pIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS1nZXQtc3RhcnRlZC10cy01a3NtbSkg4oCiIFtWaWRlb10oaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Sa1h2NEFYWENfNClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBmb3JtIGNvbmZpZ3VyYXRpb24gYW5kIHZhbGlkYXRpb24gcGFyYW1ldGVycy5cbiAqXG4gKiBAcmV0dXJucyBtZXRob2RzIC0gaW5kaXZpZHVhbCBmdW5jdGlvbnMgdG8gbWFuYWdlIHRoZSBmb3JtIHN0YXRlLiB7QGxpbmsgVXNlRm9ybVJldHVybn1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIsIGhhbmRsZVN1Ym1pdCwgd2F0Y2gsIGZvcm1TdGF0ZTogeyBlcnJvcnMgfSB9ID0gdXNlRm9ybSgpO1xuICogICBjb25zdCBvblN1Ym1pdCA9IGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICBjb25zb2xlLmxvZyh3YXRjaChcImV4YW1wbGVcIikpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICA8aW5wdXQgZGVmYXVsdFZhbHVlPVwidGVzdFwiIHsuLi5yZWdpc3RlcihcImV4YW1wbGVcIil9IC8+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwiZXhhbXBsZVJlcXVpcmVkXCIsIHsgcmVxdWlyZWQ6IHRydWUgfSl9IC8+XG4gKiAgICAgICB7ZXJyb3JzLmV4YW1wbGVSZXF1aXJlZCAmJiA8c3Bhbj5UaGlzIGZpZWxkIGlzIHJlcXVpcmVkPC9zcGFuPn1cbiAqICAgICAgIDxidXR0b24+U3VibWl0PC9idXR0b24+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUZvcm0ocHJvcHMgPSB7fSkge1xuICAgIGNvbnN0IF9mb3JtQ29udHJvbCA9IFJlYWN0LnVzZVJlZih1bmRlZmluZWQpO1xuICAgIGNvbnN0IF92YWx1ZXMgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgICBjb25zdCBbZm9ybVN0YXRlLCB1cGRhdGVGb3JtU3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNMb2FkaW5nOiBpc0Z1bmN0aW9uKHByb3BzLmRlZmF1bHRWYWx1ZXMpLFxuICAgICAgICBpc1N1Ym1pdHRlZDogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBzdWJtaXRDb3VudDogMCxcbiAgICAgICAgZGlydHlGaWVsZHM6IHt9LFxuICAgICAgICB0b3VjaGVkRmllbGRzOiB7fSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczoge30sXG4gICAgICAgIGVycm9yczogcHJvcHMuZXJyb3JzIHx8IHt9LFxuICAgICAgICBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgICAgIGRlZmF1bHRWYWx1ZXM6IGlzRnVuY3Rpb24ocHJvcHMuZGVmYXVsdFZhbHVlcylcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHByb3BzLmRlZmF1bHRWYWx1ZXMsXG4gICAgfSk7XG4gICAgaWYgKCFfZm9ybUNvbnRyb2wuY3VycmVudCkge1xuICAgICAgICBfZm9ybUNvbnRyb2wuY3VycmVudCA9IHtcbiAgICAgICAgICAgIC4uLmNyZWF0ZUZvcm1Db250cm9sKHByb3BzKSxcbiAgICAgICAgICAgIGZvcm1TdGF0ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY29udHJvbCA9IF9mb3JtQ29udHJvbC5jdXJyZW50LmNvbnRyb2w7XG4gICAgY29udHJvbC5fb3B0aW9ucyA9IHByb3BzO1xuICAgIHVzZVN1YnNjcmliZSh7XG4gICAgICAgIHN1YmplY3Q6IGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLFxuICAgICAgICBuZXh0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW5kZXJGb3JtU3RhdGUodmFsdWUsIGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlLCBjb250cm9sLl91cGRhdGVGb3JtU3RhdGUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRm9ybVN0YXRlKHsgLi4uY29udHJvbC5fZm9ybVN0YXRlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiBjb250cm9sLl9kaXNhYmxlRm9ybShwcm9wcy5kaXNhYmxlZCksIFtjb250cm9sLCBwcm9wcy5kaXNhYmxlZF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChjb250cm9sLl9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5KSB7XG4gICAgICAgICAgICBjb25zdCBpc0RpcnR5ID0gY29udHJvbC5fZ2V0RGlydHkoKTtcbiAgICAgICAgICAgIGlmIChpc0RpcnR5ICE9PSBmb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBpc0RpcnR5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wsIGZvcm1TdGF0ZS5pc0RpcnR5XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb3BzLnZhbHVlcyAmJiAhZGVlcEVxdWFsKHByb3BzLnZhbHVlcywgX3ZhbHVlcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29udHJvbC5fcmVzZXQocHJvcHMudmFsdWVzLCBjb250cm9sLl9vcHRpb25zLnJlc2V0T3B0aW9ucyk7XG4gICAgICAgICAgICBfdmFsdWVzLmN1cnJlbnQgPSBwcm9wcy52YWx1ZXM7XG4gICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoKHN0YXRlKSA9PiAoeyAuLi5zdGF0ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sLl9yZXNldERlZmF1bHRWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgIH0sIFtwcm9wcy52YWx1ZXMsIGNvbnRyb2xdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvcHMuZXJyb3JzKSB7XG4gICAgICAgICAgICBjb250cm9sLl9zZXRFcnJvcnMocHJvcHMuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH0sIFtwcm9wcy5lcnJvcnMsIGNvbnRyb2xdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbnRyb2wuX3N0YXRlLm1vdW50KSB7XG4gICAgICAgICAgICBjb250cm9sLl91cGRhdGVWYWxpZCgpO1xuICAgICAgICAgICAgY29udHJvbC5fc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sLl9zdGF0ZS53YXRjaCkge1xuICAgICAgICAgICAgY29udHJvbC5fc3RhdGUud2F0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5jb250cm9sLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5fcmVtb3ZlVW5tb3VudGVkKCk7XG4gICAgfSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcHJvcHMuc2hvdWxkVW5yZWdpc3RlciAmJlxuICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogY29udHJvbC5fZ2V0V2F0Y2goKSxcbiAgICAgICAgICAgIH0pO1xuICAgIH0sIFtwcm9wcy5zaG91bGRVbnJlZ2lzdGVyLCBjb250cm9sXSk7XG4gICAgX2Zvcm1Db250cm9sLmN1cnJlbnQuZm9ybVN0YXRlID0gZ2V0UHJveHlGb3JtU3RhdGUoZm9ybVN0YXRlLCBjb250cm9sKTtcbiAgICByZXR1cm4gX2Zvcm1Db250cm9sLmN1cnJlbnQ7XG59XG5cbmV4cG9ydCB7IENvbnRyb2xsZXIsIEZvcm0sIEZvcm1Qcm92aWRlciwgYXBwZW5kRXJyb3JzLCBnZXQsIHNldCwgdXNlQ29udHJvbGxlciwgdXNlRmllbGRBcnJheSwgdXNlRm9ybSwgdXNlRm9ybUNvbnRleHQsIHVzZUZvcm1TdGF0ZSwgdXNlV2F0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5tanMubWFwXG4iLCJpbXBvcnQge01vZGFsfSBmcm9tIFwiQHNyYy9zaGFyZWQvdWkvbW9kYWxcIjtcbmltcG9ydCB7TW9kYWxQcm9wc30gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL21vZGFsL01vZGFsXCI7XG5pbXBvcnQge1RleHRJbnB1dH0gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL3RleHQtaW5wdXQvVGV4dElucHV0XCI7XG5pbXBvcnQge1R5cG9ncmFwaHl9IGZyb20gXCJAc3JjL3NoYXJlZC91aS90eXBvZ3JhcGh5XCI7XG5pbXBvcnQge0RhdGVQaWNrZXJ9IGZyb20gXCJAc3JjL3dpZGdldHMvZGF0ZS1waWNrZXJcIjtcbmltcG9ydCAqIGFzIHMgZnJvbSAnLi9DcmVhdGVUYXNrTW9kYWwuY3NzJ1xuaW1wb3J0IHtUZXh0YXJlYX0gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL3RleHRhcmVhL1RleHRhcmVhXCI7XG5pbXBvcnQge2NvbG9yc30gZnJvbSAnQHNyYy9zaGFyZWQvY29uZmlnJ1xuaW1wb3J0IHtCdXR0b259IGZyb20gXCJAc3JjL3NoYXJlZC91aS9idXR0b25cIjtcbmltcG9ydCB7Q29sb3JQaWNrfSBmcm9tIFwiQHNyYy93aWRnZXRzL2NyZWF0ZS10YXNrLW1vZGFsL3VpL2NvbG9yLXBpY2svQ29sb3JQaWNrXCI7XG5pbXBvcnQge3VzZVJvb3RDb250ZXh0fSBmcm9tIFwiQHNyYy9hcHAvcHJvdmlkZXJzL3Jvb3RQcm92aWRlclwiO1xuaW1wb3J0IHtDcmVhdGVUYXNrRGF0YX0gZnJvbSBcIkBzcmMvZW50aXRpZXMvdGFzay9hcGkvY3JlYXRlVGFza1wiO1xuaW1wb3J0IHtJQ3JlYXRlVGFza0Zvcm19IGZyb20gXCJAc3JjL3dpZGdldHMvY3JlYXRlLXRhc2stbW9kYWwvbW9kZWxcIjtcbmltcG9ydCB7b2JzZXJ2ZXJ9IGZyb20gXCJtb2J4LXJlYWN0XCI7XG5pbXBvcnQge0NvbnRyb2xsZXIsIFN1Ym1pdEVycm9ySGFuZGxlciwgU3VibWl0SGFuZGxlciwgdXNlRm9ybX0gZnJvbSBcInJlYWN0LWhvb2stZm9ybVwiO1xuXG5leHBvcnQgY29uc3QgQ3JlYXRlVGFza01vZGFsID0gb2JzZXJ2ZXIoKHA6IE1vZGFsUHJvcHMpID0+IHtcbiAgICBjb25zdCB7dGFzaywgbm90aWZ5fSA9IHVzZVJvb3RDb250ZXh0KClcblxuICAgIGNvbnN0IHtoYW5kbGVTdWJtaXQsIGNvbnRyb2wsIHJlc2V0LCBmb3JtU3RhdGV9ID0gdXNlRm9ybTxJQ3JlYXRlVGFza0Zvcm0+KHtcbiAgICAgICAgZGVmYXVsdFZhbHVlczoge1xuICAgICAgICAgICAgY29sb3I6IGNvbG9ycy5yZWRcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBvblN1Ym1pdDogU3VibWl0SGFuZGxlcjxJQ3JlYXRlVGFza0Zvcm0+ID0gYXN5bmMgKGRhdGEsIGUpID0+IHtcbiAgICAgICAgZT8ucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCBhZGRpbmdEYXRhOiBDcmVhdGVUYXNrRGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICAgIGNvbXBsZXRlZDogZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRhc2suYWRkKGFkZGluZ0RhdGEpXG4gICAgICAgIGF3YWl0IHRhc2suZmV0Y2goKVxuICAgICAgICBub3RpZnkucHVzaCh7XG4gICAgICAgICAgICBpZDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgICB0aXRsZTogJ9CX0LDQtNCw0YfQsCDRgdC+0LfQtNCw0L3QsCEnXG4gICAgICAgIH0pXG4gICAgICAgIHJlc2V0KClcbiAgICAgICAgcC5jbG9zZSgpXG4gICAgfVxuXG4gICAgY29uc3Qgb25FcnJvcjogU3VibWl0RXJyb3JIYW5kbGVyPElDcmVhdGVUYXNrRm9ybT4gPSAoZXJyb3JzLCBlKSA9PiB7XG4gICAgICAgIGU/LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgbm90aWZ5LnB1c2goe1xuICAgICAgICAgICAgaWQ6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgIHRpdGxlOiAn0J7RiNC40LHQutC4INC30LDQv9C+0LvQvdC10L3QuNGPINGE0L7RgNC80YsnLFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxNb2RhbCBjbG9zZT17cC5jbG9zZX0gb3Blbj17cC5vcGVufT5cbiAgICAgICAgICAgIDxmb3JtIGFjdGlvbj1cIiNcIiBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0LCBvbkVycm9yKX0+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJ0YXNrLW5hbWUtaW5wdXRcIj5cbiAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dCBjbGFzc05hbWU9e3MubGFiZWx9PtCd0LDQt9Cy0LDQvdC40LUg0LfQsNC00LDRh9C4PC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgICAgIDxDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXsnbmFtZSd9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sPXtjb250cm9sfVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAn0K3RgtC+INC/0L7Qu9C1INC+0LHRj9C30LDRgtC10LvRjNC90L4g0Log0LfQsNC/0L7Qu9C90LXQvdC40Y4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXI9eyh7ZmllbGQsIGZpZWxkU3RhdGV9KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRleHRJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD1cInRhc2stbmFtZS1pbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwi0JLQstC10LTQuNGC0LUuLi5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZmllbGQudmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlPXtmaWVsZC5vbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzLnRleHRfaW5wdXR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWQ9e2ZpZWxkU3RhdGUuaW52YWxpZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXsobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSAmJiBwLm9wZW4gJiYgbm9kZS5mb2N1cygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLmRhdGVzfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQgY2xhc3NOYW1lPXtzLmxhYmVsfT7QndCw0YfQsNC70L48L1R5cG9ncmFwaHkuVGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17J3N0YXJ0J31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sPXtjb250cm9sfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAn0K3RgtC+INC/0L7Qu9C1INC+0LHRj9C30LDRgtC10LvRjNC90L4g0Log0LfQsNC/0L7Qu9C90LXQvdC40Y4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyPXsoe2ZpZWxkLCBmaWVsZFN0YXRlfSkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGF0ZVBpY2tlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ZpZWxkLnZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWU9e2ZpZWxkLm9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZD17ZmllbGRTdGF0ZS5pbnZhbGlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQgY2xhc3NOYW1lPXtzLmxhYmVsfT7QmtC+0L3QtdGGPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Q29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9eydlbmQnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w9e2NvbnRyb2x9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICfQrdGC0L4g0L/QvtC70LUg0L7QsdGP0LfQsNGC0LXQu9GM0L3QviDQuiDQt9Cw0L/QvtC70L3QtdC90LjRjicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXI9eyh7ZmllbGQsIGZpZWxkU3RhdGV9KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEYXRlUGlja2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZmllbGQudmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZT17ZmllbGQub25DaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkPXtmaWVsZFN0YXRlLmludmFsaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJ0YXNrLWRlc2NyaXB0aW9uLWlucHV0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQgY2xhc3NOYW1lPXtzLmxhYmVsfT7QntC/0LjRgdCw0L3QuNC1PC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgICAgIDxDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXsnZGVzY3JpcHRpb24nfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbD17Y29udHJvbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcj17KHtmaWVsZH0pID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8VGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJ0YXNrLWRlc2NyaXB0aW9uLWlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ZpZWxkLnZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZT17ZmllbGQub25DaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cy50ZXh0YXJlYX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dCBjbGFzc05hbWU9e3MubGFiZWx9PtCm0LLQtdGCPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLmNvbG9yX2NvbnRhaW5lcn0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Q29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9eydjb2xvcid9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbD17Y29udHJvbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXI9eyh7ZmllbGR9KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhjb2xvcnMpLm1hcChpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENvbG9yUGlja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2l9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtpID09PSBmaWVsZC52YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtmaWVsZC5vbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPEJ1dHRvbj7QlNC+0LHQsNCy0LjRgtGMPC9CdXR0b24+XG4gICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgIDwvTW9kYWw+XG4gICAgKTtcbn0pIiwiZXhwb3J0IHtDcmVhdGVUYXNrTW9kYWx9IGZyb20gJy4vQ3JlYXRlVGFza01vZGFsJyIsImltcG9ydCAqIGFzIHMgZnJvbSAnLi9TaWRlYmFyVGFza3MuY3NzJ1xuaW1wb3J0IHtUeXBvZ3JhcGh5fSBmcm9tIFwiQHNyYy9zaGFyZWQvdWkvdHlwb2dyYXBoeVwiO1xuaW1wb3J0IHtTaWRlYmFyVGFza30gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL3NpZGViYXItdGFza1wiO1xuaW1wb3J0IHtvYnNlcnZlcn0gZnJvbSBcIm1vYngtcmVhY3RcIjtcbmltcG9ydCB7dXNlUm9vdENvbnRleHR9IGZyb20gXCJAc3JjL2FwcC9wcm92aWRlcnMvcm9vdFByb3ZpZGVyXCI7XG5pbXBvcnQge3VzZUVmZmVjdCwgdXNlU3RhdGV9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtQbHVzSWNvbn0gZnJvbSBcIkBzcmMvcGFnZXMvZ2FudHQvdWkvcGx1cy1pY29uL1BsdXNJY29uXCI7XG5pbXBvcnQge0NyZWF0ZVRhc2tNb2RhbH0gZnJvbSBcIkBzcmMvd2lkZ2V0cy9jcmVhdGUtdGFzay1tb2RhbC91aVwiO1xuXG5leHBvcnQgY29uc3QgU2lkZWJhclRhc2tzID0gb2JzZXJ2ZXIoKCkgPT4ge1xuICAgIGNvbnN0IHt0YXNrfSA9IHVzZVJvb3RDb250ZXh0KClcbiAgICBjb25zdCBbbW9kYWxPcGVuLCBzZXRNb2RhbE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB0YXNrLmZldGNoKClcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3MuY29udGFpbmVyfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cy50b3BfYmxvY2t9PlxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeS5IZWFkaW5nIGNsYXNzTmFtZT17cy5wcm9qZWN0X3RpdGxlfT7QndCw0LfQstCw0L3QuNC1INC/0YDQvtC10LrRgtCwPC9UeXBvZ3JhcGh5LkhlYWRpbmc+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3Muc2lkZWJhcl9oZWFkaW5nfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQ+0JfQsNC00LDRh9CwPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeS5UZXh0PtCf0YDQvtCz0YDQtdGB0YE8L1R5cG9ncmFwaHkuVGV4dD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3Mub3ZlcmZsb3dfYmxvY2t9PlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGFzay50YXNrcykubWFwKGkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U2lkZWJhclRhc2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tOYW1lPXtpLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50PXtpLnByb2dyZXNzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpLmlkLnRvU3RyaW5nKCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3MuYnV0dG9ufVxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNb2RhbE9wZW4odHJ1ZSl9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8UGx1c0ljb24vPlxuICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeS5UZXh0PtCd0L7QstCw0Y8g0LfQsNC00LDRh9CwPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxDcmVhdGVUYXNrTW9kYWwgb3Blbj17bW9kYWxPcGVufSBjbG9zZT17KCkgPT4gc2V0TW9kYWxPcGVuKGZhbHNlKX0vPlxuICAgICAgICA8Lz5cbiAgICApO1xufSkiLCJleHBvcnQge1NpZGViYXJUYXNrc30gZnJvbSAnLi9TaWRlYmFyVGFza3MnIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG52YXIgXzEgPSBcIldRd2RKekFBWkk2clJwYWVxOWN4XCI7XG5leHBvcnQgeyBfMSBhcyBcImNvbnRhaW5lclwiIH1cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxudmFyIF8xID0gXCJFM01uX1NiUkxTTkM5ZzlFQUtCRVwiO1xudmFyIF8yID0gXCJDWlh2WkJBSndoWkttNHFFcEx0SVwiO1xudmFyIF8zID0gXCJGaDRyTWU5MXZpRjg0UHBGMTJDQ1wiO1xudmFyIF80ID0gXCJrbzUwX1hzb0Jvc2VLWEdlS2F0TVwiO1xudmFyIF81ID0gXCJmRlA5eFlScUdwXzRaRmdycVBEVlwiO1xuZXhwb3J0IHsgXzEgYXMgXCJjaGFydF9ib2R5XCIsIF8yIGFzIFwiY2hhcnRfaGVhZGluZ19ibG9ja1wiLCBfMyBhcyBcImNoYXJ0X2hlYWRpbmdfZGF0ZXNcIiwgXzQgYXMgXCJjaGFydF9oZWFkaW5nX3RleHRcIiwgXzUgYXMgXCJjb250YWluZXJcIiB9XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbnZhciBfMSA9IFwiS1cwbm85c1VKVWZCS1lMMWgzeHVcIjtcbnZhciBfMiA9IFwiYmZiQlJBQVc1ZEpyeTZUektsUUFcIjtcbnZhciBfMyA9IFwiX1VBekJuZHFyYzNOS29YWFVIUXhcIjtcbmV4cG9ydCB7IF8xIGFzIFwiY29udGFpbmVyXCIsIF8yIGFzIFwiZGF0ZVwiLCBfMyBhcyBcImRheVwiIH1cbiIsImltcG9ydCAqIGFzIHMgZnJvbSAnLi9UYWJsZUhlYWRFbGVtZW50LmNzcydcbmltcG9ydCB7V2Vla2RheXN9IGZyb20gXCJAc3JjL3NoYXJlZC9tb2RlbC90eXBlc1wiO1xuXG5leHBvcnQgdHlwZSBUYWJsZUhlYWRFbGVtZW50UHJvcHMgPSB7XG4gICAgY3VycmVudDogYm9vbGVhbixcbiAgICBkYXk6IFdlZWtkYXlzLFxuICAgIGRhdGU6IG51bWJlclxufVxuXG5leHBvcnQgY29uc3QgVGFibGVIZWFkRWxlbWVudCA9IChwOiBUYWJsZUhlYWRFbGVtZW50UHJvcHMpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e3MuY29udGFpbmVyfVxuICAgICAgICAgICAgZGF0YS1jdXJyZW50PXtwLmN1cnJlbnR9XG4gICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLmRheX0+e3AuZGF5fTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3MuZGF0ZX0+e3AuZGF0ZX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07IiwiZXhwb3J0IGNvbnN0IGNvbHVtbldpZHRoID0gOTZcbmV4cG9ydCBjb25zdCBvdXRlckNvbHVtbnNDb3VudCA9IDYiLCJleHBvcnQgY29uc3QgZ2V0RGVmYXVsdERhdGUgPSAobGVmdE9mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBub3cuc2V0RGF0ZShub3cuZ2V0RGF0ZSgpIC0gbGVmdE9mZnNldCk7XG4gICAgcmV0dXJuIG5vdztcbn0iLCJpbXBvcnQge1dlZWtkYXlzfSBmcm9tIFwiQHNyYy9zaGFyZWQvbW9kZWwvdHlwZXNcIjtcblxuZXhwb3J0IGNvbnN0IGdldFdlZWtkYXkgPSAoZGF0ZTogRGF0ZSk6IFdlZWtkYXlzID0+XG4gICAgZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoXG4gICAgICAgICdydS1SVScsXG4gICAgICAgIHt3ZWVrZGF5OiAnc2hvcnQnfVxuICAgICkudG9VcHBlckNhc2UoKSBhcyBXZWVrZGF5cyIsImltcG9ydCB7Q2hhcnREYXRlfSBmcm9tIFwiQHNyYy9wYWdlcy9nYW50dC9tb2RlbC90eXBlc1wiO1xuaW1wb3J0IHtnZXRXZWVrZGF5fSBmcm9tIFwiQHNyYy9zaGFyZWQvbGliL2dldC13ZWVrZGF5XCI7XG5cbmV4cG9ydCBjb25zdCBnZXRDaGFydERhdGUgPSAobm93RGF0ZVN0cmluZzogc3RyaW5nLCBkYXRlOiBEYXRlKTogQ2hhcnREYXRlID0+ICh7XG4gICAgZGF0ZTogZGF0ZS5nZXREYXRlKCksXG4gICAgZGF0ZVN0cmluZzogZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoKSxcbiAgICB3ZWVrZGF5OiBnZXRXZWVrZGF5KGRhdGUpLFxuICAgIGN1cnJlbnREYXRlOiBub3dEYXRlU3RyaW5nID09PSBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpLFxufSkiLCJleHBvcnQgY29uc3Qgc2V0Q2hhcnRFbGVtZW50c09mZnNldCA9IChoZWFkOiBIVE1MRGl2RWxlbWVudCwgY2hhcnQ6IEhUTUxEaXZFbGVtZW50LCBvZmZzZXRYOiBudW1iZXIpID0+IHtcbiAgICBoZWFkLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtvZmZzZXRYfXB4LCAwcHgpYFxuICAgIGNoYXJ0LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtvZmZzZXRYfXB4LCAwcHgpYFxufSIsInR5cGUgU3BsaXREYXRlUmVzdWx0ID0gW2RheTogbnVtYmVyLCBtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXJdXG5cbmV4cG9ydCBjb25zdCBzcGxpdERhdGUgPSAoZGF0ZVN0cmluZzogc3RyaW5nKTogRGF0ZSA9PiB7XG4gICAgY29uc3Qgc3BsaXRSZXN1bHQgPSBkYXRlU3RyaW5nLnNwbGl0KCcuJykubWFwKE51bWJlcikgYXMgU3BsaXREYXRlUmVzdWx0XG4gICAgcmV0dXJuIG5ldyBEYXRlKHNwbGl0UmVzdWx0WzJdLCBzcGxpdFJlc3VsdFsxXSAtIDEsIHNwbGl0UmVzdWx0WzBdKVxufSIsImltcG9ydCB7Q2hhcnREYXRlfSBmcm9tIFwiQHNyYy9wYWdlcy9nYW50dC9tb2RlbC90eXBlc1wiO1xuaW1wb3J0IHtzcGxpdERhdGV9IGZyb20gXCJAc3JjL3dpZGdldHMvY3JlYXRlLXRhc2stbW9kYWwvbGliL3NwbGl0LWRhdGVcIjtcbmltcG9ydCB7Z2V0Q2hhcnREYXRlfSBmcm9tIFwiQHNyYy9wYWdlcy9nYW50dC9saWIvZ2V0LWNoYXJ0LWRhdGVcIjtcblxuZXhwb3J0IGNvbnN0IGdldENoYXJ0UmlnaHREYXRlcyA9IChkYXRlczogQXJyYXk8Q2hhcnREYXRlPiwgY291bnQgOm51bWJlciwgbm93U3RyaW5nOiBzdHJpbmcpOiBBcnJheTxDaGFydERhdGU+ID0+IHtcbiAgICBjb25zdCBsYXN0RGF0ZSA9IHNwbGl0RGF0ZShkYXRlc1tkYXRlcy5sZW5ndGggLSAxXS5kYXRlU3RyaW5nKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsYXN0RGF0ZS5zZXREYXRlKGxhc3REYXRlLmdldERhdGUoKSArIDEpXG4gICAgICAgIGRhdGVzLnB1c2goZ2V0Q2hhcnREYXRlKG5vd1N0cmluZywgbGFzdERhdGUpKVxuICAgICAgICBkYXRlcy5zaGlmdCgpXG4gICAgfVxuICAgIHJldHVybiBkYXRlcztcbn0iLCJpbXBvcnQge3NwbGl0RGF0ZX0gZnJvbSBcIkBzcmMvd2lkZ2V0cy9jcmVhdGUtdGFzay1tb2RhbC9saWIvc3BsaXQtZGF0ZVwiO1xuaW1wb3J0IHtnZXRDaGFydERhdGV9IGZyb20gXCJAc3JjL3BhZ2VzL2dhbnR0L2xpYi9nZXQtY2hhcnQtZGF0ZVwiO1xuaW1wb3J0IHtDaGFydERhdGV9IGZyb20gXCJAc3JjL3BhZ2VzL2dhbnR0L21vZGVsL3R5cGVzXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRDaGFydExlZnREYXRlcyA9IChkYXRlczogQXJyYXk8Q2hhcnREYXRlPiwgY291bnQgOm51bWJlciwgbm93U3RyaW5nOiBzdHJpbmcpOiBBcnJheTxDaGFydERhdGU+ID0+IHtcbiAgICBjb25zdCBmaXJzdERhdGUgPSBzcGxpdERhdGUoZGF0ZXNbMF0uZGF0ZVN0cmluZylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgZmlyc3REYXRlLnNldERhdGUoZmlyc3REYXRlLmdldERhdGUoKSAtMSlcbiAgICAgICAgZGF0ZXMudW5zaGlmdChnZXRDaGFydERhdGUobm93U3RyaW5nLCBmaXJzdERhdGUpKVxuICAgICAgICBkYXRlcy5wb3AoKVxuICAgIH1cbiAgICByZXR1cm4gZGF0ZXNcbn0iLCJleHBvcnQgY29uc3QgdXNlVGhyb3R0bGUgPSAoY2I6ICguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiBhbnksIG1zOiBudW1iZXIpID0+IHtcbiAgICBsZXQgdGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgbnVsbCA9IG51bGxcblxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgY2I+KSA9PiB7XG4gICAgICAgIGlmICh0aW1lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY2IoLi4uYXJncylcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aW1lciA9IG51bGwsIG1zKVxuICAgICAgICB9XG4gICAgfVxufSIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxudmFyIF8xID0gXCJ2QmZvWktOeXR3d3pWSWMyOVF5MVwiO1xuZXhwb3J0IHsgXzEgYXMgXCJjb2x1bW5cIiB9XG4iLCJpbXBvcnQgKiBhcyBzIGZyb20gJy4vQ2hhcnRDb2x1bW4uY3NzJ1xuXG50eXBlIFByb3BzID0ge1xuICAgIGRhdGVTdHJpbmc6IHN0cmluZ1xufVxuXG5leHBvcnQgY29uc3QgQ2hhcnRDb2x1bW4gPSAocDogUHJvcHMpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cy5jb2x1bW59IGRhdGEtZGF0ZS1zdHJpbmc9e3AuZGF0ZVN0cmluZ30gZHJhZ2dhYmxlPVwiZmFsc2VcIiAvPlxuICAgICk7XG59OyIsImV4cG9ydCB7Q2hhcnRDb2x1bW59IGZyb20gJy4vQ2hhcnRDb2x1bW4nIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG52YXIgXzEgPSBcImRRTl9sWDJYaXM5UzEzRkM5MmVUXCI7XG5leHBvcnQgeyBfMSBhcyBcImNvbnRhaW5lclwiIH1cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxudmFyIF8xID0gXCJEbTBMXzNzdDBpRTc0RzBEZWtmUVwiO1xudmFyIF8yID0gXCJ1N2hsMzl3SmJkTFM5dFEzM0RNQVwiO1xudmFyIF8zID0gXCJBM3hETllEVnJUbVc5MzZpS3B3OVwiO1xudmFyIF80ID0gXCJhRGs2VHhPQUd5a0RTVm1VT3g5clwiO1xudmFyIF81ID0gXCJPdDRMWGk5eVNXbWRvVTdjVTFiTFwiO1xuZXhwb3J0IHsgXzEgYXMgXCJiYWNrXCIsIF8yIGFzIFwiY29udGFpbmVyXCIsIF8zIGFzIFwiY29udGVudFwiLCBfNCBhcyBcInBlcmNlbnRfYmFja1wiLCBfNSBhcyBcInRleHRcIiB9XG4iLCJpbXBvcnQge2dldENvbm5lY3Rpb259IGZyb20gXCJAc3JjL3NoYXJlZC9hcGkvaW5kZXhlZC1kYi9pbmRleGVkREJcIjtcbmltcG9ydCB7VEFTS19UQUJMRV9OQU1FfSBmcm9tIFwiQHNyYy9lbnRpdGllcy90YXNrL2NvbmZpZ1wiO1xuaW1wb3J0IHtUYXNrfSBmcm9tIFwiQHNyYy9lbnRpdGllcy90YXNrL21vZGVsXCI7XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVUYXNrID0gYXN5bmMgKGRhdGE6IFRhc2spOiBQcm9taXNlPElEQlZhbGlkS2V5IHwgRE9NRXhjZXB0aW9uPiA9PiB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IGdldENvbm5lY3Rpb24oVEFTS19UQUJMRV9OQU1FKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNvbm5lY3Rpb24udHJhbnNhY3Rpb24oVEFTS19UQUJMRV9OQU1FLCAncmVhZHdyaXRlJylcbiAgICBjb25zdCByZXF1ZXN0ID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoVEFTS19UQUJMRV9OQU1FKS5wdXQoZGF0YSlcbiAgICBjb25zdCByZXNwb25zZTogUHJvbWlzZTxJREJWYWxpZEtleSB8IERPTUV4Y2VwdGlvbj4gPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXMocmVxdWVzdC5yZXN1bHQpXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlaihyZXF1ZXN0LmVycm9yKVxuICAgIH0pXG4gICAgY29ubmVjdGlvbi5jbG9zZSgpXG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlXG59IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG52YXIgXzEgPSBcIlBxYXJ2UFltdXNQZGJjSEVfQllXXCI7XG52YXIgXzIgPSBcIlFpa0s5X0JrMm81YUlIQXQzSTJCXCI7XG52YXIgXzMgPSBcInhyNVZpMjVmRWcxd2hrN29wXzFyXCI7XG52YXIgXzQgPSBcInFaTzJEWDFMcHFpckxDckltVjZpXCI7XG52YXIgXzUgPSBcInhKMV9ETzA0ZDM2OTJmRWhTbFFTXCI7XG52YXIgXzYgPSBcIlg5T3pWWU9fdlRublhHdnF1YUtxXCI7XG52YXIgXzcgPSBcIktvZkhEVlBhWUZOVHdIbFpmRV9uXCI7XG52YXIgXzggPSBcInEwZ2lIRUhLQWVKaVp0bEJjX1lfXCI7XG52YXIgXzkgPSBcImxhbU84QnAzSUllTzk1bGtxalU2XCI7XG52YXIgX2EgPSBcImlKNThqa1Q0ejRLTVd6andoblJWXCI7XG52YXIgX2IgPSBcImtfRGZyN1h0eU81N3lzUFRSVlJSXCI7XG5leHBvcnQgeyBfMSBhcyBcImJvdHRvbV9ibG9ja1wiLCBfMiBhcyBcImNpcmNsZVwiLCBfMyBhcyBcImNvbG9yX3BpY2tlclwiLCBfNCBhcyBcImNvbnRhaW5lclwiLCBfNSBhcyBcImZvbnRfc2l6ZVwiLCBfNiBhcyBcIm5leHRfaWNvblwiLCBfNyBhcyBcInByb2dyZXNzXCIsIF84IGFzIFwicHJvZ3Jlc3NfcGlja2VyXCIsIF85IGFzIFwic3VibWVudVwiLCBfYSBhcyBcInN1Ym1lbnVfdHJpZ2dlclwiLCBfYiBhcyBcInRvcF9ibG9ja1wiIH1cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxudmFyIF8xID0gXCJrSW1hMnVlREtCZTd0NWYzeUk3Z1wiO1xudmFyIF8yID0gXCJnaW5Wem1VSWxmc1lYaFludkR4V1wiO1xudmFyIF8zID0gXCJweWRnS2d0SnJxTlg1Zm5IcFo5NFwiO1xuZXhwb3J0IHsgXzEgYXMgXCJjaGVja2JveF9jb250YWluZXJcIiwgXzIgYXMgXCJsYWJlbFwiLCBfMyBhcyBcIm1hcmtcIiB9XG4iLCJpbXBvcnQgKiBhcyBzIGZyb20gJy4vQ2hlY2tib3guY3NzJ1xuaW1wb3J0IE1hcmtJbWFnZSBmcm9tICdAc3JjL3NoYXJlZC91aS9hc3NldHMvaW1hZ2VzL21hcmsuc3ZnJ1xuaW1wb3J0IHt1c2VJZH0gZnJvbSBcInJlYWN0XCI7XG5cbnR5cGUgUHJvcHMgPSB7XG4gICAgY2hlY2tlZDogYm9vbGVhbixcbiAgICBzZXRDaGVja2VkOiAoY2hlY2tlZDogYm9vbGVhbikgPT4gdm9pZCxcbn07XG5leHBvcnQgY29uc3QgQ2hlY2tib3ggPSAocDogUHJvcHMpID0+IHtcbiAgICBjb25zdCBpZCA9IHVzZUlkKClcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxsYWJlbCBjbGFzc05hbWU9e3MubGFiZWx9IGlkPXtpZH0+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICAgICAgICBjaGVja2VkPXtwLmNoZWNrZWR9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBwLnNldENoZWNrZWQoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfVxuICAgICAgICAgICAgLz5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3MuY2hlY2tib3hfY29udGFpbmVyfT5cbiAgICAgICAgICAgICAgICA8aW1nIGNsYXNzTmFtZT17cy5tYXJrfSBzcmM9e01hcmtJbWFnZX0gYWx0PVwiIFwiIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICApO1xufTsiLCJleHBvcnQge0NoZWNrYm94fSBmcm9tICcuL0NoZWNrYm94JyIsImltcG9ydCAqIGFzIHMgZnJvbSAnLi9Db250ZXh0TWVudS5jc3MnXG5pbXBvcnQge0NoZWNrYm94fSBmcm9tIFwiQHNyYy9zaGFyZWQvdWkvY2hlY2tib3hcIjtcbmltcG9ydCB7VHlwb2dyYXBoeX0gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL3R5cG9ncmFwaHlcIjtcbmltcG9ydCBFZGl0SWNvbiBmcm9tICdAc3JjL3NoYXJlZC91aS9hc3NldHMvaW1hZ2VzL2VkaXQuc3ZnJ1xuaW1wb3J0IENvbG9ySWNvbiBmcm9tICdAc3JjL3NoYXJlZC91aS9hc3NldHMvaW1hZ2VzL2NvbG9yLnN2ZydcbmltcG9ydCBQcm9ncmVzc0ljb24gZnJvbSAnQHNyYy9zaGFyZWQvdWkvYXNzZXRzL2ltYWdlcy9wcm9ncmVzcy5zdmcnXG5pbXBvcnQgRGVsZXRlSWNvbiBmcm9tICdAc3JjL3NoYXJlZC91aS9hc3NldHMvaW1hZ2VzL2RlbGV0ZS5zdmcnXG5pbXBvcnQgTmV4dEljb24gZnJvbSAnQHNyYy9zaGFyZWQvdWkvYXNzZXRzL2ltYWdlcy9uZXh0LnN2ZydcbmltcG9ydCB7Y2xhc3Nlc30gZnJvbSBcIkBzcmMvc2hhcmVkL2xpYi9jbGFzc2VzXCI7XG5pbXBvcnQge2NvbG9yc30gZnJvbSAnQHNyYy9zaGFyZWQvY29uZmlnJ1xuaW1wb3J0IHtjcmVhdGVQb3J0YWx9IGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7UmVhY3ROb2RlLCB1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtvYnNlcnZlcn0gZnJvbSBcIm1vYngtcmVhY3RcIjtcbmltcG9ydCB7dXNlUm9vdENvbnRleHR9IGZyb20gXCJAc3JjL2FwcC9wcm92aWRlcnMvcm9vdFByb3ZpZGVyXCI7XG5pbXBvcnQge1Rhc2t9IGZyb20gXCJAc3JjL2VudGl0aWVzL3Rhc2svbW9kZWxcIjtcbmltcG9ydCB7dXBkYXRlVGFza30gZnJvbSBcIkBzcmMvZW50aXRpZXMvdGFzay9hcGkvdXBkYXRlVGFza1wiO1xuXG50eXBlIFByb3BzID0ge1xuICAgIHg6IG51bWJlcixcbiAgICB5OiBudW1iZXIsXG4gICAgb3BlbjogYm9vbGVhbixcbiAgICBjbG9zZTogKCkgPT4gdm9pZCxcbiAgICBpZDogSURCVmFsaWRLZXlcbn1cblxuZXhwb3J0IGNvbnN0IENvbnRleHRNZW51ID0gb2JzZXJ2ZXIoKHA6IFByb3BzKSA9PiB7XG4gICAgY29uc3Qge3Rhc2t9ID0gdXNlUm9vdENvbnRleHQoKVxuICAgIGNvbnN0IGN1cnJlbnRUYXNrID0gdGFzay50YXNrc1twLmlkLnRvU3RyaW5nKCldID8/IHt9XG4gICAgY29uc3QgcHJvZ3Jlc3NCdXR0b25zOiBSZWFjdE5vZGVbXSA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDEwOyBpIDw9IDEwMDsgaSArPSAxMCkge1xuICAgICAgICBwcm9ncmVzc0J1dHRvbnMucHVzaChcbiAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHRcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB1cGRhdGVUYXNrUHJvcCgncHJvZ3Jlc3MnLCBpKX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3MucHJvZ3Jlc3N9XG4gICAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgPntpfSU8L1R5cG9ncmFwaHkuVGV4dD5cbiAgICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZVRhc2tQcm9wID0gYXN5bmMgKGtleToga2V5b2YgVGFzaywgdmFsdWU6IFRhc2tba2V5b2YgVGFza10pID0+IHtcbiAgICAgICAgYXdhaXQgdXBkYXRlVGFzayh7IC4uLmN1cnJlbnRUYXNrLCBba2V5XTogdmFsdWUgfSlcbiAgICAgICAgYXdhaXQgdGFzay5mZXRjaCgpXG4gICAgfVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2xvc2UgPSAoKSA9PiBwLmNsb3NlKClcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbG9zZSlcbiAgICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xvc2UpXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHAub3BlbiAmJiBjcmVhdGVQb3J0YWwoXG4gICAgICAgIChcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBwLnksXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHAueFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IGUuc3RvcFByb3BhZ2F0aW9uKCl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3MuY29udGFpbmVyfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzLnRvcF9ibG9ja31cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17Y3VycmVudFRhc2suY29tcGxldGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENoZWNrZWQ9e2FzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlVGFza1Byb3AoJ2NvbXBsZXRlZCcsICFjdXJyZW50VGFzay5jb21wbGV0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRhc2suZmV0Y2goKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dCBjbGFzc05hbWU9e3MuZm9udF9zaXplfT7QktGL0L/QvtC70L3QtdC90L48L1R5cG9ncmFwaHkuVGV4dD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3MuYm90dG9tX2Jsb2NrfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtFZGl0SWNvbn0gYWx0PVwiXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHkuVGV4dCBjbGFzc05hbWU9e3MuZm9udF9zaXplfT7QoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjDwvVHlwb2dyYXBoeS5UZXh0PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NlcyhzLmJvdHRvbV9ibG9jaywgcy5zdWJtZW51X3RyaWdnZXIpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtDb2xvckljb259IGFsdD1cIlwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQgY2xhc3NOYW1lPXtzLmZvbnRfc2l6ZX0+0KbQstC10YI8L1R5cG9ncmFwaHkuVGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPXtzLm5leHRfaWNvbn0gc3JjPXtOZXh0SWNvbn0gYWx0PVwiXCIvPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cy5zdWJtZW51fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cy5jb2xvcl9waWNrZXJ9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LnZhbHVlcyhjb2xvcnMpLm1hcChpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB1cGRhdGVUYXNrUHJvcCgnY29sb3InLCBpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3MuY2lyY2xlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7YmFja2dyb3VuZENvbG9yOiBpfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NlcyhzLmJvdHRvbV9ibG9jaywgcy5zdWJtZW51X3RyaWdnZXIpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtQcm9ncmVzc0ljb259IGFsdD1cIlwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQgY2xhc3NOYW1lPXtzLmZvbnRfc2l6ZX0+0J/RgNC+0LPRgNC10YHRgTwvVHlwb2dyYXBoeS5UZXh0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzc05hbWU9e3MubmV4dF9pY29ufSBzcmM9e05leHRJY29ufSBhbHQ9XCJcIi8+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLnN1Ym1lbnV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLnByb2dyZXNzX3BpY2tlcn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtwcm9ncmVzc0J1dHRvbnN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzLmJvdHRvbV9ibG9ja31cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2FzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0YXNrLmRlbGV0ZSgrcC5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0YXNrLmZldGNoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtEZWxldGVJY29ufSBhbHQ9XCJcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeS5UZXh0IGNsYXNzTmFtZT17cy5mb250X3NpemV9PtCj0LTQsNC70LjRgtGMPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICksXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250ZXh0LW1lbnUtcG9ydGFsJykhXG4gICAgKVxufSkiLCJleHBvcnQge0NvbnRleHRNZW51fSBmcm9tICcuL0NvbnRleHRNZW51JyIsImltcG9ydCAqIGFzIHMgZnJvbSAnLi9UYWJsZVRhc2suY3NzJ1xuaW1wb3J0IHtUeXBvZ3JhcGh5fSBmcm9tIFwiQHNyYy9zaGFyZWQvdWkvdHlwb2dyYXBoeVwiO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnQHNyYy9zaGFyZWQvdWkvYXNzZXRzL2ltYWdlcy90YWJsZS10YXNrLWJ1dHRvbi5zdmcnXG5pbXBvcnQge3VzZVJlZiwgdXNlU3RhdGV9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtvYnNlcnZlcn0gZnJvbSBcIm1vYngtcmVhY3RcIjtcbmltcG9ydCB7dXNlUm9vdENvbnRleHR9IGZyb20gXCJAc3JjL2FwcC9wcm92aWRlcnMvcm9vdFByb3ZpZGVyXCI7XG5pbXBvcnQge3VwZGF0ZVRhc2t9IGZyb20gXCJAc3JjL2VudGl0aWVzL3Rhc2svYXBpL3VwZGF0ZVRhc2tcIjtcbmltcG9ydCB7dXNlVGhyb3R0bGV9IGZyb20gXCJAc3JjL3NoYXJlZC9saWIvdXNlLXRocm90dGxlXCI7XG5pbXBvcnQge0NvbnRleHRNZW51fSBmcm9tIFwiQHNyYy93aWRnZXRzL2NvbnRleHQtbWVudS91aVwiO1xuXG50eXBlIFByb3BzID0ge1xuICAgIGlkOiBJREJWYWxpZEtleVxufVxuXG5leHBvcnQgY29uc3QgVGFibGVUYXNrID0gb2JzZXJ2ZXIoKHA6IFByb3BzKSA9PiB7XG4gICAgY29uc3QgW2NvbnRleHRNZW51T3Blbiwgc2V0Q29udGV4dE1lbnVPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IGNvbnRleHRNZW51UG9zaXRpb24gPSB1c2VSZWYoeyB4OiAwLCB5OiAwIH0pXG5cbiAgICBjb25zdCB7dGFzaywgbm90aWZ5fSA9IHVzZVJvb3RDb250ZXh0KClcbiAgICBjb25zdCBjdXJyZW50VGFzayA9IHRhc2sudGFza3NbcC5pZC50b1N0cmluZygpXSA/PyB7fVxuXG4gICAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBwYXJlbnRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpXG5cbiAgICBsZXQgc3RhcnRNb3ZlWCA9IDBcbiAgICBsZXQgaW5pdFdpZHRoID0gMFxuICAgIGxldCBpbml0TGVmdCA9IDBcblxuICAgIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW0gPSBtdXRhdGlvbnNbMF0udGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50XG4gICAgICAgIGluaXRMZWZ0ID0gK3RhcmdldEVsZW0uc3R5bGUubGVmdC5yZXBsYWNlQWxsKCdweCcsICcnKVxuICAgIH0pXG5cbiAgICBjb25zdCB1cGRhdGVEYXRlID0gYXN5bmMgKHg6IG51bWJlciwgeTogbnVtYmVyLCBrZXk6ICdzdGFydCcgfCAnZW5kJykgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtID0gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQoeCwgeSkuZmluZChpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGkuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtZGF0ZS1zdHJpbmcnKSlcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAodGFyZ2V0RWxlbSAmJiBjdXJyZW50VGFzaykge1xuICAgICAgICAgICAgLy/QvtCx0L3QvtCy0LjRgtGMXG4gICAgICAgICAgICBjb25zdCB0YXJnZXREYXRlID0gdGFyZ2V0RWxlbS5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1kYXRlLXN0cmluZycpIVxuICAgICAgICAgICAgY29uc3QgbmV3RW5kRGF0ZSA9IHRhcmdldERhdGUudmFsdWVcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVRhc2soey4uLmN1cnJlbnRUYXNrLCBba2V5XTogbmV3RW5kRGF0ZX0pXG4gICAgICAgICAgICBhd2FpdCB0YXNrLmZldGNoKClcbiAgICAgICAgICAgIG5vdGlmeS5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAn0KHRgNC+0LrQuCDQt9Cw0LTQsNGH0Lgg0LjQt9C80LXQvdC10L3RiydcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZVVwTGVmdCA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIHN0YXJ0TW92ZVggPSAwXG4gICAgICAgIGluaXRXaWR0aCA9IDBcbiAgICAgICAgaW5pdExlZnQgPSAwXG5cbiAgICAgICAgdXBkYXRlRGF0ZShlLmNsaWVudFgsIGUuY2xpZW50WSwgJ3N0YXJ0JylcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXBMZWZ0KVxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3ZlTGVmdClcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZVVwUmlnaHQgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICBzdGFydE1vdmVYID0gMFxuICAgICAgICBpbml0V2lkdGggPSAwXG4gICAgICAgIGluaXRMZWZ0ID0gMFxuICAgICAgICB1cGRhdGVEYXRlKGUuY2xpZW50WCwgZS5jbGllbnRZLCAnZW5kJylcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXBSaWdodClcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW92ZVJpZ2h0KVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZU1vdmVMZWZ0ID0gdXNlVGhyb3R0bGUoKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHBhcmVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gZS5jbGllbnRYIC0gc3RhcnRNb3ZlWFxuICAgICAgICAgICAgcGFyZW50UmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGluaXRMZWZ0ICsgZGlmZiArICdweCdcbiAgICAgICAgICAgIHBhcmVudFJlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gaW5pdFdpZHRoIC0gZGlmZiArICdweCdcbiAgICAgICAgfVxuICAgIH0sIDEwMClcblxuICAgIGNvbnN0IGhhbmRsZU1vdmVSaWdodCA9IHVzZVRocm90dGxlKChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChwYXJlbnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcGFyZW50UmVmLmN1cnJlbnQuc3R5bGUud2lkdGggPSBpbml0V2lkdGggKyBlLmNsaWVudFggLSBzdGFydE1vdmVYICsgJ3B4J1xuICAgICAgICB9XG4gICAgfSwgMTAwKVxuXG4gICAgY29uc3QgaGFuZGxlTW91c2VEb3duTGVmdCA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgc3RhcnRNb3ZlWCA9IGUuY2xpZW50WFxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXBMZWZ0KVxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW92ZUxlZnQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZURvd25SaWdodCA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICBzdGFydE1vdmVYID0gZS5jbGllbnRYXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcFJpZ2h0KVxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW92ZVJpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2FsbGJhY2tSZWYgPSAobm9kZTogSFRNTERpdkVsZW1lbnQpID0+IHtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGluaXRXaWR0aCA9IG5vZGUuY2xpZW50V2lkdGhcbiAgICAgICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50ID0gbm9kZVxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlIGFzIEhUTUxEaXZFbGVtZW50XG4gICAgICAgICAgICBpbml0TGVmdCA9IHBhcmVudC5vZmZzZXRMZWZ0XG4gICAgICAgICAgICBwYXJlbnRSZWYuY3VycmVudCA9IHBhcmVudFxuICAgICAgICAgICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHBhcmVudCwge2F0dHJpYnV0ZXM6IHRydWV9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXBSaWdodClcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdmVSaWdodClcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwTGVmdClcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdmVMZWZ0KVxuICAgICAgICAgICAgbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17cy5jb250YWluZXJ9XG4gICAgICAgICAgICByZWY9e2NhbGxiYWNrUmVmfVxuICAgICAgICAgICAgb25Db250ZXh0TWVudT17KGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICBjb250ZXh0TWVudVBvc2l0aW9uLmN1cnJlbnQueCA9IGUuY2xpZW50WFxuICAgICAgICAgICAgICAgIGNvbnRleHRNZW51UG9zaXRpb24uY3VycmVudC55ID0gZS5jbGllbnRZXG4gICAgICAgICAgICAgICAgc2V0Q29udGV4dE1lbnVPcGVuKHRydWUpXG4gICAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzLmJhY2t9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3tiYWNrZ3JvdW5kQ29sb3I6IGBjb2xvci1taXgoaW4gb2tsYWIsICR7Y3VycmVudFRhc2suY29sb3J9LCB0cmFuc3BhcmVudCA2MCUpYH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cy5wZXJjZW50X2JhY2t9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGAke2N1cnJlbnRUYXNrLnByb2dyZXNzfSVgLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGN1cnJlbnRUYXNrLmNvbG9yXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cy5jb250ZW50fT5cbiAgICAgICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgICAgICAgIHNyYz17QnV0dG9uSWNvbn1cbiAgICAgICAgICAgICAgICAgICAgYWx0PVwiXCJcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd249e2hhbmRsZU1vdXNlRG93bkxlZnR9XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQgY2xhc3NOYW1lPXtzLnRleHR9PntjdXJyZW50VGFzay5uYW1lfTwvVHlwb2dyYXBoeS5UZXh0PlxuICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQgY2xhc3NOYW1lPXtzLnRleHR9PntjdXJyZW50VGFzay5wcm9ncmVzc30lPC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgICBzcmM9e0J1dHRvbkljb259XG4gICAgICAgICAgICAgICAgICAgIGFsdD1cIlwiXG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXtoYW5kbGVNb3VzZURvd25SaWdodH1cbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPENvbnRleHRNZW51XG4gICAgICAgICAgICAgICAgb3Blbj17Y29udGV4dE1lbnVPcGVufVxuICAgICAgICAgICAgICAgIHg9e2NvbnRleHRNZW51UG9zaXRpb24uY3VycmVudC54fVxuICAgICAgICAgICAgICAgIHk9e2NvbnRleHRNZW51UG9zaXRpb24uY3VycmVudC55fVxuICAgICAgICAgICAgICAgIGNsb3NlPXsoKSA9PiBzZXRDb250ZXh0TWVudU9wZW4oZmFsc2UpfVxuICAgICAgICAgICAgICAgIGlkPXtwLmlkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn0pIiwiZXhwb3J0IHtUYWJsZVRhc2t9IGZyb20gJy4vVGFibGVUYXNrJyIsImltcG9ydCB7VGFza30gZnJvbSBcIkBzcmMvZW50aXRpZXMvdGFzay9tb2RlbFwiO1xuaW1wb3J0IHtDaGFydERhdGUsIFRhc2tUb1JlbmRlcn0gZnJvbSBcIkBzcmMvcGFnZXMvZ2FudHQvbW9kZWwvdHlwZXNcIjtcbmltcG9ydCB7Y29sdW1uV2lkdGh9IGZyb20gXCJAc3JjL3BhZ2VzL2dhbnR0L2NvbmZpZ1wiO1xuaW1wb3J0IHtzcGxpdERhdGV9IGZyb20gXCJAc3JjL3dpZGdldHMvY3JlYXRlLXRhc2stbW9kYWwvbGliL3NwbGl0LWRhdGVcIjtcblxuZXhwb3J0IGNvbnN0IGdldFRhc2tzVG9SZW5kZXIgPSAodGFza3M6IFRhc2tbXSwgZGF0ZXM6IENoYXJ0RGF0ZVtdKTogQXJyYXk8VGFza1RvUmVuZGVyPiA9PiB7XG4gICAgY29uc3QgdGFza3NUb1JlbmRlcjogQXJyYXk8VGFza1RvUmVuZGVyPiA9IFtdXG5cbiAgICB0YXNrcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtU3RhcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPEhUTUxEaXZFbGVtZW50PihgW2RhdGEtZGF0ZS1zdHJpbmc9XCIke2kuc3RhcnR9XCJdYClcbiAgICAgICAgY29uc3QgZWxlbUVuZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3I8SFRNTERpdkVsZW1lbnQ+KGBbZGF0YS1kYXRlLXN0cmluZz1cIiR7aS5lbmR9XCJdYClcblxuICAgICAgICAvL9C10YHQu9C4INC+0LHQtSDQtNCw0YLRiyDQvtGC0L7QsdGA0LDQttC10L3RiyDQsiDRgtCw0LHQu9C40YbQtVxuICAgICAgICBpZiAoZWxlbVN0YXJ0ICYmIGVsZW1FbmQpIHtcbiAgICAgICAgICAgIC8v0LXRgdC70Lgg0LTQsNGC0LAg0L3QsNGH0LDQu9CwINC4INC60L7QvdGG0LAg0YHQvtCy0L/QsNC00LDRjtGCXG4gICAgICAgICAgICBpZiAoZWxlbVN0YXJ0ID09PSBlbGVtRW5kKSB7XG4gICAgICAgICAgICAgICAgdGFza3NUb1JlbmRlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGkuaWQsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBpLnByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0YXNrTmFtZTogaS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlbGVtU3RhcnQub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhc2tzVG9SZW5kZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGkuaWQsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IGkucHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgdGFza05hbWU6IGkubmFtZSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBlbGVtU3RhcnQub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogZWxlbUVuZC5vZmZzZXRMZWZ0IC0gZWxlbVN0YXJ0Lm9mZnNldExlZnQgKyBjb2x1bW5XaWR0aCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxlZnREYXRlID0gc3BsaXREYXRlKGRhdGVzWzBdLmRhdGVTdHJpbmcpIC8v0LrRgNCw0L3Rj9GPINC70LXQstCw0Y8g0LTQsNGC0LBcbiAgICAgICAgY29uc3QgZGF5TWlsbGlzID0gMTAwMCAqIDYwICAqIDYwICogMjRcbiAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gc3BsaXREYXRlKGkuc3RhcnQpXG4gICAgICAgIGNvbnN0IGVuZERhdGUgPSBzcGxpdERhdGUoaS5lbmQpXG4gICAgICAgIGNvbnN0IHRvdGFsRGlmZiA9IE1hdGguZmxvb3IoKCtlbmREYXRlIC0gK3N0YXJ0RGF0ZSkgLyBkYXlNaWxsaXMpXG4gICAgICAgIGNvbnN0IGxlZnREaWZmID0gTWF0aC5mbG9vcigoK3N0YXJ0RGF0ZSAtICtsZWZ0RGF0ZSkgLyBkYXlNaWxsaXMpXG5cbiAgICAgICAgdGFza3NUb1JlbmRlci5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBpLmlkLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IGkucHJvZ3Jlc3MsXG4gICAgICAgICAgICB0YXNrTmFtZTogaS5uYW1lLFxuICAgICAgICAgICAgbGVmdDogKGxlZnREaWZmKSAqIGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgd2lkdGg6ICh0b3RhbERpZmYgKyAxKSAqIGNvbHVtbldpZHRoLFxuICAgICAgICB9KVxuXG4gICAgfSlcbiAgICByZXR1cm4gdGFza3NUb1JlbmRlclxufSIsImltcG9ydCB7Q2hhcnREYXRlLCBUYXNrVG9SZW5kZXJ9IGZyb20gXCJAc3JjL3BhZ2VzL2dhbnR0L21vZGVsL3R5cGVzXCI7XG5pbXBvcnQge0NoYXJ0Q29sdW1ufSBmcm9tIFwiQHNyYy9wYWdlcy9nYW50dC91aS9jaGFydC1jb2x1bW5cIjtcbmltcG9ydCAqIGFzIHMgZnJvbSAnLi9DaGFydFRhc2tzLmNzcydcbmltcG9ydCB7dXNlUm9vdENvbnRleHR9IGZyb20gXCJAc3JjL2FwcC9wcm92aWRlcnMvcm9vdFByb3ZpZGVyXCI7XG5pbXBvcnQge29ic2VydmVyfSBmcm9tIFwibW9ieC1yZWFjdFwiO1xuaW1wb3J0IHtUYWJsZVRhc2t9IGZyb20gXCJAc3JjL3dpZGdldHMvdGFibGUtdGFzay91aVwiO1xuaW1wb3J0IHtnZXRUYXNrc1RvUmVuZGVyfSBmcm9tIFwiQHNyYy9wYWdlcy9nYW50dC9saWIvZ2V0LXRhc2tzLXRvLXJlbmRlclwiO1xuaW1wb3J0IHt1c2VFZmZlY3QsIHVzZVN0YXRlfSBmcm9tIFwicmVhY3RcIjtcblxudHlwZSBQcm9wcyA9IHtcbiAgICBkYXRlczogQXJyYXk8Q2hhcnREYXRlPlxufVxuZXhwb3J0IGNvbnN0IENoYXJ0VGFza3MgPSBvYnNlcnZlcigocDogUHJvcHMpID0+IHtcbiAgICBjb25zdCB7dGFza30gPSB1c2VSb290Q29udGV4dCgpXG4gICAgY29uc3QgW3Rhc2tzVG9SZW5kZXIsIHNldFRhc2tzVG9SZW5kZXJdID1cbiAgICAgICAgdXNlU3RhdGU8VGFza1RvUmVuZGVyW10+KFtdKVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHAuZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2V0VGFza3NUb1JlbmRlcihnZXRUYXNrc1RvUmVuZGVyKE9iamVjdC52YWx1ZXModGFzay50YXNrcyksIHAuZGF0ZXMpKVxuICAgICAgICB9XG4gICAgfSwgW3AuZGF0ZXMsIHRhc2sudGFza3NdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17cy5jb250YWluZXJ9XG4gICAgICAgID5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwLmRhdGVzLm1hcCgoaSkgPT4gPENoYXJ0Q29sdW1uIGtleT17aS5kYXRlU3RyaW5nfSBkYXRlU3RyaW5nPXtpLmRhdGVTdHJpbmd9Lz4pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFza3NUb1JlbmRlci5tYXAoKGksIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogaS5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogaW5kZXggKiA2NSArIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA1OSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aS5pZC50b1N0cmluZygpfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFibGVUYXNrIGlkPXtpLmlkfS8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICB9XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59KSIsImV4cG9ydCB7Q2hhcnRUYXNrc30gZnJvbSAnLi9DaGFydFRhc2tzJyIsImltcG9ydCAqIGFzIHMgZnJvbSAnLi9DaGFydFZpZXcuY3NzJ1xuaW1wb3J0IHtUeXBvZ3JhcGh5fSBmcm9tIFwiQHNyYy9zaGFyZWQvdWkvdHlwb2dyYXBoeVwiO1xuaW1wb3J0IHtUYWJsZUhlYWRFbGVtZW50fSBmcm9tIFwiQHNyYy9zaGFyZWQvdWkvdGFibGUtaGVhZC1lbGVtZW50L1RhYmxlSGVhZEVsZW1lbnRcIjtcbmltcG9ydCB7dXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7Y29sdW1uV2lkdGgsIG91dGVyQ29sdW1uc0NvdW50fSBmcm9tIFwiQHNyYy9wYWdlcy9nYW50dC9jb25maWdcIjtcbmltcG9ydCB7Z2V0RGVmYXVsdERhdGV9IGZyb20gXCJAc3JjL3BhZ2VzL2dhbnR0L2xpYi9nZXQtZGVmYXVsdC1kYXRlXCI7XG5pbXBvcnQge0NoYXJ0RGF0ZX0gZnJvbSBcIkBzcmMvcGFnZXMvZ2FudHQvbW9kZWwvdHlwZXNcIjtcbmltcG9ydCB7Z2V0Q2hhcnREYXRlfSBmcm9tIFwiQHNyYy9wYWdlcy9nYW50dC9saWIvZ2V0LWNoYXJ0LWRhdGVcIjtcbmltcG9ydCB7c2V0Q2hhcnRFbGVtZW50c09mZnNldH0gZnJvbSBcIkBzcmMvcGFnZXMvZ2FudHQvbGliL3NldC1jaGFydC1lbGVtZW50cy1vZmZzZXRcIjtcbmltcG9ydCB7Z2V0Q2hhcnRSaWdodERhdGVzfSBmcm9tIFwiQHNyYy9wYWdlcy9nYW50dC9saWIvZ2V0LWNoYXJ0LXJpZ2h0LWRhdGVzXCI7XG5pbXBvcnQge2dldENoYXJ0TGVmdERhdGVzfSBmcm9tIFwiQHNyYy9wYWdlcy9nYW50dC9saWIvZ2V0LWNoYXJ0LWxlZnQtZGF0ZXNcIjtcbmltcG9ydCB7dXNlVGhyb3R0bGV9IGZyb20gXCJAc3JjL3NoYXJlZC9saWIvdXNlLXRocm90dGxlXCI7XG5pbXBvcnQge0NoYXJ0VGFza3N9IGZyb20gXCJAc3JjL3BhZ2VzL2dhbnR0L3VpL2NoYXJ0LXRhc2tzXCI7XG5pbXBvcnQge3NwbGl0RGF0ZX0gZnJvbSBcIkBzcmMvd2lkZ2V0cy9jcmVhdGUtdGFzay1tb2RhbC9saWIvc3BsaXQtZGF0ZVwiO1xuXG50eXBlIENoYXJ0RGF0ZXMgPSBBcnJheTxDaGFydERhdGU+XG5jb25zdCBkZWZhdWx0T2Zmc2V0WCA9IGNvbHVtbldpZHRoICogLW91dGVyQ29sdW1uc0NvdW50XG5jb25zdCB0b2RheVRpdGxlID0gbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygncnUtUlUnLCB7bW9udGg6ICdsb25nJywgeWVhcjogJ251bWVyaWMnIH0pXG5cbmV4cG9ydCBjb25zdCBDaGFydFZpZXcgPSAoKSA9PiB7XG4gICAgY29uc3Qgdmlld1JlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gICAgY29uc3QgaGVhZFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gICAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzUmVmID0gdXNlUmVmPHt4OiBudW1iZXIsIHk6IG51bWJlcn0+KG51bGwpO1xuICAgIGNvbnN0IGhlYWRUZXh0UmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcblxuICAgIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgIGlmIChjb29yZGluYXRlc1JlZi5jdXJyZW50ICYmIGhlYWRUZXh0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW0gPVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoY29vcmRpbmF0ZXNSZWYuY3VycmVudC54LCBjb29yZGluYXRlc1JlZi5jdXJyZW50LnkpIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IHRhcmdldEVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWRhdGUtc3RyaW5nJylcblxuICAgICAgICAgICAgaWYgKGRhdGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gc3BsaXREYXRlKGRhdGVTdHJpbmcpXG4gICAgICAgICAgICAgICAgaGVhZFRleHRSZWYuY3VycmVudC5pbm5lclRleHQgPSBkYXRlLnRvTG9jYWxlU3RyaW5nKCdydS1SVScsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6ICdsb25nJyxcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3Qgbm93U3RyaW5nID0gbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKTtcbiAgICBjb25zdCBvZmZzZXRYID0gZGVmYXVsdE9mZnNldFhcbiAgICBsZXQgaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICBsZXQgbW92ZVggPSAwXG5cbiAgICBjb25zdCBbZGF0ZXMsIHNldERhdGVzXSA9IHVzZVN0YXRlPENoYXJ0RGF0ZXM+KFtdKVxuXG4gICAgY29uc3QgaGFuZGxlTW92ZSA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50LCBNb3VzZUV2ZW50PikgPT4ge1xuICAgICAgICBpZiAoaXNNb3VzZURvd24gJiYgaGVhZFJlZi5jdXJyZW50ICYmIGNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld09mZnNldFggPSBvZmZzZXRYIC0gbW92ZVggKyBlLmNsaWVudFhcbiAgICAgICAgICAgIHNldENoYXJ0RWxlbWVudHNPZmZzZXQoaGVhZFJlZi5jdXJyZW50LCBjaGFydFJlZi5jdXJyZW50LCBuZXdPZmZzZXRYKVxuXG4gICAgICAgICAgICAvL9C00LLQuNC20LXQvdC40LUg0LLQv9GA0LDQstC+XG4gICAgICAgICAgICBpZiAobmV3T2Zmc2V0WCA8PSAob3V0ZXJDb2x1bW5zQ291bnQgKiAtMikgKiBjb2x1bW5XaWR0aCkge1xuICAgICAgICAgICAgICAgIHNldERhdGVzKFsuLi5nZXRDaGFydFJpZ2h0RGF0ZXMoZGF0ZXMsIG91dGVyQ29sdW1uc0NvdW50LCBub3dTdHJpbmcpXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy/QtNCy0LjQttC10L3QuNC1INCy0LvQtdCy0L5cbiAgICAgICAgICAgIGlmIChuZXdPZmZzZXRYID49IDApIHtcbiAgICAgICAgICAgICAgICBzZXREYXRlcyhbLi4uZ2V0Q2hhcnRMZWZ0RGF0ZXMoZGF0ZXMsIG91dGVyQ29sdW1uc0NvdW50LCBub3dTdHJpbmcpXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRocm90dGxlZE1vdmUgPSB1c2VUaHJvdHRsZShoYW5kbGVNb3ZlLCAxNSlcblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlRG93biA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50LCBNb3VzZUV2ZW50PikgPT4ge1xuICAgICAgICAvL9C+0YLQu9Cw0LLQu9C40LLQsNC10Lwg0YLQvtC70YzQutC+INC70LXQstGD0Y4g0LrQvdC+0L/QutGDINC80YvRiNC4XG4gICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgaXNNb3VzZURvd24gPSB0cnVlXG4gICAgICAgICAgICBtb3ZlWCA9IGUuY2xpZW50WFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlTW91c2VVcCA9ICgpID0+IHtcbiAgICAgICAgaXNNb3VzZURvd24gPSBmYWxzZVxuICAgICAgICBtb3ZlWCA9IDBcbiAgICB9XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodmlld1JlZi5jdXJyZW50ICYmIGhlYWRSZWYuY3VycmVudCAmJiBjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBoZWFkVGV4dFJlZi5jdXJyZW50ID0gdmlld1JlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3I8SFRNTERpdkVsZW1lbnQ+KCdbZGF0YS1oZWFkLXRleHQ9XCJ0cnVlXCJdJylcblxuICAgICAgICAgICAgY29uc3Qge3dpZHRofSA9IHZpZXdSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgY29uc3QgY29sc0NvdW50ID0gTWF0aC5jZWlsKHdpZHRoIC8gY29sdW1uV2lkdGgpICsgKG91dGVyQ29sdW1uc0NvdW50ICogMilcbiAgICAgICAgICAgIGNvbnN0IG5ld0RhdGVzOiBDaGFydERhdGVzID0gW11cbiAgICAgICAgICAgIGNvbnN0IGxlZnREYXRlID0gZ2V0RGVmYXVsdERhdGUob3V0ZXJDb2x1bW5zQ291bnQpXG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGNvbHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0ZXMucHVzaChnZXRDaGFydERhdGUobm93U3RyaW5nLCBsZWZ0RGF0ZSkpXG4gICAgICAgICAgICAgICAgbGVmdERhdGUuc2V0RGF0ZShsZWZ0RGF0ZS5nZXREYXRlKCkgKyAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoaGVhZFJlZi5jdXJyZW50LCB7YXR0cmlidXRlczogdHJ1ZX0pXG4gICAgICAgICAgICBzZXRDaGFydEVsZW1lbnRzT2Zmc2V0KGhlYWRSZWYuY3VycmVudCwgY2hhcnRSZWYuY3VycmVudCwgb2Zmc2V0WClcbiAgICAgICAgICAgIHNldERhdGVzKG5ld0RhdGVzKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGhlYWRSZWYuY3VycmVudCAmJiBjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRDaGFydEVsZW1lbnRzT2Zmc2V0KGhlYWRSZWYuY3VycmVudCwgY2hhcnRSZWYuY3VycmVudCwgZGVmYXVsdE9mZnNldFgpXG4gICAgICAgIH1cbiAgICB9LCBbZGF0ZXNdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17cy5jb250YWluZXJ9XG4gICAgICAgICAgICByZWY9e3ZpZXdSZWZ9XG4gICAgICAgID5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3MuY2hhcnRfaGVhZGluZ19ibG9ja31cbiAgICAgICAgICAgICAgICByZWY9eyhub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZHMgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXNSZWYuY3VycmVudCA9IHt4OiBib3VuZHMueCwgeTogYm91bmRzLnkgKyAyMDB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHRcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzLmNoYXJ0X2hlYWRpbmdfdGV4dH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS1oZWFkLXRleHQ9XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICA+e3RvZGF5VGl0bGV9PC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3MuY2hhcnRfaGVhZGluZ19kYXRlc31cbiAgICAgICAgICAgICAgICAgICAgcmVmPXtoZWFkUmVmfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZXMubWFwKChpKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRhYmxlSGVhZEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudD17aS5jdXJyZW50RGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5PXtpLndlZWtkYXl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU9e2kuZGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpLmRhdGVTdHJpbmd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzLmNoYXJ0X2JvZHl9XG4gICAgICAgICAgICAgICAgcmVmPXtjaGFydFJlZn1cbiAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17aGFuZGxlTW91c2VEb3dufVxuICAgICAgICAgICAgICAgIG9uTW91c2VVcD17aGFuZGxlTW91c2VVcH1cbiAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZT17dGhyb3R0bGVkTW92ZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8Q2hhcnRUYXNrcyBkYXRlcz17ZGF0ZXN9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07IiwiZXhwb3J0IHtDaGFydFZpZXd9IGZyb20gJy4vQ2hhcnRWaWV3JyIsImltcG9ydCB7U2lkZWJhck5hdmlnYXRpb259IGZyb20gXCJAc3JjL3dpZGdldHMvc2lkZWJhci1uYXZpZ2F0aW9uL3VpXCI7XG5pbXBvcnQge1NpZGViYXJUYXNrc30gZnJvbSBcIkBzcmMvd2lkZ2V0cy9zaWRlYmFyLXRhc2tzL3VpXCI7XG5pbXBvcnQgKiBhcyBzIGZyb20gJy4vR2FudHRQYWdlLmNzcydcbmltcG9ydCB7Q2hhcnRWaWV3fSBmcm9tIFwiQHNyYy9wYWdlcy9nYW50dC91aS9jaGFydC12aWV3XCI7XG5cbmV4cG9ydCBjb25zdCBHYW50dFBhZ2UgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3MuY29udGFpbmVyfT5cbiAgICAgICAgICAgIDxTaWRlYmFyTmF2aWdhdGlvbi8+XG4gICAgICAgICAgICA8U2lkZWJhclRhc2tzLz5cbiAgICAgICAgICAgIDxDaGFydFZpZXcvPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbnZhciBfMSA9IFwiR3l1cHVYdjFXdkNTM2pEUE1CbUpcIjtcbnZhciBfMiA9IFwiZXR6T0JxYnhfb1RBREhyMUdOVkNcIjtcbnZhciBfMyA9IFwibWdxTHpNXzFpTmNQNFBoUWN2SV9cIjtcbnZhciBfNCA9IFwiemZsVnFWUUxaY2ZDWERLaWVKMUZcIjtcbnZhciBfNSA9IFwibEhtckkyOTVNdUpBS3ZuQ3M4NUtcIjtcbnZhciBfNiA9IFwiU0FQWDhaeTVzYXBldzloY2pyanJcIjtcbnZhciBfNyA9IFwia3BIbVJ0SHdtWHVLQTBRVmV1cmhcIjtcbnZhciBfOCA9IFwiaURacUVlVzBYd2FwVzFFNWJjc1hcIjtcbmV4cG9ydCB7IF8xIGFzIFwiYnV0dG9uXCIsIF8yIGFzIFwiY29udGFpbmVyXCIsIF8zIGFzIFwiZGVzY3JpcHRpb25cIiwgXzQgYXMgXCJmYWRlX291dFwiLCBfNSBhcyBcImljb25cIiwgXzYgYXMgXCJzaG93XCIsIF83IGFzIFwidGV4dF9ibG9ja1wiLCBfOCBhcyBcInRpdGxlXCIgfVxuIiwiaW1wb3J0ICogYXMgcyBmcm9tICcuL05vdGlmeS5jc3MnXG5pbXBvcnQgU3VjY2Vzc0ljb24gZnJvbSAnQHNyYy9zaGFyZWQvdWkvYXNzZXRzL2ltYWdlcy9ub3RpZnkvc3VjY2Vzcy5zdmcnXG5pbXBvcnQgV2FybmluZ0ljb24gZnJvbSAnQHNyYy9zaGFyZWQvdWkvYXNzZXRzL2ltYWdlcy9ub3RpZnkvd2FybmluZy5zdmcnXG5pbXBvcnQgRXJyb3JJY29uIGZyb20gJ0BzcmMvc2hhcmVkL3VpL2Fzc2V0cy9pbWFnZXMvbm90aWZ5L2Vycm9yLnN2ZydcbmltcG9ydCBJbmZvSWNvbiBmcm9tICdAc3JjL3NoYXJlZC91aS9hc3NldHMvaW1hZ2VzL25vdGlmeS9pbmZvLnN2ZydcbmltcG9ydCB7VHlwb2dyYXBoeX0gZnJvbSBcIkBzcmMvc2hhcmVkL3VpL3R5cG9ncmFwaHlcIjtcbmltcG9ydCB7Tm90aWZ5IGFzIFByb3BzfSBmcm9tIFwiQHNyYy9lbnRpdGllcy9ub3RpZnkvbW9kZWxcIjtcbmltcG9ydCB7dXNlUm9vdENvbnRleHR9IGZyb20gXCJAc3JjL2FwcC9wcm92aWRlcnMvcm9vdFByb3ZpZGVyXCI7XG5pbXBvcnQge3VzZVN0YXRlfSBmcm9tIFwicmVhY3RcIjtcblxuY29uc3QgaWNvbnM6IFJlY29yZDxQcm9wc1sndHlwZSddLCBzdHJpbmc+ID0ge1xuICAgIHN1Y2Nlc3M6IFN1Y2Nlc3NJY29uLFxuICAgIHdhcm5pbmc6IFdhcm5pbmdJY29uLFxuICAgIGluZm86IEluZm9JY29uLFxuICAgIGVycm9yOiBFcnJvckljb25cbn1cblxuZXhwb3J0IGNvbnN0IE5vdGlmeSA9IChwOiBQcm9wcykgPT4ge1xuICAgIGNvbnN0IHtub3RpZnl9ID0gdXNlUm9vdENvbnRleHQoKVxuICAgIGNvbnN0IFtjbG9zZSwgc2V0Q2xvc2VdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpXG5cbiAgICBjb25zdCBoYW5kbGVDbGljayA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZUNhbGwgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICBzZXRDbG9zZSh0cnVlKVxuXG4gICAgICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSB0aW1lQ2FsbCA+PSAzMDApIHtcbiAgICAgICAgICAgICAgICBub3RpZnkuZGVsZXRlKHAuaWQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17cy5jb250YWluZXJ9XG4gICAgICAgICAgICBkYXRhLWNsb3NlPXtjbG9zZX1cbiAgICAgICAgPlxuICAgICAgICAgICAgPGltZyBjbGFzc05hbWU9e3MuaWNvbn0gc3JjPXtpY29uc1twLnR5cGVdfSBhbHQ9XCJcIi8+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLnRleHRfYmxvY2t9PlxuICAgICAgICAgICAgICAgIDxUeXBvZ3JhcGh5LlRleHQgY2xhc3NOYW1lPXtzLnRpdGxlfT57cC50aXRsZX08L1R5cG9ncmFwaHkuVGV4dD5cbiAgICAgICAgICAgICAgICA8VHlwb2dyYXBoeS5UZXh0IGNsYXNzTmFtZT17cy5kZXNjcmlwdGlvbn0+e3AuZGVzY3JpcHRpb259PC9UeXBvZ3JhcGh5LlRleHQ+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cy5idXR0b259XG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgICAgICAgICB3aWR0aD1cIjE2XCJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PVwiMTZcIlxuICAgICAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDM1Mi44MTcgMzUyLjgxN1wiXG4gICAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBpZD1cInBhdGhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTkuNzYgOS43NkMtMy4yNiAyMi43OCAtMy4yNiA0My44OCA5Ljc2IDU2LjlMMTI5LjI2IDE3Ni40TDkuNzYgMjk1LjkxQy0zLjI2IDMwOC45MyAtMy4yNiAzMzAuMDMgOS43NiAzNDMuMDVDMjIuNzggMzU2LjA3IDQzLjg4IDM1Ni4wNyA1Ni45IDM0My4wNUwxNzYuNCAyMjMuNTRMMjk1LjkxIDM0My4wNUMzMDguOTMgMzU2LjA3IDMzMC4wMyAzNTYuMDcgMzQzLjA1IDM0My4wNUMzNTYuMDcgMzMwLjAzIDM1Ni4wNyAzMDguOTMgMzQzLjA1IDI5NS45MUwyMjMuNTQgMTc2LjRMMzQzLjA1IDU2LjlDMzU2LjA3IDQzLjg4IDM1Ni4wNyAyMi43OCAzNDMuMDUgOS43NkMzMzAuMDMgLTMuMjYgMzA4LjkzIC0zLjI2IDI5NS45MSA5Ljc2TDE3Ni40IDEyOS4yNkw1Ni45IDkuNzZDNDMuODggLTMuMjYgMjIuNzggLTMuMjYgOS43NiA5Ljc2WlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJ2YXIoLS1saWdodC1ncmF5KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5PVwiMS4wMDAwMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsUnVsZT1cIm5vbnplcm9cIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59OyIsImV4cG9ydCB7Tm90aWZ5fSBmcm9tICcuL05vdGlmeSciLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbnZhciBfMSA9IFwiRUZpTFczRVZrZXNSZnprQm1FOFpcIjtcbmV4cG9ydCB7IF8xIGFzIFwiY29udGFpbmVyXCIgfVxuIiwiaW1wb3J0IHtvYnNlcnZlcn0gZnJvbSBcIm1vYngtcmVhY3RcIjtcbmltcG9ydCB7dXNlUm9vdENvbnRleHR9IGZyb20gXCJAc3JjL2FwcC9wcm92aWRlcnMvcm9vdFByb3ZpZGVyXCI7XG5pbXBvcnQge05vdGlmeX0gZnJvbSBcIkBzcmMvZW50aXRpZXMvbm90aWZ5L3VpL25vdGlmeVwiO1xuaW1wb3J0ICogYXMgcyBmcm9tICcuL05vdGlmeUJsb2NrLmNzcydcblxuZXhwb3J0IGNvbnN0IE5vdGlmeUJsb2NrID0gb2JzZXJ2ZXIoKCkgPT4ge1xuICAgIGNvbnN0IHtub3RpZnl9ID0gdXNlUm9vdENvbnRleHQoKVxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzLmNvbnRhaW5lcn0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm90aWZ5Lm5vdGlmaWVzLm1hcChpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPE5vdGlmeVxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ9e2kuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPXtpLnR5cGV9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17aS50aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtpLmRlc2NyaXB0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpLmlkfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICB9XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59KSIsImV4cG9ydCB7Tm90aWZ5QmxvY2t9IGZyb20gJy4vTm90aWZ5QmxvY2snIiwiaW1wb3J0IHtHYW50dFBhZ2V9IGZyb20gXCJAc3JjL3BhZ2VzL2dhbnR0L3VpL0dhbnR0UGFnZVwiO1xuaW1wb3J0IHtTdHJpY3RNb2RlfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7Um9vdFByb3ZpZGVyfSBmcm9tIFwiQHNyYy9hcHAvcHJvdmlkZXJzL3Jvb3RQcm92aWRlclwiO1xuaW1wb3J0IHtOb3RpZnlCbG9ja30gZnJvbSBcIkBzcmMvZW50aXRpZXMvbm90aWZ5L3VpL25vdGlmeS1ibG9ja1wiO1xuXG5leHBvcnQgY29uc3QgQXBwID0gKCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8U3RyaWN0TW9kZT5cbiAgICAgICAgICAgICAgICA8Um9vdFByb3ZpZGVyPlxuICAgICAgICAgICAgICAgICAgICA8R2FudHRQYWdlLz5cbiAgICAgICAgICAgICAgICAgICAgPE5vdGlmeUJsb2NrLz5cbiAgICAgICAgICAgICAgICA8L1Jvb3RQcm92aWRlcj5cbiAgICAgICAgICAgIDwvU3RyaWN0TW9kZT5cbiAgICAgICAgPC8+XG4gICAgKTtcbn07IiwiaW1wb3J0IHtjcmVhdGVSb290fSBmcm9tICdyZWFjdC1kb20vY2xpZW50J1xuaW1wb3J0IHtBcHB9IGZyb20gXCJAc3JjL2FwcC9BcHBcIjtcbmltcG9ydCAnLi9pbmRleC5jc3MnXG5cbmNvbnN0IHJvb3RDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcm9vdCcpXG5jb25zdCByb290ID0gY3JlYXRlUm9vdChyb290Q29udGFpbmVyISlcbnJvb3QucmVuZGVyKDxBcHAvPikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=